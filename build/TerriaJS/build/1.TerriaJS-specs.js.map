{"version":3,"sources":["webpack:///./node_modules/terriajs-cesium/Source/Core/CornerType.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/CompositeProperty.js","webpack:///./node_modules/terriajs-cesium/Source/Scene/ColorBlendMode.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/CompositePositionProperty.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/ReferenceProperty.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/ScaledPositionProperty.js","webpack:///./node_modules/terriajs-cesium/Source/Scene/OrderedGroundPrimitiveCollection.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/BillboardVisualizer.js","webpack:///./node_modules/terriajs-cesium/Source/Scene/MaterialAppearance.js","webpack:///./node_modules/terriajs-cesium/Source/Shaders/Appearances/BasicMaterialAppearanceVS.js","webpack:///./node_modules/terriajs-cesium/Source/Shaders/Appearances/BasicMaterialAppearanceFS.js","webpack:///./node_modules/terriajs-cesium/Source/Shaders/Appearances/TexturedMaterialAppearanceVS.js","webpack:///./node_modules/terriajs-cesium/Source/Shaders/Appearances/TexturedMaterialAppearanceFS.js","webpack:///./node_modules/terriajs-cesium/Source/Shaders/Appearances/AllMaterialAppearanceVS.js","webpack:///./node_modules/terriajs-cesium/Source/Shaders/Appearances/AllMaterialAppearanceFS.js","webpack:///./node_modules/terriajs-cesium/Source/Core/DistanceDisplayConditionGeometryInstanceAttribute.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/MaterialProperty.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/DynamicGeometryUpdater.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/GeometryUpdater.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/TerrainOffsetProperty.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/heightReferenceOnEntityPropertyChanged.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/BoxGeometryUpdater.js","webpack:///./node_modules/terriajs-cesium/Source/Core/PolylinePipeline.js","webpack:///./node_modules/terriajs-cesium/Source/Core/PolylineVolumeGeometryLibrary.js","webpack:///./node_modules/terriajs-cesium/Source/Core/CorridorGeometryLibrary.js","webpack:///./node_modules/terriajs-cesium/Source/Core/CorridorGeometry.js","webpack:///./node_modules/terriajs-cesium/Source/Core/CorridorOutlineGeometry.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/GroundGeometryUpdater.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/CorridorGeometryUpdater.js","webpack:///./node_modules/terriajs-cesium/Source/Core/CylinderGeometryLibrary.js","webpack:///./node_modules/terriajs-cesium/Source/Core/CylinderGeometry.js","webpack:///./node_modules/terriajs-cesium/Source/Core/CylinderOutlineGeometry.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/CylinderGeometryUpdater.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/DynamicGeometryBatch.js","webpack:///./node_modules/terriajs-cesium/Source/Core/EllipseGeometryLibrary.js","webpack:///./node_modules/terriajs-cesium/Source/Core/EllipseGeometry.js","webpack:///./node_modules/terriajs-cesium/Source/Core/EllipseOutlineGeometry.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/EllipseGeometryUpdater.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/EllipsoidGeometryUpdater.js","webpack:///./node_modules/terriajs-cesium/Source/Core/PlaneGeometry.js","webpack:///./node_modules/terriajs-cesium/Source/Core/PlaneOutlineGeometry.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/PlaneGeometryUpdater.js","webpack:///./node_modules/terriajs-cesium/Source/Core/CoplanarPolygonGeometryLibrary.js","webpack:///./node_modules/terriajs-cesium/Source/Core/CoplanarPolygonGeometry.js","webpack:///./node_modules/terriajs-cesium/Source/Core/CoplanarPolygonOutlineGeometry.js","webpack:///./node_modules/terriajs-cesium/Source/Core/PolygonGeometry.js","webpack:///./node_modules/terriajs-cesium/Source/Core/PolygonOutlineGeometry.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/PolygonGeometryUpdater.js","webpack:///./node_modules/terriajs-cesium/Source/Core/PolylineVolumeGeometry.js","webpack:///./node_modules/terriajs-cesium/Source/Core/PolylineVolumeOutlineGeometry.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/PolylineVolumeGeometryUpdater.js","webpack:///./node_modules/terriajs-cesium/Source/Core/RectangleGeometry.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/RectangleGeometryUpdater.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/StaticGeometryColorBatch.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/StaticGeometryPerMaterialBatch.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/StaticGroundGeometryColorBatch.js","webpack:///./node_modules/terriajs-cesium/Source/ThirdParty/quickselect.js","webpack:///./node_modules/terriajs-cesium/Source/ThirdParty/rbush.js","webpack:///./node_modules/terriajs-cesium/Source/Core/RectangleCollisionChecker.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/StaticGroundGeometryPerMaterialBatch.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/StaticOutlineGeometryBatch.js","webpack:///./node_modules/terriajs-cesium/Source/Core/WallGeometryLibrary.js","webpack:///./node_modules/terriajs-cesium/Source/Core/WallGeometry.js","webpack:///./node_modules/terriajs-cesium/Source/Core/WallOutlineGeometry.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/WallGeometryUpdater.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/GeometryVisualizer.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/LabelVisualizer.js","webpack:///./node_modules/terriajs-cesium/Source/Scene/Axis.js","webpack:///./node_modules/terriajs-cesium/Source/Core/getMagic.js","webpack:///./node_modules/terriajs-cesium/Source/Core/loadImageFromTypedArray.js","webpack:///./node_modules/terriajs-cesium/Source/ThirdParty/GltfPipeline/addToArray.js","webpack:///./node_modules/terriajs-cesium/Source/ThirdParty/GltfPipeline/hasExtension.js","webpack:///./node_modules/terriajs-cesium/Source/ThirdParty/GltfPipeline/ForEach.js","webpack:///./node_modules/terriajs-cesium/Source/ThirdParty/GltfPipeline/numberOfComponentsForType.js","webpack:///./node_modules/terriajs-cesium/Source/ThirdParty/GltfPipeline/getAccessorByteStride.js","webpack:///./node_modules/terriajs-cesium/Source/ThirdParty/GltfPipeline/addDefaults.js","webpack:///./node_modules/terriajs-cesium/Source/ThirdParty/GltfPipeline/addPipelineExtras.js","webpack:///./node_modules/terriajs-cesium/Source/ThirdParty/GltfPipeline/removeExtensionsRequired.js","webpack:///./node_modules/terriajs-cesium/Source/ThirdParty/GltfPipeline/removeExtensionsUsed.js","webpack:///./node_modules/terriajs-cesium/Source/ThirdParty/GltfPipeline/parseGlb.js","webpack:///./node_modules/terriajs-cesium/Source/ThirdParty/GltfPipeline/addExtensionsUsed.js","webpack:///./node_modules/terriajs-cesium/Source/ThirdParty/GltfPipeline/getComponentReader.js","webpack:///./node_modules/terriajs-cesium/Source/ThirdParty/GltfPipeline/findAccessorMinMax.js","webpack:///./node_modules/terriajs-cesium/Source/ThirdParty/GltfPipeline/moveTechniqueRenderStates.js","webpack:///./node_modules/terriajs-cesium/Source/ThirdParty/GltfPipeline/addExtensionsRequired.js","webpack:///./node_modules/terriajs-cesium/Source/ThirdParty/GltfPipeline/moveTechniquesToExtension.js","webpack:///./node_modules/terriajs-cesium/Source/ThirdParty/GltfPipeline/removeUnusedElements.js","webpack:///./node_modules/terriajs-cesium/Source/ThirdParty/GltfPipeline/addBuffer.js","webpack:///./node_modules/terriajs-cesium/Source/ThirdParty/GltfPipeline/readAccessorPacked.js","webpack:///./node_modules/terriajs-cesium/Source/ThirdParty/GltfPipeline/updateAccessorComponentTypes.js","webpack:///./node_modules/terriajs-cesium/Source/ThirdParty/GltfPipeline/updateVersion.js","webpack:///./node_modules/terriajs-cesium/Source/Scene/DracoLoader.js","webpack:///./node_modules/terriajs-cesium/Source/Scene/getClipAndStyleCode.js","webpack:///./node_modules/terriajs-cesium/Source/Core/Spline.js","webpack:///./node_modules/terriajs-cesium/Source/Core/LinearSpline.js","webpack:///./node_modules/terriajs-cesium/Source/Core/QuaternionSpline.js","webpack:///./node_modules/terriajs-cesium/Source/Core/WeightSpline.js","webpack:///./node_modules/terriajs-cesium/Source/Scene/AttributeType.js","webpack:///./node_modules/terriajs-cesium/Source/Scene/ModelAnimationCache.js","webpack:///./node_modules/terriajs-cesium/Source/Scene/ModelAnimationLoop.js","webpack:///./node_modules/terriajs-cesium/Source/Scene/ModelAnimationState.js","webpack:///./node_modules/terriajs-cesium/Source/Scene/ModelAnimation.js","webpack:///./node_modules/terriajs-cesium/Source/Scene/ModelAnimationCollection.js","webpack:///./node_modules/terriajs-cesium/Source/Scene/ModelLoadResources.js","webpack:///./node_modules/terriajs-cesium/Source/Scene/ModelMaterial.js","webpack:///./node_modules/terriajs-cesium/Source/Scene/ModelMesh.js","webpack:///./node_modules/terriajs-cesium/Source/Scene/ModelNode.js","webpack:///./node_modules/terriajs-cesium/Source/Scene/ModelUtility.js","webpack:///./node_modules/terriajs-cesium/Source/Core/webGLConstantToGlslType.js","webpack:///./node_modules/terriajs-cesium/Source/Scene/processModelMaterialsCommon.js","webpack:///./node_modules/terriajs-cesium/Source/Scene/processPbrMaterials.js","webpack:///./node_modules/terriajs-cesium/Source/Scene/Model.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/ModelVisualizer.js","webpack:///./node_modules/terriajs-cesium/Source/Scene/Polyline.js","webpack:///./node_modules/terriajs-cesium/Source/Scene/PolylineCollection.js","webpack:///./node_modules/terriajs-cesium/Source/Shaders/PolylineVS.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/PathVisualizer.js","webpack:///./node_modules/terriajs-cesium/Source/Scene/createBillboardPointCallback.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/PointVisualizer.js","webpack:///./node_modules/terriajs-cesium/Source/Core/PolylineGeometry.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/PolylineGeometryUpdater.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/StaticGroundPolylinePerMaterialBatch.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/PolylineVisualizer.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/DataSourceDisplay.js"],"names":["ROUNDED","MITERED","BEVELED","CompositeProperty","this","_eventHelper","_definitionChanged","_intervals","changedEvent","addEventListener","prototype","_intervalsChanged","isConstant","get","isEmpty","definitionChanged","intervals","getValue","time","result","innerProperty","findDataForIntervalContainingDate","equals","other","property","eventHelper","callback","raiseEvent","items","removeAll","length","i","interval","data","indexOf","add","subscribeAll","ColorBlendMode","HIGHLIGHT","REPLACE","MIX","colorBlendMode","colorBlendAmount","clamp","EPSILON4","CompositePositionProperty","referenceFrame","_referenceFrame","FIXED","_composite","_raiseDefinitionChanged","set","value","getValueInReferenceFrame","resolve","that","targetProperty","_targetProperty","targetEntity","_targetEntity","_targetCollection","getById","_targetId","undefined","ReferenceProperty","_onTargetEntityDefinitionChanged","targetPropertyNames","_targetPropertyNames","len","targetCollection","targetId","collectionChanged","_onCollectionChanged","target","resolvedProperty","fromString","referenceString","identifier","values","inIdentifier","isEscaped","token","c","charAt","push","getType","names","otherNames","name","oldValue","collection","added","removed","removeEventListener","ScaledPositionProperty","_value","_removeSubscription","setValue","WGS84","scaleToGeodeticSurface","OrderedGroundPrimitiveCollection","_length","_collections","_collectionsArray","show","defineProperties","primitive","zIndex","defined","PrimitiveCollection","destroyPrimitives","_zIndex","array","splice","remove","doNotDestroy","contains","index","removeAndDestroy","destroy","collections","update","frameState","isDestroyed","destroyObject","defaultColor","Color","WHITE","defaultEyeOffset","Cartesian3","ZERO","defaultHeightReference","HeightReference","NONE","defaultPixelOffset","Cartesian2","defaultAlignedAxis","defaultHorizontalOrigin","HorizontalOrigin","CENTER","defaultVerticalOrigin","VerticalOrigin","positionScratch","colorScratch","eyeOffsetScratch","pixelOffsetScratch","scaleByDistanceScratch","NearFarScalar","translucencyByDistanceScratch","pixelOffsetScaleByDistanceScratch","boundingRectangleScratch","BoundingRectangle","distanceDisplayConditionScratch","DistanceDisplayCondition","EntityData","entity","billboard","textureValue","BillboardVisualizer","entityCluster","entityCollection","_cluster","_entityCollection","_items","AssociativeArray","returnPrimitive","item","cluster","removeBillboard","position","billboardGraphics","_billboard","isShowing","isAvailable","Property","getValueOrDefault","_show","getValueOrUndefined","_position","_image","_clusterDirty","getBillboard","id","image","color","_color","eyeOffset","_eyeOffset","heightReference","_heightReference","pixelOffset","_pixelOffset","scale","_scale","rotation","_rotation","alignedAxis","_alignedAxis","horizontalOrigin","_horizontalOrigin","verticalOrigin","_verticalOrigin","width","_width","height","_height","scaleByDistance","_scaleByDistance","translucencyByDistance","_translucencyByDistance","pixelOffsetScaleByDistance","_pixelOffsetScaleByDistance","sizeInMeters","_sizeInMeters","distanceDisplayCondition","_distanceDisplayCondition","disableDepthTestDistance","_disableDepthTestDistance","subRegion","_imageSubRegion","setImageSubRegion","_imageId","getBoundingSphere","BoundingSphereState","FAILED","center","clone","_clampedPosition","PENDING","radius","DONE","entities","changed","MaterialAppearance","options","EMPTY_OBJECT","translucent","closed","materialSupport","MaterialSupport","TEXTURED","material","Material","fromType","ColorType","_vertexShaderSource","vertexShaderSource","_fragmentShaderSource","fragmentShaderSource","_renderState","Appearance","getDefaultRenderState","renderState","_closed","_materialSupport","_vertexFormat","vertexFormat","_flat","flat","_faceForward","faceForward","getFragmentShaderSource","isTranslucent","getRenderState","BASIC","freezeObject","VertexFormat","POSITION_AND_NORMAL","POSITION_NORMAL_AND_ST","ALL","DistanceDisplayConditionGeometryInstanceAttribute","near","far","Number","MAX_VALUE","Float32Array","componentDatatype","ComponentDatatype","FLOAT","componentsPerAttribute","normalize","fromDistanceDisplayCondition","toValue","MaterialProperty","DeveloperError","throwInstantiationError","materialProperty","type","uniforms","DynamicGeometryUpdater","geometryUpdater","primitives","orderedGroundPrimitives","_primitives","_orderedGroundPrimitives","_primitive","_outlinePrimitive","_geometryUpdater","_options","_entity","_material","_isHidden","geometry","_setOptions","onTerrain","_onTerrain","_geometryPropertyName","shadows","shadowsProperty","fill","appearance","fillMaterialProperty","isColorAppearance","ColorMaterialProperty","_getIsClosed","PerInstanceColorAppearance","_supportsMaterialsforEntitiesOnTerrain","VERTEX_FORMAT","GroundPrimitive","geometryInstances","createFillGeometryInstance","asynchronous","classificationType","classificationTypeProperty","fillInstance","attributes","Primitive","outline","outlineInstance","createOutlineGeometryInstance","outlineWidth","lineWidth","_scene","clampLineWidth","outlinePrimitive","ready","getGeometryInstanceAttributes","boundingSphere","BoundingSphere","defaultShow","ConstantProperty","defaultFill","defaultOutline","defaultOutlineColor","BLACK","defaultShadows","ShadowMode","DISABLED","defaultDistanceDisplayCondition","defaultClassificationType","ClassificationType","BOTH","GeometryUpdater","geometryPropertyName","scene","_fillEnabled","_isClosed","_dynamic","_outlineEnabled","_geometryChanged","Event","_showProperty","_materialProperty","_showOutlineProperty","_outlineColorProperty","_outlineWidth","_shadowsProperty","_distanceDisplayConditionProperty","_classificationTypeProperty","geometryOptions","_id","_observedPropertyNames","observedPropertyNames","Entity","supportsMaterialsforEntitiesOnTerrain","fillEnabled","hasConstantFill","availability","_fillProperty","outlineEnabled","hasConstantOutline","outlineColorProperty","distanceDisplayConditionProperty","isDynamic","isClosed","geometryChanged","isOutlineVisible","visible","isFilled","Iso8601","MINIMUM_VALUE","_isOnTerrain","_isDynamic","_setStaticOptions","_onEntityPropertyChanged","propertyName","newValue","fillProperty","outlineProperty","outlineColor","oneTimeWarning","geometryOutlines","createDynamicUpdater","groundPrimitives","constructor","scratchPosition","scratchCarto","Cartographic","TerrainOffsetProperty","positionProperty","heightReferenceProperty","extrudedHeightReferenceProperty","_extrudedHeightReference","_positionProperty","_cartographicPosition","_normal","_terrainHeight","_removeCallbackFunc","_removeEventListener","_removeModeListener","globe","terrainProviderChanged","_updateClamping","morphComplete","ellipsoid","geodeticSurfaceNormal","surface","_surface","cartographicPosition","cartesianToCartographic","getHeight","updateHeight","clampedPosition","mode","SceneMode","SCENE3D","carto","x","extrudedHeightReference","RELATIVE_TO_GROUND","multiplyByScalar","equalsEpsilon","EPSILON10","normal","call","_terrainOffsetProperty","centerPosition","CallbackProperty","_computeCenter","bind","defaultOffset","offsetScratch","scratchColor","BoxGeometryOptions","dimensions","offsetAttribute","BoxGeometryUpdater","box","DynamicBoxGeometryUpdater","Object","create","terrainOffsetProperty","currentColor","ShowGeometryInstanceAttribute","offset","ColorGeometryInstanceAttribute","fromColor","OffsetGeometryInstanceAttribute","fromCartesian3","GeometryInstance","BoxGeometry","fromDimensions","modelMatrix","computeModelMatrixForHeightReference","z","mapProjection","BoxOutlineGeometry","orientation","GeometryOffsetAttribute","PolylinePipeline","p0","p1","minDistance","distance","Math","ceil","granularity","radiansDistanceSquared","pow","longitude","latitude","sqrt","cartoScratch","extractHeights","positions","heights","Array","p","wrapLongitudeInversMatrix","Matrix4","wrapLongitudeOrigin","wrapLongitudeXZNormal","wrapLongitudeXZPlane","Plane","UNIT_X","wrapLongitudeYZNormal","wrapLongitudeYZPlane","wrapLongitudeIntersection","wrapLongitudeOffset","subdivideHeightsScratchArray","subdivideHeights","numPoints","h0","h1","heightPerVertex","h","carto1","carto2","scaleFirst","scaleLast","EllipsoidGeodesic","ellipsoidRhumb","EllipsoidRhumbLine","generateCartesianArc","first","last","numberOfPoints","start","end","setEndPoints","surfaceDistanceBetweenPoints","surfaceDistance","cart","cartographicToCartesian","pack","interpolateUsingSurfaceDistance","generateCartesianRhumbArc","numberOfPointsRhumbLine","wrapLongitude","cartesians","segments","IDENTITY","inverseModelMatrix","inverseTransformation","origin","multiplyByPoint","xzNormal","multiplyByPointAsVector","UNIT_Y","xzPlane","fromPointNormal","yzNormal","yzPlane","count","prev","cur","getPointDistance","intersection","IntersectionTests","lineSegmentPlane","negate","lengths","generateArc","Ellipsoid","hasHeightArray","isArray","n","y","RADIANS_PER_DEGREE","chordLength","maximumRadius","arrayLength","newPositions","lastPoint","scratchCartographic0","scratchCartographic1","generateRhumbArc","c1","c0","numberArray","size","unpack","scratch2Array","scratchCartesian1","scratchCartesian2","scratchCartesian3","scratchCartesian4","scratchCartesian5","scratchCartesian6","scratchCartesian7","scratchCartesian8","scratchCartesian9","scratch1","scratch2","PolylineVolumeGeometryLibrary","points","angleBetween","nextScratch","prevScratch","negativeX","rotationZ","Matrix3","scaleMatrix","westScratch","finalPosScratch","Cartesian4","heightCartesian","addPosition","left","shape","finalPositions","xScalar","repeat","west","finalPosition","Transforms","eastNorthUpToFixedFrame","angle","tangentPlane","EllipsoidTangentPlane","next","projectPointOntoPlane","computeRotationAngle","fromRotationZ","multiplyTransformation","fromRotationTranslation","j","fromArray","multiplyByVector","centerScratch","addPositions","centers","convertShapeTo3D","shape2D","boundingRectangle","xOffset","yOffset","quaterion","Quaternion","startPointScratch","rotMatrix","computeRoundCorner","pivot","startPoint","endPoint","cornerType","leftIsOutside","duplicatePoints","m","subtract","CornerType","toRadians","fromQuaternion","fromAxisAngle","removeDuplicatesFromShape","shapePositions","cleanedPositions","i0","i1","v0","v1","angleIsGreaterThanPi","forward","backward","scratchForwardProjection","scratchBackwardProjection","computePositions","_ellipsoid","pos","scaleToSurface","_granularity","_cornerType","shapeForSides","point","convertShapeTo3DDuplicate","shapeForEnds","heightOffset","ends","cornerDirection","surfaceNormal","previousPosition","nextPosition","cross","subdividedHeights","forwardProjection","dot","backwardProjection","abs","EPSILON7","scalar","max","magnitude","posLength","combinedPositions","Float64Array","CorridorGeometryLibrary","scratch3","scratch4","scaleArray2","cartesian1","cartesian2","cartesian3","cartesian4","cartesian5","cartesian6","cartesian7","cartesian8","cartesian9","cartesian10","cornerPoint","computeMiteredCorner","leftCornerDirection","addShiftedPositions","calculatedPositions","rightPositions","leftPositions","scaledLeft","scaledRight","rightIndex","leftIndex","rightPos","leftPos","addAttribute","attribute","front","back","params","saveAttributes","previousPos","calculatedLefts","calculatedNormals","endPositions","corners","leftEdge","firstEndCap","midpoint","rightEdge","addEndCaps","lefts","normals","addNormals","attr","tangents","bitangents","tangent","bitangent","combine","computedPositions","corner","computedLefts","computedNormals","GeometryAttributes","leftCount","rightCount","indicesLength","leftSide","endPositionLength","addEndPositions","UL","LL","UR","LR","halfLength","indices","IndexDatatype","createTypedArray","firstEndPositions","rightNormal","leftNormal","posIndex","compIndex","l","r","outsidePoint","previousPoint","nextPoint","lastEndPositions","GeometryAttribute","DOUBLE","st","rightSt","leftSt","stIndex","a","theta","PI","halfEndPos","PI_OVER_TWO","cos","sin","addWallPositions","wallPositions","computePositionsExtruded","topVertexFormat","shadowVolume","extrudedHeight","extrudedPositions","PolygonPipeline","scaleToGeodeticHeight","topNormals","topBitangents","threeSize","twoSize","sixSize","topPosition","bottomPosition","attrIndex","attrIndexOffset","topTangents","topSt","s","t","extrudedAttributes","extrudeNormals","extrudeDirection","applyOffset","Uint8Array","TOP","arrayFill","applyOffsetValue","UNSIGNED_BYTE","iLength","newIndices","v2","scratchCartographic","computeOffsetPoints","position1","position2","halfWidth","min","direction","offsetDirection","minLat","minLon","maxLat","maxLon","lat","lon","scratchCartesianOffset","scratchCartesianEnds","scratchCartographicMin","scratchCartographicMax","computeRectangle","cleanPositions","arrayRemoveDuplicates","Rectangle","POSITIVE_INFINITY","NEGATIVE_INFINITY","rectangle","north","south","east","CorridorGeometry","_positions","DEFAULT","_extrudedHeight","_shadowVolume","_workerName","_offsetAttribute","_rectangle","packedLength","startingIndex","scratchEllipsoid","UNIT_SPHERE","scratchVertexFormat","scratchOptions","createGeometry","corridorGeometry","extrude","EPSILON2","fromVertices","Geometry","primitiveType","PrimitiveType","TRIANGLES","createShadowVolume","minHeightFunc","maxHeightFunc","minHeight","maxHeight","POSITION_ONLY","textureCoordinateRotationPoints","wallIndices","floor","CorridorOutlineGeometry","corridorOutlineGeometry","offsetValue","LINES","defaultZIndex","GroundGeometryUpdater","isSupported","geometryZIndex","getGeometryHeight","CLAMP_TO_GROUND","geometryHeightReference","getGeometryExtrudedHeight","geometryExtrudedHeightReference","computeGeometryOffsetAttribute","scratchRectangle","CorridorGeometryOptions","CorridorGeometryUpdater","corridor","DynamicCorridorGeometryUpdater","heightValue","heightReferenceValue","extrudedHeightValue","extrudedHeightReferenceValue","ApproximateTerrainHeights","getMinimumMaximumHeights","minimumTerrainHeight","CylinderGeometryLibrary","topRadius","bottomRadius","slices","topZ","bottomZ","twoSlice","tbIndex","bottomOffset","topOffset","TWO_PI","bottomX","bottomY","topX","topY","radiusScratch","normalScratch","bitangentScratch","tangentScratch","CylinderGeometry","_topRadius","_bottomRadius","_slices","unitCylinderGeometry","cylinderGeometry","twoSlices","threeSlices","numVertices","computeNormal","computeTangent","normalIndex","tangentIndex","bitangentIndex","atan2","normalScale","UNIT_Z","numIndices","textureCoordIndex","rad","getUnitCylinder","CylinderOutlineGeometry","numberOfVerticalLines","_numberOfVerticalLines","numSide","numSideLines","round","CylinderGeometryOptions","CylinderGeometryUpdater","cylinder","DynamicCylinderGeometryUpdater","DynamicGeometryBatch","_dynamicUpdaters","updater","dynamicUpdater","geometries","removeAllPrimitives","EllipseGeometryLibrary","rotAxis","tempVec","unitQuat","rotMtx","pointOnEllipsoid","northVec","eastVec","aSqr","ab","bSqr","mag","unitPos","azimuth","cosThetaSquared","sinThetaSquared","scratchNormal","raisePositionsToHeight","i2","extrudedPosition","scaledNormal","unitPosScratch","eastVecScratch","northVecScratch","computeEllipsePositions","addFillPositions","addEdgePositions","semiMinorAxis","semiMajorAxis","numPts","deltaTheta","numInterior","interiorPosition","positionIndex","reflectedPosition","outerPositionsLength","outerRightIndex","outerLeftIndex","outerPositions","lerp","texCoordScratch","textureMatrixScratch","tangentMatrixScratch","quaternionScratch","scratchTangent","scratchBitangent","projectedCenterScratch","scratchMinTexCoord","scratchMaxTexCoord","computeTopBottomAttributes","stRotation","textureCoordinates","projection","GeographicProjection","projectedCenter","project","geodeticNormal","textureMatrix","tangentMatrix","minTexCoord","fromElements","maxTexCoord","stOffset","rotatedPoint","projectedPoint","k","topIndices","prevIndex","indicesIndex","boundingSphereCenter","topBoundingSphere","bottomBoundingSphere","computeExtrudedEllipse","cep","union","topBottomAttributes","topBottomIndices","topBottomGeo","wallAttributes","bottom","computeWallAttributes","computeWallIndices","wallGeo","geo","GeometryPipeline","combineInstances","positionsFlat","positionsCount","fromCartesianArray","EllipseGeometry","_center","_semiMajorAxis","_semiMinorAxis","_stRotation","_textureCoordinateRotationPoints","scratchCenter","ellipseGeometry","computeEllipse","EllipseOutlineGeometry","maxI","EllipseGeometryOptions","EllipseGeometryUpdater","ellipse","DynamicEllipseGeometryUpdater","radiiScratch","innerRadiiScratch","unitSphere","EllipsoidGeometryOptions","radii","innerRadii","minimumClock","maximumClock","minimumCone","maximumCone","stackPartitions","slicePartitions","subdivisions","EllipsoidGeometryUpdater","DynamicEllipsoidGeometryUpdater","_modelMatrix","_attributes","_outlineAttributes","_lastSceneMode","_lastShow","_lastOutlineShow","_lastOutlineWidth","_lastOutlineColor","_lastOffset","skipModelMatrix","modelMatrixResult","EllipsoidGeometry","EllipsoidOutlineGeometry","showFill","showOutline","getValueOrClonedDefault","sceneMode","in3D","_lastDistanceDisplayCondition","outlineAttributes","multiplyByScale","PlaneGeometry","planeGeometry","texCoords","Uint16Array","PlaneOutlineGeometry","PlaneGeometryOptions","plane","PlaneGeometryUpdater","DynamicPlaneGeometryUpdater","distanceDisplayConditionAttribute","planeGraphics","computeModelMatrix","createPrimitiveMatrix","isColorMaterial","scratchAxis","scratchAxis2","scratchTranslation","scratchScale","scratchQuaternion","scratchMatrix3","transform","translation","transformedNormal","up","EPSILON8","rotationMatrix","setColumn","fromRotationMatrix","fromTranslationQuaternionRotationScale","CoplanarPolygonGeometryLibrary","scratchIntersectionPoint","scratchXAxis","scratchYAxis","scratchZAxis","obbScratch","OrientedBoundingBox","projectTo2D","axis1","axis2","v","validOutline","halfAxes","fromPoints","xAxis","getColumn","yAxis","zAxis","xMag","yMag","zMag","computeProjectTo2DArguments","centerResult","planeAxis1Result","planeAxis2Result","planeAxis1","planeAxis2","orientedBoundingBox","createProjectPointsTo2DFunction","positionResults","createProjectPointTo2DFunction","scratchBR","stScratch","textureCoordinatesOrigin","axis1Scratch","axis2Scratch","tangentRotationScratch","surfaceNormalScratch","createGeometryFromPolygon","polygon","projectPointTo2D","triangulate","positions2D","holes","tangentRotation","stOrigin","flatPositions","stx","sty","CoplanarPolygonGeometry","polygonHierarchy","_polygonHierarchy","PolygonGeometryLibrary","computeHierarchyPackedLength","fromPositions","packPolygonHierarchy","unpackPolygonHierarchy","polygonGeometry","EPSILON6","projectPoints","projectPoint","results","polygonsFromHierarchy","hierarchy","polygons","outerRing","computeBoundingRectangle","geometryInstance","createGeometryFromPositions","CoplanarPolygonOutlineGeometry","polygonOutlinesFromHierarchy","scratchCarto1","scratchCarto2","adjustPosHeightsForNormal","p2","p1Carto","p2Carto","scratchBoundingRectangle","p1Scratch","p2Scratch","scratchPerPosNormal","scratchPerPosTangent","scratchPerPosBitangent","appendTextureCoordinatesOrigin","appendTextureCoordinatesCartesian2","appendTextureCoordinatesCartesian3","appendTextureCoordinatesQuaternion","appendTextureCoordinatesMatrix3","computeAttributes","wall","top","perPositionHeight","recomputeNormal","tangentRotationMatrix","_plane","bottomOffset2","attrIndex1","attrIndex2","startCartographicScratch","endCartographicScratch","westOverIDL","eastOverIDL","arcType","ArcType","RHUMB","swap","inverseChordLength","positionsLength","endCartographic","startCartographic","interpolateAndGrowRectangle","interpolatedCartographicScratch","ellipsoidGeodesic","idlCross","segmentLength","subsegmentDistance","interpolationDistance","interpolatedCartographic","lonAdjusted","createGeometryFromPositionsExtrudedPositions","createGeometryFromPositionsExtruded","closeTop","closeBottom","geos","walls","numPositions","topGeo","edgePoints","topBottomPositions","concat","ilength","topAndBottom","projectPointsOntoPlane","windingOrder","computeWindingOrder2D","WindingOrder","CLOCKWISE","slice","reverse","computeWallGeometry","hole","COUNTER_CLOCKWISE","PolygonGeometry","perPositionHeightExtrude","_closeTop","_closeBottom","_perPositionHeight","_perPositionHeightExtrude","_arcType","GEODESIC","dummyOptions","splitGeometry","scaleToGeodeticHeightExtruded","createGeometryFromPositionsPositions","createGeometryFromPositionsSubdivided","subdividedPositions","subdivideLineCount","subdivideRhumbLineCount","tempPositions","subdivideLine","subdivideRhumbLine","tempPositionsLength","indicesSize","cornersLength","PolygonOutlineGeometry","scratch2DPositions","cart2Scratch","PolygonGeometryOptions","PolygonGeometryUpdater","DyanmicPolygonGeometryUpdater","area","centroid2D","f","sum","projectPointOntoEllipsoid","perPositionHeightProperty","perPositionHeightEnabled","hierarchyValue","perPositionHeightValue","isExtruded","PolylineVolumeGeometry","polylinePositions","_shape","numComponents","brScratch","polylineVolumeGeometry","ll","ul","ur","lr","shapeLength","vertexCount","firstEndIndices","indicesCount","lengthSt","heightSt","stindex","endOffset","computeTangentAndBitangent","e","PolylineVolumeOutlineGeometry","polylineVolumeOutlineGeometry","shapeCount","firstOffset","secondOffset","PolylineVolumeGeometryOptions","PolylineVolumeGeometryUpdater","polylineVolume","DynamicPolylineVolumeGeometryUpdater","rectangleScratch","createAttributes","v1Scratch","v2Scratch","constructRectangle","rectangleGeometry","computedOptions","northCap","southCap","rowStart","rowEnd","rowHeight","minX","minY","maxX","maxY","row","col","RectangleGeometryLibrary","computePosition","calculateAttributes","upperLeft","lowerLeft","lowerRight","upperRight","northIndex","southIndex","topPositions","bottomPositions","addWallTextureCoordinates","wallTextures","constructExtrudedRectangle","offsetAttributeValue","_surfaceHeight","newVertexFormat","newLength","textures","hasOffsets","widthMultiplier","perimeterPositions","dupliateCorners","wallCount","wallExtrudeNormals","wallOffsetAttribute","computeTopOffsets","threeI","extrudeNormalIndex","wallOffsetIndex","calculateAttributesWall","scratchRectanglePoints","nwScratch","stNwScratch","computeOptions","RectangleGeometry","_rotatedRectangle","surfaceHeight","tangentRotationMatrixScratch","axis","geodeticSurfaceNormalCartographic","lonScalar","latScalar","topBS","fromRectangle3D","bottomBS","unrotatedTextureRectangleScratch","points2DScratch","rotation2DScratch","Matrix2","rectangleCenterScratch","unrotatedTextureRectangle","points2D","toDesiredInComputed","fromRotation","boundingRectangleCenter","point2D","minXYCorner","maxYCorner","maxXCorner","scratchCenterRect","RectangleGeometryOptions","RectangleGeometryUpdater","DynamicRectangleGeometryUpdater","RectangleOutlineGeometry","rect","coordinates","toCartesian","Batch","appearanceType","depthFailAppearanceType","depthFailMaterialProperty","removeMaterialSubscription","depthFailMaterial","createPrimitive","waitingOnCreate","oldPrimitive","updaters","updatersWithAttributes","subscriptions","showsUpdated","itemsToRemove","invalidated","onMaterialChanged","StaticGeometryColorBatch","_solidItems","_translucentItems","_appearanceType","_depthFailAppearanceType","_shadows","removeItem","moveItems","batch","itemsMoved","itemsToMoveLength","updateItems","isUpdated","updatersLength","isMaterial","updaterMaterial","instance","unsubscribe","removedCount","depthFailAppearance","colorProperty","resultColor","_lastColor","depthFailColorProperty","depthColor","_lastDepthFailColor","depthFailColor","offsetProperty","updateShows","solidsMoved","translucentsMoved","updaterDepthFailMaterial","StaticGeometryPerMaterialBatch","key","isDirty","scratchArray","StaticGroundGeometryColorBatch","_batches","_classificationType","fillColor","newColor","toBytes","bs","batches","batchKey","Uint32Array","buffer","batchesArray","batchCount","oldBatch","newBatch","batchesArrayCopy","batchesCopyCount","arr","tmp","defaultCompare","b","right","compare","quickselectStep","log","exp","sd","newLeft","newRight","rbush","maxEntries","format","_maxEntries","_minEntries","_initFormat","clear","findItem","equalsFn","calcBBox","node","toBBox","distBBox","children","destNode","createNode","Infinity","child","extend","leaf","compareNodeMinX","compareNodeMinY","bboxArea","bboxMargin","intersects","multiSelect","mid","stack","pop","all","_all","search","bbox","childBBox","nodesToSearch","collides","load","insert","_build","_splitRoot","tmpNode","_insert","parent","goingUp","path","indexes","_condense","compareMinX","compareMinY","toJSON","fromJSON","apply","N","M","right2","right3","N2","N1","_chooseSubtree","level","targetNode","enlargement","minArea","minEnlargement","isNode","insertPath","_split","_adjustParentBBoxes","_chooseSplitAxis","splitIndex","_chooseSplitIndex","newNode","bbox1","bbox2","overlap","minOverlap","_allDistMargin","sort","leftBBox","rightBBox","margin","siblings","compareArr","Function","join","RectangleCollisionChecker","_tree","RectangleWithId","idCompare","fromRectangleAndId","withId","removalScratch","collisionScratch","usingSphericalTextureCoordinates","rectangleCollisionCheck","StaticGroundGeometryPerMaterialBatch","overlapping","ShadowVolumeAppearance","shouldUseSphericalCoordinates","StaticOutlineGeometryBatch","_solidBatches","_translucentBatches","solidBatches","solidBatchesLength","translucentBatches","translucentBatchesLength","needUpdate","solidsToMoveLength","translucentToMoveLength","solidBatch","translucentBatch","WallGeometryLibrary","latLonEquals","EPSILON14","scratchCartographic2","positionsArrayScratch","heightsArrayScratch","generateArcOptionsScratch","maximumHeights","minimumHeights","duplicateCorners","o","topHeights","bottomHeights","hasBottomHeights","hasTopHeights","hasAllZeroHeights","cleanedTopHeights","cleanedBottomHeights","removeDuplicates","numCorners","generateArcOptions","generateArcPositions","generateArcHeights","scratchCartesian3Position1","scratchCartesian3Position2","scratchCartesian3Position3","scratchCartesian3Position4","scratchCartesian3Position5","WallGeometry","_minimumHeights","_maximumHeights","fromConstantHeights","minHeights","maxHeights","minimumHeight","maximumHeight","doMin","doMax","wallGeometry","ds","i3","nextTop","groundPosition","scalednextPosition","scaledGroundPosition","edgeIndex","pl","pr","WallOutlineGeometry","WallGeometryOptions","WallGeometryUpdater","DynamicWallGeometryUpdater","emptyArray","geometryUpdaters","GeometryUpdaterSet","EventHelper","_removeEntitySubscription","GeometryVisualizer","_groundPrimitives","_addedObjects","_removedObjects","_changedObjects","numberOfShadowModes","NUMBER_OF_SHADOW_MODES","_outlineBatches","_closedColorBatches","_closedMaterialBatches","_openColorBatches","_openMaterialBatches","numberOfClassificationTypes","NUMBER_OF_CLASSIFICATION_TYPES","groundColorBatches","groundMaterialBatches","_groundColorBatches","_groundMaterialBatches","_dynamicBatch","_subscriptions","_updaterSets","forEach","updaterSet","addedObjects","removedObjects","changedObjects","_removeUpdater","_insertUpdaterIntoBatch","_onGeometryChanged","getBoundingSphereArrayScratch","getBoundingSphereBoundingSphereScratch","boundingSpheres","state","batchesLength","fromBoundingSpheres","updaterSets","defaultStyle","LabelStyle","FILL","defaultFillColor","defaultBackgroundColor","defaultBackgroundPadding","fillColorScratch","outlineColorScratch","backgroundColorScratch","backgroundPaddingScratch","label","LabelVisualizer","removeLabel","text","labelGraphics","_label","_text","updateClamping","getLabel","font","_font","style","_style","_fillColor","_outlineColor","showBackground","_showBackground","backgroundColor","_backgroundColor","backgroundPadding","_backgroundPadding","Axis","X","Y","Z","Y_UP_TO_Z_UP","fromRotationX","Z_UP_TO_Y_UP","X_UP_TO_Z_UP","fromRotationY","Z_UP_TO_X_UP","X_UP_TO_Y_UP","Y_UP_TO_X_UP","fromName","uint8Array","byteOffset","getStringFromTypedArray","blobUrl","request","flipY","blob","Blob","Resource","supportsImageBitmapOptions","then","when","createImageBitmapFromBlob","premultiplyAlpha","window","URL","createObjectURL","url","fetchImage","revokeObjectURL","otherwise","error","reject","element","checkDuplicates","gltf","extension","extensionsUsed","ForEach","objectLegacy","objects","handler","objectId","hasOwnProperty","object","arrayOfObjects","topLevel","gltfProperty","accessor","accessorWithSemantic","semantic","visited","mesh","meshPrimitive","valueForEach","meshPrimitiveAttribute","accessorId","attributeSemantic","meshPrimitiveTarget","meshPrimitiveTargetAttribute","accessorContainingVertexAttributeData","accessorContainingIndexData","animation","animationChannel","channels","animationSampler","samplers","bufferView","camera","compressedImage","extras","compressedImages","compressedImage3DTiles","materialValue","extensions","KHR_techniques_webgl","primitivesLength","targets","nodeInTree","nodeIds","nodes","nodeId","nodeInScene","sceneNodeIds","program","programs","sampler","shader","shaders","skin","skinJoint","joints","jointsLength","techniqueAttribute","technique","attributeName","techniqueUniform","uniformName","techniqueParameter","parameters","parameterName","techniques","texture","bufferViewId","bufferViews","byteStride","getSizeInBytes","componentType","addTextureDefaults","texCoord","WebGLConstants","materials","accessors","normalized","ARRAY_BUFFER","ELEMENT_ARRAY_BUFFER","materialsCommon","KHR_materials_common","ambient","emission","transparency","transparent","doubleSided","diffuse","specular","shininess","emissiveFactor","alphaMode","alphaCutoff","techniquesExtension","emissiveTexture","normalTexture","occlusionTexture","pbrMetallicRoughness","baseColorFactor","metallicFactor","roughnessFactor","baseColorTexture","metallicRoughnessTexture","pbrSpecularGlossiness","diffuseFactor","specularFactor","glossinessFactor","specularGlossinessTexture","interpolation","animatedNodes","channel","getAnimatedNodes","matrix","wrapS","REPEAT","wrapT","scenes","addExtras","_pipeline","extensionsRequired","readHeader","glb","dataView","DataView","header","getUint32","RuntimeError","version","contentLength","binaryStart","contentString","JSON","parse","binaryBuffer","subarray","buffers","keys","binaryGltfBuffer","binary_glTF","KHR_binary_glTF","source","parseGlbVersion1","chunkHeader","chunkLength","chunkType","chunkBuffer","jsonString","parseGlbVersion2","BYTE","numberOfComponents","componentTypeByteLength","getInt8","getUint8","SHORT","getInt16","UNSIGNED_SHORT","getUint16","INT","getInt32","UNSIGNED_INT","getFloat32","getFloat64","components","componentReader","defaultBlendEquation","FUNC_ADD","defaultBlendFactors","ONE","isStateEnabled","renderStates","enabled","enable","supportedBlendFactors","SRC_COLOR","ONE_MINUS_SRC_COLOR","SRC_ALPHA","ONE_MINUS_SRC_ALPHA","DST_ALPHA","ONE_MINUS_DST_ALPHA","DST_COLOR","ONE_MINUS_DST_COLOR","getSupportedBlendFactors","defaultValue","blendingForTechnique","materialPropertiesForTechnique","techniquesLegacy","techniqueLegacy","techniqueIndex","states","materialProperties","BLEND","blendFunctions","functions","blendEquationSeparate","blendFuncSeparate","blendEquation","blendFactors","CULL_FACE","blending","KHR_blend","mappedUniforms","updatedTechniqueIndices","glExtensions","glExtensionsUsed","parameterLegacy","programLegacy","fragmentShader","vertexShader","fs","vs","materialExtension","allElementTypes","TypeToGltfElementName","Remove","getListOfElementsIdsInUse","attributeAccessorId","inverseBindMatrices","input","output","bufferId","compressedImageBufferView","KHR_draco_mesh_compression","meshId","meshes","skeleton","map","uniform","filter","materialId","usedAccessorIds","usedBufferIds","usedBufferViewIds","usedMeshIds","usedNodeIds","nodeIsEmpty","weights","joint","usedMaterialIds","elementTypes","usedIds","removeUnusedElementsByType","newBuffer","byteLength","convertType","updatedComponentType","typedArray","updateFunctions","asset","profile","split","api","updateInstanceTechniques","setPrimitiveModes","updateNodes","updateAnimations","removeTechniquePasses","allExtensions","lights","animations","animationId","samplerId","removeAnimationSamplersIndirection","isNodeEmpty","deleteNode","sceneNodes","parentNode","parentNodeId","removeEmptyNodes","jointName","globalMapping","cameras","images","skins","jointNameToId","topLevelId","objectMapping","objectToArray","binaryGltf","parameter","childrenLength","meshesLength","meshNode","meshNodeId","skeletons","jointNames","jointNamesLength","sceneNodesLength","samplerMapping","mimeType","compressedExtensions","compressedBinaryGltf","objectsToArrays","removeAnimationSamplerNames","premultipliedAlpha","stripAsset","extensionsUsedLength","knownExtensions","requireKnownExtensions","accessorByteStride","computeAccessorByteStride","accessorByteEnd","requireByteLength","bufferViewHasVertexAttributes","bufferViewMap","currentByteOffset","currentIndex","accessorsLength","accessorByteOffset","accessorByteLength","hasNextAccessor","nextAccessorByteStride","newBufferView","newBufferViewId","moveByteStrideToBufferView","minMax","requirePositionAccessorMinMax","requireAnimationAccessorMinMax","removeBufferType","internalFormat","removeTextureProperties","TEXCOORD_0","COLOR_0","TEXCOORD","COLOR","requireAttributeSetIndex","mappedSemantics","newSemantic","setIndex","strippedSemantic","suffix","substring","indexedSemantic","indexedSemantics","knownSemantics","mappedSemantic","underscoreApplicationSpecificSemantics","perspective","aspectRatio","yfov","clampCameraParameters","removeEmptyArrays","instanceTechnique","defaultMode","quat","w","instanceSkin","updatedAccessors","channelsLength","componentsLength","createArrayBufferView","techniqueId","passes","passName","pass","instanceProgram","mapping","CESIUM_RTC","WEB3D_quantized_attributes","POSITION","NORMAL","TANGENT","JOINT","JOINTS","WEIGHT","WEIGHTS","fromColumnMajorArray","targetVersion","toString","updateFunction","DracoLoader","addBufferToLoadResources","loadResources","createdBufferViews","loadResourceBuffers","addNewVertexBuffer","model","context","_loadResources","vertexBuffersToCreate","enqueue","scheduleDecodingTask","decoderTaskProcessor","_taskProcessorReady","taskData","primitivesToDecode","peek","promise","scheduleTask","activeDecodingTasks","dequeue","decodedIndexBuffer","indexArray","indexBuffersToCreate","fromTypedArray","numberOfIndices","addNewIndexBuffer","decodedAttributeData","attributeData","vertexBufferView","_decodedData","_maxDecodingConcurrency","FeatureDetection","hardwareConcurrency","_decoderTaskProcessor","_getDecoderTaskProcessor","processor","TaskProcessor","initWebAssemblyModule","modulePath","wasmBinaryFile","fallbackModulePath","hasExtension","_decodedModelResourceCache","cacheKey","cache","modelDecodingCache","cachedData","pendingDecodingCache","dequantizeInShader","_dequantizeInShader","primitiveId","compressionData","arraySlice","compressedAttributes","decodeModel","decodingPromises","decodePointCloud","cacheDataForModel","destroyCachedDataForModel","samplerUniformName","matrixUniformName","styleUniformName","Spline","times","evaluate","findTimeInterval","startIndex","wrapTime","timeEnd","timeStart","timeStretch","clampTime","LinearSpline","_times","_points","_lastTimeIndex","u","QuaternionSpline","_evaluateFunction","spline","q0","q1","fastSlerp","createEvaluateFunction","WeightSpline","_weights","_count","SCALAR","VEC2","VEC3","VEC4","MAT2","MAT3","MAT4","ModelAnimationCache","dataUriRegex","getAccessorKey","uriKey","test","uri","cachedAnimationParameters","getAnimationParameterValues","typedArrayView","cachedAnimationSplines","ConstantSpline","getAnimationSpline","animationName","samplerName","getAnimationSplineKey","controlPoints","cachedSkinInverseBindMatrices","getSkinInverseBindMatrices","matrices","MIRRORED_REPEAT","STOPPED","ANIMATING","ModelAnimation","runtimeAnimation","_name","_startTime","JulianDate","startTime","_delay","delay","_stopTime","stopTime","removeOnStop","_multiplier","multiplier","_reverse","_loop","loop","stop","_state","ModelAnimationState","_runtimeAnimation","_computedStartTime","_duration","_raiseStartEvent","_updateEventTime","_raiseUpdateEvent","_raiseStopEvent","ModelAnimationCollection","animationAdded","animationRemoved","_model","_scheduledAnimations","_previousTime","_runtime","scheduledAnimation","animateChannels","localAnimationTime","channelEvaluators","addAll","scheduledAnimations","animationsToRemove","createAnimationRemovedFunction","modelAnimationCollection","animationOccured","sceneTime","addSeconds","duration","delta","secondsDifference","pastStartTime","lessThanOrEquals","numberOfListeners","afterRender","fract","animationToRemove","ModelLoadResources","initialized","resourcesParsed","Queue","pendingBufferLoads","programsToCreate","pendingShaderLoads","texturesToCreate","pendingTextureLoads","texturesToCreateFromBufferView","pendingBufferViewToImage","createSamplers","createSkins","createRuntimeAnimations","createVertexArrays","createRenderStates","createUniformMaps","createRuntimeNodes","skinnedNodesIds","getBuffer","finishedPendingBufferLoads","finishedBuffersCreation","finishedProgramCreation","finishedTextureCreation","finishedPendingLoads","finishedResourceCreation","finishedEverythingButTextureCreation","finishedDecoding","finished","ModelMaterial","_uniformMap","_uniformMaps","_technique","_program","_values","ModelMesh","runtimeMaterialsById","_materials","ModelNode","runtimeNode","_runtimeNode","useMatrix","_matrix","_originalMatrix","_perNodeShowDirty","_cesiumAnimationsDirty","dirtyNumber","_maxDirtyNumber","originalMatrix","setMatrix","ModelUtility","cachedSourceVersion","sourceVersion","getAssetVersion","_gltfForwardAxis","primitiveInfoByMaterial","materialIndex","jointAccessorId","JOINTS_0","jointAccessor","isSkinned","hasVertexColors","hasMorphTargets","hasNormals","hasTangents","hasTexCoords","primitiveInfo","skinning","skinned","clonedMaterial","toLowerCase","NEEDS_LOAD","LOADING","LOADED","ModelState","message","_readyPromise","bufferLoad","bufferResource","_resource","getDerivedResource","fetchArrayBuffer","getFailedLoadFunction","aMinScratch","aMaxScratch","techniqueAttributeForSemantic","getTechniqueAttributeOrUniformFunction","ignoreNodes","attributeOrUniform","attributeOrUniformName","computeBoundingSphere","gltfNodes","gltfMeshes","rootNodes","rootNodesLength","nodeStack","_transformToRoot","getTransform","transformToRoot","positionAccessor","getAccessorMinMax","aMin","aMax","minimumByComponent","maximumByComponent","fromCornerPoints","_forwardAxis","transformWithoutScale","_upAxis","ensureSemanticExistence","techniquesWebgl","targetAttributes","lowerCase","pipelineExtras","shaderText","getShaderVariable","ensureSemanticExistenceForPrimitive","createAttributeLocations","precreatedAttributes","attributeLocations","hasIndex0","accessorMin","accessorMax","quantizedAttributes","decodedMin","decodedMax","getAttributeOrUniformBySemantic","programId","getDiffuseAttributeOrUniform","diffuseUniformName","nodeTranslationScratch","nodeQuaternionScratch","nodeScaleScratch","replaceAllButFirstInString","string","find","replace","RegExp","match","getQuantizedAttributes","getAttributeVariableName","getScalarUniformFunction","func","getVec2UniformFunction","getVec3UniformFunction","getVec4UniformFunction","getMat2UniformFunction","getMat3UniformFunction","getMat4UniformFunction","DelayLoadedTextureUniform","defaultTexture","_textureId","_textures","_defaultTexture","getUsedExtensions","cachedExtensionsUsed","getRequiredExtensions","cachedExtensionsRequired","extensionsRequiredLength","supportedExtensions","checkSupportedExtensions","browserSupportsWebp","checkSupportedGlExtensions","glExtensionsUsedLength","elementIndexUint","modifyShaderForDracoQuantizedAttributes","decodedAttributes","quantizedUniforms","quantization","attributeVarName","decodeUniformVarName","variableType","newMain","decodedAttributeVarName","octEncoded","vec3Color","decode","decodeUniformVarNameRangeConstant","decodeUniformVarNameNormConstant","decodeUniformVarNameMin","ShaderSource","replaceMain","modifyShaderForQuantizedAttributes","decodeUniformVarNameScale","decodeUniformVarNameTranslate","decodeMatrix","mat","vec","toClipCoordinatesGLSL","positionName","decodedPositionName","modelViewProjectionName","projectionName","modelViewName","modifyFragmentShaderForLogDepth","modifyVertexShaderForLogDepth","gltfUniformFunctions","translateFromMatrix5Array","FLOAT_VEC2","FLOAT_VEC3","FLOAT_VEC4","INT_VEC2","INT_VEC3","INT_VEC4","BOOL","BOOL_VEC2","BOOL_VEC3","BOOL_VEC4","FLOAT_MAT2","FLOAT_MAT3","FLOAT_MAT4","SAMPLER_2D","createUniformFunction","createUniformsForDracoQuantizedAttributes","uniformMap","decodedData","uniformVarName","uniformVarNameRangeConstant","rangeConstant","quantizationBits","uniformVarNameNormConstant","normConstant","range","uniformVarNameMin","minValues","createUniformsForQuantizedAttributes","setUniforms","uniformVariable","uniformVariableScale","uniformVariableTranslate","quantizedUniform","properties","scratchTranslationRtc","gltfSemanticUniforms","MODEL","uniformState","VIEW","view","PROJECTION","MODELVIEW","modelView","CESIUM_RTC_MODELVIEW","mvRtc","_rtcCenter","getTranslation","setTranslation","MODELVIEWPROJECTION","modelViewProjection","MODELINVERSE","inverseModel","VIEWINVERSE","inverseView","PROJECTIONINVERSE","inverseProjection","MODELVIEWINVERSE","inverseModelView","MODELVIEWPROJECTIONINVERSE","inverseModelViewProjection","MODELINVERSETRANSPOSE","inverseTransposeModel","MODELVIEWINVERSETRANSPOSE","VIEWPORT","viewportCartesian4","getGltfSemanticUniforms","webGLValue","getKHRMaterialsCommonValueType","paramName","paramValue","khrMaterialsCommon","lightsLength","lightId","light","ambientLight","directional","directionalLight","pointLight","constantAttenuation","linearAttenuation","quadraticAttenuation","spot","spotLight","fallOffAngle","fallOffExponent","lightDefaults","lightParameters","nodeName","nodeLightId","lightCount","lightName","lightType","lightBaseName","baseName","useInFragment","generateLightParameters","primitiveByMaterial","splitIncompatibleMaterials","generatedTechniques","techniqueKey","keysCount","jointCount","skinningInfo","getTechniqueKey","addBatchIdToGeneratedShaders","lightingModel","toUpperCase","parameterValues","hasSkinning","techniqueUniforms","u_modelViewMatrix","u_projectionMatrix","u_normalMatrix","u_jointMatrix","uniformType","u_diffuse","lightParamName","arraySize","vertexShaderMain","v_texcoord","techniqueAttributes","a_position","a_normal","a_texcoord_0","attributeType","a_joint","a_weight","a_vertexColor","a_batchId","hasSpecular","u_specular","u_shininess","hasNonAmbientLights","hasAmbientLights","fragmentLightingBlock","varyingDirectionName","varyingPositionName","lightColorName","finalColorComputation","colorCreationBlock","u_transparency","u_emission","u_ambient","vertexShaderId","VERTEX_SHADER","fragmentShaderId","FRAGMENT_SHADER","generateTechnique","materialValues","valueName","addTextureCoordinates","textureName","generatedMaterialValues","defaultTexCoord","fragmentShaderMain","DEFAULT_TEXTURE_OFFSET","DEFAULT_TEXTURE_ROTATION","DEFAULT_TEXTURE_SCALE","handleKHRTextureTransform","KHR_texture_transform","getPBRValueType","useSpecGloss","KHR_materials_pbrSpecularGlossiness","isSpecularGlossinessMaterial","additional","morphTargets","isUnlit","KHR_materials_unlit","u_morphWeights","u_alphaCutoff","baseColorUniform","u_baseColorTexture","u_baseColorFactor","targetAttribute","a_tangent","v_texCoord","normalTexCoord","baseColorTexCoord","specularGlossinessTexCoord","diffuseTexCoord","metallicRoughnessTexCoord","occlusionTexCoord","emissiveTexCoord","u_normalTexture","u_specularGlossinessTexture","u_specularFactor","u_glossinessFactor","u_diffuseTexture","u_diffuseFactor","u_metallicRoughnessTexture","u_metallicFactor","u_roughnessFactor","u_occlusionTexture","u_emissiveTexture","u_emissiveFactor","isOutline","TERRIA_solid_outlines","boundingSphereCartesian3Scratch","articulationEpsilon","EPSILON16","setCachedGltf","cachedGltf","_cachedGltf","CachedGltf","_gltf","modelsToLoad","makeReady","gltfJson","models","gltfCache","uriToGuid","Model","_cacheKey","_releaseGltfJson","releaseGltfJson","ArrayBuffer","basePath","createIfNeeded","credit","Credit","_credit","_resourceCredits","silhouetteColor","RED","_silhouetteColor","_silhouetteColorPreviousAlpha","_normalAttributeName","silhouetteSize","_clampedModelMatrix","minimumPixelSize","_minimumPixelSize","maximumScale","_maximumScale","_heightChanged","_removeUpdateHeightCallback","_terrainProviderChangedCallback","_pickObject","pickObject","_allowPicking","allowPicking","_ready","defer","activeAnimations","clampAnimations","_incrementallyLoadTextures","incrementallyLoadTextures","_asynchronous","ENABLED","_colorPreviousAlpha","_colorShadingEnabled","_clippingPlanes","clippingPlanes","_clippingPlanesState","clippingPlanesOriginMatrix","debugShowBoundingVolume","_debugShowBoundingVolume","debugWireframe","_debugWireframe","_addBatchIdToGeneratedShaders","_precreatedAttributes","_vertexShaderLoaded","vertexShaderLoaded","_fragmentShaderLoaded","fragmentShaderLoaded","_uniformMapLoaded","uniformMapLoaded","_pickIdLoaded","pickIdLoaded","_ignoreCommands","ignoreCommands","_requestType","requestType","upAxis","forwardAxis","cull","opaquePass","Pass","OPAQUE","_computedModelMatrix","_clippingPlaneModelViewMatrix","_initialRadius","_boundingSphere","_scaledBoundingSphere","_mode","_dirty","articulationsByName","articulationsByStageKey","stagesByKey","nodesByName","skinnedNodes","meshesByName","materialsByName","materialsById","_extensionsUsed","_extensionsRequired","_quantizedUniforms","_programPrimitives","_rendererResources","vertexArrays","sourceShaders","silhouettePrograms","_cachedRendererResources","_loadRendererResourcesFromCache","_cachedGeometryByteLength","_cachedTexturesByteLength","_geometryByteLength","_texturesByteLength","_trianglesLength","_sourceTechniques","_sourcePrograms","_quantizedVertexShaders","_nodeCommands","_pickIds","_rtcCenterEye","_rtcCenter3D","_rtcCenter2D","_sourceVersion","_sourceKHRTechniquesWebGL","_imageBasedLightingFactor","imageBasedLightingFactor","_lightColor","lightColor","_luminanceAtZenith","luminanceAtZenith","_sphericalHarmonicCoefficients","sphericalHarmonicCoefficients","_specularEnvironmentMaps","specularEnvironmentMaps","_shouldUpdateSpecularMapAtlas","_specularEnvironmentMapAtlas","_useDefaultSphericalHarmonics","_useDefaultSpecularMaps","_shouldRegenerateShaders","silhouetteSupported","stencilBuffer","isColorShadingEnabled","isClippingEnabled","getRuntime","runtimeName","nonUniformScale","getScale","scaledBoundingSphere","multiplyComponents","maximumComponent","readyPromise","dirty","trianglesLength","geometryByteLength","texturesByteLength","cachedGeometryByteLength","cachedTexturesByteLength","ClippingPlaneCollection","setOwner","pickIds","lum","fromGltf","modelResource","resource","getAbsoluteUri","createGuid","headers","Accept","arrayBuffer","parsedGltf","json","resourceCredits","credits","_gltfCache","getNode","publicNode","getMesh","getMaterial","setArticulationStage","articulationStageKey","stage","articulation","minimumValue","maximumValue","currentValue","scratchArticulationCartesian","scratchArticulationRotation","applyArticulationStageMatrix","cartesian","multiplyByMatrix3","multiplyByTranslation","multiplyByUniformScale","scratchApplyArticulationTransform","imageLoad","textureId","applyArticulations","articulationName","numNodes","numStages","stages","ktxRegex","crnRegex","scratchArticulationStageInitialTransform","CreateVertexBufferJob","createVertexBuffer","vertexBuffer","Buffer","usage","BufferUsage","STATIC_DRAW","vertexArrayDestroyable","sizeInBytes","execute","CreateIndexBufferJob","createIndexBuffer","indexBuffer","indexDatatype","scratchVertexBufferJob","scratchIndexBufferJob","getProgramForPrimitive","programName","modifyShader","CreateProgramJob","programToCreate","createProgram","quantizedVertexShaders","_toClipCoordinatesGLSL","quantizedVS","drawVS","drawFS","isInternetExplorer","useIBL","OctahedralProjectedCubeMap","usesSH","usesSM","createAttributesAndProgram","recreateProgram","clippingPlaneCollection","addClippingPlaneCode","finalFS","_modifyShaderForColor","_getClippingFunction","modifyShaderForClippingPlanes","ShaderProgram","fromCache","scratchCreateProgramJob","getOnImageCreatedFromTypedArray","gltfTexture","CreateTextureJob","createTexture","Sampler","TextureWrap","usesTextureTransform","materialsLength","minFilter","minificationFilter","TextureMinificationFilter","LINEAR","NEAREST","NEAREST_MIPMAP_NEAREST","NEAREST_MIPMAP_LINEAR","textureMinificationFilter","textureMagnificationFilter","magnificationFilter","tx","mipmap","PixelFormat","isCompressedFormat","LINEAR_MIPMAP_NEAREST","LINEAR_MIPMAP_LINEAR","requiresNpot","Texture","arrayBufferView","pixelFormat","npot","isPowerOfTwo","canvas","document","createElement","nextPowerOfTwo","getContext","drawImage","pixelDatatype","generateMipmap","scratchCreateTextureJob","mapJointNames","forest","jointNodes","runtimeSkins","bindShapeMatrix","runtimeNodes","skinnedNode","runtimeSkin","mappedJointNames","gltfJointNames","jointNode","createJoints","getChannelEvaluator","targetPath","rendererBuffers","rendererVertexArrays","attributeLocation","location","programVertexAttributes","vertexAttributes","programAttributeLocations","_attributeLocations","getAttributeLocations","decodedAttribute","offsetInBytes","strideInBytes","VertexArray","rendererRenderStates","polygonOffset","hasOutlines","factor","units","enableCulling","blendingEnabled","RenderState","depthTest","depthMask","equationRgb","equationAlpha","functionSourceRgb","functionDestinationRgb","functionSourceAlpha","functionDestinationAlpha","createRenderStateForMaterial","gltfUniformsFromNode","computedMatrix","mv","mvp","multiply","_projection","mInverse","inverse","mvInverse","mvpInverse","mInverseTranspose","getMatrix3","transpose","mvInverseTranspose","createUniformsForMaterial","instanceValues","jointMatrixUniformName","morphWeightsUniformName","uniformValues","uv","getUniformFunctionFromSource","alphaCutoffValue","uv2","createPickColorFunction","createJointMatricesFunction","computedJointMatrices","createMorphWeightsFunction","createSilhouetteColorFunction","createSilhouetteSizeFunction","createColorFunction","scratchClippingPlaneMatrix","createClippingPlanesMatrixFunction","createClippingPlanesFunction","createClippingPlanesEdgeStyleFunction","withAlpha","edgeColor","alpha","edgeWidth","createColorBlendFunction","getColorBlend","createIBLFactorFunction","createLightColorFunction","createLuminanceAtZenithFunction","createSphericalHarmonicCoefficientsFunction","createSpecularEnvironmentMapFunction","createSpecularEnvironmentMapSizeFunction","createSpecularEnvironmentMapLOD","maximumMipmapLevel","triangleCountFromPrimitiveIndices","TRIANGLE_STRIP","TRIANGLE_FAN","createCommand","gltfNode","scene3DOnly","nodeCommands","runtimeMeshesByName","resources","rendererPrograms","uniformMaps","ix","vertexArray","um","jointUniformMap","morphWeightsUniformMap","gltf_color","gltf_colorBlend","gltf_clippingPlanes","gltf_clippingPlanesEdgeStyle","gltf_clippingPlanesMatrix","gltf_iblFactor","gltf_lightColor","gltf_sphericalHarmonicCoefficients","gltf_specularMap","gltf_specularMapSize","gltf_maxSpecularLOD","gltf_luminanceAtZenith","quantizedUniformMap","rs","owner","pickId","castShadows","receiveShadows","createPickId","pickUniforms","czm_pickColor","command2D","command","DrawCommand","boundingVolume","shaderProgram","TRANSLUCENT","shallowClone","nodeCommand","silhouetteModelCommand","silhouetteModelCommand2D","silhouetteColorCommand","silhouetteColorCommand2D","translucentCommand","translucentCommand2D","commands","createResources","toClipCoordinates","cachedResources","memory","getGeometryByteLength","getTexturesByteLength","jobScheduler","JobType","BUFFER","createBuffers","PROGRAM","createPrograms","rendererSamplers","magFilter","onerror","loadKTX","loadCRN","onload","loadTexturesFromBufferViews","TEXTURE","createTextures","modelMaterial","seen","parentRuntimeNode","skeletonIds","parents","childId","getNodeMatrix","publicMatrix","scratchNodeStack","scratchComputedTranslation","scratchComputedMatrixIn2D","scratchObjectSpace","deriveTranslucentCommand","BlendingState","ALPHA_BLEND","updateColor","forceDerive","getProgramId","createSilhouetteProgram","sources","normalAttributeName","hasSilhouette","isInvisible","alphaDirty","currAlpha","prevAlpha","silhouettesLength","createSilhouetteCommands","stencilReference","silhouetteTranslucent","hasTranslucentCommands","modelCommand","stencilTest","frontFunction","ALWAYS","backFunction","reference","mask","frontOperation","fail","KEEP","zFail","zPass","backOperation","colorMask","red","green","blue","NOTEQUAL","silhouetteProgram","silhouetteUniformMap","gltf_silhouetteColor","gltf_silhouetteSize","updateSilhouette","force","scratchBoundingSphere","maxPixelSize","drawingBufferWidth","drawingBufferHeight","cartographic","metersPerPixel","positionWC","getPixelSize","scaleInPixels","pixelsPerMeter","releaseCachedGltf","CachedRendererResources","getUpdateHeightCallback","cartoPosition","clampedCart","clampedModelMatrix","release","modelRendererResourceCache","scratchDisplayConditionCartesian","scratchDistanceDisplayConditionCartographic","destroyIfNotCached","rendererResources","cachedRendererResources","MORPHING","supportsWebP","modelCaches","projectedCart","parseBuffers","justLoaded","brdfLutGenerator","updateForwardAxis","sourceKHRTechniquesWebGL","addBuffersToLoadResources","runtimeStagesByKey","AGI_articulations","gltfArticulations","articulations","numArticulations","initialValue","stageKey","parseArticulations","sourcePrograms","sourceTechniques","parseTechniques","indexBufferIds","parseBufferViews","shaderResource","fetchText","shaderLoad","parseShaders","parsePrograms","imageId","EXT_texture_webp","gltfImage","crunch","s3tc","pvrtc","pvrtc1","etc1","imageResource","parseTextures","runtimeMaterialsByName","parseMaterials","programPrimitives","parseMeshes","runtimeNodesByName","computedShow","parseNodes","iblSupported","console","recompileWithDefaultAtlas","recompileWithoutDefaultAtlas","recompileWithDefaultSHCoeffs","recompileWithoutDefaultSHCoeffs","silhouette","invisible","displayConditionPassed","distance2","ddc","nearSquared","farSquared","SCENE2D","frustum","COLUMBUS_VIEW","distanceSquared","distanceDisplayConditionVisible","animated","modeChanged","modelTransformChanged","cb","computedModelMatrix","maxDirtyNumber","UNIT_W","to2D","wgs84To2DModelMatrix","basisTo2D","nodeMatrix","commandsLength","primitiveCommand","sign","updateNodeHierarchyModelMatrix","inverseBindMatricesLength","applySkins","nodeCommandsLength","updatePerNodeShow","updatePickIds","updateWireframe","updateShowBoundingVolume","updateShadows","updateClippingPlanes","currentClippingPlanesState","useClippingPlanes","view3D","clippingPlanesState","shouldRegenerateShaders","currentlyColorShadingEnabled","visitedPrograms","commandCount","renderProgram","regenerateShaders","nc","commandList","idl2D","render","pick","creditDisplay","addCredit","creditCount","initialize","getClippingFunction","defaultSilhouetteColor","defaultColorBlendMode","defaultImageBasedLightingFactor","defaultUpAxis","modelMatrixScratch","nodeMatrixScratch","ModelVisualizer","_modelHash","_entitiesToVisualize","removeModel","visualizer","modelHash","modelData","modelPrimitive","clearNodeTransformationsArticulationsScratch","nodeTransformationsScratch","articulationsScratch","checkModelLoad","loadFail","modelGraphics","_uri","animationsRunning","_silhouetteSize","_colorBlendMode","_colorBlendAmount","_clampAnimations","runAnimations","_runAnimations","nodeTransformations","_nodeTransformations","nodeNames","nodeIndex","nodeLength","nodeTransformation","modelNode","transformationMatrix","fromTranslationRotationScale","anyArticulationUpdated","_articulations","articulationStageKeys","numKeys","articulationStageValue","Polyline","polylineCollection","_actualPositions","_segments","_actualLength","_propertiesChanged","NUMBER_OF_PROPERTIES","_polylineCollection","_pickId","_boundingVolume","_boundingVolumeWC","_boundingVolume2D","POSITION_INDEX","SHOW_INDEX","WIDTH_INDEX","MATERIAL_INDEX","POSITION_SIZE_INDEX","DISTANCE_DISPLAY_CONDITION","makeDirty","polyline","propertyChanged","_updatePolyline","segmentPositionsLength","segmentLengths","positionsChanged","getPickId","_clean","_destroy","texCoordExpandAndBatchIndex","position3DHigh","position3DLow","position2DHigh","position2DLow","prevPosition3DHigh","prevPosition3DLow","prevPosition2DHigh","prevPosition2DLow","nextPosition3DHigh","nextPosition3DLow","nextPosition2DHigh","nextPosition2DLow","PolylineCollection","_opaqueRS","_translucentRS","_colorCommands","_polylinesUpdated","_polylinesRemoved","_createVertexArray","_polylines","_polylineBuckets","_positionBufferUsage","bufferUsage","frameCount","_polylinesToUpdate","_vertexArrays","_positionBuffer","_texCoordExpandAndBatchIndexBuffer","_batchTable","_createBatchTable","_useHighlightColor","_highlightColor","u_highlightColor","removePolylines","_index","_bucket","bucket","releaseShaders","destroyPolylines","scratchUpdatePolylineEncodedCartesian","EncodedCartesian3","scratchUpdatePolylineCartesian4","scratchNearFarCartesian2","updateMode","ContextLimits","maximumVertexTextureImageUnits","functionName","BatchTable","createBatchTable","usageChanged","STREAM_DRAW","computeNewBuffersUsage","polylinesToUpdate","updateLength","polylineBuckets","ii","writeUpdate","lengthOfPositions","setBatchedAttribute","encodedCenter","fromCartesian","low","high","nearFarCartesian","useDepthTest","morphTime","commandIndex","cloneBoundingSphere","uniformCallback","getUniformMapCallback","va","buckets","bucketLength","currentId","currentMaterial","bucketLocator","sp","polylines","polylineLength","mId","createMaterialId","_uniforms","boundingSphereScratch","locators","_locatorBuckets","locatorLength","locator","boundingSphereScratch2","createCommandLists","destroyVertexArrays","emptyVertexBuffer","PolylineBucket","addPolyline","sortPolylinesIntoBuckets","totalIndices","batchTable","useHighlightColor","vertexBufferOffset","vertexArrayBuckets","totalLength","updateShader","position3DArray","positionArray","texCoordExpandAndBatchIndexArray","colorIndex","texCoordExpandAndBatchIndexIndex","write","writeForMorph","updateIndices","position3DBuffer","positionBufferUsage","texCoordExpandAndBatchIndexBufferUsage","positionSizeInBytes","BYTES_PER_ELEMENT","texCoordExpandAndBatchIndexSizeInBytes","vbo","numberOfIndicesArrays","indicesArray","buffer3D","bufferProperty3D","buffer2D","bufferProperty2D","positionHighOffset","SIXTY_FOUR_KILOBYTES","positionLowOffset","prevPositionHighOffset","prevPositionLowOffset","nextPositionHighOffset","nextPositionLowOffset","vertexTexCoordExpandAndBatchIndexBufferOffset","replacer","scratchUniformArray","_uniformList","stringify","definedPolylines","definedPolylinesToUpdate","polyIndex","VertexArrayBucketLocator","intersectsIDL","intersectPlane","ORIGIN_ZX_PLANE","Intersect","INTERSECTING","getPolylinePositionsLength","defines","shaderSource","PolylineFS","vsSource","getVertexShaderCallback","PolylineCommon","scratchWritePosition","scratchWritePrevPosition","scratchWriteNextPosition","scratchWriteVector","scratchPickColorCartesian","scratchWidthShowCartesian","polylineBatchIndex","getSegments","pickColor","segmentIndex","segmentStart","segmentEnd","endK","writeElements","colorCartesian","floatToByte","widthShowCartesian","morphPositionScratch","morphPrevPositionScratch","morphNextPositionScratch","morphVectorScratch","prevPosition","scratchSegmentLengths","vaCount","numberOfSegments","segmentIndexCount","getPolylineStartIndex","scratchPositionsArray","scratchSegments","scratchLengths","pscratch","center2D","positionBuffer","positionsArrayLength","endJ","copyFromArrayView","scratchTimeInterval","TimeInterval","subSampleCompositePropertyScratch","subSampleIntervalPropertyScratch","reallySubSample","updateTime","maximumStep","SampledPositionProperty","sampleStepsToTake","sampleStepsTaken","sampleStepSize","steppedOnNow","greaterThanOrEquals","current","loopStop","sampling","greaterThan","lessThan","secondsUntilNext","subSampleSampledProperty","_property","intersect","intervalStart","intervalStop","sampleStart","sampleStop","subSampleCompositeProperty","TimeIntervalCollectionPositionProperty","isStartIncluded","isStopIncluded","subSampleIntervalProperty","ConstantPositionProperty","subSampleConstantProperty","stepSize","subSampleGenericProperty","subSample","toFixedScratch","PolylineUpdater","_unusedIndexes","PathVisualizer","_updaters","ReferenceFrame","INERTIAL","toFixed","computeIcrfToFixedMatrix","computeTemeToPseudoFixedMatrix","updateObject","pathGraphics","_path","showProperty","leadTime","_leadTime","trailTime","_trailTime","_availability","hasAvailability","hasLeadTime","hasTrailTime","unusedIndexes","resolution","_resolution","removeObject","lastUpdater","frameToVisualize","currentUpdater","_subSample","centerAlpha","cssColor","cssOutlineColor","cssOutlineWidth","pixelSize","context2D","clearRect","beginPath","arc","closePath","fillStyle","save","globalCompositeOperation","restore","pointPrimitive","PointVisualizer","removePoint","pointGraphics","_point","needsRedraw","getPoint","_pixelSize","newOutlineColor","newOutlineWidth","newPixelSize","toCssColorString","setImage","scratchInterpolateColorsArray","interpolateColors","color0","color1","colors","r0","g0","b0","a0","r1","g1","b1","a1","redPerVertex","greenPerVertex","bluePerVertex","alphaPerVertex","PolylineGeometry","colorsPerVertex","_colors","_colorsPerVertex","scratchPrevPosition","scratchNextPosition","polylineGeometry","subdivisionSize","numberOfPointsFunction","colorLength","newColors","newColorIndex","numColors","interpolatedColors","interpolatedColorsLength","prevPositions","nextPositions","expandAndWidth","finalColors","expandAndWidthIndex","geometryType","GeometryType","POLYLINES","polylineCollections","GeometryOptions","GroundGeometryOptions","PolylineGeometryUpdater","_entitySubscription","_depthFailMaterialProperty","_geometryOptions","_groundGeometryOptions","_clampToGround","_supportsPolylinesOnTerrain","supportsPolylinesOnTerrain","clampToGround","GroundPolylineGeometry","positionsProperty","PolylineColorAppearance","PolylineMaterialAppearance","groundGeometryOptions","generateCartesianArcOptions","_line","_groundPolylinePrimitive","getLine","dynamicGeometryUpdater","sceneId","line","GroundPolylinePrimitive","groundPolylinePrimitive","StaticGroundPolylinePerMaterialBatch","removeUpdater","insertUpdaterIntoBatch","_groundBatches","_colorBatches","_materialBatches","PolylineVisualizer","DataSourceDisplay","_displayID","initializeTerrainHeights","dataSourceCollection","dataSourceAdded","_onDataSourceAdded","dataSourceRemoved","_onDataSourceRemoved","dataSourceMoved","_onDataSourceMoved","postRender","_postRender","_dataSourceCollection","_visualizersCallback","visualizersCallback","defaultVisualizersCallback","primitivesAdded","removeDefaultDataSourceListener","removeDataSourceCollectionListener","defaultDataSource","CustomDataSource","_defaultDataSource","addPrimitives","_removeDefaultDataSourceListener","_removeDataSourceCollectionListener","dataSource","dataSources","visualizers","vLength","_visualizersByDisplayID","allowPartial","d","_visualizers","visualizersLength","displayPrimitives","displayGroundPrimitives","clustering","_initialize","newIndex","oldIndex","raise","lower","lowerToBottom","raiseToTop"],"mappings":"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","file":"1.TerriaJS-specs.js","sourcesContent":["import freezeObject from './freezeObject.js';\n\n    /**\n     * Style options for corners.\n     *\n     * @demo The {@link https://sandcastle.cesium.com/index.html?src=Corridor.html&label=Geometries|Corridor Demo}\n     * demonstrates the three corner types, as used by {@link CorridorGraphics}.\n     *\n     * @exports CornerType\n     */\n    var CornerType = {\n        /**\n         * <img src=\"Images/CornerTypeRounded.png\" style=\"vertical-align: middle;\" width=\"186\" height=\"189\" />\n         *\n         * Corner has a smooth edge.\n         * @type {Number}\n         * @constant\n         */\n        ROUNDED : 0,\n\n        /**\n         * <img src=\"Images/CornerTypeMitered.png\" style=\"vertical-align: middle;\" width=\"186\" height=\"189\" />\n         *\n         * Corner point is the intersection of adjacent edges.\n         * @type {Number}\n         * @constant\n         */\n        MITERED : 1,\n\n        /**\n         * <img src=\"Images/CornerTypeBeveled.png\" style=\"vertical-align: middle;\" width=\"186\" height=\"189\" />\n         *\n         * Corner is clipped.\n         * @type {Number}\n         * @constant\n         */\n        BEVELED : 2\n    };\nexport default freezeObject(CornerType);\n","import defined from '../Core/defined.js';\nimport defineProperties from '../Core/defineProperties.js';\nimport DeveloperError from '../Core/DeveloperError.js';\nimport Event from '../Core/Event.js';\nimport EventHelper from '../Core/EventHelper.js';\nimport TimeIntervalCollection from '../Core/TimeIntervalCollection.js';\nimport Property from './Property.js';\n\n    function subscribeAll(property, eventHelper, definitionChanged, intervals) {\n        function callback() {\n            definitionChanged.raiseEvent(property);\n        }\n        var items = [];\n        eventHelper.removeAll();\n        var length = intervals.length;\n        for (var i = 0; i < length; i++) {\n            var interval = intervals.get(i);\n            if (defined(interval.data) && items.indexOf(interval.data) === -1) {\n                eventHelper.add(interval.data.definitionChanged, callback);\n            }\n        }\n    }\n\n    /**\n     * A {@link Property} which is defined by a {@link TimeIntervalCollection}, where the\n     * data property of each {@link TimeInterval} is another Property instance which is\n     * evaluated at the provided time.\n     *\n     * @alias CompositeProperty\n     * @constructor\n     *\n     *\n     * @example\n     * var constantProperty = ...;\n     * var sampledProperty = ...;\n     *\n     * //Create a composite property from two previously defined properties\n     * //where the property is valid on August 1st, 2012 and uses a constant\n     * //property for the first half of the day and a sampled property for the\n     * //remaining half.\n     * var composite = new Cesium.CompositeProperty();\n     * composite.intervals.addInterval(Cesium.TimeInterval.fromIso8601({\n     *     iso8601 : '2012-08-01T00:00:00.00Z/2012-08-01T12:00:00.00Z',\n     *     data : constantProperty\n     * }));\n     * composite.intervals.addInterval(Cesium.TimeInterval.fromIso8601({\n     *     iso8601 : '2012-08-01T12:00:00.00Z/2012-08-02T00:00:00.00Z',\n     *     isStartIncluded : false,\n     *     isStopIncluded : false,\n     *     data : sampledProperty\n     * }));\n     *\n     * @see CompositeMaterialProperty\n     * @see CompositePositionProperty\n     */\n    function CompositeProperty() {\n        this._eventHelper = new EventHelper();\n        this._definitionChanged = new Event();\n        this._intervals = new TimeIntervalCollection();\n        this._intervals.changedEvent.addEventListener(CompositeProperty.prototype._intervalsChanged, this);\n    }\n\n    defineProperties(CompositeProperty.prototype, {\n        /**\n         * Gets a value indicating if this property is constant.  A property is considered\n         * constant if getValue always returns the same result for the current definition.\n         * @memberof CompositeProperty.prototype\n         *\n         * @type {Boolean}\n         * @readonly\n         */\n        isConstant : {\n            get : function() {\n                return this._intervals.isEmpty;\n            }\n        },\n        /**\n         * Gets the event that is raised whenever the definition of this property changes.\n         * The definition is changed whenever setValue is called with data different\n         * than the current value.\n         * @memberof CompositeProperty.prototype\n         *\n         * @type {Event}\n         * @readonly\n         */\n        definitionChanged : {\n            get : function() {\n                return this._definitionChanged;\n            }\n        },\n        /**\n         * Gets the interval collection.\n         * @memberof CompositeProperty.prototype\n         *\n         * @type {TimeIntervalCollection}\n         */\n        intervals : {\n            get : function() {\n                return this._intervals;\n            }\n        }\n    });\n\n    /**\n     * Gets the value of the property at the provided time.\n     *\n     * @param {JulianDate} time The time for which to retrieve the value.\n     * @param {Object} [result] The object to store the value into, if omitted, a new instance is created and returned.\n     * @returns {Object} The modified result parameter or a new instance if the result parameter was not supplied.\n     */\n    CompositeProperty.prototype.getValue = function(time, result) {\n        \n\n        var innerProperty = this._intervals.findDataForIntervalContainingDate(time);\n        if (defined(innerProperty)) {\n            return innerProperty.getValue(time, result);\n        }\n        return undefined;\n    };\n\n    /**\n     * Compares this property to the provided property and returns\n     * <code>true</code> if they are equal, <code>false</code> otherwise.\n     *\n     * @param {Property} [other] The other property.\n     * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n     */\n    CompositeProperty.prototype.equals = function(other) {\n        return this === other || //\n               (other instanceof CompositeProperty && //\n                this._intervals.equals(other._intervals, Property.equals));\n    };\n\n    /**\n     * @private\n     */\n    CompositeProperty.prototype._intervalsChanged = function() {\n        subscribeAll(this, this._eventHelper, this._definitionChanged, this._intervals);\n        this._definitionChanged.raiseEvent(this);\n    };\nexport default CompositeProperty;\n","import freezeObject from '../Core/freezeObject.js';\nimport CesiumMath from '../Core/Math.js';\n\n    /**\n     * Defines different modes for blending between a target color and a primitive's source color.\n     *\n     * HIGHLIGHT multiplies the source color by the target color\n     * REPLACE replaces the source color with the target color\n     * MIX blends the source color and target color together\n     *\n     * @exports ColorBlendMode\n     *\n     * @see Model.colorBlendMode\n     */\n    var ColorBlendMode = {\n        HIGHLIGHT : 0,\n        REPLACE : 1,\n        MIX : 2\n    };\n\n    /**\n     * @private\n     */\n    ColorBlendMode.getColorBlend = function(colorBlendMode, colorBlendAmount) {\n        if (colorBlendMode === ColorBlendMode.HIGHLIGHT) {\n            return 0.0;\n        } else if (colorBlendMode === ColorBlendMode.REPLACE) {\n            return 1.0;\n        } else if (colorBlendMode === ColorBlendMode.MIX) {\n            // The value 0.0 is reserved for highlight, so clamp to just above 0.0.\n            return CesiumMath.clamp(colorBlendAmount, CesiumMath.EPSILON4, 1.0);\n        }\n    };\nexport default freezeObject(ColorBlendMode);\n","import defaultValue from '../Core/defaultValue.js';\nimport defined from '../Core/defined.js';\nimport defineProperties from '../Core/defineProperties.js';\nimport DeveloperError from '../Core/DeveloperError.js';\nimport Event from '../Core/Event.js';\nimport ReferenceFrame from '../Core/ReferenceFrame.js';\nimport CompositeProperty from './CompositeProperty.js';\nimport Property from './Property.js';\n\n    /**\n     * A {@link CompositeProperty} which is also a {@link PositionProperty}.\n     *\n     * @alias CompositePositionProperty\n     * @constructor\n     *\n     * @param {ReferenceFrame} [referenceFrame=ReferenceFrame.FIXED] The reference frame in which the position is defined.\n     */\n    function CompositePositionProperty(referenceFrame) {\n        this._referenceFrame = defaultValue(referenceFrame, ReferenceFrame.FIXED);\n        this._definitionChanged = new Event();\n        this._composite = new CompositeProperty();\n        this._composite.definitionChanged.addEventListener(CompositePositionProperty.prototype._raiseDefinitionChanged, this);\n    }\n\n    defineProperties(CompositePositionProperty.prototype, {\n        /**\n         * Gets a value indicating if this property is constant.  A property is considered\n         * constant if getValue always returns the same result for the current definition.\n         * @memberof CompositePositionProperty.prototype\n         *\n         * @type {Boolean}\n         * @readonly\n         */\n        isConstant : {\n            get : function() {\n                return this._composite.isConstant;\n            }\n        },\n        /**\n         * Gets the event that is raised whenever the definition of this property changes.\n         * The definition is changed whenever setValue is called with data different\n         * than the current value.\n         * @memberof CompositePositionProperty.prototype\n         *\n         * @type {Event}\n         * @readonly\n         */\n        definitionChanged : {\n            get : function() {\n                return this._definitionChanged;\n            }\n        },\n        /**\n         * Gets the interval collection.\n         * @memberof CompositePositionProperty.prototype\n         *\n         * @type {TimeIntervalCollection}\n         */\n        intervals : {\n            get : function() {\n                return this._composite.intervals;\n            }\n        },\n        /**\n         * Gets or sets the reference frame which this position presents itself as.\n         * Each PositionProperty making up this object has it's own reference frame,\n         * so this property merely exposes a \"preferred\" reference frame for clients\n         * to use.\n         * @memberof CompositePositionProperty.prototype\n         *\n         * @type {ReferenceFrame}\n         */\n        referenceFrame : {\n            get : function() {\n                return this._referenceFrame;\n            },\n            set : function(value) {\n                this._referenceFrame = value;\n            }\n        }\n    });\n\n    /**\n     * Gets the value of the property at the provided time in the fixed frame.\n     *\n     * @param {JulianDate} time The time for which to retrieve the value.\n     * @param {Object} [result] The object to store the value into, if omitted, a new instance is created and returned.\n     * @returns {Object} The modified result parameter or a new instance if the result parameter was not supplied.\n     */\n    CompositePositionProperty.prototype.getValue = function(time, result) {\n        return this.getValueInReferenceFrame(time, ReferenceFrame.FIXED, result);\n    };\n\n    /**\n     * Gets the value of the property at the provided time and in the provided reference frame.\n     *\n     * @param {JulianDate} time The time for which to retrieve the value.\n     * @param {ReferenceFrame} referenceFrame The desired referenceFrame of the result.\n     * @param {Cartesian3} [result] The object to store the value into, if omitted, a new instance is created and returned.\n     * @returns {Cartesian3} The modified result parameter or a new instance if the result parameter was not supplied.\n     */\n    CompositePositionProperty.prototype.getValueInReferenceFrame = function(time, referenceFrame, result) {\n        \n\n        var innerProperty = this._composite._intervals.findDataForIntervalContainingDate(time);\n        if (defined(innerProperty)) {\n            return innerProperty.getValueInReferenceFrame(time, referenceFrame, result);\n        }\n        return undefined;\n    };\n\n    /**\n     * Compares this property to the provided property and returns\n     * <code>true</code> if they are equal, <code>false</code> otherwise.\n     *\n     * @param {Property} [other] The other property.\n     * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n     */\n    CompositePositionProperty.prototype.equals = function(other) {\n        return this === other || //\n               (other instanceof CompositePositionProperty && //\n                this._referenceFrame === other._referenceFrame && //\n                this._composite.equals(other._composite, Property.equals));\n    };\n\n    /**\n     * @private\n     */\n    CompositePositionProperty.prototype._raiseDefinitionChanged = function() {\n        this._definitionChanged.raiseEvent(this);\n    };\nexport default CompositePositionProperty;\n","import defined from '../Core/defined.js';\nimport defineProperties from '../Core/defineProperties.js';\nimport DeveloperError from '../Core/DeveloperError.js';\nimport Event from '../Core/Event.js';\nimport Property from './Property.js';\n\n    function resolve(that) {\n        var targetProperty = that._targetProperty;\n\n        if (!defined(targetProperty)) {\n            var targetEntity = that._targetEntity;\n\n            if (!defined(targetEntity)) {\n                targetEntity = that._targetCollection.getById(that._targetId);\n\n                if (!defined(targetEntity)) {\n                    // target entity not found\n                    that._targetEntity = that._targetProperty = undefined;\n                    return;\n                }\n\n                // target entity was found. listen for changes to entity definition\n                targetEntity.definitionChanged.addEventListener(ReferenceProperty.prototype._onTargetEntityDefinitionChanged, that);\n                that._targetEntity = targetEntity;\n            }\n\n            // walk the list of property names and resolve properties\n            var targetPropertyNames = that._targetPropertyNames;\n            targetProperty = that._targetEntity;\n            for (var i = 0, len = targetPropertyNames.length; i < len && defined(targetProperty); ++i) {\n                targetProperty = targetProperty[targetPropertyNames[i]];\n            }\n\n            // target property may or may not be defined, depending on if it was found\n            that._targetProperty = targetProperty;\n        }\n\n        return targetProperty;\n    }\n\n    /**\n     * A {@link Property} which transparently links to another property on a provided object.\n     *\n     * @alias ReferenceProperty\n     * @constructor\n     *\n     * @param {EntityCollection} targetCollection The entity collection which will be used to resolve the reference.\n     * @param {String} targetId The id of the entity which is being referenced.\n     * @param {String[]} targetPropertyNames The names of the property on the target entity which we will use.\n     *\n     * @example\n     * var collection = new Cesium.EntityCollection();\n     *\n     * //Create a new entity and assign a billboard scale.\n     * var object1 = new Cesium.Entity({id:'object1'});\n     * object1.billboard = new Cesium.BillboardGraphics();\n     * object1.billboard.scale = new Cesium.ConstantProperty(2.0);\n     * collection.add(object1);\n     *\n     * //Create a second entity and reference the scale from the first one.\n     * var object2 = new Cesium.Entity({id:'object2'});\n     * object2.model = new Cesium.ModelGraphics();\n     * object2.model.scale = new Cesium.ReferenceProperty(collection, 'object1', ['billboard', 'scale']);\n     * collection.add(object2);\n     *\n     * //Create a third object, but use the fromString helper function.\n     * var object3 = new Cesium.Entity({id:'object3'});\n     * object3.billboard = new Cesium.BillboardGraphics();\n     * object3.billboard.scale = Cesium.ReferenceProperty.fromString(collection, 'object1#billboard.scale');\n     * collection.add(object3);\n     *\n     * //You can refer to an entity with a # or . in id and property names by escaping them.\n     * var object4 = new Cesium.Entity({id:'#object.4'});\n     * object4.billboard = new Cesium.BillboardGraphics();\n     * object4.billboard.scale = new Cesium.ConstantProperty(2.0);\n     * collection.add(object4);\n     *\n     * var object5 = new Cesium.Entity({id:'object5'});\n     * object5.billboard = new Cesium.BillboardGraphics();\n     * object5.billboard.scale = Cesium.ReferenceProperty.fromString(collection, '\\\\#object\\\\.4#billboard.scale');\n     * collection.add(object5);\n     */\n    function ReferenceProperty(targetCollection, targetId, targetPropertyNames) {\n        \n\n        this._targetCollection = targetCollection;\n        this._targetId = targetId;\n        this._targetPropertyNames = targetPropertyNames;\n        this._targetProperty = undefined;\n        this._targetEntity = undefined;\n        this._definitionChanged = new Event();\n\n        targetCollection.collectionChanged.addEventListener(ReferenceProperty.prototype._onCollectionChanged, this);\n    }\n\n    defineProperties(ReferenceProperty.prototype, {\n        /**\n         * Gets a value indicating if this property is constant.\n         * @memberof ReferenceProperty.prototype\n         * @type {Boolean}\n         * @readonly\n         */\n        isConstant : {\n            get : function() {\n                return Property.isConstant(resolve(this));\n            }\n        },\n        /**\n         * Gets the event that is raised whenever the definition of this property changes.\n         * The definition is changed whenever the referenced property's definition is changed.\n         * @memberof ReferenceProperty.prototype\n         * @type {Event}\n         * @readonly\n         */\n        definitionChanged : {\n            get : function() {\n                return this._definitionChanged;\n            }\n        },\n        /**\n         * Gets the reference frame that the position is defined in.\n         * This property is only valid if the referenced property is a {@link PositionProperty}.\n         * @memberof ReferenceProperty.prototype\n         * @type {ReferenceFrame}\n         * @readonly\n         */\n        referenceFrame : {\n            get : function() {\n                var target = resolve(this);\n                return defined(target) ? target.referenceFrame : undefined;\n            }\n        },\n        /**\n         * Gets the id of the entity being referenced.\n         * @memberof ReferenceProperty.prototype\n         * @type {String}\n         * @readonly\n         */\n        targetId : {\n            get : function() {\n                return this._targetId;\n            }\n        },\n        /**\n         * Gets the collection containing the entity being referenced.\n         * @memberof ReferenceProperty.prototype\n         * @type {EntityCollection}\n         * @readonly\n         */\n        targetCollection : {\n            get : function() {\n                return this._targetCollection;\n            }\n        },\n        /**\n         * Gets the array of property names used to retrieve the referenced property.\n         * @memberof ReferenceProperty.prototype\n         * @type {String[]}\n         * @readonly\n         */\n        targetPropertyNames : {\n            get : function() {\n                return this._targetPropertyNames;\n            }\n        },\n        /**\n         * Gets the resolved instance of the underlying referenced property.\n         * @memberof ReferenceProperty.prototype\n         * @type {Property}\n         * @readonly\n         */\n        resolvedProperty : {\n            get : function() {\n                return resolve(this);\n            }\n        }\n    });\n\n    /**\n     * Creates a new instance given the entity collection that will\n     * be used to resolve it and a string indicating the target entity id and property.\n     * The format of the string is \"objectId#foo.bar\", where # separates the id from\n     * property path and . separates sub-properties.  If the reference identifier or\n     * or any sub-properties contains a # . or \\ they must be escaped.\n     *\n     * @param {EntityCollection} targetCollection\n     * @param {String} referenceString\n     * @returns {ReferenceProperty} A new instance of ReferenceProperty.\n     *\n     * @exception {DeveloperError} invalid referenceString.\n     */\n    ReferenceProperty.fromString = function(targetCollection, referenceString) {\n        \n\n        var identifier;\n        var values = [];\n\n        var inIdentifier = true;\n        var isEscaped = false;\n        var token = '';\n        for (var i = 0; i < referenceString.length; ++i) {\n            var c = referenceString.charAt(i);\n\n            if (isEscaped) {\n                token += c;\n                isEscaped = false;\n            } else if (c === '\\\\') {\n                isEscaped = true;\n            } else if (inIdentifier && c === '#') {\n                identifier = token;\n                inIdentifier = false;\n                token = '';\n            } else if (!inIdentifier && c === '.') {\n                values.push(token);\n                token = '';\n            } else {\n                token += c;\n            }\n        }\n        values.push(token);\n\n        return new ReferenceProperty(targetCollection, identifier, values);\n    };\n\n    /**\n     * Gets the value of the property at the provided time.\n     *\n     * @param {JulianDate} time The time for which to retrieve the value.\n     * @param {Object} [result] The object to store the value into, if omitted, a new instance is created and returned.\n     * @returns {Object} The modified result parameter or a new instance if the result parameter was not supplied.\n     */\n    ReferenceProperty.prototype.getValue = function(time, result) {\n        var target = resolve(this);\n        return defined(target) ? target.getValue(time, result) : undefined;\n    };\n\n    /**\n     * Gets the value of the property at the provided time and in the provided reference frame.\n     * This method is only valid if the property being referenced is a {@link PositionProperty}.\n     *\n     * @param {JulianDate} time The time for which to retrieve the value.\n     * @param {ReferenceFrame} referenceFrame The desired referenceFrame of the result.\n     * @param {Cartesian3} [result] The object to store the value into, if omitted, a new instance is created and returned.\n     * @returns {Cartesian3} The modified result parameter or a new instance if the result parameter was not supplied.\n     */\n    ReferenceProperty.prototype.getValueInReferenceFrame = function(time, referenceFrame, result) {\n        var target = resolve(this);\n        return defined(target) ? target.getValueInReferenceFrame(time, referenceFrame, result) : undefined;\n    };\n\n    /**\n     * Gets the {@link Material} type at the provided time.\n     * This method is only valid if the property being referenced is a {@link MaterialProperty}.\n     *\n     * @param {JulianDate} time The time for which to retrieve the type.\n     * @returns {String} The type of material.\n     */\n    ReferenceProperty.prototype.getType = function(time) {\n        var target = resolve(this);\n        return defined(target) ? target.getType(time) : undefined;\n    };\n\n    /**\n     * Compares this property to the provided property and returns\n     * <code>true</code> if they are equal, <code>false</code> otherwise.\n     *\n     * @param {Property} [other] The other property.\n     * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n     */\n    ReferenceProperty.prototype.equals = function(other) {\n        if (this === other) {\n            return true;\n        }\n\n        var names = this._targetPropertyNames;\n        var otherNames = other._targetPropertyNames;\n\n        if (this._targetCollection !== other._targetCollection || //\n            this._targetId !== other._targetId || //\n            names.length !== otherNames.length) {\n            return false;\n        }\n\n        var length = this._targetPropertyNames.length;\n        for (var i = 0; i < length; i++) {\n            if (names[i] !== otherNames[i]) {\n                return false;\n            }\n        }\n\n        return true;\n    };\n\n    ReferenceProperty.prototype._onTargetEntityDefinitionChanged = function(targetEntity, name, value, oldValue) {\n        if (defined(this._targetProperty) && this._targetPropertyNames[0] === name) {\n            this._targetProperty = undefined;\n            this._definitionChanged.raiseEvent(this);\n        }\n    };\n\n    ReferenceProperty.prototype._onCollectionChanged = function(collection, added, removed) {\n        var targetEntity = this._targetEntity;\n        if (defined(targetEntity) && removed.indexOf(targetEntity) !== -1) {\n            targetEntity.definitionChanged.removeEventListener(ReferenceProperty.prototype._onTargetEntityDefinitionChanged, this);\n            this._targetEntity = this._targetProperty = undefined;\n        } else if (!defined(targetEntity)) {\n            targetEntity = resolve(this);\n            if (defined(targetEntity)) {\n                this._definitionChanged.raiseEvent(this);\n            }\n        }\n    };\nexport default ReferenceProperty;\n","import defined from '../Core/defined.js';\nimport defineProperties from '../Core/defineProperties.js';\nimport DeveloperError from '../Core/DeveloperError.js';\nimport Ellipsoid from '../Core/Ellipsoid.js';\nimport Event from '../Core/Event.js';\nimport ReferenceFrame from '../Core/ReferenceFrame.js';\nimport Property from './Property.js';\n\n    /**\n     * This is a temporary class for scaling position properties to the WGS84 surface.\n     * It will go away or be refactored to support data with arbitrary height references.\n     * @private\n     */\n    function ScaledPositionProperty(value) {\n        this._definitionChanged = new Event();\n        this._value = undefined;\n        this._removeSubscription = undefined;\n        this.setValue(value);\n    }\n\n    defineProperties(ScaledPositionProperty.prototype, {\n        isConstant : {\n            get : function() {\n                return Property.isConstant(this._value);\n            }\n        },\n        definitionChanged : {\n            get : function() {\n                return this._definitionChanged;\n            }\n        },\n        referenceFrame : {\n            get : function() {\n                return defined(this._value) ? this._value.referenceFrame : ReferenceFrame.FIXED;\n            }\n        }\n    });\n\n    ScaledPositionProperty.prototype.getValue = function(time, result) {\n        return this.getValueInReferenceFrame(time, ReferenceFrame.FIXED, result);\n    };\n\n    ScaledPositionProperty.prototype.setValue = function(value) {\n        if (this._value !== value) {\n            this._value = value;\n\n            if (defined(this._removeSubscription)) {\n                this._removeSubscription();\n                this._removeSubscription = undefined;\n            }\n\n            if (defined(value)) {\n                this._removeSubscription = value.definitionChanged.addEventListener(this._raiseDefinitionChanged, this);\n            }\n            this._definitionChanged.raiseEvent(this);\n        }\n    };\n\n    ScaledPositionProperty.prototype.getValueInReferenceFrame = function(time, referenceFrame, result) {\n        \n\n        if (!defined(this._value)) {\n            return undefined;\n        }\n\n        result = this._value.getValueInReferenceFrame(time, referenceFrame, result);\n        return defined(result) ? Ellipsoid.WGS84.scaleToGeodeticSurface(result, result) : undefined;\n    };\n\n    ScaledPositionProperty.prototype.equals = function(other) {\n        return this === other || (other instanceof ScaledPositionProperty && this._value === other._value);\n    };\n\n    ScaledPositionProperty.prototype._raiseDefinitionChanged = function() {\n        this._definitionChanged.raiseEvent(this);\n    };\nexport default ScaledPositionProperty;\n","import Check from '../Core/Check.js';\nimport defaultValue from '../Core/defaultValue.js';\nimport defined from '../Core/defined.js';\nimport defineProperties from '../Core/defineProperties.js';\nimport destroyObject from '../Core/destroyObject.js';\nimport PrimitiveCollection from './PrimitiveCollection.js';\n\n    /**\n     * A primitive collection for helping maintain the order or ground primitives based on a z-index\n     *\n     * @private\n     */\n    function OrderedGroundPrimitiveCollection() {\n        this._length = 0;\n        this._collections = {};\n        this._collectionsArray = [];\n\n        this.show = true;\n    }\n\n    defineProperties(OrderedGroundPrimitiveCollection.prototype, {\n        /**\n         * Gets the number of primitives in the collection.\n         *\n         * @memberof OrderedGroundPrimitiveCollection.prototype\n         *\n         * @type {Number}\n         * @readonly\n         */\n        length : {\n            get : function() {\n                return this._length;\n            }\n        }\n    });\n\n    /**\n     * Adds a primitive to the collection.\n     *\n     * @param {GroundPrimitive} primitive The primitive to add.\n     * @param {Number} [zIndex = 0] The index of the primitive\n     * @returns {GroundPrimitive} The primitive added to the collection.\n     */\n    OrderedGroundPrimitiveCollection.prototype.add = function(primitive, zIndex) {\n        \n\n        zIndex = defaultValue(zIndex, 0);\n        var collection = this._collections[zIndex];\n        if (!defined(collection)) {\n            collection = new PrimitiveCollection({ destroyPrimitives: false });\n            collection._zIndex = zIndex;\n            this._collections[zIndex] = collection;\n            var array = this._collectionsArray;\n            var i = 0;\n            while (i < array.length && array[i]._zIndex < zIndex) {\n                i++;\n            }\n            array.splice(i, 0, collection);\n        }\n\n        collection.add(primitive);\n        this._length++;\n        primitive._zIndex = zIndex;\n\n        return primitive;\n    };\n\n    /**\n     * Adjusts the z-index\n     * @param {GroundPrimitive} primitive\n     * @param {Number} zIndex\n     */\n    OrderedGroundPrimitiveCollection.prototype.set = function(primitive, zIndex) {\n        \n\n        if (zIndex === primitive._zIndex) {\n            return primitive;\n        }\n\n        this.remove(primitive, true);\n        this.add(primitive, zIndex);\n\n        return primitive;\n    };\n\n    /**\n     * Removes a primitive from the collection.\n     *\n     * @param {Object} primitive The primitive to remove.\n     * @param {Boolean} [doNotDestroy = false]\n     * @returns {Boolean} <code>true</code> if the primitive was removed; <code>false</code> if the primitive is <code>undefined</code> or was not found in the collection.\n     */\n    OrderedGroundPrimitiveCollection.prototype.remove = function(primitive, doNotDestroy) {\n        if (this.contains(primitive)) {\n            var index = primitive._zIndex;\n            var collection = this._collections[index];\n            var result;\n            if (doNotDestroy) {\n                result = collection.remove(primitive);\n            } else {\n                result = collection.removeAndDestroy(primitive);\n            }\n\n            if (result) {\n                this._length--;\n            }\n\n            if (collection.length === 0) {\n                this._collectionsArray.splice(this._collectionsArray.indexOf(collection), 1);\n                this._collections[index] = undefined;\n                collection.destroy();\n            }\n\n            return result;\n        }\n\n        return false;\n    };\n\n    /**\n     * Removes all primitives in the collection.\n     *\n     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n     *\n     * @see OrderedGroundPrimitiveCollection#destroyPrimitives\n     */\n    OrderedGroundPrimitiveCollection.prototype.removeAll = function() {\n        var collections = this._collectionsArray;\n        for (var i = 0; i < collections.length; i++) {\n            var collection = collections[i];\n            collection.destroyPrimitives = true;\n            collection.destroy();\n        }\n\n        this._collections = {};\n        this._collectionsArray = [];\n        this._length = 0;\n    };\n\n    /**\n     * Determines if this collection contains a primitive.\n     *\n     * @param {Object} primitive The primitive to check for.\n     * @returns {Boolean} <code>true</code> if the primitive is in the collection; <code>false</code> if the primitive is <code>undefined</code> or was not found in the collection.\n     */\n    OrderedGroundPrimitiveCollection.prototype.contains = function(primitive) {\n        if (!defined(primitive)) {\n            return false;\n        }\n        var collection = this._collections[primitive._zIndex];\n        return defined(collection) && collection.contains(primitive);\n    };\n\n    /**\n     * @private\n     */\n    OrderedGroundPrimitiveCollection.prototype.update = function(frameState) {\n        if (!this.show) {\n            return;\n        }\n\n        var collections = this._collectionsArray;\n        for (var i = 0 ; i < collections.length; i++) {\n            collections[i].update(frameState);\n        }\n    };\n\n    /**\n     * Returns true if this object was destroyed; otherwise, false.\n     * <br /><br />\n     * If this object was destroyed, it should not be used; calling any function other than\n     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n     *\n     * @returns {Boolean} True if this object was destroyed; otherwise, false.\n     *\n     * @see OrderedGroundPrimitiveCollection#destroy\n     */\n    OrderedGroundPrimitiveCollection.prototype.isDestroyed = function() {\n        return false;\n    };\n\n    /**\n     * Destroys the WebGL resources held by each primitive in this collection.  Explicitly destroying this\n     * collection allows for deterministic release of WebGL resources, instead of relying on the garbage\n     * collector to destroy this collection.\n     * <br /><br />\n     * Since destroying a collection destroys all the contained primitives, only destroy a collection\n     * when you are sure no other code is still using any of the contained primitives.\n     * <br /><br />\n     * Once this collection is destroyed, it should not be used; calling any function other than\n     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n     * assign the return value (<code>undefined</code>) to the object as done in the example.\n     *\n     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n     *\n     *\n     * @example\n     * primitives = primitives && primitives.destroy();\n     *\n     * @see OrderedGroundPrimitiveCollection#isDestroyed\n     */\n    OrderedGroundPrimitiveCollection.prototype.destroy = function() {\n        this.removeAll();\n        return destroyObject(this);\n    };\nexport default OrderedGroundPrimitiveCollection;\n","import AssociativeArray from '../Core/AssociativeArray.js';\nimport BoundingRectangle from '../Core/BoundingRectangle.js';\nimport Cartesian2 from '../Core/Cartesian2.js';\nimport Cartesian3 from '../Core/Cartesian3.js';\nimport Color from '../Core/Color.js';\nimport defined from '../Core/defined.js';\nimport destroyObject from '../Core/destroyObject.js';\nimport DeveloperError from '../Core/DeveloperError.js';\nimport DistanceDisplayCondition from '../Core/DistanceDisplayCondition.js';\nimport NearFarScalar from '../Core/NearFarScalar.js';\nimport HeightReference from '../Scene/HeightReference.js';\nimport HorizontalOrigin from '../Scene/HorizontalOrigin.js';\nimport VerticalOrigin from '../Scene/VerticalOrigin.js';\nimport BoundingSphereState from './BoundingSphereState.js';\nimport Property from './Property.js';\n\n    var defaultColor = Color.WHITE;\n    var defaultEyeOffset = Cartesian3.ZERO;\n    var defaultHeightReference = HeightReference.NONE;\n    var defaultPixelOffset = Cartesian2.ZERO;\n    var defaultScale = 1.0;\n    var defaultRotation = 0.0;\n    var defaultAlignedAxis = Cartesian3.ZERO;\n    var defaultHorizontalOrigin = HorizontalOrigin.CENTER;\n    var defaultVerticalOrigin = VerticalOrigin.CENTER;\n    var defaultSizeInMeters = false;\n\n    var positionScratch = new Cartesian3();\n    var colorScratch = new Color();\n    var eyeOffsetScratch = new Cartesian3();\n    var pixelOffsetScratch = new Cartesian2();\n    var scaleByDistanceScratch = new NearFarScalar();\n    var translucencyByDistanceScratch = new NearFarScalar();\n    var pixelOffsetScaleByDistanceScratch = new NearFarScalar();\n    var boundingRectangleScratch = new BoundingRectangle();\n    var distanceDisplayConditionScratch = new DistanceDisplayCondition();\n\n    function EntityData(entity) {\n        this.entity = entity;\n        this.billboard = undefined;\n        this.textureValue = undefined;\n    }\n\n    /**\n     * A {@link Visualizer} which maps {@link Entity#billboard} to a {@link Billboard}.\n     * @alias BillboardVisualizer\n     * @constructor\n     *\n     * @param {EntityCluster} entityCluster The entity cluster to manage the collection of billboards and optionally cluster with other entities.\n     * @param {EntityCollection} entityCollection The entityCollection to visualize.\n     */\n    function BillboardVisualizer(entityCluster, entityCollection) {\n        \n\n        entityCollection.collectionChanged.addEventListener(BillboardVisualizer.prototype._onCollectionChanged, this);\n\n        this._cluster = entityCluster;\n        this._entityCollection = entityCollection;\n        this._items = new AssociativeArray();\n        this._onCollectionChanged(entityCollection, entityCollection.values, [], []);\n    }\n\n    /**\n     * Updates the primitives created by this visualizer to match their\n     * Entity counterpart at the given time.\n     *\n     * @param {JulianDate} time The time to update to.\n     * @returns {Boolean} This function always returns true.\n     */\n    BillboardVisualizer.prototype.update = function(time) {\n        \n\n        var items = this._items.values;\n        var cluster = this._cluster;\n\n        for (var i = 0, len = items.length; i < len; i++) {\n            var item = items[i];\n            var entity = item.entity;\n            var billboardGraphics = entity._billboard;\n            var textureValue;\n            var billboard = item.billboard;\n            var show = entity.isShowing && entity.isAvailable(time) && Property.getValueOrDefault(billboardGraphics._show, time, true);\n            var position;\n            if (show) {\n                position = Property.getValueOrUndefined(entity._position, time, positionScratch);\n                textureValue = Property.getValueOrUndefined(billboardGraphics._image, time);\n                show = defined(position) && defined(textureValue);\n            }\n\n            if (!show) {\n                //don't bother creating or updating anything else\n                returnPrimitive(item, entity, cluster);\n                continue;\n            }\n\n            if (!Property.isConstant(entity._position)) {\n                cluster._clusterDirty = true;\n            }\n\n            if (!defined(billboard)) {\n                billboard = cluster.getBillboard(entity);\n                billboard.id = entity;\n                billboard.image = undefined;\n                item.billboard = billboard;\n            }\n\n            billboard.show = show;\n            if (!defined(billboard.image) || item.textureValue !== textureValue) {\n                billboard.image = textureValue;\n                item.textureValue = textureValue;\n            }\n            billboard.position = position;\n            billboard.color = Property.getValueOrDefault(billboardGraphics._color, time, defaultColor, colorScratch);\n            billboard.eyeOffset = Property.getValueOrDefault(billboardGraphics._eyeOffset, time, defaultEyeOffset, eyeOffsetScratch);\n            billboard.heightReference = Property.getValueOrDefault(billboardGraphics._heightReference, time, defaultHeightReference);\n            billboard.pixelOffset = Property.getValueOrDefault(billboardGraphics._pixelOffset, time, defaultPixelOffset, pixelOffsetScratch);\n            billboard.scale = Property.getValueOrDefault(billboardGraphics._scale, time, defaultScale);\n            billboard.rotation = Property.getValueOrDefault(billboardGraphics._rotation, time, defaultRotation);\n            billboard.alignedAxis = Property.getValueOrDefault(billboardGraphics._alignedAxis, time, defaultAlignedAxis);\n            billboard.horizontalOrigin = Property.getValueOrDefault(billboardGraphics._horizontalOrigin, time, defaultHorizontalOrigin);\n            billboard.verticalOrigin = Property.getValueOrDefault(billboardGraphics._verticalOrigin, time, defaultVerticalOrigin);\n            billboard.width = Property.getValueOrUndefined(billboardGraphics._width, time);\n            billboard.height = Property.getValueOrUndefined(billboardGraphics._height, time);\n            billboard.scaleByDistance = Property.getValueOrUndefined(billboardGraphics._scaleByDistance, time, scaleByDistanceScratch);\n            billboard.translucencyByDistance = Property.getValueOrUndefined(billboardGraphics._translucencyByDistance, time, translucencyByDistanceScratch);\n            billboard.pixelOffsetScaleByDistance = Property.getValueOrUndefined(billboardGraphics._pixelOffsetScaleByDistance, time, pixelOffsetScaleByDistanceScratch);\n            billboard.sizeInMeters = Property.getValueOrDefault(billboardGraphics._sizeInMeters, time, defaultSizeInMeters);\n            billboard.distanceDisplayCondition = Property.getValueOrUndefined(billboardGraphics._distanceDisplayCondition, time, distanceDisplayConditionScratch);\n            billboard.disableDepthTestDistance = Property.getValueOrUndefined(billboardGraphics._disableDepthTestDistance, time);\n\n            var subRegion = Property.getValueOrUndefined(billboardGraphics._imageSubRegion, time, boundingRectangleScratch);\n            if (defined(subRegion)) {\n                billboard.setImageSubRegion(billboard._imageId, subRegion);\n            }\n        }\n        return true;\n    };\n\n    /**\n     * Computes a bounding sphere which encloses the visualization produced for the specified entity.\n     * The bounding sphere is in the fixed frame of the scene's globe.\n     *\n     * @param {Entity} entity The entity whose bounding sphere to compute.\n     * @param {BoundingSphere} result The bounding sphere onto which to store the result.\n     * @returns {BoundingSphereState} BoundingSphereState.DONE if the result contains the bounding sphere,\n     *                       BoundingSphereState.PENDING if the result is still being computed, or\n     *                       BoundingSphereState.FAILED if the entity has no visualization in the current scene.\n     * @private\n     */\n    BillboardVisualizer.prototype.getBoundingSphere = function(entity, result) {\n        \n\n        var item = this._items.get(entity.id);\n        if (!defined(item) || !defined(item.billboard)) {\n            return BoundingSphereState.FAILED;\n        }\n\n        var billboard = item.billboard;\n        if (billboard.heightReference === HeightReference.NONE) {\n            result.center = Cartesian3.clone(billboard.position, result.center);\n        } else {\n            if (!defined(billboard._clampedPosition)) {\n                return BoundingSphereState.PENDING;\n            }\n            result.center = Cartesian3.clone(billboard._clampedPosition, result.center);\n        }\n        result.radius = 0;\n        return BoundingSphereState.DONE;\n    };\n\n    /**\n     * Returns true if this object was destroyed; otherwise, false.\n     *\n     * @returns {Boolean} True if this object was destroyed; otherwise, false.\n     */\n    BillboardVisualizer.prototype.isDestroyed = function() {\n        return false;\n    };\n\n    /**\n     * Removes and destroys all primitives created by this instance.\n     */\n    BillboardVisualizer.prototype.destroy = function() {\n        this._entityCollection.collectionChanged.removeEventListener(BillboardVisualizer.prototype._onCollectionChanged, this);\n        var entities = this._entityCollection.values;\n        for (var i = 0; i < entities.length; i++) {\n            this._cluster.removeBillboard(entities[i]);\n        }\n        return destroyObject(this);\n    };\n\n    BillboardVisualizer.prototype._onCollectionChanged = function(entityCollection, added, removed, changed) {\n        var i;\n        var entity;\n        var items = this._items;\n        var cluster = this._cluster;\n\n        for (i = added.length - 1; i > -1; i--) {\n            entity = added[i];\n            if (defined(entity._billboard) && defined(entity._position)) {\n                items.set(entity.id, new EntityData(entity));\n            }\n        }\n\n        for (i = changed.length - 1; i > -1; i--) {\n            entity = changed[i];\n            if (defined(entity._billboard) && defined(entity._position)) {\n                if (!items.contains(entity.id)) {\n                    items.set(entity.id, new EntityData(entity));\n                }\n            } else {\n                returnPrimitive(items.get(entity.id), entity, cluster);\n                items.remove(entity.id);\n            }\n        }\n\n        for (i = removed.length - 1; i > -1; i--) {\n            entity = removed[i];\n            returnPrimitive(items.get(entity.id), entity, cluster);\n            items.remove(entity.id);\n        }\n    };\n\n    function returnPrimitive(item, entity, cluster) {\n        if (defined(item)) {\n            item.billboard = undefined;\n            cluster.removeBillboard(entity);\n        }\n    }\nexport default BillboardVisualizer;\n","import defaultValue from '../Core/defaultValue.js';\nimport defined from '../Core/defined.js';\nimport defineProperties from '../Core/defineProperties.js';\nimport freezeObject from '../Core/freezeObject.js';\nimport VertexFormat from '../Core/VertexFormat.js';\nimport AllMaterialAppearanceFS from '../Shaders/Appearances/AllMaterialAppearanceFS.js';\nimport AllMaterialAppearanceVS from '../Shaders/Appearances/AllMaterialAppearanceVS.js';\nimport BasicMaterialAppearanceFS from '../Shaders/Appearances/BasicMaterialAppearanceFS.js';\nimport BasicMaterialAppearanceVS from '../Shaders/Appearances/BasicMaterialAppearanceVS.js';\nimport TexturedMaterialAppearanceFS from '../Shaders/Appearances/TexturedMaterialAppearanceFS.js';\nimport TexturedMaterialAppearanceVS from '../Shaders/Appearances/TexturedMaterialAppearanceVS.js';\nimport Appearance from './Appearance.js';\nimport Material from './Material.js';\n\n    /**\n     * An appearance for arbitrary geometry (as opposed to {@link EllipsoidSurfaceAppearance}, for example)\n     * that supports shading with materials.\n     *\n     * @alias MaterialAppearance\n     * @constructor\n     *\n     * @param {Object} [options] Object with the following properties:\n     * @param {Boolean} [options.flat=false] When <code>true</code>, flat shading is used in the fragment shader, which means lighting is not taking into account.\n     * @param {Boolean} [options.faceForward=!options.closed] When <code>true</code>, the fragment shader flips the surface normal as needed to ensure that the normal faces the viewer to avoid dark spots.  This is useful when both sides of a geometry should be shaded like {@link WallGeometry}.\n     * @param {Boolean} [options.translucent=true] When <code>true</code>, the geometry is expected to appear translucent so {@link MaterialAppearance#renderState} has alpha blending enabled.\n     * @param {Boolean} [options.closed=false] When <code>true</code>, the geometry is expected to be closed so {@link MaterialAppearance#renderState} has backface culling enabled.\n     * @param {MaterialAppearance.MaterialSupport} [options.materialSupport=MaterialAppearance.MaterialSupport.TEXTURED] The type of materials that will be supported.\n     * @param {Material} [options.material=Material.ColorType] The material used to determine the fragment color.\n     * @param {String} [options.vertexShaderSource] Optional GLSL vertex shader source to override the default vertex shader.\n     * @param {String} [options.fragmentShaderSource] Optional GLSL fragment shader source to override the default fragment shader.\n     * @param {RenderState} [options.renderState] Optional render state to override the default render state.\n     *\n     * @see {@link https://github.com/AnalyticalGraphicsInc/cesium/wiki/Fabric|Fabric}\n     * @demo {@link https://sandcastle.cesium.com/index.html?src=Materials.html|Cesium Sandcastle Material Appearance Demo}\n     *\n     * @example\n     * var primitive = new Cesium.Primitive({\n     *   geometryInstances : new Cesium.GeometryInstance({\n     *     geometry : new Cesium.WallGeometry({\n            materialSupport :  Cesium.MaterialAppearance.MaterialSupport.BASIC.vertexFormat,\n     *       // ...\n     *     })\n     *   }),\n     *   appearance : new Cesium.MaterialAppearance({\n     *     material : Cesium.Material.fromType('Color'),\n     *     faceForward : true\n     *   })\n     *\n     * });\n     */\n    function MaterialAppearance(options) {\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n        var translucent = defaultValue(options.translucent, true);\n        var closed = defaultValue(options.closed, false);\n        var materialSupport = defaultValue(options.materialSupport, MaterialAppearance.MaterialSupport.TEXTURED);\n\n        /**\n         * The material used to determine the fragment color.  Unlike other {@link MaterialAppearance}\n         * properties, this is not read-only, so an appearance's material can change on the fly.\n         *\n         * @type Material\n         *\n         * @default {@link Material.ColorType}\n         *\n         * @see {@link https://github.com/AnalyticalGraphicsInc/cesium/wiki/Fabric|Fabric}\n         */\n        this.material = (defined(options.material)) ? options.material : Material.fromType(Material.ColorType);\n\n        /**\n         * When <code>true</code>, the geometry is expected to appear translucent.\n         *\n         * @type {Boolean}\n         *\n         * @default true\n         */\n        this.translucent = translucent;\n\n        this._vertexShaderSource = defaultValue(options.vertexShaderSource, materialSupport.vertexShaderSource);\n        this._fragmentShaderSource = defaultValue(options.fragmentShaderSource, materialSupport.fragmentShaderSource);\n        this._renderState = Appearance.getDefaultRenderState(translucent, closed, options.renderState);\n        this._closed = closed;\n\n        // Non-derived members\n\n        this._materialSupport = materialSupport;\n        this._vertexFormat = materialSupport.vertexFormat;\n        this._flat = defaultValue(options.flat, false);\n        this._faceForward = defaultValue(options.faceForward, !closed);\n    }\n\n    defineProperties(MaterialAppearance.prototype, {\n        /**\n         * The GLSL source code for the vertex shader.\n         *\n         * @memberof MaterialAppearance.prototype\n         *\n         * @type {String}\n         * @readonly\n         */\n        vertexShaderSource : {\n            get : function() {\n                return this._vertexShaderSource;\n            }\n        },\n\n        /**\n         * The GLSL source code for the fragment shader.  The full fragment shader\n         * source is built procedurally taking into account {@link MaterialAppearance#material},\n         * {@link MaterialAppearance#flat}, and {@link MaterialAppearance#faceForward}.\n         * Use {@link MaterialAppearance#getFragmentShaderSource} to get the full source.\n         *\n         * @memberof MaterialAppearance.prototype\n         *\n         * @type {String}\n         * @readonly\n         */\n        fragmentShaderSource : {\n            get : function() {\n                return this._fragmentShaderSource;\n            }\n        },\n\n        /**\n         * The WebGL fixed-function state to use when rendering the geometry.\n         * <p>\n         * The render state can be explicitly defined when constructing a {@link MaterialAppearance}\n         * instance, or it is set implicitly via {@link MaterialAppearance#translucent}\n         * and {@link MaterialAppearance#closed}.\n         * </p>\n         *\n         * @memberof MaterialAppearance.prototype\n         *\n         * @type {Object}\n         * @readonly\n         */\n        renderState : {\n            get : function() {\n                return this._renderState;\n            }\n        },\n\n        /**\n         * When <code>true</code>, the geometry is expected to be closed so\n         * {@link MaterialAppearance#renderState} has backface culling enabled.\n         * If the viewer enters the geometry, it will not be visible.\n         *\n         * @memberof MaterialAppearance.prototype\n         *\n         * @type {Boolean}\n         * @readonly\n         *\n         * @default false\n         */\n        closed : {\n            get : function() {\n                return this._closed;\n            }\n        },\n\n        /**\n         * The type of materials supported by this instance.  This impacts the required\n         * {@link VertexFormat} and the complexity of the vertex and fragment shaders.\n         *\n         * @memberof MaterialAppearance.prototype\n         *\n         * @type {MaterialAppearance.MaterialSupport}\n         * @readonly\n         *\n         * @default {@link MaterialAppearance.MaterialSupport.TEXTURED}\n         */\n        materialSupport : {\n            get : function() {\n                return this._materialSupport;\n            }\n        },\n\n        /**\n         * The {@link VertexFormat} that this appearance instance is compatible with.\n         * A geometry can have more vertex attributes and still be compatible - at a\n         * potential performance cost - but it can't have less.\n         *\n         * @memberof MaterialAppearance.prototype\n         *\n         * @type VertexFormat\n         * @readonly\n         *\n         * @default {@link MaterialAppearance.MaterialSupport.TEXTURED.vertexFormat}\n         */\n        vertexFormat : {\n            get : function() {\n                return this._vertexFormat;\n            }\n        },\n\n        /**\n         * When <code>true</code>, flat shading is used in the fragment shader,\n         * which means lighting is not taking into account.\n         *\n         * @memberof MaterialAppearance.prototype\n         *\n         * @type {Boolean}\n         * @readonly\n         *\n         * @default false\n         */\n        flat : {\n            get : function() {\n                return this._flat;\n            }\n        },\n\n        /**\n         * When <code>true</code>, the fragment shader flips the surface normal\n         * as needed to ensure that the normal faces the viewer to avoid\n         * dark spots.  This is useful when both sides of a geometry should be\n         * shaded like {@link WallGeometry}.\n         *\n         * @memberof MaterialAppearance.prototype\n         *\n         * @type {Boolean}\n         * @readonly\n         *\n         * @default true\n         */\n        faceForward : {\n            get : function() {\n                return this._faceForward;\n            }\n        }\n    });\n\n    /**\n     * Procedurally creates the full GLSL fragment shader source.  For {@link MaterialAppearance},\n     * this is derived from {@link MaterialAppearance#fragmentShaderSource}, {@link MaterialAppearance#material},\n     * {@link MaterialAppearance#flat}, and {@link MaterialAppearance#faceForward}.\n     *\n     * @function\n     *\n     * @returns {String} The full GLSL fragment shader source.\n     */\n    MaterialAppearance.prototype.getFragmentShaderSource = Appearance.prototype.getFragmentShaderSource;\n\n    /**\n     * Determines if the geometry is translucent based on {@link MaterialAppearance#translucent} and {@link Material#isTranslucent}.\n     *\n     * @function\n     *\n     * @returns {Boolean} <code>true</code> if the appearance is translucent.\n     */\n    MaterialAppearance.prototype.isTranslucent = Appearance.prototype.isTranslucent;\n\n    /**\n     * Creates a render state.  This is not the final render state instance; instead,\n     * it can contain a subset of render state properties identical to the render state\n     * created in the context.\n     *\n     * @function\n     *\n     * @returns {Object} The render state.\n     */\n    MaterialAppearance.prototype.getRenderState = Appearance.prototype.getRenderState;\n\n    /**\n     * Determines the type of {@link Material} that is supported by a\n     * {@link MaterialAppearance} instance.  This is a trade-off between\n     * flexibility (a wide array of materials) and memory/performance\n     * (required vertex format and GLSL shader complexity.\n     * @exports MaterialAppearance.MaterialSupport\n     */\n    MaterialAppearance.MaterialSupport = {\n        /**\n         * Only basic materials, which require just <code>position</code> and\n         * <code>normal</code> vertex attributes, are supported.\n         *\n         * @constant\n         */\n        BASIC : freezeObject({\n            vertexFormat : VertexFormat.POSITION_AND_NORMAL,\n            vertexShaderSource : BasicMaterialAppearanceVS,\n            fragmentShaderSource : BasicMaterialAppearanceFS\n        }),\n        /**\n         * Materials with textures, which require <code>position</code>,\n         * <code>normal</code>, and <code>st</code> vertex attributes,\n         * are supported.  The vast majority of materials fall into this category.\n         *\n         * @constant\n         */\n        TEXTURED : freezeObject({\n            vertexFormat : VertexFormat.POSITION_NORMAL_AND_ST,\n            vertexShaderSource : TexturedMaterialAppearanceVS,\n            fragmentShaderSource : TexturedMaterialAppearanceFS\n        }),\n        /**\n         * All materials, including those that work in tangent space, are supported.\n         * This requires <code>position</code>, <code>normal</code>, <code>st</code>,\n         * <code>tangent</code>, and <code>bitangent</code> vertex attributes.\n         *\n         * @constant\n         */\n        ALL : freezeObject({\n            vertexFormat : VertexFormat.ALL,\n            vertexShaderSource : AllMaterialAppearanceVS,\n            fragmentShaderSource : AllMaterialAppearanceFS\n        })\n    };\nexport default MaterialAppearance;\n","//This file is automatically rebuilt by the Cesium build process.\nexport default \"attribute vec3 position3DHigh;\\n\\\nattribute vec3 position3DLow;\\n\\\nattribute vec3 normal;\\n\\\nattribute float batchId;\\n\\\n\\n\\\nvarying vec3 v_positionEC;\\n\\\nvarying vec3 v_normalEC;\\n\\\n\\n\\\nvoid main()\\n\\\n{\\n\\\n    vec4 p = czm_computePosition();\\n\\\n\\n\\\n    v_positionEC = (czm_modelViewRelativeToEye * p).xyz;      // position in eye coordinates\\n\\\n    v_normalEC = czm_normal * normal;                         // normal in eye coordinates\\n\\\n\\n\\\n    gl_Position = czm_modelViewProjectionRelativeToEye * p;\\n\\\n}\\n\\\n\";\n","//This file is automatically rebuilt by the Cesium build process.\nexport default \"varying vec3 v_positionEC;\\n\\\nvarying vec3 v_normalEC;\\n\\\n\\n\\\nvoid main()\\n\\\n{\\n\\\n    vec3 positionToEyeEC = -v_positionEC;\\n\\\n\\n\\\n    vec3 normalEC = normalize(v_normalEC);\\n\\\n#ifdef FACE_FORWARD\\n\\\n    normalEC = faceforward(normalEC, vec3(0.0, 0.0, 1.0), -normalEC);\\n\\\n#endif\\n\\\n\\n\\\n    czm_materialInput materialInput;\\n\\\n    materialInput.normalEC = normalEC;\\n\\\n    materialInput.positionToEyeEC = positionToEyeEC;\\n\\\n    czm_material material = czm_getMaterial(materialInput);\\n\\\n\\n\\\n#ifdef FLAT\\n\\\n    gl_FragColor = vec4(material.diffuse + material.emission, material.alpha);\\n\\\n#else\\n\\\n    gl_FragColor = czm_phong(normalize(positionToEyeEC), material, czm_lightDirectionEC);\\n\\\n#endif\\n\\\n}\\n\\\n\";\n","//This file is automatically rebuilt by the Cesium build process.\nexport default \"attribute vec3 position3DHigh;\\n\\\nattribute vec3 position3DLow;\\n\\\nattribute vec3 normal;\\n\\\nattribute vec2 st;\\n\\\nattribute float batchId;\\n\\\n\\n\\\nvarying vec3 v_positionEC;\\n\\\nvarying vec3 v_normalEC;\\n\\\nvarying vec2 v_st;\\n\\\n\\n\\\nvoid main()\\n\\\n{\\n\\\n    vec4 p = czm_computePosition();\\n\\\n\\n\\\n    v_positionEC = (czm_modelViewRelativeToEye * p).xyz;      // position in eye coordinates\\n\\\n    v_normalEC = czm_normal * normal;                         // normal in eye coordinates\\n\\\n    v_st = st;\\n\\\n\\n\\\n    gl_Position = czm_modelViewProjectionRelativeToEye * p;\\n\\\n}\\n\\\n\";\n","//This file is automatically rebuilt by the Cesium build process.\nexport default \"varying vec3 v_positionEC;\\n\\\nvarying vec3 v_normalEC;\\n\\\nvarying vec2 v_st;\\n\\\n\\n\\\nvoid main()\\n\\\n{\\n\\\n    vec3 positionToEyeEC = -v_positionEC;\\n\\\n\\n\\\n    vec3 normalEC = normalize(v_normalEC);\\n\\\n#ifdef FACE_FORWARD\\n\\\n    normalEC = faceforward(normalEC, vec3(0.0, 0.0, 1.0), -normalEC);\\n\\\n#endif\\n\\\n\\n\\\n    czm_materialInput materialInput;\\n\\\n    materialInput.normalEC = normalEC;\\n\\\n    materialInput.positionToEyeEC = positionToEyeEC;\\n\\\n    materialInput.st = v_st;\\n\\\n    czm_material material = czm_getMaterial(materialInput);\\n\\\n\\n\\\n#ifdef FLAT\\n\\\n    gl_FragColor = vec4(material.diffuse + material.emission, material.alpha);\\n\\\n#else\\n\\\n    gl_FragColor = czm_phong(normalize(positionToEyeEC), material, czm_lightDirectionEC);\\n\\\n#endif\\n\\\n}\\n\\\n\";\n","//This file is automatically rebuilt by the Cesium build process.\nexport default \"attribute vec3 position3DHigh;\\n\\\nattribute vec3 position3DLow;\\n\\\nattribute vec3 normal;\\n\\\nattribute vec3 tangent;\\n\\\nattribute vec3 bitangent;\\n\\\nattribute vec2 st;\\n\\\nattribute float batchId;\\n\\\n\\n\\\nvarying vec3 v_positionEC;\\n\\\nvarying vec3 v_normalEC;\\n\\\nvarying vec3 v_tangentEC;\\n\\\nvarying vec3 v_bitangentEC;\\n\\\nvarying vec2 v_st;\\n\\\n\\n\\\nvoid main()\\n\\\n{\\n\\\n    vec4 p = czm_computePosition();\\n\\\n\\n\\\n    v_positionEC = (czm_modelViewRelativeToEye * p).xyz;      // position in eye coordinates\\n\\\n    v_normalEC = czm_normal * normal;                         // normal in eye coordinates\\n\\\n    v_tangentEC = czm_normal * tangent;                       // tangent in eye coordinates\\n\\\n    v_bitangentEC = czm_normal * bitangent;                   // bitangent in eye coordinates\\n\\\n    v_st = st;\\n\\\n\\n\\\n    gl_Position = czm_modelViewProjectionRelativeToEye * p;\\n\\\n}\\n\\\n\";\n","//This file is automatically rebuilt by the Cesium build process.\nexport default \"varying vec3 v_positionEC;\\n\\\nvarying vec3 v_normalEC;\\n\\\nvarying vec3 v_tangentEC;\\n\\\nvarying vec3 v_bitangentEC;\\n\\\nvarying vec2 v_st;\\n\\\n\\n\\\nvoid main()\\n\\\n{\\n\\\n    vec3 positionToEyeEC = -v_positionEC;\\n\\\n    mat3 tangentToEyeMatrix = czm_tangentToEyeSpaceMatrix(v_normalEC, v_tangentEC, v_bitangentEC);\\n\\\n\\n\\\n    vec3 normalEC = normalize(v_normalEC);\\n\\\n#ifdef FACE_FORWARD\\n\\\n    normalEC = faceforward(normalEC, vec3(0.0, 0.0, 1.0), -normalEC);\\n\\\n#endif\\n\\\n\\n\\\n    czm_materialInput materialInput;\\n\\\n    materialInput.normalEC = normalEC;\\n\\\n    materialInput.tangentToEyeMatrix = tangentToEyeMatrix;\\n\\\n    materialInput.positionToEyeEC = positionToEyeEC;\\n\\\n    materialInput.st = v_st;\\n\\\n    czm_material material = czm_getMaterial(materialInput);\\n\\\n\\n\\\n#ifdef FLAT\\n\\\n    gl_FragColor = vec4(material.diffuse + material.emission, material.alpha);\\n\\\n#else\\n\\\n    gl_FragColor = czm_phong(normalize(positionToEyeEC), material, czm_lightDirectionEC);\\n\\\n#endif\\n\\\n}\\n\\\n\";\n","import ComponentDatatype from './ComponentDatatype.js';\nimport defaultValue from './defaultValue.js';\nimport defined from './defined.js';\nimport defineProperties from './defineProperties.js';\nimport DeveloperError from './DeveloperError.js';\n\n    /**\n     * Value and type information for per-instance geometry attribute that determines if the geometry instance has a distance display condition.\n     *\n     * @alias DistanceDisplayConditionGeometryInstanceAttribute\n     * @constructor\n     *\n     * @param {Number} [near=0.0] The near distance.\n     * @param {Number} [far=Number.MAX_VALUE] The far distance.\n     *\n     * @exception {DeveloperError} far must be greater than near.\n     *\n     * @example\n     * var instance = new Cesium.GeometryInstance({\n     *   geometry : new Cesium.BoxGeometry({\n     *     vertexFormat : Cesium.VertexFormat.POSITION_AND_NORMAL,\n     *     minimum : new Cesium.Cartesian3(-250000.0, -250000.0, -250000.0),\n     *     maximum : new Cesium.Cartesian3(250000.0, 250000.0, 250000.0)\n     *   }),\n     *   modelMatrix : Cesium.Matrix4.multiplyByTranslation(Cesium.Transforms.eastNorthUpToFixedFrame(\n     *     Cesium.Cartesian3.fromDegrees(-75.59777, 40.03883)), new Cesium.Cartesian3(0.0, 0.0, 1000000.0), new Cesium.Matrix4()),\n     *   id : 'box',\n     *   attributes : {\n     *     distanceDisplayCondition : new Cesium.DistanceDisplayConditionGeometryInstanceAttribute(100.0, 10000.0)\n     *   }\n     * });\n     *\n     * @see GeometryInstance\n     * @see GeometryInstanceAttribute\n     */\n    function DistanceDisplayConditionGeometryInstanceAttribute(near, far) {\n        near = defaultValue(near, 0.0);\n        far = defaultValue(far, Number.MAX_VALUE);\n\n        \n\n        /**\n         * The values for the attributes stored in a typed array.\n         *\n         * @type Float32Array\n         *\n         * @default [0.0, 0.0, Number.MAX_VALUE]\n         */\n        this.value = new Float32Array([near, far]);\n    }\n\n    defineProperties(DistanceDisplayConditionGeometryInstanceAttribute.prototype, {\n        /**\n         * The datatype of each component in the attribute, e.g., individual elements in\n         * {@link DistanceDisplayConditionGeometryInstanceAttribute#value}.\n         *\n         * @memberof DistanceDisplayConditionGeometryInstanceAttribute.prototype\n         *\n         * @type {ComponentDatatype}\n         * @readonly\n         *\n         * @default {@link ComponentDatatype.FLOAT}\n         */\n        componentDatatype : {\n            get : function() {\n                return ComponentDatatype.FLOAT;\n            }\n        },\n\n        /**\n         * The number of components in the attributes, i.e., {@link DistanceDisplayConditionGeometryInstanceAttribute#value}.\n         *\n         * @memberof DistanceDisplayConditionGeometryInstanceAttribute.prototype\n         *\n         * @type {Number}\n         * @readonly\n         *\n         * @default 3\n         */\n        componentsPerAttribute : {\n            get : function() {\n                return 2;\n            }\n        },\n\n        /**\n         * When <code>true</code> and <code>componentDatatype</code> is an integer format,\n         * indicate that the components should be mapped to the range [0, 1] (unsigned)\n         * or [-1, 1] (signed) when they are accessed as floating-point for rendering.\n         *\n         * @memberof DistanceDisplayConditionGeometryInstanceAttribute.prototype\n         *\n         * @type {Boolean}\n         * @readonly\n         *\n         * @default false\n         */\n        normalize : {\n            get : function() {\n                return false;\n            }\n        }\n    });\n\n    /**\n     * Creates a new {@link DistanceDisplayConditionGeometryInstanceAttribute} instance given the provided an enabled flag and {@link DistanceDisplayCondition}.\n     *\n     * @param {DistanceDisplayCondition} distanceDisplayCondition The distance display condition.\n     * @returns {DistanceDisplayConditionGeometryInstanceAttribute} The new {@link DistanceDisplayConditionGeometryInstanceAttribute} instance.\n     *\n     * @exception {DeveloperError} distanceDisplayCondition.far must be greater than distanceDisplayCondition.near\n     *\n     * @example\n     * var distanceDisplayCondition = new Cesium.DistanceDisplayCondition(100.0, 10000.0);\n     * var instance = new Cesium.GeometryInstance({\n     *   geometry : geometry,\n     *   attributes : {\n     *     distanceDisplayCondition : Cesium.DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(distanceDisplayCondition)\n     *   }\n     * });\n     */\n    DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition = function(distanceDisplayCondition) {\n        \n\n        return new DistanceDisplayConditionGeometryInstanceAttribute(distanceDisplayCondition.near, distanceDisplayCondition.far);\n    };\n\n    /**\n     * Converts a distance display condition to a typed array that can be used to assign a distance display condition attribute.\n     *\n     * @param {DistanceDisplayCondition} distanceDisplayCondition The distance display condition value.\n     * @param {Float32Array} [result] The array to store the result in, if undefined a new instance will be created.\n     * @returns {Float32Array} The modified result parameter or a new instance if result was undefined.\n     *\n     * @example\n     * var attributes = primitive.getGeometryInstanceAttributes('an id');\n     * attributes.distanceDisplayCondition = Cesium.DistanceDisplayConditionGeometryInstanceAttribute.toValue(distanceDisplayCondition, attributes.distanceDisplayCondition);\n     */\n    DistanceDisplayConditionGeometryInstanceAttribute.toValue = function(distanceDisplayCondition, result) {\n        \n\n        if (!defined(result)) {\n            return new Float32Array([distanceDisplayCondition.near, distanceDisplayCondition.far]);\n        }\n        result[0] = distanceDisplayCondition.near;\n        result[1] = distanceDisplayCondition.far;\n        return result;\n    };\nexport default DistanceDisplayConditionGeometryInstanceAttribute;\n","import Color from '../Core/Color.js';\nimport defined from '../Core/defined.js';\nimport defineProperties from '../Core/defineProperties.js';\nimport DeveloperError from '../Core/DeveloperError.js';\nimport Material from '../Scene/Material.js';\n\n    /**\n     * The interface for all {@link Property} objects that represent {@link Material} uniforms.\n     * This type defines an interface and cannot be instantiated directly.\n     *\n     * @alias MaterialProperty\n     * @constructor\n     * @abstract\n     *\n     * @see ColorMaterialProperty\n     * @see CompositeMaterialProperty\n     * @see GridMaterialProperty\n     * @see ImageMaterialProperty\n     * @see PolylineGlowMaterialProperty\n     * @see PolylineOutlineMaterialProperty\n     * @see StripeMaterialProperty\n     */\n    function MaterialProperty() {\n        DeveloperError.throwInstantiationError();\n    }\n\n    defineProperties(MaterialProperty.prototype, {\n        /**\n         * Gets a value indicating if this property is constant.  A property is considered\n         * constant if getValue always returns the same result for the current definition.\n         * @memberof MaterialProperty.prototype\n         *\n         * @type {Boolean}\n         * @readonly\n         */\n        isConstant : {\n            get : DeveloperError.throwInstantiationError\n        },\n        /**\n         * Gets the event that is raised whenever the definition of this property changes.\n         * The definition is considered to have changed if a call to getValue would return\n         * a different result for the same time.\n         * @memberof MaterialProperty.prototype\n         *\n         * @type {Event}\n         * @readonly\n         */\n        definitionChanged : {\n            get : DeveloperError.throwInstantiationError\n        }\n    });\n\n    /**\n     * Gets the {@link Material} type at the provided time.\n     * @function\n     *\n     * @param {JulianDate} time The time for which to retrieve the type.\n     * @returns {String} The type of material.\n     */\n    MaterialProperty.prototype.getType = DeveloperError.throwInstantiationError;\n\n    /**\n     * Gets the value of the property at the provided time.\n     * @function\n     *\n     * @param {JulianDate} time The time for which to retrieve the value.\n     * @param {Object} [result] The object to store the value into, if omitted, a new instance is created and returned.\n     * @returns {Object} The modified result parameter or a new instance if the result parameter was not supplied.\n     */\n    MaterialProperty.prototype.getValue = DeveloperError.throwInstantiationError;\n\n    /**\n     * Compares this property to the provided property and returns\n     * <code>true</code> if they are equal, <code>false</code> otherwise.\n     * @function\n     *\n     * @param {Property} [other] The other property.\n     * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n     */\n    MaterialProperty.prototype.equals = DeveloperError.throwInstantiationError;\n\n    /**\n     * @private\n     */\n    MaterialProperty.getValue = function(time, materialProperty, material) {\n        var type;\n\n        if (defined(materialProperty)) {\n            type = materialProperty.getType(time);\n            if (defined(type)) {\n                if (!defined(material) || (material.type !== type)) {\n                    material = Material.fromType(type);\n                }\n                materialProperty.getValue(time, material.uniforms);\n                return material;\n            }\n        }\n\n        if (!defined(material) || (material.type !== Material.ColorType)) {\n            material = Material.fromType(Material.ColorType);\n        }\n        Color.clone(Color.WHITE, material.uniforms.color);\n\n        return material;\n    };\nexport default MaterialProperty;\n","import BoundingSphere from '../Core/BoundingSphere.js';\nimport Check from '../Core/Check.js';\nimport defined from '../Core/defined.js';\nimport destroyObject from '../Core/destroyObject.js';\nimport DeveloperError from '../Core/DeveloperError.js';\nimport GroundPrimitive from '../Scene/GroundPrimitive.js';\nimport MaterialAppearance from '../Scene/MaterialAppearance.js';\nimport PerInstanceColorAppearance from '../Scene/PerInstanceColorAppearance.js';\nimport Primitive from '../Scene/Primitive.js';\nimport BoundingSphereState from './BoundingSphereState.js';\nimport ColorMaterialProperty from './ColorMaterialProperty.js';\nimport MaterialProperty from './MaterialProperty.js';\nimport Property from './Property.js';\n\n    /**\n     * Defines the interface for a dynamic geometry updater.  A DynamicGeometryUpdater\n     * is responsible for handling visualization of a specific type of geometry\n     * that needs to be recomputed based on simulation time.\n     * This object is never used directly by client code, but is instead created by\n     * {@link GeometryUpdater} implementations which contain dynamic geometry.\n     *\n     * This type defines an interface and cannot be instantiated directly.\n     *\n     * @alias DynamicGeometryUpdater\n     * @constructor\n     * @private\n     * @abstract\n     */\n    function DynamicGeometryUpdater(geometryUpdater, primitives, orderedGroundPrimitives) {\n        \n\n        this._primitives = primitives;\n        this._orderedGroundPrimitives = orderedGroundPrimitives;\n        this._primitive = undefined;\n        this._outlinePrimitive = undefined;\n        this._geometryUpdater = geometryUpdater;\n        this._options = geometryUpdater._options;\n        this._entity = geometryUpdater._entity;\n        this._material = undefined;\n    }\n\n    DynamicGeometryUpdater.prototype._isHidden = function(entity, geometry, time) {\n        return !entity.isShowing || !entity.isAvailable(time) || !Property.getValueOrDefault(geometry.show, time, true);\n    };\n\n    DynamicGeometryUpdater.prototype._setOptions = DeveloperError.throwInstantiationError;\n\n    /**\n     * Updates the geometry to the specified time.\n     * @memberof DynamicGeometryUpdater\n     * @function\n     *\n     * @param {JulianDate} time The current time.\n     */\n    DynamicGeometryUpdater.prototype.update = function(time) {\n        \n\n        var geometryUpdater = this._geometryUpdater;\n        var onTerrain = geometryUpdater._onTerrain;\n\n        var primitives = this._primitives;\n        var orderedGroundPrimitives = this._orderedGroundPrimitives;\n        if (onTerrain) {\n            orderedGroundPrimitives.remove(this._primitive);\n        } else {\n            primitives.removeAndDestroy(this._primitive);\n            primitives.removeAndDestroy(this._outlinePrimitive);\n            this._outlinePrimitive = undefined;\n        }\n        this._primitive = undefined;\n\n        var entity = this._entity;\n        var geometry = entity[this._geometryUpdater._geometryPropertyName];\n        this._setOptions(entity, geometry, time);\n        if (this._isHidden(entity, geometry, time)) {\n            return;\n        }\n\n        var shadows = this._geometryUpdater.shadowsProperty.getValue(time);\n        var options = this._options;\n        if (!defined(geometry.fill) || geometry.fill.getValue(time)) {\n            var fillMaterialProperty = geometryUpdater.fillMaterialProperty;\n            var isColorAppearance = fillMaterialProperty instanceof ColorMaterialProperty;\n            var appearance;\n            var closed = geometryUpdater._getIsClosed(options);\n            if (isColorAppearance) {\n                appearance = new PerInstanceColorAppearance({\n                    closed: closed,\n                    flat : onTerrain && !geometryUpdater._supportsMaterialsforEntitiesOnTerrain\n                });\n            } else {\n                var material = MaterialProperty.getValue(time, fillMaterialProperty, this._material);\n                this._material = material;\n                appearance = new MaterialAppearance({\n                    material : material,\n                    translucent : material.isTranslucent(),\n                    closed : closed\n                });\n            }\n\n            if (onTerrain) {\n                options.vertexFormat = PerInstanceColorAppearance.VERTEX_FORMAT;\n                this._primitive = orderedGroundPrimitives.add(new GroundPrimitive({\n                    geometryInstances : this._geometryUpdater.createFillGeometryInstance(time),\n                    appearance : appearance,\n                    asynchronous : false,\n                    shadows : shadows,\n                    classificationType : this._geometryUpdater.classificationTypeProperty.getValue(time)\n                }), Property.getValueOrUndefined(this._geometryUpdater.zIndex, time));\n            } else {\n                options.vertexFormat = appearance.vertexFormat;\n\n                var fillInstance = this._geometryUpdater.createFillGeometryInstance(time);\n\n                if (isColorAppearance) {\n                    appearance.translucent = fillInstance.attributes.color.value[3] !== 255;\n                }\n\n                this._primitive = primitives.add(new Primitive({\n                    geometryInstances : fillInstance,\n                    appearance : appearance,\n                    asynchronous : false,\n                    shadows : shadows\n                }));\n            }\n        }\n\n        if (!onTerrain && defined(geometry.outline) && geometry.outline.getValue(time)) {\n            var outlineInstance = this._geometryUpdater.createOutlineGeometryInstance(time);\n            var outlineWidth = Property.getValueOrDefault(geometry.outlineWidth, time, 1.0);\n\n            this._outlinePrimitive = primitives.add(new Primitive({\n                geometryInstances : outlineInstance,\n                appearance : new PerInstanceColorAppearance({\n                    flat : true,\n                    translucent : outlineInstance.attributes.color.value[3] !== 255,\n                    renderState : {\n                        lineWidth : geometryUpdater._scene.clampLineWidth(outlineWidth)\n                    }\n                }),\n                asynchronous : false,\n                shadows : shadows\n            }));\n        }\n    };\n\n    /**\n     * Computes a bounding sphere which encloses the visualization produced for the specified entity.\n     * The bounding sphere is in the fixed frame of the scene's globe.\n     * @function\n     *\n     * @param {BoundingSphere} result The bounding sphere onto which to store the result.\n     * @returns {BoundingSphereState} BoundingSphereState.DONE if the result contains the bounding sphere,\n     *                       BoundingSphereState.PENDING if the result is still being computed, or\n     *                       BoundingSphereState.FAILED if the entity has no visualization in the current scene.\n     * @private\n     */\n    DynamicGeometryUpdater.prototype.getBoundingSphere = function(result) {\n        \n        var entity = this._entity;\n        var primitive = this._primitive;\n        var outlinePrimitive = this._outlinePrimitive;\n\n        var attributes;\n\n        //Outline and Fill geometries have the same bounding sphere, so just use whichever one is defined and ready\n        if (defined(primitive) && primitive.show && primitive.ready) {\n            attributes = primitive.getGeometryInstanceAttributes(entity);\n            if (defined(attributes) && defined(attributes.boundingSphere)) {\n                BoundingSphere.clone(attributes.boundingSphere, result);\n                return BoundingSphereState.DONE;\n            }\n        }\n\n        if (defined(outlinePrimitive) && outlinePrimitive.show && outlinePrimitive.ready) {\n            attributes = outlinePrimitive.getGeometryInstanceAttributes(entity);\n            if (defined(attributes) && defined(attributes.boundingSphere)) {\n                BoundingSphere.clone(attributes.boundingSphere, result);\n                return BoundingSphereState.DONE;\n            }\n        }\n\n        if ((defined(primitive) && !primitive.ready) || (defined(outlinePrimitive) && !outlinePrimitive.ready)) {\n            return BoundingSphereState.PENDING;\n        }\n\n        return BoundingSphereState.FAILED;\n    };\n\n    /**\n     * Returns true if this object was destroyed; otherwise, false.\n     * @memberof DynamicGeometryUpdater\n     * @function\n     *\n     * @returns {Boolean} True if this object was destroyed; otherwise, false.\n     */\n    DynamicGeometryUpdater.prototype.isDestroyed = function() {\n        return false;\n    };\n\n    /**\n     * Destroys and resources used by the object.  Once an object is destroyed, it should not be used.\n     * @memberof DynamicGeometryUpdater\n     * @function\n     *\n     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n     */\n    DynamicGeometryUpdater.prototype.destroy = function() {\n        var primitives = this._primitives;\n        var orderedGroundPrimitives = this._orderedGroundPrimitives;\n        if (this._geometryUpdater._onTerrain) {\n            orderedGroundPrimitives.remove(this._primitive);\n        } else {\n            primitives.removeAndDestroy(this._primitive);\n        }\n        primitives.removeAndDestroy(this._outlinePrimitive);\n        destroyObject(this);\n    };\nexport default DynamicGeometryUpdater;\n","import Check from '../Core/Check.js';\nimport Color from '../Core/Color.js';\nimport defaultValue from '../Core/defaultValue.js';\nimport defined from '../Core/defined.js';\nimport defineProperties from '../Core/defineProperties.js';\nimport destroyObject from '../Core/destroyObject.js';\nimport DeveloperError from '../Core/DeveloperError.js';\nimport DistanceDisplayCondition from '../Core/DistanceDisplayCondition.js';\nimport Event from '../Core/Event.js';\nimport Iso8601 from '../Core/Iso8601.js';\nimport oneTimeWarning from '../Core/oneTimeWarning.js';\nimport ClassificationType from '../Scene/ClassificationType.js';\nimport ShadowMode from '../Scene/ShadowMode.js';\nimport ColorMaterialProperty from './ColorMaterialProperty.js';\nimport ConstantProperty from './ConstantProperty.js';\nimport Entity from './Entity.js';\nimport Property from './Property.js';\n\n    var defaultMaterial = new ColorMaterialProperty(Color.WHITE);\n    var defaultShow = new ConstantProperty(true);\n    var defaultFill = new ConstantProperty(true);\n    var defaultOutline = new ConstantProperty(false);\n    var defaultOutlineColor = new ConstantProperty(Color.BLACK);\n    var defaultShadows = new ConstantProperty(ShadowMode.DISABLED);\n    var defaultDistanceDisplayCondition = new ConstantProperty(new DistanceDisplayCondition());\n    var defaultClassificationType = new ConstantProperty(ClassificationType.BOTH);\n\n    /**\n     * An abstract class for updating geometry entities.\n     * @alias GeometryUpdater\n     * @constructor\n     *\n     * @param {Object} options An object with the following properties:\n     * @param {Entity} options.entity The entity containing the geometry to be visualized.\n     * @param {Scene} options.scene The scene where visualization is taking place.\n     * @param {Object} options.geometryOptions Options for the geometry\n     * @param {String} options.geometryPropertyName The geometry property name\n     * @param {String[]} options.observedPropertyNames The entity properties this geometry cares about\n     */\n    function GeometryUpdater(options) {\n        \n\n        var entity = options.entity;\n        var geometryPropertyName = options.geometryPropertyName;\n\n        this._entity = entity;\n        this._scene = options.scene;\n        this._fillEnabled = false;\n        this._isClosed = false;\n        this._onTerrain = false;\n        this._dynamic = false;\n        this._outlineEnabled = false;\n        this._geometryChanged = new Event();\n        this._showProperty = undefined;\n        this._materialProperty = undefined;\n        this._showOutlineProperty = undefined;\n        this._outlineColorProperty = undefined;\n        this._outlineWidth = 1.0;\n        this._shadowsProperty = undefined;\n        this._distanceDisplayConditionProperty = undefined;\n        this._classificationTypeProperty = undefined;\n        this._options = options.geometryOptions;\n        this._geometryPropertyName = geometryPropertyName;\n        this._id = geometryPropertyName + '-' + entity.id;\n        this._observedPropertyNames = options.observedPropertyNames;\n        this._supportsMaterialsforEntitiesOnTerrain = Entity.supportsMaterialsforEntitiesOnTerrain(options.scene);\n    }\n\n    defineProperties(GeometryUpdater.prototype, {\n        /**\n         * Gets the unique ID associated with this updater\n         * @memberof GeometryUpdater.prototype\n         * @type {String}\n         * @readonly\n         */\n        id : {\n            get : function() {\n                return this._id;\n            }\n        },\n        /**\n         * Gets the entity associated with this geometry.\n         * @memberof GeometryUpdater.prototype\n         *\n         * @type {Entity}\n         * @readonly\n         */\n        entity : {\n            get : function() {\n                return this._entity;\n            }\n        },\n        /**\n         * Gets a value indicating if the geometry has a fill component.\n         * @memberof GeometryUpdater.prototype\n         *\n         * @type {Boolean}\n         * @readonly\n         */\n        fillEnabled : {\n            get : function() {\n                return this._fillEnabled;\n            }\n        },\n        /**\n         * Gets a value indicating if fill visibility varies with simulation time.\n         * @memberof GeometryUpdater.prototype\n         *\n         * @type {Boolean}\n         * @readonly\n         */\n        hasConstantFill : {\n            get : function() {\n                return !this._fillEnabled ||\n                       (!defined(this._entity.availability) &&\n                        Property.isConstant(this._showProperty) &&\n                        Property.isConstant(this._fillProperty));\n            }\n        },\n        /**\n         * Gets the material property used to fill the geometry.\n         * @memberof GeometryUpdater.prototype\n         *\n         * @type {MaterialProperty}\n         * @readonly\n         */\n        fillMaterialProperty : {\n            get : function() {\n                return this._materialProperty;\n            }\n        },\n        /**\n         * Gets a value indicating if the geometry has an outline component.\n         * @memberof GeometryUpdater.prototype\n         *\n         * @type {Boolean}\n         * @readonly\n         */\n        outlineEnabled : {\n            get : function() {\n                return this._outlineEnabled;\n            }\n        },\n        /**\n         * Gets a value indicating if the geometry has an outline component.\n         * @memberof GeometryUpdater.prototype\n         *\n         * @type {Boolean}\n         * @readonly\n         */\n        hasConstantOutline : {\n            get : function() {\n                return !this._outlineEnabled ||\n                       (!defined(this._entity.availability) &&\n                        Property.isConstant(this._showProperty) &&\n                        Property.isConstant(this._showOutlineProperty));\n            }\n        },\n        /**\n         * Gets the {@link Color} property for the geometry outline.\n         * @memberof GeometryUpdater.prototype\n         *\n         * @type {Property}\n         * @readonly\n         */\n        outlineColorProperty : {\n            get : function() {\n                return this._outlineColorProperty;\n            }\n        },\n        /**\n         * Gets the constant with of the geometry outline, in pixels.\n         * This value is only valid if isDynamic is false.\n         * @memberof GeometryUpdater.prototype\n         *\n         * @type {Number}\n         * @readonly\n         */\n        outlineWidth : {\n            get : function() {\n                return this._outlineWidth;\n            }\n        },\n        /**\n         * Gets the property specifying whether the geometry\n         * casts or receives shadows from light sources.\n         * @memberof GeometryUpdater.prototype\n         *\n         * @type {Property}\n         * @readonly\n         */\n        shadowsProperty : {\n            get : function() {\n                return this._shadowsProperty;\n            }\n        },\n        /**\n         * Gets or sets the {@link DistanceDisplayCondition} Property specifying at what distance from the camera that this geometry will be displayed.\n         * @memberof GeometryUpdater.prototype\n         *\n         * @type {Property}\n         * @readonly\n         */\n        distanceDisplayConditionProperty : {\n            get : function() {\n                return this._distanceDisplayConditionProperty;\n            }\n        },\n        /**\n         * Gets or sets the {@link ClassificationType} Property specifying if this geometry will classify terrain, 3D Tiles, or both when on the ground.\n         * @memberof GeometryUpdater.prototype\n         *\n         * @type {Property}\n         * @readonly\n         */\n        classificationTypeProperty : {\n            get : function() {\n                return this._classificationTypeProperty;\n            }\n        },\n        /**\n         * Gets a value indicating if the geometry is time-varying.\n         * If true, all visualization is delegated to a DynamicGeometryUpdater\n         * returned by GeometryUpdater#createDynamicUpdater.\n         * @memberof GeometryUpdater.prototype\n         *\n         * @type {Boolean}\n         * @readonly\n         */\n        isDynamic : {\n            get : function() {\n                return this._dynamic;\n            }\n        },\n        /**\n         * Gets a value indicating if the geometry is closed.\n         * This property is only valid for static geometry.\n         * @memberof GeometryUpdater.prototype\n         *\n         * @type {Boolean}\n         * @readonly\n         */\n        isClosed : {\n            get : function() {\n                return this._isClosed;\n            }\n        },\n        /**\n         * Gets a value indicating if the geometry should be drawn on terrain.\n         * @memberof EllipseGeometryUpdater.prototype\n         *\n         * @type {Boolean}\n         * @readonly\n         */\n        onTerrain : {\n            get : function() {\n                return this._onTerrain;\n            }\n        },\n        /**\n         * Gets an event that is raised whenever the public properties\n         * of this updater change.\n         * @memberof GeometryUpdater.prototype\n         *\n         * @type {Boolean}\n         * @readonly\n         */\n        geometryChanged : {\n            get : function() {\n                return this._geometryChanged;\n            }\n        }\n    });\n\n    /**\n     * Checks if the geometry is outlined at the provided time.\n     *\n     * @param {JulianDate} time The time for which to retrieve visibility.\n     * @returns {Boolean} true if geometry is outlined at the provided time, false otherwise.\n     */\n    GeometryUpdater.prototype.isOutlineVisible = function(time) {\n        var entity = this._entity;\n        var visible = this._outlineEnabled && entity.isAvailable(time) && this._showProperty.getValue(time) && this._showOutlineProperty.getValue(time);\n        return defaultValue(visible, false);\n    };\n\n    /**\n     * Checks if the geometry is filled at the provided time.\n     *\n     * @param {JulianDate} time The time for which to retrieve visibility.\n     * @returns {Boolean} true if geometry is filled at the provided time, false otherwise.\n     */\n    GeometryUpdater.prototype.isFilled = function(time) {\n        var entity = this._entity;\n        var visible = this._fillEnabled && entity.isAvailable(time) && this._showProperty.getValue(time) && this._fillProperty.getValue(time);\n        return defaultValue(visible, false);\n    };\n\n    /**\n     * Creates the geometry instance which represents the fill of the geometry.\n     *\n     * @function\n     * @param {JulianDate} time The time to use when retrieving initial attribute values.\n     * @returns {GeometryInstance} The geometry instance representing the filled portion of the geometry.\n     *\n     * @exception {DeveloperError} This instance does not represent a filled geometry.\n     */\n    GeometryUpdater.prototype.createFillGeometryInstance = DeveloperError.throwInstantiationError;\n\n    /**\n     * Creates the geometry instance which represents the outline of the geometry.\n     *\n     * @function\n     * @param {JulianDate} time The time to use when retrieving initial attribute values.\n     * @returns {GeometryInstance} The geometry instance representing the outline portion of the geometry.\n     *\n     * @exception {DeveloperError} This instance does not represent an outlined geometry.\n     */\n    GeometryUpdater.prototype.createOutlineGeometryInstance = DeveloperError.throwInstantiationError;\n\n    /**\n     * Returns true if this object was destroyed; otherwise, false.\n     *\n     * @returns {Boolean} True if this object was destroyed; otherwise, false.\n     */\n    GeometryUpdater.prototype.isDestroyed = function() {\n        return false;\n    };\n\n    /**\n     * Destroys and resources used by the object.  Once an object is destroyed, it should not be used.\n     *\n     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n     */\n    GeometryUpdater.prototype.destroy = function() {\n        destroyObject(this);\n    };\n    /**\n     * @param {Entity} entity\n     * @param {Object} geometry\n     * @private\n     */\n    GeometryUpdater.prototype._isHidden = function(entity, geometry) {\n        var show = geometry.show;\n        return defined(show) && show.isConstant && !show.getValue(Iso8601.MINIMUM_VALUE);\n    };\n\n    /**\n     * @param {Entity} entity\n     * @param {Object} geometry\n     * @private\n     */\n    GeometryUpdater.prototype._isOnTerrain = function(entity, geometry) {\n        return false;\n    };\n\n    /**\n     * @param {GeometryOptions} options\n     * @private\n     */\n    GeometryUpdater.prototype._getIsClosed = function(options) {\n        return true;\n    };\n\n    /**\n     * @param {Entity} entity\n     * @param {Object} geometry\n     * @private\n     */\n    GeometryUpdater.prototype._isDynamic = DeveloperError.throwInstantiationError;\n\n    /**\n     * @param {Entity} entity\n     * @param {Object} geometry\n     * @private\n     */\n    GeometryUpdater.prototype._setStaticOptions = DeveloperError.throwInstantiationError;\n\n    /**\n     * @param {Entity} entity\n     * @param {String} propertyName\n     * @param {*} newValue\n     * @param {*} oldValue\n     * @private\n     */\n    GeometryUpdater.prototype._onEntityPropertyChanged = function(entity, propertyName, newValue, oldValue) {\n        if (this._observedPropertyNames.indexOf(propertyName) === -1) {\n            return;\n        }\n\n        var geometry = this._entity[this._geometryPropertyName];\n\n        if (!defined(geometry)) {\n            if (this._fillEnabled || this._outlineEnabled) {\n                this._fillEnabled = false;\n                this._outlineEnabled = false;\n                this._geometryChanged.raiseEvent(this);\n            }\n            return;\n        }\n\n        var fillProperty = geometry.fill;\n        var fillEnabled = defined(fillProperty) && fillProperty.isConstant ? fillProperty.getValue(Iso8601.MINIMUM_VALUE) : true;\n\n        var outlineProperty = geometry.outline;\n        var outlineEnabled = defined(outlineProperty);\n        if (outlineEnabled && outlineProperty.isConstant) {\n            outlineEnabled = outlineProperty.getValue(Iso8601.MINIMUM_VALUE);\n        }\n\n        if (!fillEnabled && !outlineEnabled) {\n            if (this._fillEnabled || this._outlineEnabled) {\n                this._fillEnabled = false;\n                this._outlineEnabled = false;\n                this._geometryChanged.raiseEvent(this);\n            }\n            return;\n        }\n\n        var show = geometry.show;\n        if (this._isHidden(entity, geometry)) {\n            if (this._fillEnabled || this._outlineEnabled) {\n                this._fillEnabled = false;\n                this._outlineEnabled = false;\n                this._geometryChanged.raiseEvent(this);\n            }\n            return;\n        }\n\n        this._materialProperty = defaultValue(geometry.material, defaultMaterial);\n        this._fillProperty = defaultValue(fillProperty, defaultFill);\n        this._showProperty = defaultValue(show, defaultShow);\n        this._showOutlineProperty = defaultValue(geometry.outline, defaultOutline);\n        this._outlineColorProperty = outlineEnabled ? defaultValue(geometry.outlineColor, defaultOutlineColor) : undefined;\n        this._shadowsProperty = defaultValue(geometry.shadows, defaultShadows);\n        this._distanceDisplayConditionProperty = defaultValue(geometry.distanceDisplayCondition, defaultDistanceDisplayCondition);\n        this._classificationTypeProperty = defaultValue(geometry.classificationType, defaultClassificationType);\n\n        this._fillEnabled = fillEnabled;\n\n        var onTerrain = this._isOnTerrain(entity, geometry) &&\n            (this._supportsMaterialsforEntitiesOnTerrain || this._materialProperty instanceof ColorMaterialProperty);\n\n        if (outlineEnabled && onTerrain) {\n            oneTimeWarning(oneTimeWarning.geometryOutlines);\n            outlineEnabled = false;\n        }\n\n        this._onTerrain = onTerrain;\n        this._outlineEnabled = outlineEnabled;\n\n        if (this._isDynamic(entity, geometry)) {\n            if (!this._dynamic) {\n                this._dynamic = true;\n                this._geometryChanged.raiseEvent(this);\n            }\n        } else {\n            this._setStaticOptions(entity, geometry);\n            this._isClosed = this._getIsClosed(this._options);\n            var outlineWidth = geometry.outlineWidth;\n            this._outlineWidth = defined(outlineWidth) ? outlineWidth.getValue(Iso8601.MINIMUM_VALUE) : 1.0;\n            this._dynamic = false;\n            this._geometryChanged.raiseEvent(this);\n        }\n    };\n\n    /**\n     * Creates the dynamic updater to be used when GeometryUpdater#isDynamic is true.\n     *\n     * @param {PrimitiveCollection} primitives The primitive collection to use.\n     * @param {PrimitiveCollection} [groundPrimitives] The primitive collection to use for ground primitives.\n     *\n     * @returns {DynamicGeometryUpdater} The dynamic updater used to update the geometry each frame.\n     *\n     * @exception {DeveloperError} This instance does not represent dynamic geometry.\n     */\n    GeometryUpdater.prototype.createDynamicUpdater = function(primitives, groundPrimitives) {\n        \n\n        return new this.constructor.DynamicGeometryUpdater(this, primitives, groundPrimitives);\n    };\nexport default GeometryUpdater;\n","import Cartesian3 from '../Core/Cartesian3.js';\nimport Cartographic from '../Core/Cartographic.js';\nimport Check from '../Core/Check.js';\nimport defined from '../Core/defined.js';\nimport defineProperties from '../Core/defineProperties.js';\nimport destroyObject from '../Core/destroyObject.js';\nimport Event from '../Core/Event.js';\nimport Iso8601 from '../Core/Iso8601.js';\nimport CesiumMath from '../Core/Math.js';\nimport HeightReference from '../Scene/HeightReference.js';\nimport SceneMode from '../Scene/SceneMode.js';\nimport Property from './Property.js';\n\n    var scratchPosition = new Cartesian3();\n    var scratchCarto = new Cartographic();\n\n    /**\n     * @private\n     */\n    function TerrainOffsetProperty(scene, positionProperty, heightReferenceProperty, extrudedHeightReferenceProperty) {\n        \n\n        this._scene = scene;\n        this._heightReference = heightReferenceProperty;\n        this._extrudedHeightReference = extrudedHeightReferenceProperty;\n        this._positionProperty = positionProperty;\n\n        this._position = new Cartesian3();\n        this._cartographicPosition = new Cartographic();\n        this._normal = new Cartesian3();\n\n        this._definitionChanged = new Event();\n        this._terrainHeight = 0;\n        this._removeCallbackFunc = undefined;\n        this._removeEventListener = undefined;\n        this._removeModeListener = undefined;\n\n        var that = this;\n        if (defined(scene.globe)) {\n            this._removeEventListener = scene.terrainProviderChanged.addEventListener(function() {\n                that._updateClamping();\n            });\n            this._removeModeListener = scene.morphComplete.addEventListener(function() {\n                that._updateClamping();\n            });\n        }\n\n        if (positionProperty.isConstant) {\n            var position = positionProperty.getValue(Iso8601.MINIMUM_VALUE, scratchPosition);\n            if (!defined(position) || Cartesian3.equals(position, Cartesian3.ZERO) || !defined(scene.globe)) {\n                return;\n            }\n            this._position = Cartesian3.clone(position, this._position);\n\n            this._updateClamping();\n\n            this._normal = scene.globe.ellipsoid.geodeticSurfaceNormal(position, this._normal);\n        }\n    }\n\n    defineProperties(TerrainOffsetProperty.prototype, {\n        /**\n         * Gets a value indicating if this property is constant.\n         * @memberof TerrainOffsetProperty.prototype\n         *\n         * @type {Boolean}\n         * @readonly\n         */\n        isConstant : {\n            get : function() {\n                return false;\n            }\n        },\n        /**\n         * Gets the event that is raised whenever the definition of this property changes.\n         * @memberof TerrainOffsetProperty.prototype\n         *\n         * @type {Event}\n         * @readonly\n         */\n        definitionChanged : {\n            get : function() {\n                return this._definitionChanged;\n            }\n        }\n    });\n\n    /**\n     * @private\n     */\n    TerrainOffsetProperty.prototype._updateClamping = function() {\n        if (defined(this._removeCallbackFunc)) {\n            this._removeCallbackFunc();\n        }\n\n        var scene = this._scene;\n        var globe = scene.globe;\n        var position = this._position;\n\n        if (!defined(globe) || Cartesian3.equals(position, Cartesian3.ZERO)) {\n            this._terrainHeight = 0;\n            return;\n        }\n        var ellipsoid = globe.ellipsoid;\n        var surface = globe._surface;\n\n        var that = this;\n        var cartographicPosition = ellipsoid.cartesianToCartographic(position, this._cartographicPosition);\n        var height = globe.getHeight(cartographicPosition);\n        if (defined(height)) {\n            this._terrainHeight = height;\n        } else {\n            this._terrainHeight = 0;\n        }\n\n        function updateFunction(clampedPosition) {\n            if (scene.mode === SceneMode.SCENE3D) {\n                var carto = ellipsoid.cartesianToCartographic(clampedPosition, scratchCarto);\n                that._terrainHeight = carto.height;\n            } else {\n                that._terrainHeight = clampedPosition.x;\n            }\n            that.definitionChanged.raiseEvent();\n        }\n        this._removeCallbackFunc = surface.updateHeight(cartographicPosition, updateFunction);\n    };\n\n    /**\n     * Gets the height relative to the terrain based on the positions.\n     *\n     * @returns {Cartesian3} The offset\n     */\n    TerrainOffsetProperty.prototype.getValue = function(time, result) {\n        var heightReference = Property.getValueOrDefault(this._heightReference, time, HeightReference.NONE);\n        var extrudedHeightReference = Property.getValueOrDefault(this._extrudedHeightReference, time, HeightReference.NONE);\n\n        if (heightReference === HeightReference.NONE && extrudedHeightReference !== HeightReference.RELATIVE_TO_GROUND) {\n            this._position = Cartesian3.clone(Cartesian3.ZERO, this._position);\n            return Cartesian3.clone(Cartesian3.ZERO, result);\n        }\n\n        if (this._positionProperty.isConstant) {\n            return Cartesian3.multiplyByScalar(this._normal, this._terrainHeight, result);\n        }\n\n        var scene = this._scene;\n        var position = this._positionProperty.getValue(time, scratchPosition);\n        if (!defined(position) || Cartesian3.equals(position, Cartesian3.ZERO) || !defined(scene.globe)) {\n            return Cartesian3.clone(Cartesian3.ZERO, result);\n        }\n\n        if (Cartesian3.equalsEpsilon(this._position, position, CesiumMath.EPSILON10)) {\n            return Cartesian3.multiplyByScalar(this._normal, this._terrainHeight, result);\n        }\n\n        this._position = Cartesian3.clone(position, this._position);\n\n        this._updateClamping();\n\n        var normal = scene.globe.ellipsoid.geodeticSurfaceNormal(position, this._normal);\n        return Cartesian3.multiplyByScalar(normal, this._terrainHeight, result);\n    };\n\n    TerrainOffsetProperty.prototype.isDestroyed = function() {\n        return false;\n    };\n\n    TerrainOffsetProperty.prototype.destroy = function() {\n        if (defined(this._removeEventListener)) {\n            this._removeEventListener();\n        }\n        if (defined(this._removeModeListener)) {\n            this._removeModeListener();\n        }\n        if (defined(this._removeCallbackFunc)) {\n            this._removeCallbackFunc();\n        }\n        return destroyObject(this);\n    };\n\n    /**\n     * A function which creates one or more providers.\n     * @callback TerrainOffsetProperty~PositionFunction\n     * @param {JulianDate} time The clock time at which to retrieve the position\n     * @param {Cartesian3} result The result position\n     * @returns {Cartesian3} The position at which to do the terrain height check\n     */\nexport default TerrainOffsetProperty;\n","import defined from '../Core/defined.js';\nimport CallbackProperty from './CallbackProperty.js';\nimport GeometryUpdater from './GeometryUpdater.js';\nimport TerrainOffsetProperty from './TerrainOffsetProperty.js';\n\n    function heightReferenceOnEntityPropertyChanged(entity, propertyName, newValue, oldValue) {\n        GeometryUpdater.prototype._onEntityPropertyChanged.call(this, entity, propertyName, newValue, oldValue);\n        if (this._observedPropertyNames.indexOf(propertyName) === -1) {\n            return;\n        }\n\n        var geometry = this._entity[this._geometryPropertyName];\n        if (!defined(geometry)) {\n            return;\n        }\n\n        if (defined(this._terrainOffsetProperty)) {\n            this._terrainOffsetProperty.destroy();\n            this._terrainOffsetProperty = undefined;\n        }\n\n        var heightReferenceProperty = geometry.heightReference;\n\n        if (defined(heightReferenceProperty)) {\n            var centerPosition = new CallbackProperty(this._computeCenter.bind(this), !this._dynamic);\n            this._terrainOffsetProperty = new TerrainOffsetProperty(this._scene, centerPosition, heightReferenceProperty);\n        }\n    }\nexport default heightReferenceOnEntityPropertyChanged;\n","import BoxGeometry from '../Core/BoxGeometry.js';\nimport BoxOutlineGeometry from '../Core/BoxOutlineGeometry.js';\nimport Cartesian3 from '../Core/Cartesian3.js';\nimport Check from '../Core/Check.js';\nimport Color from '../Core/Color.js';\nimport ColorGeometryInstanceAttribute from '../Core/ColorGeometryInstanceAttribute.js';\nimport defined from '../Core/defined.js';\nimport defineProperties from '../Core/defineProperties.js';\nimport DeveloperError from '../Core/DeveloperError.js';\nimport DistanceDisplayConditionGeometryInstanceAttribute from '../Core/DistanceDisplayConditionGeometryInstanceAttribute.js';\nimport GeometryInstance from '../Core/GeometryInstance.js';\nimport GeometryOffsetAttribute from '../Core/GeometryOffsetAttribute.js';\nimport Iso8601 from '../Core/Iso8601.js';\nimport OffsetGeometryInstanceAttribute from '../Core/OffsetGeometryInstanceAttribute.js';\nimport ShowGeometryInstanceAttribute from '../Core/ShowGeometryInstanceAttribute.js';\nimport HeightReference from '../Scene/HeightReference.js';\nimport MaterialAppearance from '../Scene/MaterialAppearance.js';\nimport PerInstanceColorAppearance from '../Scene/PerInstanceColorAppearance.js';\nimport ColorMaterialProperty from './ColorMaterialProperty.js';\nimport DynamicGeometryUpdater from './DynamicGeometryUpdater.js';\nimport GeometryUpdater from './GeometryUpdater.js';\nimport heightReferenceOnEntityPropertyChanged from './heightReferenceOnEntityPropertyChanged.js';\nimport Property from './Property.js';\n\n    var defaultOffset = Cartesian3.ZERO;\n\n    var offsetScratch = new Cartesian3();\n    var positionScratch = new Cartesian3();\n    var scratchColor = new Color();\n\n    function BoxGeometryOptions(entity) {\n        this.id = entity;\n        this.vertexFormat = undefined;\n        this.dimensions = undefined;\n        this.offsetAttribute = undefined;\n    }\n\n    /**\n     * A {@link GeometryUpdater} for boxes.\n     * Clients do not normally create this class directly, but instead rely on {@link DataSourceDisplay}.\n     * @alias BoxGeometryUpdater\n     * @constructor\n     *\n     * @param {Entity} entity The entity containing the geometry to be visualized.\n     * @param {Scene} scene The scene where visualization is taking place.\n     */\n    function BoxGeometryUpdater(entity, scene) {\n        GeometryUpdater.call(this, {\n            entity : entity,\n            scene : scene,\n            geometryOptions : new BoxGeometryOptions(entity),\n            geometryPropertyName : 'box',\n            observedPropertyNames : ['availability', 'position', 'orientation', 'box']\n        });\n\n        this._onEntityPropertyChanged(entity, 'box', entity.box, undefined);\n    }\n\n    if (defined(Object.create)) {\n        BoxGeometryUpdater.prototype = Object.create(GeometryUpdater.prototype);\n        BoxGeometryUpdater.prototype.constructor = BoxGeometryUpdater;\n    }\n\n    defineProperties(BoxGeometryUpdater.prototype, {\n        /**\n         * Gets the terrain offset property\n         * @type {TerrainOffsetProperty}\n         * @memberof BoxGeometryUpdater.prototype\n         * @readonly\n         */\n        terrainOffsetProperty: {\n            get: function() {\n                return this._terrainOffsetProperty;\n            }\n        }\n    });\n\n    /**\n     * Creates the geometry instance which represents the fill of the geometry.\n     *\n     * @param {JulianDate} time The time to use when retrieving initial attribute values.\n     * @returns {GeometryInstance} The geometry instance representing the filled portion of the geometry.\n     *\n     * @exception {DeveloperError} This instance does not represent a filled geometry.\n     */\n    BoxGeometryUpdater.prototype.createFillGeometryInstance = function(time) {\n        \n\n        var entity = this._entity;\n        var isAvailable = entity.isAvailable(time);\n\n        var show = new ShowGeometryInstanceAttribute(isAvailable && entity.isShowing && this._showProperty.getValue(time) && this._fillProperty.getValue(time));\n        var distanceDisplayCondition = this._distanceDisplayConditionProperty.getValue(time);\n        var distanceDisplayConditionAttribute = DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(distanceDisplayCondition);\n\n        var attributes = {\n            show : show,\n            distanceDisplayCondition : distanceDisplayConditionAttribute,\n            color : undefined,\n            offset: undefined\n        };\n        if (this._materialProperty instanceof ColorMaterialProperty) {\n            var currentColor;\n            if (defined(this._materialProperty.color) && (this._materialProperty.color.isConstant || isAvailable)) {\n                currentColor = this._materialProperty.color.getValue(time, scratchColor);\n            }\n            if (!defined(currentColor)) {\n                currentColor = Color.WHITE;\n            }\n            attributes.color = ColorGeometryInstanceAttribute.fromColor(currentColor);\n        }\n        if (defined(this._options.offsetAttribute)) {\n            attributes.offset = OffsetGeometryInstanceAttribute.fromCartesian3(Property.getValueOrDefault(this._terrainOffsetProperty, time, defaultOffset, offsetScratch));\n        }\n\n        return new GeometryInstance({\n            id : entity,\n            geometry : BoxGeometry.fromDimensions(this._options),\n            modelMatrix : entity.computeModelMatrixForHeightReference(time, entity.box.heightReference, this._options.dimensions.z * 0.5, this._scene.mapProjection.ellipsoid),\n            attributes : attributes\n        });\n    };\n\n    /**\n     * Creates the geometry instance which represents the outline of the geometry.\n     *\n     * @param {JulianDate} time The time to use when retrieving initial attribute values.\n     * @returns {GeometryInstance} The geometry instance representing the outline portion of the geometry.\n     *\n     * @exception {DeveloperError} This instance does not represent an outlined geometry.\n     */\n    BoxGeometryUpdater.prototype.createOutlineGeometryInstance = function(time) {\n        \n\n        var entity = this._entity;\n        var isAvailable = entity.isAvailable(time);\n        var outlineColor = Property.getValueOrDefault(this._outlineColorProperty, time, Color.BLACK, scratchColor);\n        var distanceDisplayCondition = this._distanceDisplayConditionProperty.getValue(time);\n\n        var attributes = {\n            show : new ShowGeometryInstanceAttribute(isAvailable && entity.isShowing && this._showProperty.getValue(time) && this._showOutlineProperty.getValue(time)),\n            color : ColorGeometryInstanceAttribute.fromColor(outlineColor),\n            distanceDisplayCondition : DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(distanceDisplayCondition),\n            offset : undefined\n        };\n        if (defined(this._options.offsetAttribute)) {\n            attributes.offset = OffsetGeometryInstanceAttribute.fromCartesian3(Property.getValueOrDefault(this._terrainOffsetProperty, time, defaultOffset, offsetScratch));\n        }\n\n        return new GeometryInstance({\n            id : entity,\n            geometry : BoxOutlineGeometry.fromDimensions(this._options),\n            modelMatrix : entity.computeModelMatrixForHeightReference(time, entity.box.heightReference, this._options.dimensions.z * 0.5, this._scene.mapProjection.ellipsoid),\n            attributes : attributes\n        });\n    };\n\n    BoxGeometryUpdater.prototype._computeCenter = function(time, result) {\n        return Property.getValueOrUndefined(this._entity.position, time, result);\n    };\n\n    BoxGeometryUpdater.prototype._isHidden = function(entity, box) {\n        return !defined(box.dimensions) || !defined(entity.position) || GeometryUpdater.prototype._isHidden.call(this, entity, box);\n    };\n\n    BoxGeometryUpdater.prototype._isDynamic = function(entity, box) {\n        return !entity.position.isConstant ||  !Property.isConstant(entity.orientation) ||  !box.dimensions.isConstant ||  !Property.isConstant(box.outlineWidth);\n    };\n\n    BoxGeometryUpdater.prototype._setStaticOptions = function(entity, box) {\n        var heightReference = Property.getValueOrDefault(box.heightReference, Iso8601.MINIMUM_VALUE, HeightReference.NONE);\n\n        var options = this._options;\n        options.vertexFormat = this._materialProperty instanceof ColorMaterialProperty ? PerInstanceColorAppearance.VERTEX_FORMAT : MaterialAppearance.MaterialSupport.TEXTURED.vertexFormat;\n        options.dimensions = box.dimensions.getValue(Iso8601.MINIMUM_VALUE, options.dimensions);\n        options.offsetAttribute = heightReference !== HeightReference.NONE ? GeometryOffsetAttribute.ALL : undefined;\n    };\n\n    BoxGeometryUpdater.prototype._onEntityPropertyChanged = heightReferenceOnEntityPropertyChanged;\n\n    BoxGeometryUpdater.DynamicGeometryUpdater = DynamicBoxGeometryUpdater;\n\n    /**\n     * @private\n     */\n    function DynamicBoxGeometryUpdater(geometryUpdater, primitives, groundPrimitives) {\n        DynamicGeometryUpdater.call(this, geometryUpdater, primitives, groundPrimitives);\n    }\n\n    if (defined(Object.create)) {\n        DynamicBoxGeometryUpdater.prototype = Object.create(DynamicGeometryUpdater.prototype);\n        DynamicBoxGeometryUpdater.prototype.constructor = DynamicBoxGeometryUpdater;\n    }\n\n    DynamicBoxGeometryUpdater.prototype._isHidden = function(entity, box, time) {\n        var position = Property.getValueOrUndefined(entity.position, time, positionScratch);\n        var dimensions = this._options.dimensions;\n        return !defined(position) || !defined(dimensions) || DynamicGeometryUpdater.prototype._isHidden.call(this, entity, box, time);\n    };\n\n    DynamicBoxGeometryUpdater.prototype._setOptions = function(entity, box, time) {\n        var heightReference = Property.getValueOrDefault(box.heightReference, time, HeightReference.NONE);\n        var options = this._options;\n        options.dimensions = Property.getValueOrUndefined(box.dimensions, time, options.dimensions);\n        options.offsetAttribute = heightReference !== HeightReference.NONE ? GeometryOffsetAttribute.ALL : undefined;\n    };\nexport default BoxGeometryUpdater;\n","import Cartesian3 from './Cartesian3.js';\nimport Cartographic from './Cartographic.js';\nimport defaultValue from './defaultValue.js';\nimport defined from './defined.js';\nimport DeveloperError from './DeveloperError.js';\nimport Ellipsoid from './Ellipsoid.js';\nimport EllipsoidGeodesic from './EllipsoidGeodesic.js';\nimport EllipsoidRhumbLine from './EllipsoidRhumbLine.js';\nimport IntersectionTests from './IntersectionTests.js';\nimport isArray from './isArray.js';\nimport CesiumMath from './Math.js';\nimport Matrix4 from './Matrix4.js';\nimport Plane from './Plane.js';\n\n    /**\n     * @private\n     */\n    var PolylinePipeline = {};\n\n    PolylinePipeline.numberOfPoints = function(p0, p1, minDistance) {\n        var distance = Cartesian3.distance(p0, p1);\n        return Math.ceil(distance / minDistance);\n    };\n\n    PolylinePipeline.numberOfPointsRhumbLine = function(p0, p1, granularity) {\n        var radiansDistanceSquared = Math.pow((p0.longitude - p1.longitude), 2) + Math.pow((p0.latitude - p1.latitude), 2);\n        return Math.ceil(Math.sqrt(radiansDistanceSquared / (granularity * granularity)));\n    };\n\n    var cartoScratch = new Cartographic();\n    PolylinePipeline.extractHeights = function(positions, ellipsoid) {\n        var length = positions.length;\n        var heights = new Array(length);\n        for (var i = 0; i < length; i++) {\n            var p = positions[i];\n            heights[i] = ellipsoid.cartesianToCartographic(p, cartoScratch).height;\n        }\n        return heights;\n    };\n\n    var wrapLongitudeInversMatrix = new Matrix4();\n    var wrapLongitudeOrigin = new Cartesian3();\n    var wrapLongitudeXZNormal = new Cartesian3();\n    var wrapLongitudeXZPlane = new Plane(Cartesian3.UNIT_X, 0.0);\n    var wrapLongitudeYZNormal = new Cartesian3();\n    var wrapLongitudeYZPlane = new Plane(Cartesian3.UNIT_X, 0.0);\n    var wrapLongitudeIntersection = new Cartesian3();\n    var wrapLongitudeOffset = new Cartesian3();\n\n    var subdivideHeightsScratchArray = [];\n\n    function subdivideHeights(numPoints, h0, h1) {\n        var heights = subdivideHeightsScratchArray;\n        heights.length = numPoints;\n\n        var i;\n        if (h0 === h1) {\n            for (i = 0; i < numPoints; i++) {\n                heights[i] = h0;\n            }\n            return heights;\n        }\n\n        var dHeight = h1 - h0;\n        var heightPerVertex = dHeight / numPoints;\n\n        for (i = 0; i < numPoints; i++) {\n            var h = h0 + i*heightPerVertex;\n            heights[i] = h;\n        }\n\n        return heights;\n    }\n\n    var carto1 = new Cartographic();\n    var carto2 = new Cartographic();\n    var cartesian = new Cartesian3();\n    var scaleFirst = new Cartesian3();\n    var scaleLast = new Cartesian3();\n    var ellipsoidGeodesic = new EllipsoidGeodesic();\n    var ellipsoidRhumb = new EllipsoidRhumbLine();\n\n    //Returns subdivided line scaled to ellipsoid surface starting at p1 and ending at p2.\n    //Result includes p1, but not include p2.  This function is called for a sequence of line segments,\n    //and this prevents duplication of end point.\n    function generateCartesianArc(p0, p1, minDistance, ellipsoid, h0, h1, array, offset) {\n        var first = ellipsoid.scaleToGeodeticSurface(p0, scaleFirst);\n        var last = ellipsoid.scaleToGeodeticSurface(p1, scaleLast);\n        var numPoints = PolylinePipeline.numberOfPoints(p0, p1, minDistance);\n        var start = ellipsoid.cartesianToCartographic(first, carto1);\n        var end = ellipsoid.cartesianToCartographic(last, carto2);\n        var heights = subdivideHeights(numPoints, h0, h1);\n\n        ellipsoidGeodesic.setEndPoints(start, end);\n        var surfaceDistanceBetweenPoints = ellipsoidGeodesic.surfaceDistance / numPoints;\n\n        var index = offset;\n        start.height = h0;\n        var cart = ellipsoid.cartographicToCartesian(start, cartesian);\n        Cartesian3.pack(cart, array, index);\n        index += 3;\n\n        for (var i = 1; i < numPoints; i++) {\n            var carto = ellipsoidGeodesic.interpolateUsingSurfaceDistance(i * surfaceDistanceBetweenPoints, carto2);\n            carto.height = heights[i];\n            cart = ellipsoid.cartographicToCartesian(carto, cartesian);\n            Cartesian3.pack(cart, array, index);\n            index += 3;\n        }\n\n        return index;\n    }\n\n    //Returns subdivided line scaled to ellipsoid surface starting at p1 and ending at p2.\n    //Result includes p1, but not include p2.  This function is called for a sequence of line segments,\n    //and this prevents duplication of end point.\n    function generateCartesianRhumbArc(p0, p1, granularity, ellipsoid, h0, h1, array, offset) {\n        var first = ellipsoid.scaleToGeodeticSurface(p0, scaleFirst);\n        var last = ellipsoid.scaleToGeodeticSurface(p1, scaleLast);\n        var start = ellipsoid.cartesianToCartographic(first, carto1);\n        var end = ellipsoid.cartesianToCartographic(last, carto2);\n\n        var numPoints = PolylinePipeline.numberOfPointsRhumbLine(start, end, granularity);\n        var heights = subdivideHeights(numPoints, h0, h1);\n\n        if (!ellipsoidRhumb.ellipsoid.equals(ellipsoid)) {\n            ellipsoidRhumb = new EllipsoidRhumbLine(undefined, undefined, ellipsoid);\n        }\n        ellipsoidRhumb.setEndPoints(start, end);\n        var surfaceDistanceBetweenPoints = ellipsoidRhumb.surfaceDistance / numPoints;\n\n        var index = offset;\n        start.height = h0;\n        var cart = ellipsoid.cartographicToCartesian(start, cartesian);\n        Cartesian3.pack(cart, array, index);\n        index += 3;\n\n        for (var i = 1; i < numPoints; i++) {\n            var carto = ellipsoidRhumb.interpolateUsingSurfaceDistance(i * surfaceDistanceBetweenPoints, carto2);\n            carto.height = heights[i];\n            cart = ellipsoid.cartographicToCartesian(carto, cartesian);\n            Cartesian3.pack(cart, array, index);\n            index += 3;\n        }\n\n        return index;\n    }\n\n    /**\n     * Breaks a {@link Polyline} into segments such that it does not cross the &plusmn;180 degree meridian of an ellipsoid.\n     *\n     * @param {Cartesian3[]} positions The polyline's Cartesian positions.\n     * @param {Matrix4} [modelMatrix=Matrix4.IDENTITY] The polyline's model matrix. Assumed to be an affine\n     * transformation matrix, where the upper left 3x3 elements are a rotation matrix, and\n     * the upper three elements in the fourth column are the translation.  The bottom row is assumed to be [0, 0, 0, 1].\n     * The matrix is not verified to be in the proper form.\n     * @returns {Object} An object with a <code>positions</code> property that is an array of positions and a\n     * <code>segments</code> property.\n     *\n     *\n     * @example\n     * var polylines = new Cesium.PolylineCollection();\n     * var polyline = polylines.add(...);\n     * var positions = polyline.positions;\n     * var modelMatrix = polylines.modelMatrix;\n     * var segments = Cesium.PolylinePipeline.wrapLongitude(positions, modelMatrix);\n     *\n     * @see PolygonPipeline.wrapLongitude\n     * @see Polyline\n     * @see PolylineCollection\n     */\n    PolylinePipeline.wrapLongitude = function(positions, modelMatrix) {\n        var cartesians = [];\n        var segments = [];\n\n        if (defined(positions) && positions.length > 0) {\n            modelMatrix = defaultValue(modelMatrix, Matrix4.IDENTITY);\n            var inverseModelMatrix = Matrix4.inverseTransformation(modelMatrix, wrapLongitudeInversMatrix);\n\n            var origin = Matrix4.multiplyByPoint(inverseModelMatrix, Cartesian3.ZERO, wrapLongitudeOrigin);\n            var xzNormal = Cartesian3.normalize(Matrix4.multiplyByPointAsVector(inverseModelMatrix, Cartesian3.UNIT_Y, wrapLongitudeXZNormal), wrapLongitudeXZNormal);\n            var xzPlane = Plane.fromPointNormal(origin, xzNormal, wrapLongitudeXZPlane);\n            var yzNormal = Cartesian3.normalize(Matrix4.multiplyByPointAsVector(inverseModelMatrix, Cartesian3.UNIT_X, wrapLongitudeYZNormal), wrapLongitudeYZNormal);\n            var yzPlane = Plane.fromPointNormal(origin, yzNormal, wrapLongitudeYZPlane);\n\n            var count = 1;\n            cartesians.push(Cartesian3.clone(positions[0]));\n            var prev = cartesians[0];\n\n            var length = positions.length;\n            for (var i = 1; i < length; ++i) {\n                var cur = positions[i];\n\n                // intersects the IDL if either endpoint is on the negative side of the yz-plane\n                if (Plane.getPointDistance(yzPlane, prev) < 0.0 || Plane.getPointDistance(yzPlane, cur) < 0.0) {\n                    // and intersects the xz-plane\n                    var intersection = IntersectionTests.lineSegmentPlane(prev, cur, xzPlane, wrapLongitudeIntersection);\n                    if (defined(intersection)) {\n                        // move point on the xz-plane slightly away from the plane\n                        var offset = Cartesian3.multiplyByScalar(xzNormal, 5.0e-9, wrapLongitudeOffset);\n                        if (Plane.getPointDistance(xzPlane, prev) < 0.0) {\n                            Cartesian3.negate(offset, offset);\n                        }\n\n                        cartesians.push(Cartesian3.add(intersection, offset, new Cartesian3()));\n                        segments.push(count + 1);\n\n                        Cartesian3.negate(offset, offset);\n                        cartesians.push(Cartesian3.add(intersection, offset, new Cartesian3()));\n                        count = 1;\n                    }\n                }\n\n                cartesians.push(Cartesian3.clone(positions[i]));\n                count++;\n\n                prev = cur;\n            }\n\n            segments.push(count);\n        }\n\n        return {\n            positions : cartesians,\n            lengths : segments\n        };\n    };\n\n    /**\n     * Subdivides polyline and raises all points to the specified height.  Returns an array of numbers to represent the positions.\n     * @param {Object} options Object with the following properties:\n     * @param {Cartesian3[]} options.positions The array of type {Cartesian3} representing positions.\n     * @param {Number|Number[]} [options.height=0.0] A number or array of numbers representing the heights of each position.\n     * @param {Number} [options.granularity = CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n     * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the positions lie.\n     * @returns {Number[]} A new array of positions of type {Number} that have been subdivided and raised to the surface of the ellipsoid.\n     *\n     * @example\n     * var positions = Cesium.Cartesian3.fromDegreesArray([\n     *   -105.0, 40.0,\n     *   -100.0, 38.0,\n     *   -105.0, 35.0,\n     *   -100.0, 32.0\n     * ]);\n     * var surfacePositions = Cesium.PolylinePipeline.generateArc({\n     *   positons: positions\n     * });\n     */\n    PolylinePipeline.generateArc = function(options) {\n        if (!defined(options)) {\n            options = {};\n        }\n        var positions = options.positions;\n        \n\n        var length = positions.length;\n        var ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\n        var height = defaultValue(options.height, 0);\n        var hasHeightArray = isArray(height);\n\n        if (length < 1) {\n            return [];\n        } else if (length === 1) {\n            var p = ellipsoid.scaleToGeodeticSurface(positions[0], scaleFirst);\n            height = hasHeightArray ? height[0] : height;\n            if (height !== 0) {\n                var n = ellipsoid.geodeticSurfaceNormal(p, cartesian);\n                Cartesian3.multiplyByScalar(n, height, n);\n                Cartesian3.add(p, n, p);\n            }\n\n            return [p.x, p.y, p.z];\n        }\n\n        var minDistance = options.minDistance;\n        if (!defined(minDistance)) {\n            var granularity = defaultValue(options.granularity, CesiumMath.RADIANS_PER_DEGREE);\n            minDistance = CesiumMath.chordLength(granularity, ellipsoid.maximumRadius);\n        }\n\n        var numPoints = 0;\n        var i;\n\n        for (i = 0; i < length -1; i++) {\n            numPoints += PolylinePipeline.numberOfPoints(positions[i], positions[i+1], minDistance);\n        }\n\n        var arrayLength = (numPoints + 1) * 3;\n        var newPositions = new Array(arrayLength);\n        var offset = 0;\n\n        for (i = 0; i < length - 1; i++) {\n            var p0 = positions[i];\n            var p1 = positions[i + 1];\n\n            var h0 = hasHeightArray ? height[i] : height;\n            var h1 = hasHeightArray ? height[i + 1] : height;\n\n            offset = generateCartesianArc(p0, p1, minDistance, ellipsoid, h0, h1, newPositions, offset);\n        }\n\n        subdivideHeightsScratchArray.length = 0;\n\n        var lastPoint = positions[length - 1];\n        var carto = ellipsoid.cartesianToCartographic(lastPoint, carto1);\n        carto.height = hasHeightArray ? height[length - 1] : height;\n        var cart = ellipsoid.cartographicToCartesian(carto, cartesian);\n        Cartesian3.pack(cart, newPositions, arrayLength - 3);\n\n        return newPositions;\n    };\n\n    var scratchCartographic0 = new Cartographic();\n    var scratchCartographic1 = new Cartographic();\n\n    /**\n     * Subdivides polyline and raises all points to the specified height using Rhumb lines.  Returns an array of numbers to represent the positions.\n     * @param {Object} options Object with the following properties:\n     * @param {Cartesian3[]} options.positions The array of type {Cartesian3} representing positions.\n     * @param {Number|Number[]} [options.height=0.0] A number or array of numbers representing the heights of each position.\n     * @param {Number} [options.granularity = CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n     * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the positions lie.\n     * @returns {Number[]} A new array of positions of type {Number} that have been subdivided and raised to the surface of the ellipsoid.\n     *\n     * @example\n     * var positions = Cesium.Cartesian3.fromDegreesArray([\n     *   -105.0, 40.0,\n     *   -100.0, 38.0,\n     *   -105.0, 35.0,\n     *   -100.0, 32.0\n     * ]);\n     * var surfacePositions = Cesium.PolylinePipeline.generateRhumbArc({\n     *   positons: positions\n     * });\n     */\n    PolylinePipeline.generateRhumbArc = function(options) {\n        if (!defined(options)) {\n            options = {};\n        }\n        var positions = options.positions;\n        \n\n        var length = positions.length;\n        var ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\n        var height = defaultValue(options.height, 0);\n        var hasHeightArray = isArray(height);\n\n        if (length < 1) {\n            return [];\n        } else if (length === 1) {\n            var p = ellipsoid.scaleToGeodeticSurface(positions[0], scaleFirst);\n            height = hasHeightArray ? height[0] : height;\n            if (height !== 0) {\n                var n = ellipsoid.geodeticSurfaceNormal(p, cartesian);\n                Cartesian3.multiplyByScalar(n, height, n);\n                Cartesian3.add(p, n, p);\n            }\n\n            return [p.x, p.y, p.z];\n        }\n\n        var granularity = defaultValue(options.granularity, CesiumMath.RADIANS_PER_DEGREE);\n\n        var numPoints = 0;\n        var i;\n\n        var c0 = ellipsoid.cartesianToCartographic(positions[0], scratchCartographic0);\n        var c1;\n        for (i = 0; i < length - 1; i++) {\n            c1 = ellipsoid.cartesianToCartographic(positions[i + 1], scratchCartographic1);\n            numPoints += PolylinePipeline.numberOfPointsRhumbLine(c0, c1, granularity);\n            c0 = Cartographic.clone(c1, scratchCartographic0);\n        }\n\n        var arrayLength = (numPoints + 1) * 3;\n        var newPositions = new Array(arrayLength);\n        var offset = 0;\n\n        for (i = 0; i < length - 1; i++) {\n            var p0 = positions[i];\n            var p1 = positions[i + 1];\n\n            var h0 = hasHeightArray ? height[i] : height;\n            var h1 = hasHeightArray ? height[i + 1] : height;\n\n            offset = generateCartesianRhumbArc(p0, p1, granularity, ellipsoid, h0, h1, newPositions, offset);\n        }\n\n        subdivideHeightsScratchArray.length = 0;\n\n        var lastPoint = positions[length - 1];\n        var carto = ellipsoid.cartesianToCartographic(lastPoint, carto1);\n        carto.height = hasHeightArray ? height[length - 1] : height;\n        var cart = ellipsoid.cartographicToCartesian(carto, cartesian);\n        Cartesian3.pack(cart, newPositions, arrayLength - 3);\n\n        return newPositions;\n    };\n\n    /**\n     * Subdivides polyline and raises all points to the specified height. Returns an array of new {Cartesian3} positions.\n     * @param {Object} options Object with the following properties:\n     * @param {Cartesian3[]} options.positions The array of type {Cartesian3} representing positions.\n     * @param {Number|Number[]} [options.height=0.0] A number or array of numbers representing the heights of each position.\n     * @param {Number} [options.granularity = CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n     * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the positions lie.\n     * @returns {Cartesian3[]} A new array of cartesian3 positions that have been subdivided and raised to the surface of the ellipsoid.\n     *\n     * @example\n     * var positions = Cesium.Cartesian3.fromDegreesArray([\n     *   -105.0, 40.0,\n     *   -100.0, 38.0,\n     *   -105.0, 35.0,\n     *   -100.0, 32.0\n     * ]);\n     * var surfacePositions = Cesium.PolylinePipeline.generateCartesianArc({\n     *   positons: positions\n     * });\n     */\n    PolylinePipeline.generateCartesianArc = function(options) {\n        var numberArray = PolylinePipeline.generateArc(options);\n        var size = numberArray.length/3;\n        var newPositions = new Array(size);\n        for (var i = 0; i < size; i++) {\n            newPositions[i] = Cartesian3.unpack(numberArray, i*3);\n        }\n        return newPositions;\n    };\n\n    /**\n     * Subdivides polyline and raises all points to the specified height using Rhumb Lines. Returns an array of new {Cartesian3} positions.\n     * @param {Object} options Object with the following properties:\n     * @param {Cartesian3[]} options.positions The array of type {Cartesian3} representing positions.\n     * @param {Number|Number[]} [options.height=0.0] A number or array of numbers representing the heights of each position.\n     * @param {Number} [options.granularity = CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n     * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the positions lie.\n     * @returns {Cartesian3[]} A new array of cartesian3 positions that have been subdivided and raised to the surface of the ellipsoid.\n     *\n     * @example\n     * var positions = Cesium.Cartesian3.fromDegreesArray([\n     *   -105.0, 40.0,\n     *   -100.0, 38.0,\n     *   -105.0, 35.0,\n     *   -100.0, 32.0\n     * ]);\n     * var surfacePositions = Cesium.PolylinePipeline.generateCartesianRhumbArc({\n     *   positons: positions\n     * });\n     */\n    PolylinePipeline.generateCartesianRhumbArc = function(options) {\n        var numberArray = PolylinePipeline.generateRhumbArc(options);\n        var size = numberArray.length/3;\n        var newPositions = new Array(size);\n        for (var i = 0; i < size; i++) {\n            newPositions[i] = Cartesian3.unpack(numberArray, i*3);\n        }\n        return newPositions;\n    };\nexport default PolylinePipeline;\n","import Cartesian2 from './Cartesian2.js';\nimport Cartesian3 from './Cartesian3.js';\nimport Cartesian4 from './Cartesian4.js';\nimport Cartographic from './Cartographic.js';\nimport CornerType from './CornerType.js';\nimport EllipsoidTangentPlane from './EllipsoidTangentPlane.js';\nimport CesiumMath from './Math.js';\nimport Matrix3 from './Matrix3.js';\nimport Matrix4 from './Matrix4.js';\nimport PolylinePipeline from './PolylinePipeline.js';\nimport Quaternion from './Quaternion.js';\nimport Transforms from './Transforms.js';\n\n    var scratch2Array = [new Cartesian3(), new Cartesian3()];\n    var scratchCartesian1 = new Cartesian3();\n    var scratchCartesian2 = new Cartesian3();\n    var scratchCartesian3 = new Cartesian3();\n    var scratchCartesian4 = new Cartesian3();\n    var scratchCartesian5 = new Cartesian3();\n    var scratchCartesian6 = new Cartesian3();\n    var scratchCartesian7 = new Cartesian3();\n    var scratchCartesian8 = new Cartesian3();\n    var scratchCartesian9 = new Cartesian3();\n\n    var scratch1 = new Cartesian3();\n    var scratch2 = new Cartesian3();\n\n    /**\n     * @private\n     */\n    var PolylineVolumeGeometryLibrary = {};\n\n    var cartographic = new Cartographic();\n    function scaleToSurface(positions, ellipsoid) {\n        var heights = new Array(positions.length);\n        for (var i = 0; i < positions.length; i++) {\n            var pos = positions[i];\n            cartographic = ellipsoid.cartesianToCartographic(pos, cartographic);\n            heights[i] = cartographic.height;\n            positions[i] = ellipsoid.scaleToGeodeticSurface(pos, pos);\n        }\n        return heights;\n    }\n\n    function subdivideHeights(points, h0, h1, granularity) {\n        var p0 = points[0];\n        var p1 = points[1];\n        var angleBetween = Cartesian3.angleBetween(p0, p1);\n        var numPoints = Math.ceil(angleBetween / granularity);\n        var heights = new Array(numPoints);\n        var i;\n        if (h0 === h1) {\n            for (i = 0; i < numPoints; i++) {\n                heights[i] = h0;\n            }\n            heights.push(h1);\n            return heights;\n        }\n\n        var dHeight = h1 - h0;\n        var heightPerVertex = dHeight / (numPoints);\n\n        for (i = 1; i < numPoints; i++) {\n            var h = h0 + i * heightPerVertex;\n            heights[i] = h;\n        }\n\n        heights[0] = h0;\n        heights.push(h1);\n        return heights;\n    }\n\n    var nextScratch = new Cartesian3();\n    var prevScratch = new Cartesian3();\n\n    function computeRotationAngle(start, end, position, ellipsoid) {\n        var tangentPlane = new EllipsoidTangentPlane(position, ellipsoid);\n        var next = tangentPlane.projectPointOntoPlane(Cartesian3.add(position, start, nextScratch), nextScratch);\n        var prev = tangentPlane.projectPointOntoPlane(Cartesian3.add(position, end, prevScratch), prevScratch);\n        var angle = Cartesian2.angleBetween(next, prev);\n\n        return (prev.x * next.y - prev.y * next.x >= 0.0) ? -angle : angle;\n    }\n\n    var negativeX = new Cartesian3(-1, 0, 0);\n    var transform = new Matrix4();\n    var translation = new Matrix4();\n    var rotationZ = new Matrix3();\n    var scaleMatrix = Matrix3.IDENTITY.clone();\n    var westScratch = new Cartesian3();\n    var finalPosScratch = new Cartesian4();\n    var heightCartesian = new Cartesian3();\n    function addPosition(center, left, shape, finalPositions, ellipsoid, height, xScalar, repeat) {\n        var west = westScratch;\n        var finalPosition = finalPosScratch;\n        transform = Transforms.eastNorthUpToFixedFrame(center, ellipsoid, transform);\n\n        west = Matrix4.multiplyByPointAsVector(transform, negativeX, west);\n        west = Cartesian3.normalize(west, west);\n        var angle = computeRotationAngle(west, left, center, ellipsoid);\n        rotationZ = Matrix3.fromRotationZ(angle, rotationZ);\n\n        heightCartesian.z = height;\n        transform = Matrix4.multiplyTransformation(transform, Matrix4.fromRotationTranslation(rotationZ, heightCartesian, translation), transform);\n        var scale = scaleMatrix;\n        scale[0] = xScalar;\n\n        for (var j = 0; j < repeat; j++) {\n            for (var i = 0; i < shape.length; i += 3) {\n                finalPosition = Cartesian3.fromArray(shape, i, finalPosition);\n                finalPosition = Matrix3.multiplyByVector(scale, finalPosition, finalPosition);\n                finalPosition = Matrix4.multiplyByPoint(transform, finalPosition, finalPosition);\n                finalPositions.push(finalPosition.x, finalPosition.y, finalPosition.z);\n            }\n        }\n\n        return finalPositions;\n    }\n\n    var centerScratch = new Cartesian3();\n    function addPositions(centers, left, shape, finalPositions, ellipsoid, heights, xScalar) {\n        for (var i = 0; i < centers.length; i += 3) {\n            var center = Cartesian3.fromArray(centers, i, centerScratch);\n            finalPositions = addPosition(center, left, shape, finalPositions, ellipsoid, heights[i / 3], xScalar, 1);\n        }\n        return finalPositions;\n    }\n\n    function convertShapeTo3DDuplicate(shape2D, boundingRectangle) { //orientate 2D shape to XZ plane center at (0, 0, 0), duplicate points\n        var length = shape2D.length;\n        var shape = new Array(length * 6);\n        var index = 0;\n        var xOffset = boundingRectangle.x + boundingRectangle.width / 2;\n        var yOffset = boundingRectangle.y + boundingRectangle.height / 2;\n\n        var point = shape2D[0];\n        shape[index++] = point.x - xOffset;\n        shape[index++] = 0.0;\n        shape[index++] = point.y - yOffset;\n        for (var i = 1; i < length; i++) {\n            point = shape2D[i];\n            var x = point.x - xOffset;\n            var z = point.y - yOffset;\n            shape[index++] = x;\n            shape[index++] = 0.0;\n            shape[index++] = z;\n\n            shape[index++] = x;\n            shape[index++] = 0.0;\n            shape[index++] = z;\n        }\n        point = shape2D[0];\n        shape[index++] = point.x - xOffset;\n        shape[index++] = 0.0;\n        shape[index++] = point.y - yOffset;\n\n        return shape;\n    }\n\n    function convertShapeTo3D(shape2D, boundingRectangle) { //orientate 2D shape to XZ plane center at (0, 0, 0)\n        var length = shape2D.length;\n        var shape = new Array(length * 3);\n        var index = 0;\n        var xOffset = boundingRectangle.x + boundingRectangle.width / 2;\n        var yOffset = boundingRectangle.y + boundingRectangle.height / 2;\n\n        for (var i = 0; i < length; i++) {\n            shape[index++] = shape2D[i].x - xOffset;\n            shape[index++] = 0;\n            shape[index++] = shape2D[i].y - yOffset;\n        }\n\n        return shape;\n    }\n\n    var quaterion = new Quaternion();\n    var startPointScratch = new Cartesian3();\n    var rotMatrix = new Matrix3();\n    function computeRoundCorner(pivot, startPoint, endPoint, cornerType, leftIsOutside, ellipsoid, finalPositions, shape, height, duplicatePoints) {\n        var angle = Cartesian3.angleBetween(Cartesian3.subtract(startPoint, pivot, scratch1), Cartesian3.subtract(endPoint, pivot, scratch2));\n        var granularity = (cornerType === CornerType.BEVELED) ? 0 : Math.ceil(angle / CesiumMath.toRadians(5));\n\n        var m;\n        if (leftIsOutside) {\n            m = Matrix3.fromQuaternion(Quaternion.fromAxisAngle(Cartesian3.negate(pivot, scratch1), angle / (granularity + 1), quaterion), rotMatrix);\n        } else {\n            m = Matrix3.fromQuaternion(Quaternion.fromAxisAngle(pivot, angle / (granularity + 1), quaterion), rotMatrix);\n        }\n\n        var left;\n        var surfacePoint;\n        startPoint = Cartesian3.clone(startPoint, startPointScratch);\n        if (granularity > 0) {\n            var repeat = duplicatePoints ? 2 : 1;\n            for (var i = 0; i < granularity; i++) {\n                startPoint = Matrix3.multiplyByVector(m, startPoint, startPoint);\n                left = Cartesian3.subtract(startPoint, pivot, scratch1);\n                left = Cartesian3.normalize(left, left);\n                if (!leftIsOutside) {\n                    left = Cartesian3.negate(left, left);\n                }\n                surfacePoint = ellipsoid.scaleToGeodeticSurface(startPoint, scratch2);\n                finalPositions = addPosition(surfacePoint, left, shape, finalPositions, ellipsoid, height, 1, repeat);\n            }\n        } else {\n            left = Cartesian3.subtract(startPoint, pivot, scratch1);\n            left = Cartesian3.normalize(left, left);\n            if (!leftIsOutside) {\n                left = Cartesian3.negate(left, left);\n            }\n            surfacePoint = ellipsoid.scaleToGeodeticSurface(startPoint, scratch2);\n            finalPositions = addPosition(surfacePoint, left, shape, finalPositions, ellipsoid, height, 1, 1);\n\n            endPoint = Cartesian3.clone(endPoint, startPointScratch);\n            left = Cartesian3.subtract(endPoint, pivot, scratch1);\n            left = Cartesian3.normalize(left, left);\n            if (!leftIsOutside) {\n                left = Cartesian3.negate(left, left);\n            }\n            surfacePoint = ellipsoid.scaleToGeodeticSurface(endPoint, scratch2);\n            finalPositions = addPosition(surfacePoint, left, shape, finalPositions, ellipsoid, height, 1, 1);\n        }\n\n        return finalPositions;\n    }\n\n    PolylineVolumeGeometryLibrary.removeDuplicatesFromShape = function(shapePositions) {\n        var length = shapePositions.length;\n        var cleanedPositions = [];\n        for (var i0 = length - 1, i1 = 0; i1 < length; i0 = i1++) {\n            var v0 = shapePositions[i0];\n            var v1 = shapePositions[i1];\n\n            if (!Cartesian2.equals(v0, v1)) {\n                cleanedPositions.push(v1); // Shallow copy!\n            }\n        }\n\n        return cleanedPositions;\n    };\n\n    PolylineVolumeGeometryLibrary.angleIsGreaterThanPi = function(forward, backward, position, ellipsoid) {\n        var tangentPlane = new EllipsoidTangentPlane(position, ellipsoid);\n        var next = tangentPlane.projectPointOntoPlane(Cartesian3.add(position, forward, nextScratch), nextScratch);\n        var prev = tangentPlane.projectPointOntoPlane(Cartesian3.add(position, backward, prevScratch), prevScratch);\n\n        return ((prev.x * next.y) - (prev.y * next.x)) >= 0.0;\n    };\n\n    var scratchForwardProjection = new Cartesian3();\n    var scratchBackwardProjection = new Cartesian3();\n\n    PolylineVolumeGeometryLibrary.computePositions = function(positions, shape2D, boundingRectangle, geometry, duplicatePoints) {\n        var ellipsoid = geometry._ellipsoid;\n        var heights = scaleToSurface(positions, ellipsoid);\n        var granularity = geometry._granularity;\n        var cornerType = geometry._cornerType;\n        var shapeForSides = duplicatePoints ? convertShapeTo3DDuplicate(shape2D, boundingRectangle) : convertShapeTo3D(shape2D, boundingRectangle);\n        var shapeForEnds = duplicatePoints ? convertShapeTo3D(shape2D, boundingRectangle) : undefined;\n        var heightOffset = boundingRectangle.height / 2;\n        var width = boundingRectangle.width / 2;\n        var length = positions.length;\n        var finalPositions = [];\n        var ends = duplicatePoints ? [] : undefined;\n\n        var forward = scratchCartesian1;\n        var backward = scratchCartesian2;\n        var cornerDirection = scratchCartesian3;\n        var surfaceNormal = scratchCartesian4;\n        var pivot = scratchCartesian5;\n        var start = scratchCartesian6;\n        var end = scratchCartesian7;\n        var left = scratchCartesian8;\n        var previousPosition = scratchCartesian9;\n\n        var position = positions[0];\n        var nextPosition = positions[1];\n        surfaceNormal = ellipsoid.geodeticSurfaceNormal(position, surfaceNormal);\n        forward = Cartesian3.subtract(nextPosition, position, forward);\n        forward = Cartesian3.normalize(forward, forward);\n        left = Cartesian3.cross(surfaceNormal, forward, left);\n        left = Cartesian3.normalize(left, left);\n        var h0 = heights[0];\n        var h1 = heights[1];\n        if (duplicatePoints) {\n            ends = addPosition(position, left, shapeForEnds, ends, ellipsoid, h0 + heightOffset, 1, 1);\n        }\n        previousPosition = Cartesian3.clone(position, previousPosition);\n        position = nextPosition;\n        backward = Cartesian3.negate(forward, backward);\n        var subdividedHeights;\n        var subdividedPositions;\n        for (var i = 1; i < length - 1; i++) {\n            var repeat = duplicatePoints ? 2 : 1;\n            nextPosition = positions[i + 1];\n            forward = Cartesian3.subtract(nextPosition, position, forward);\n            forward = Cartesian3.normalize(forward, forward);\n            cornerDirection = Cartesian3.add(forward, backward, cornerDirection);\n            cornerDirection = Cartesian3.normalize(cornerDirection, cornerDirection);\n            surfaceNormal = ellipsoid.geodeticSurfaceNormal(position, surfaceNormal);\n\n            var forwardProjection = Cartesian3.multiplyByScalar(surfaceNormal, Cartesian3.dot(forward, surfaceNormal), scratchForwardProjection);\n            Cartesian3.subtract(forward, forwardProjection, forwardProjection);\n            Cartesian3.normalize(forwardProjection, forwardProjection);\n\n            var backwardProjection = Cartesian3.multiplyByScalar(surfaceNormal, Cartesian3.dot(backward, surfaceNormal), scratchBackwardProjection);\n            Cartesian3.subtract(backward, backwardProjection, backwardProjection);\n            Cartesian3.normalize(backwardProjection, backwardProjection);\n\n            var doCorner = !CesiumMath.equalsEpsilon(Math.abs(Cartesian3.dot(forwardProjection, backwardProjection)), 1.0, CesiumMath.EPSILON7);\n\n            if (doCorner) {\n                cornerDirection = Cartesian3.cross(cornerDirection, surfaceNormal, cornerDirection);\n                cornerDirection = Cartesian3.cross(surfaceNormal, cornerDirection, cornerDirection);\n                cornerDirection = Cartesian3.normalize(cornerDirection, cornerDirection);\n                var scalar = 1 / Math.max(0.25, (Cartesian3.magnitude(Cartesian3.cross(cornerDirection, backward, scratch1))));\n                var leftIsOutside = PolylineVolumeGeometryLibrary.angleIsGreaterThanPi(forward, backward, position, ellipsoid);\n                if (leftIsOutside) {\n                    pivot = Cartesian3.add(position, Cartesian3.multiplyByScalar(cornerDirection, scalar * width, cornerDirection), pivot);\n                    start = Cartesian3.add(pivot, Cartesian3.multiplyByScalar(left, width, start), start);\n                    scratch2Array[0] = Cartesian3.clone(previousPosition, scratch2Array[0]);\n                    scratch2Array[1] = Cartesian3.clone(start, scratch2Array[1]);\n                    subdividedHeights = subdivideHeights(scratch2Array, h0 + heightOffset, h1 + heightOffset, granularity);\n                    subdividedPositions = PolylinePipeline.generateArc({\n                        positions: scratch2Array,\n                        granularity: granularity,\n                        ellipsoid: ellipsoid\n                    });\n                    finalPositions = addPositions(subdividedPositions, left, shapeForSides, finalPositions, ellipsoid, subdividedHeights, 1);\n                    left = Cartesian3.cross(surfaceNormal, forward, left);\n                    left = Cartesian3.normalize(left, left);\n                    end = Cartesian3.add(pivot, Cartesian3.multiplyByScalar(left, width, end), end);\n                    if (cornerType === CornerType.ROUNDED || cornerType === CornerType.BEVELED) {\n                        computeRoundCorner(pivot, start, end, cornerType, leftIsOutside, ellipsoid, finalPositions, shapeForSides, h1 + heightOffset, duplicatePoints);\n                    } else {\n                        cornerDirection = Cartesian3.negate(cornerDirection, cornerDirection);\n                        finalPositions = addPosition(position, cornerDirection, shapeForSides, finalPositions, ellipsoid, h1 + heightOffset, scalar, repeat);\n                    }\n                    previousPosition = Cartesian3.clone(end, previousPosition);\n                } else {\n                    pivot = Cartesian3.add(position, Cartesian3.multiplyByScalar(cornerDirection, scalar * width, cornerDirection), pivot);\n                    start = Cartesian3.add(pivot, Cartesian3.multiplyByScalar(left, -width, start), start);\n                    scratch2Array[0] = Cartesian3.clone(previousPosition, scratch2Array[0]);\n                    scratch2Array[1] = Cartesian3.clone(start, scratch2Array[1]);\n                    subdividedHeights = subdivideHeights(scratch2Array, h0 + heightOffset, h1 + heightOffset, granularity);\n                    subdividedPositions = PolylinePipeline.generateArc({\n                        positions: scratch2Array,\n                        granularity: granularity,\n                        ellipsoid: ellipsoid\n                    });\n                    finalPositions = addPositions(subdividedPositions, left, shapeForSides, finalPositions, ellipsoid, subdividedHeights, 1);\n                    left = Cartesian3.cross(surfaceNormal, forward, left);\n                    left = Cartesian3.normalize(left, left);\n                    end = Cartesian3.add(pivot, Cartesian3.multiplyByScalar(left, -width, end), end);\n                    if (cornerType === CornerType.ROUNDED || cornerType === CornerType.BEVELED) {\n                        computeRoundCorner(pivot, start, end, cornerType, leftIsOutside, ellipsoid, finalPositions, shapeForSides, h1 + heightOffset, duplicatePoints);\n                    } else {\n                        finalPositions = addPosition(position, cornerDirection, shapeForSides, finalPositions, ellipsoid, h1 + heightOffset, scalar, repeat);\n                    }\n                    previousPosition = Cartesian3.clone(end, previousPosition);\n                }\n                backward = Cartesian3.negate(forward, backward);\n            } else {\n                finalPositions = addPosition(previousPosition, left, shapeForSides, finalPositions, ellipsoid, h0 + heightOffset, 1, 1);\n                previousPosition = position;\n            }\n            h0 = h1;\n            h1 = heights[i + 1];\n            position = nextPosition;\n        }\n\n        scratch2Array[0] = Cartesian3.clone(previousPosition, scratch2Array[0]);\n        scratch2Array[1] = Cartesian3.clone(position, scratch2Array[1]);\n        subdividedHeights = subdivideHeights(scratch2Array, h0 + heightOffset, h1 + heightOffset, granularity);\n        subdividedPositions = PolylinePipeline.generateArc({\n            positions: scratch2Array,\n            granularity: granularity,\n            ellipsoid: ellipsoid\n        });\n        finalPositions = addPositions(subdividedPositions, left, shapeForSides, finalPositions, ellipsoid, subdividedHeights, 1);\n        if (duplicatePoints) {\n            ends = addPosition(position, left, shapeForEnds, ends, ellipsoid, h1 + heightOffset, 1, 1);\n        }\n\n        length = finalPositions.length;\n        var posLength = duplicatePoints ? length + ends.length : length;\n        var combinedPositions = new Float64Array(posLength);\n        combinedPositions.set(finalPositions);\n        if (duplicatePoints) {\n            combinedPositions.set(ends, length);\n        }\n\n        return combinedPositions;\n    };\nexport default PolylineVolumeGeometryLibrary;\n","import Cartesian3 from './Cartesian3.js';\nimport CornerType from './CornerType.js';\nimport defined from './defined.js';\nimport CesiumMath from './Math.js';\nimport Matrix3 from './Matrix3.js';\nimport PolylinePipeline from './PolylinePipeline.js';\nimport PolylineVolumeGeometryLibrary from './PolylineVolumeGeometryLibrary.js';\nimport Quaternion from './Quaternion.js';\n\n    /**\n     * @private\n     */\n    var CorridorGeometryLibrary = {};\n\n    var scratch1 = new Cartesian3();\n    var scratch2 = new Cartesian3();\n    var scratch3 = new Cartesian3();\n    var scratch4 = new Cartesian3();\n\n    var scaleArray2 = [new Cartesian3(), new Cartesian3()];\n\n    var cartesian1 = new Cartesian3();\n    var cartesian2 = new Cartesian3();\n    var cartesian3 = new Cartesian3();\n    var cartesian4 = new Cartesian3();\n    var cartesian5 = new Cartesian3();\n    var cartesian6 = new Cartesian3();\n    var cartesian7 = new Cartesian3();\n    var cartesian8 = new Cartesian3();\n    var cartesian9 = new Cartesian3();\n    var cartesian10 = new Cartesian3();\n\n    var quaterion = new Quaternion();\n    var rotMatrix = new Matrix3();\n    function computeRoundCorner(cornerPoint, startPoint, endPoint, cornerType, leftIsOutside) {\n        var angle = Cartesian3.angleBetween(Cartesian3.subtract(startPoint, cornerPoint, scratch1), Cartesian3.subtract(endPoint, cornerPoint, scratch2));\n        var granularity = (cornerType === CornerType.BEVELED) ? 1 : Math.ceil(angle / CesiumMath.toRadians(5)) + 1;\n\n        var size = granularity * 3;\n        var array = new Array(size);\n\n        array[size - 3] = endPoint.x;\n        array[size - 2] = endPoint.y;\n        array[size - 1] = endPoint.z;\n\n        var m;\n        if (leftIsOutside) {\n            m = Matrix3.fromQuaternion(Quaternion.fromAxisAngle(Cartesian3.negate(cornerPoint, scratch1), angle / granularity, quaterion), rotMatrix);\n        } else {\n            m = Matrix3.fromQuaternion(Quaternion.fromAxisAngle(cornerPoint, angle / granularity, quaterion), rotMatrix);\n        }\n\n        var index = 0;\n        startPoint = Cartesian3.clone(startPoint, scratch1);\n        for (var i = 0; i < granularity; i++) {\n            startPoint = Matrix3.multiplyByVector(m, startPoint, startPoint);\n            array[index++] = startPoint.x;\n            array[index++] = startPoint.y;\n            array[index++] = startPoint.z;\n        }\n\n        return array;\n    }\n\n    function addEndCaps(calculatedPositions) {\n        var cornerPoint = cartesian1;\n        var startPoint = cartesian2;\n        var endPoint = cartesian3;\n\n        var leftEdge = calculatedPositions[1];\n        startPoint = Cartesian3.fromArray(calculatedPositions[1], leftEdge.length - 3, startPoint);\n        endPoint = Cartesian3.fromArray(calculatedPositions[0], 0, endPoint);\n        cornerPoint = Cartesian3.midpoint(startPoint, endPoint, cornerPoint);\n        var firstEndCap = computeRoundCorner(cornerPoint, startPoint, endPoint, CornerType.ROUNDED, false);\n\n        var length = calculatedPositions.length - 1;\n        var rightEdge = calculatedPositions[length - 1];\n        leftEdge = calculatedPositions[length];\n        startPoint = Cartesian3.fromArray(rightEdge, rightEdge.length - 3, startPoint);\n        endPoint = Cartesian3.fromArray(leftEdge, 0, endPoint);\n        cornerPoint = Cartesian3.midpoint(startPoint, endPoint, cornerPoint);\n        var lastEndCap = computeRoundCorner(cornerPoint, startPoint, endPoint, CornerType.ROUNDED, false);\n\n        return [firstEndCap, lastEndCap];\n    }\n\n    function computeMiteredCorner(position, leftCornerDirection, lastPoint, leftIsOutside) {\n        var cornerPoint = scratch1;\n        if (leftIsOutside) {\n            cornerPoint = Cartesian3.add(position, leftCornerDirection, cornerPoint);\n        } else {\n            leftCornerDirection = Cartesian3.negate(leftCornerDirection, leftCornerDirection);\n            cornerPoint = Cartesian3.add(position, leftCornerDirection, cornerPoint);\n        }\n        return [cornerPoint.x, cornerPoint.y, cornerPoint.z, lastPoint.x, lastPoint.y, lastPoint.z];\n    }\n\n    function addShiftedPositions(positions, left, scalar, calculatedPositions) {\n        var rightPositions = new Array(positions.length);\n        var leftPositions = new Array(positions.length);\n        var scaledLeft = Cartesian3.multiplyByScalar(left, scalar, scratch1);\n        var scaledRight = Cartesian3.negate(scaledLeft, scratch2);\n        var rightIndex = 0;\n        var leftIndex = positions.length - 1;\n\n        for (var i = 0; i < positions.length; i += 3) {\n            var pos = Cartesian3.fromArray(positions, i, scratch3);\n            var rightPos = Cartesian3.add(pos, scaledRight, scratch4);\n            rightPositions[rightIndex++] = rightPos.x;\n            rightPositions[rightIndex++] = rightPos.y;\n            rightPositions[rightIndex++] = rightPos.z;\n\n            var leftPos = Cartesian3.add(pos, scaledLeft, scratch4);\n            leftPositions[leftIndex--] = leftPos.z;\n            leftPositions[leftIndex--] = leftPos.y;\n            leftPositions[leftIndex--] = leftPos.x;\n        }\n        calculatedPositions.push(rightPositions, leftPositions);\n\n        return calculatedPositions;\n    }\n\n    /**\n     * @private\n     */\n    CorridorGeometryLibrary.addAttribute = function(attribute, value, front, back) {\n        var x = value.x;\n        var y = value.y;\n        var z = value.z;\n        if (defined(front)) {\n            attribute[front] = x;\n            attribute[front + 1] = y;\n            attribute[front + 2] = z;\n        }\n        if (defined(back)) {\n            attribute[back] = z;\n            attribute[back - 1] = y;\n            attribute[back - 2] = x;\n        }\n    };\n\n    var scratchForwardProjection = new Cartesian3();\n    var scratchBackwardProjection = new Cartesian3();\n\n    /**\n     * @private\n     */\n    CorridorGeometryLibrary.computePositions = function(params) {\n        var granularity = params.granularity;\n        var positions = params.positions;\n        var ellipsoid = params.ellipsoid;\n        var width = params.width / 2;\n        var cornerType = params.cornerType;\n        var saveAttributes = params.saveAttributes;\n        var normal = cartesian1;\n        var forward = cartesian2;\n        var backward = cartesian3;\n        var left = cartesian4;\n        var cornerDirection = cartesian5;\n        var startPoint = cartesian6;\n        var previousPos = cartesian7;\n        var rightPos = cartesian8;\n        var leftPos = cartesian9;\n        var center = cartesian10;\n        var calculatedPositions = [];\n        var calculatedLefts = (saveAttributes) ? [] : undefined;\n        var calculatedNormals = (saveAttributes) ? [] : undefined;\n        var position = positions[0]; //add first point\n        var nextPosition = positions[1];\n\n        forward = Cartesian3.normalize(Cartesian3.subtract(nextPosition, position, forward), forward);\n        normal = ellipsoid.geodeticSurfaceNormal(position, normal);\n        left = Cartesian3.normalize(Cartesian3.cross(normal, forward, left), left);\n        if (saveAttributes) {\n            calculatedLefts.push(left.x, left.y, left.z);\n            calculatedNormals.push(normal.x, normal.y, normal.z);\n        }\n        previousPos = Cartesian3.clone(position, previousPos);\n        position = nextPosition;\n        backward = Cartesian3.negate(forward, backward);\n\n        var subdividedPositions;\n        var corners = [];\n        var i;\n        var length = positions.length;\n        for (i = 1; i < length - 1; i++) { // add middle points and corners\n            normal = ellipsoid.geodeticSurfaceNormal(position, normal);\n            nextPosition = positions[i + 1];\n            forward = Cartesian3.normalize(Cartesian3.subtract(nextPosition, position, forward), forward);\n            cornerDirection = Cartesian3.normalize(Cartesian3.add(forward, backward, cornerDirection), cornerDirection);\n\n            var forwardProjection = Cartesian3.multiplyByScalar(normal, Cartesian3.dot(forward, normal), scratchForwardProjection);\n            Cartesian3.subtract(forward, forwardProjection, forwardProjection);\n            Cartesian3.normalize(forwardProjection, forwardProjection);\n\n            var backwardProjection = Cartesian3.multiplyByScalar(normal, Cartesian3.dot(backward, normal), scratchBackwardProjection);\n            Cartesian3.subtract(backward, backwardProjection, backwardProjection);\n            Cartesian3.normalize(backwardProjection, backwardProjection);\n\n            var doCorner = !CesiumMath.equalsEpsilon(Math.abs(Cartesian3.dot(forwardProjection, backwardProjection)), 1.0, CesiumMath.EPSILON7);\n\n            if (doCorner) {\n                cornerDirection = Cartesian3.cross(cornerDirection, normal, cornerDirection);\n                cornerDirection = Cartesian3.cross(normal, cornerDirection, cornerDirection);\n                cornerDirection = Cartesian3.normalize(cornerDirection, cornerDirection);\n                var scalar = width / Math.max(0.25, Cartesian3.magnitude(Cartesian3.cross(cornerDirection, backward, scratch1)));\n                var leftIsOutside = PolylineVolumeGeometryLibrary.angleIsGreaterThanPi(forward, backward, position, ellipsoid);\n                cornerDirection = Cartesian3.multiplyByScalar(cornerDirection, scalar, cornerDirection);\n                if (leftIsOutside) {\n                    rightPos = Cartesian3.add(position, cornerDirection, rightPos);\n                    center = Cartesian3.add(rightPos, Cartesian3.multiplyByScalar(left, width, center), center);\n                    leftPos = Cartesian3.add(rightPos, Cartesian3.multiplyByScalar(left, width * 2, leftPos), leftPos);\n                    scaleArray2[0] = Cartesian3.clone(previousPos, scaleArray2[0]);\n                    scaleArray2[1] = Cartesian3.clone(center, scaleArray2[1]);\n                    subdividedPositions = PolylinePipeline.generateArc({\n                        positions: scaleArray2,\n                        granularity: granularity,\n                        ellipsoid: ellipsoid\n                    });\n                    calculatedPositions = addShiftedPositions(subdividedPositions, left, width, calculatedPositions);\n                    if (saveAttributes) {\n                        calculatedLefts.push(left.x, left.y, left.z);\n                        calculatedNormals.push(normal.x, normal.y, normal.z);\n                    }\n                    startPoint = Cartesian3.clone(leftPos, startPoint);\n                    left = Cartesian3.normalize(Cartesian3.cross(normal, forward, left), left);\n                    leftPos = Cartesian3.add(rightPos, Cartesian3.multiplyByScalar(left, width * 2, leftPos), leftPos);\n                    previousPos = Cartesian3.add(rightPos, Cartesian3.multiplyByScalar(left, width, previousPos), previousPos);\n                    if (cornerType === CornerType.ROUNDED || cornerType === CornerType.BEVELED) {\n                        corners.push({\n                            leftPositions : computeRoundCorner(rightPos, startPoint, leftPos, cornerType, leftIsOutside)\n                        });\n                    } else {\n                        corners.push({\n                            leftPositions : computeMiteredCorner(position, Cartesian3.negate(cornerDirection, cornerDirection), leftPos, leftIsOutside)\n                        });\n                    }\n                } else {\n                    leftPos = Cartesian3.add(position, cornerDirection, leftPos);\n                    center = Cartesian3.add(leftPos, Cartesian3.negate(Cartesian3.multiplyByScalar(left, width, center), center), center);\n                    rightPos = Cartesian3.add(leftPos, Cartesian3.negate(Cartesian3.multiplyByScalar(left, width * 2, rightPos), rightPos), rightPos);\n                    scaleArray2[0] = Cartesian3.clone(previousPos, scaleArray2[0]);\n                    scaleArray2[1] = Cartesian3.clone(center, scaleArray2[1]);\n                    subdividedPositions = PolylinePipeline.generateArc({\n                        positions: scaleArray2,\n                        granularity: granularity,\n                        ellipsoid: ellipsoid\n                    });\n                    calculatedPositions = addShiftedPositions(subdividedPositions, left, width, calculatedPositions);\n                    if (saveAttributes) {\n                        calculatedLefts.push(left.x, left.y, left.z);\n                        calculatedNormals.push(normal.x, normal.y, normal.z);\n                    }\n                    startPoint = Cartesian3.clone(rightPos, startPoint);\n                    left = Cartesian3.normalize(Cartesian3.cross(normal, forward, left), left);\n                    rightPos = Cartesian3.add(leftPos, Cartesian3.negate(Cartesian3.multiplyByScalar(left, width * 2, rightPos), rightPos), rightPos);\n                    previousPos = Cartesian3.add(leftPos, Cartesian3.negate(Cartesian3.multiplyByScalar(left, width, previousPos), previousPos), previousPos);\n                    if (cornerType === CornerType.ROUNDED || cornerType === CornerType.BEVELED) {\n                        corners.push({\n                            rightPositions : computeRoundCorner(leftPos, startPoint, rightPos, cornerType, leftIsOutside)\n                        });\n                    } else {\n                        corners.push({\n                            rightPositions : computeMiteredCorner(position, cornerDirection, rightPos, leftIsOutside)\n                        });\n                    }\n                }\n                backward = Cartesian3.negate(forward, backward);\n            }\n            position = nextPosition;\n        }\n\n        normal = ellipsoid.geodeticSurfaceNormal(position, normal);\n        scaleArray2[0] = Cartesian3.clone(previousPos, scaleArray2[0]);\n        scaleArray2[1] = Cartesian3.clone(position, scaleArray2[1]);\n        subdividedPositions = PolylinePipeline.generateArc({\n            positions: scaleArray2,\n            granularity: granularity,\n            ellipsoid: ellipsoid\n        });\n        calculatedPositions = addShiftedPositions(subdividedPositions, left, width, calculatedPositions);\n        if (saveAttributes) {\n            calculatedLefts.push(left.x, left.y, left.z);\n            calculatedNormals.push(normal.x, normal.y, normal.z);\n        }\n\n        var endPositions;\n        if (cornerType === CornerType.ROUNDED) {\n            endPositions = addEndCaps(calculatedPositions);\n        }\n\n        return {\n            positions : calculatedPositions,\n            corners : corners,\n            lefts : calculatedLefts,\n            normals : calculatedNormals,\n            endPositions : endPositions\n        };\n    };\nexport default CorridorGeometryLibrary;\n","import arrayFill from './arrayFill.js';\nimport arrayRemoveDuplicates from './arrayRemoveDuplicates.js';\nimport BoundingSphere from './BoundingSphere.js';\nimport Cartesian3 from './Cartesian3.js';\nimport Cartographic from './Cartographic.js';\nimport Check from './Check.js';\nimport ComponentDatatype from './ComponentDatatype.js';\nimport CornerType from './CornerType.js';\nimport CorridorGeometryLibrary from './CorridorGeometryLibrary.js';\nimport defaultValue from './defaultValue.js';\nimport defined from './defined.js';\nimport defineProperties from './defineProperties.js';\nimport Ellipsoid from './Ellipsoid.js';\nimport Geometry from './Geometry.js';\nimport GeometryAttribute from './GeometryAttribute.js';\nimport GeometryAttributes from './GeometryAttributes.js';\nimport GeometryOffsetAttribute from './GeometryOffsetAttribute.js';\nimport IndexDatatype from './IndexDatatype.js';\nimport CesiumMath from './Math.js';\nimport PolygonPipeline from './PolygonPipeline.js';\nimport PrimitiveType from './PrimitiveType.js';\nimport Rectangle from './Rectangle.js';\nimport VertexFormat from './VertexFormat.js';\n\n    var cartesian1 = new Cartesian3();\n    var cartesian2 = new Cartesian3();\n    var cartesian3 = new Cartesian3();\n    var cartesian4 = new Cartesian3();\n    var cartesian5 = new Cartesian3();\n    var cartesian6 = new Cartesian3();\n\n    var scratch1 = new Cartesian3();\n    var scratch2 = new Cartesian3();\n\n    function scaleToSurface(positions, ellipsoid) {\n        for (var i = 0; i < positions.length; i++) {\n            positions[i] = ellipsoid.scaleToGeodeticSurface(positions[i], positions[i]);\n        }\n        return positions;\n    }\n\n    function addNormals(attr, normal, left, front, back, vertexFormat) {\n        var normals = attr.normals;\n        var tangents = attr.tangents;\n        var bitangents = attr.bitangents;\n        var forward = Cartesian3.normalize(Cartesian3.cross(left, normal, scratch1), scratch1);\n        if (vertexFormat.normal) {\n            CorridorGeometryLibrary.addAttribute(normals, normal, front, back);\n        }\n        if (vertexFormat.tangent) {\n            CorridorGeometryLibrary.addAttribute(tangents, forward, front, back);\n        }\n        if (vertexFormat.bitangent) {\n            CorridorGeometryLibrary.addAttribute(bitangents, left, front, back);\n        }\n    }\n\n    function combine(computedPositions, vertexFormat, ellipsoid) {\n        var positions = computedPositions.positions;\n        var corners = computedPositions.corners;\n        var endPositions = computedPositions.endPositions;\n        var computedLefts = computedPositions.lefts;\n        var computedNormals = computedPositions.normals;\n        var attributes = new GeometryAttributes();\n        var corner;\n        var leftCount = 0;\n        var rightCount = 0;\n        var i;\n        var indicesLength = 0;\n        var length;\n        for (i = 0; i < positions.length; i += 2) {\n            length = positions[i].length - 3;\n            leftCount += length; //subtracting 3 to account for duplicate points at corners\n            indicesLength += length*2;\n            rightCount += positions[i + 1].length - 3;\n        }\n        leftCount += 3; //add back count for end positions\n        rightCount += 3;\n        for (i = 0; i < corners.length; i++) {\n            corner = corners[i];\n            var leftSide = corners[i].leftPositions;\n            if (defined(leftSide)) {\n                length = leftSide.length;\n                leftCount += length;\n                indicesLength += length;\n            } else {\n                length = corners[i].rightPositions.length;\n                rightCount += length;\n                indicesLength += length;\n            }\n        }\n\n        var addEndPositions = defined(endPositions);\n        var endPositionLength;\n        if (addEndPositions) {\n            endPositionLength = endPositions[0].length - 3;\n            leftCount += endPositionLength;\n            rightCount += endPositionLength;\n            endPositionLength /= 3;\n            indicesLength += endPositionLength * 6;\n        }\n        var size = leftCount + rightCount;\n        var finalPositions = new Float64Array(size);\n        var normals = (vertexFormat.normal) ? new Float32Array(size) : undefined;\n        var tangents = (vertexFormat.tangent) ? new Float32Array(size) : undefined;\n        var bitangents = (vertexFormat.bitangent) ? new Float32Array(size) : undefined;\n        var attr = {\n            normals : normals,\n            tangents : tangents,\n            bitangents : bitangents\n        };\n        var front = 0;\n        var back = size - 1;\n        var UL, LL, UR, LR;\n        var normal = cartesian1;\n        var left = cartesian2;\n        var rightPos, leftPos;\n        var halfLength = endPositionLength / 2;\n\n        var indices = IndexDatatype.createTypedArray(size / 3, indicesLength);\n        var index = 0;\n        if (addEndPositions) { // add rounded end\n            leftPos = cartesian3;\n            rightPos = cartesian4;\n            var firstEndPositions = endPositions[0];\n            normal = Cartesian3.fromArray(computedNormals, 0, normal);\n            left = Cartesian3.fromArray(computedLefts, 0, left);\n            for (i = 0; i < halfLength; i++) {\n                leftPos = Cartesian3.fromArray(firstEndPositions, (halfLength - 1 - i) * 3, leftPos);\n                rightPos = Cartesian3.fromArray(firstEndPositions, (halfLength + i) * 3, rightPos);\n                CorridorGeometryLibrary.addAttribute(finalPositions, rightPos, front);\n                CorridorGeometryLibrary.addAttribute(finalPositions, leftPos, undefined, back);\n                addNormals(attr, normal, left, front, back, vertexFormat);\n\n                LL = front / 3;\n                LR = LL + 1;\n                UL = (back - 2) / 3;\n                UR = UL - 1;\n                indices[index++] = UL;\n                indices[index++] = LL;\n                indices[index++] = UR;\n                indices[index++] = UR;\n                indices[index++] = LL;\n                indices[index++] = LR;\n\n                front += 3;\n                back -= 3;\n            }\n        }\n\n        var posIndex = 0;\n        var compIndex = 0;\n        var rightEdge = positions[posIndex++]; //add first two edges\n        var leftEdge = positions[posIndex++];\n        finalPositions.set(rightEdge, front);\n        finalPositions.set(leftEdge, back - leftEdge.length + 1);\n\n        left = Cartesian3.fromArray(computedLefts, compIndex, left);\n        var rightNormal;\n        var leftNormal;\n        length = leftEdge.length - 3;\n        for (i = 0; i < length; i += 3) {\n            rightNormal = ellipsoid.geodeticSurfaceNormal(Cartesian3.fromArray(rightEdge, i, scratch1), scratch1);\n            leftNormal = ellipsoid.geodeticSurfaceNormal(Cartesian3.fromArray(leftEdge, length - i, scratch2), scratch2);\n            normal = Cartesian3.normalize(Cartesian3.add(rightNormal, leftNormal, normal), normal);\n            addNormals(attr, normal, left, front, back, vertexFormat);\n\n            LL = front / 3;\n            LR = LL + 1;\n            UL = (back - 2) / 3;\n            UR = UL - 1;\n            indices[index++] = UL;\n            indices[index++] = LL;\n            indices[index++] = UR;\n            indices[index++] = UR;\n            indices[index++] = LL;\n            indices[index++] = LR;\n\n            front += 3;\n            back -= 3;\n        }\n\n        rightNormal = ellipsoid.geodeticSurfaceNormal(Cartesian3.fromArray(rightEdge, length, scratch1), scratch1);\n        leftNormal = ellipsoid.geodeticSurfaceNormal(Cartesian3.fromArray(leftEdge, length, scratch2), scratch2);\n        normal = Cartesian3.normalize(Cartesian3.add(rightNormal, leftNormal, normal), normal);\n        compIndex += 3;\n        for (i = 0; i < corners.length; i++) {\n            var j;\n            corner = corners[i];\n            var l = corner.leftPositions;\n            var r = corner.rightPositions;\n            var pivot;\n            var start;\n            var outsidePoint = cartesian6;\n            var previousPoint = cartesian3;\n            var nextPoint = cartesian4;\n            normal = Cartesian3.fromArray(computedNormals, compIndex, normal);\n            if (defined(l)) {\n                addNormals(attr, normal, left, undefined, back, vertexFormat);\n                back -= 3;\n                pivot = LR;\n                start = UR;\n                for (j = 0; j < l.length / 3; j++) {\n                    outsidePoint = Cartesian3.fromArray(l, j * 3, outsidePoint);\n                    indices[index++] = pivot;\n                    indices[index++] = start - j - 1;\n                    indices[index++] = start - j;\n                    CorridorGeometryLibrary.addAttribute(finalPositions, outsidePoint, undefined, back);\n                    previousPoint = Cartesian3.fromArray(finalPositions, (start - j - 1) * 3, previousPoint);\n                    nextPoint = Cartesian3.fromArray(finalPositions, pivot * 3, nextPoint);\n                    left = Cartesian3.normalize(Cartesian3.subtract(previousPoint, nextPoint, left), left);\n                    addNormals(attr, normal, left, undefined, back, vertexFormat);\n                    back -= 3;\n                }\n                outsidePoint = Cartesian3.fromArray(finalPositions, pivot * 3, outsidePoint);\n                previousPoint = Cartesian3.subtract(Cartesian3.fromArray(finalPositions, (start) * 3, previousPoint), outsidePoint, previousPoint);\n                nextPoint = Cartesian3.subtract(Cartesian3.fromArray(finalPositions, (start - j) * 3, nextPoint), outsidePoint, nextPoint);\n                left = Cartesian3.normalize(Cartesian3.add(previousPoint, nextPoint, left), left);\n                addNormals(attr, normal, left, front, undefined, vertexFormat);\n                front += 3;\n            } else {\n                addNormals(attr, normal, left, front, undefined, vertexFormat);\n                front += 3;\n                pivot = UR;\n                start = LR;\n                for (j = 0; j < r.length / 3; j++) {\n                    outsidePoint = Cartesian3.fromArray(r, j * 3, outsidePoint);\n                    indices[index++] = pivot;\n                    indices[index++] = start + j;\n                    indices[index++] = start + j + 1;\n                    CorridorGeometryLibrary.addAttribute(finalPositions, outsidePoint, front);\n                    previousPoint = Cartesian3.fromArray(finalPositions, pivot * 3, previousPoint);\n                    nextPoint = Cartesian3.fromArray(finalPositions, (start + j) * 3, nextPoint);\n                    left = Cartesian3.normalize(Cartesian3.subtract(previousPoint, nextPoint, left), left);\n                    addNormals(attr, normal, left, front, undefined, vertexFormat);\n                    front += 3;\n                }\n                outsidePoint = Cartesian3.fromArray(finalPositions, pivot * 3, outsidePoint);\n                previousPoint = Cartesian3.subtract(Cartesian3.fromArray(finalPositions, (start + j) * 3, previousPoint), outsidePoint, previousPoint);\n                nextPoint = Cartesian3.subtract(Cartesian3.fromArray(finalPositions, start * 3, nextPoint), outsidePoint, nextPoint);\n                left = Cartesian3.normalize(Cartesian3.negate(Cartesian3.add(nextPoint, previousPoint, left), left), left);\n                addNormals(attr, normal, left, undefined, back, vertexFormat);\n                back -= 3;\n            }\n            rightEdge = positions[posIndex++];\n            leftEdge = positions[posIndex++];\n            rightEdge.splice(0, 3); //remove duplicate points added by corner\n            leftEdge.splice(leftEdge.length - 3, 3);\n            finalPositions.set(rightEdge, front);\n            finalPositions.set(leftEdge, back - leftEdge.length + 1);\n            length = leftEdge.length - 3;\n\n            compIndex += 3;\n            left = Cartesian3.fromArray(computedLefts, compIndex, left);\n            for (j = 0; j < leftEdge.length; j += 3) {\n                rightNormal = ellipsoid.geodeticSurfaceNormal(Cartesian3.fromArray(rightEdge, j, scratch1), scratch1);\n                leftNormal = ellipsoid.geodeticSurfaceNormal(Cartesian3.fromArray(leftEdge, length - j, scratch2), scratch2);\n                normal = Cartesian3.normalize(Cartesian3.add(rightNormal, leftNormal, normal), normal);\n                addNormals(attr, normal, left, front, back, vertexFormat);\n\n                LR = front / 3;\n                LL = LR - 1;\n                UR = (back - 2) / 3;\n                UL = UR + 1;\n                indices[index++] = UL;\n                indices[index++] = LL;\n                indices[index++] = UR;\n                indices[index++] = UR;\n                indices[index++] = LL;\n                indices[index++] = LR;\n\n                front += 3;\n                back -= 3;\n            }\n            front -= 3;\n            back += 3;\n        }\n        normal = Cartesian3.fromArray(computedNormals, computedNormals.length - 3, normal);\n        addNormals(attr, normal, left, front, back, vertexFormat);\n\n        if (addEndPositions) { // add rounded end\n            front += 3;\n            back -= 3;\n            leftPos = cartesian3;\n            rightPos = cartesian4;\n            var lastEndPositions = endPositions[1];\n            for (i = 0; i < halfLength; i++) {\n                leftPos = Cartesian3.fromArray(lastEndPositions, (endPositionLength - i - 1) * 3, leftPos);\n                rightPos = Cartesian3.fromArray(lastEndPositions, i * 3, rightPos);\n                CorridorGeometryLibrary.addAttribute(finalPositions, leftPos, undefined, back);\n                CorridorGeometryLibrary.addAttribute(finalPositions, rightPos, front);\n                addNormals(attr, normal, left, front, back, vertexFormat);\n\n                LR = front / 3;\n                LL = LR - 1;\n                UR = (back - 2) / 3;\n                UL = UR + 1;\n                indices[index++] = UL;\n                indices[index++] = LL;\n                indices[index++] = UR;\n                indices[index++] = UR;\n                indices[index++] = LL;\n                indices[index++] = LR;\n\n                front += 3;\n                back -= 3;\n            }\n        }\n\n        attributes.position = new GeometryAttribute({\n            componentDatatype : ComponentDatatype.DOUBLE,\n            componentsPerAttribute : 3,\n            values : finalPositions\n        });\n\n        if (vertexFormat.st) {\n            var st = new Float32Array(size / 3 * 2);\n            var rightSt;\n            var leftSt;\n            var stIndex = 0;\n            if (addEndPositions) {\n                leftCount /= 3;\n                rightCount /= 3;\n                var theta = Math.PI / (endPositionLength + 1);\n                leftSt = 1 / (leftCount - endPositionLength + 1);\n                rightSt = 1 / (rightCount - endPositionLength + 1);\n                var a;\n                var halfEndPos = endPositionLength / 2;\n                for (i = halfEndPos + 1; i < endPositionLength + 1; i++) { // lower left rounded end\n                    a = CesiumMath.PI_OVER_TWO + theta * i;\n                    st[stIndex++] = rightSt * (1 + Math.cos(a));\n                    st[stIndex++] = 0.5 * (1 + Math.sin(a));\n                }\n                for (i = 1; i < rightCount - endPositionLength + 1; i++) { // bottom edge\n                    st[stIndex++] = i * rightSt;\n                    st[stIndex++] = 0;\n                }\n                for (i = endPositionLength; i > halfEndPos; i--) { // lower right rounded end\n                    a = CesiumMath.PI_OVER_TWO - i * theta;\n                    st[stIndex++] = 1 - rightSt * (1 + Math.cos(a));\n                    st[stIndex++] = 0.5 * (1 + Math.sin(a));\n                }\n                for (i = halfEndPos; i > 0; i--) { // upper right rounded end\n                    a = CesiumMath.PI_OVER_TWO - theta * i;\n                    st[stIndex++] = 1 - leftSt * (1 + Math.cos(a));\n                    st[stIndex++] = 0.5 * (1 + Math.sin(a));\n                }\n                for (i = leftCount - endPositionLength; i > 0; i--) { // top edge\n                    st[stIndex++] = i * leftSt;\n                    st[stIndex++] = 1;\n                }\n                for (i = 1; i < halfEndPos + 1; i++) { // upper left rounded end\n                    a = CesiumMath.PI_OVER_TWO + theta * i;\n                    st[stIndex++] = leftSt * (1 + Math.cos(a));\n                    st[stIndex++] = 0.5 * (1 + Math.sin(a));\n                }\n            } else {\n                leftCount /= 3;\n                rightCount /= 3;\n                leftSt = 1 / (leftCount - 1);\n                rightSt = 1 / (rightCount - 1);\n                for (i = 0; i < rightCount; i++) { // bottom edge\n                    st[stIndex++] = i * rightSt;\n                    st[stIndex++] = 0;\n                }\n                for (i = leftCount; i > 0; i--) { // top edge\n                    st[stIndex++] = (i - 1) * leftSt;\n                    st[stIndex++] = 1;\n                }\n            }\n\n            attributes.st = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.FLOAT,\n                componentsPerAttribute : 2,\n                values : st\n            });\n        }\n\n        if (vertexFormat.normal) {\n            attributes.normal = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.FLOAT,\n                componentsPerAttribute : 3,\n                values : attr.normals\n            });\n        }\n\n        if (vertexFormat.tangent) {\n            attributes.tangent = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.FLOAT,\n                componentsPerAttribute : 3,\n                values : attr.tangents\n            });\n        }\n\n        if (vertexFormat.bitangent) {\n            attributes.bitangent = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.FLOAT,\n                componentsPerAttribute : 3,\n                values : attr.bitangents\n            });\n        }\n\n        return {\n            attributes : attributes,\n            indices : indices\n        };\n    }\n\n    function extrudedAttributes(attributes, vertexFormat) {\n        if (!vertexFormat.normal && !vertexFormat.tangent && !vertexFormat.bitangent && !vertexFormat.st) {\n            return attributes;\n        }\n        var positions = attributes.position.values;\n        var topNormals;\n        var topBitangents;\n        if (vertexFormat.normal || vertexFormat.bitangent) {\n            topNormals = attributes.normal.values;\n            topBitangents = attributes.bitangent.values;\n        }\n        var size = attributes.position.values.length / 18;\n        var threeSize = size * 3;\n        var twoSize = size * 2;\n        var sixSize = threeSize * 2;\n        var i;\n        if (vertexFormat.normal || vertexFormat.bitangent || vertexFormat.tangent) {\n            var normals = (vertexFormat.normal) ? new Float32Array(threeSize * 6) : undefined;\n            var tangents = (vertexFormat.tangent) ? new Float32Array(threeSize * 6) : undefined;\n            var bitangents = (vertexFormat.bitangent) ? new Float32Array(threeSize * 6) : undefined;\n            var topPosition = cartesian1;\n            var bottomPosition = cartesian2;\n            var previousPosition = cartesian3;\n            var normal = cartesian4;\n            var tangent = cartesian5;\n            var bitangent = cartesian6;\n            var attrIndex = sixSize;\n            for (i = 0; i < threeSize; i += 3) {\n                var attrIndexOffset = attrIndex + sixSize;\n                topPosition      = Cartesian3.fromArray(positions, i, topPosition);\n                bottomPosition   = Cartesian3.fromArray(positions, i + threeSize, bottomPosition);\n                previousPosition = Cartesian3.fromArray(positions, (i + 3) % threeSize, previousPosition);\n                bottomPosition   = Cartesian3.subtract(bottomPosition,   topPosition, bottomPosition);\n                previousPosition = Cartesian3.subtract(previousPosition, topPosition, previousPosition);\n                normal = Cartesian3.normalize(Cartesian3.cross(bottomPosition, previousPosition, normal), normal);\n                if (vertexFormat.normal) {\n                    CorridorGeometryLibrary.addAttribute(normals, normal, attrIndexOffset);\n                    CorridorGeometryLibrary.addAttribute(normals, normal, attrIndexOffset + 3);\n                    CorridorGeometryLibrary.addAttribute(normals, normal, attrIndex);\n                    CorridorGeometryLibrary.addAttribute(normals, normal, attrIndex + 3);\n                }\n                if (vertexFormat.tangent || vertexFormat.bitangent) {\n                    bitangent = Cartesian3.fromArray(topNormals, i, bitangent);\n                    if (vertexFormat.bitangent) {\n                        CorridorGeometryLibrary.addAttribute(bitangents, bitangent, attrIndexOffset);\n                        CorridorGeometryLibrary.addAttribute(bitangents, bitangent, attrIndexOffset + 3);\n                        CorridorGeometryLibrary.addAttribute(bitangents, bitangent, attrIndex);\n                        CorridorGeometryLibrary.addAttribute(bitangents, bitangent, attrIndex + 3);\n                    }\n\n                    if (vertexFormat.tangent) {\n                        tangent = Cartesian3.normalize(Cartesian3.cross(bitangent, normal, tangent), tangent);\n                        CorridorGeometryLibrary.addAttribute(tangents, tangent, attrIndexOffset);\n                        CorridorGeometryLibrary.addAttribute(tangents, tangent, attrIndexOffset + 3);\n                        CorridorGeometryLibrary.addAttribute(tangents, tangent, attrIndex);\n                        CorridorGeometryLibrary.addAttribute(tangents, tangent, attrIndex + 3);\n                    }\n                }\n                attrIndex += 6;\n            }\n\n            if (vertexFormat.normal) {\n                normals.set(topNormals); //top\n                for (i = 0; i < threeSize; i += 3) { //bottom normals\n                    normals[i + threeSize] = -topNormals[i];\n                    normals[i + threeSize + 1] = -topNormals[i + 1];\n                    normals[i + threeSize + 2] = -topNormals[i + 2];\n                }\n                attributes.normal.values = normals;\n            } else {\n                attributes.normal = undefined;\n            }\n\n            if (vertexFormat.bitangent) {\n                bitangents.set(topBitangents); //top\n                bitangents.set(topBitangents, threeSize); //bottom\n                attributes.bitangent.values = bitangents;\n            } else {\n                attributes.bitangent = undefined;\n            }\n\n            if (vertexFormat.tangent) {\n                var topTangents = attributes.tangent.values;\n                tangents.set(topTangents); //top\n                tangents.set(topTangents, threeSize); //bottom\n                attributes.tangent.values = tangents;\n            }\n        }\n        if (vertexFormat.st) {\n            var topSt = attributes.st.values;\n            var st = new Float32Array(twoSize * 6);\n            st.set(topSt); //top\n            st.set(topSt, twoSize); //bottom\n            var index = twoSize * 2;\n\n            for ( var j = 0; j < 2; j++) {\n                st[index++] = topSt[0];\n                st[index++] = topSt[1];\n                for (i = 2; i < twoSize; i += 2) {\n                    var s = topSt[i];\n                    var t = topSt[i + 1];\n                    st[index++] = s;\n                    st[index++] = t;\n                    st[index++] = s;\n                    st[index++] = t;\n                }\n                st[index++] = topSt[0];\n                st[index++] = topSt[1];\n            }\n            attributes.st.values = st;\n        }\n\n        return attributes;\n    }\n\n    function addWallPositions(positions, index, wallPositions) {\n        wallPositions[index++] = positions[0];\n        wallPositions[index++] = positions[1];\n        wallPositions[index++] = positions[2];\n        for ( var i = 3; i < positions.length; i += 3) {\n            var x = positions[i];\n            var y = positions[i + 1];\n            var z = positions[i + 2];\n            wallPositions[index++] = x;\n            wallPositions[index++] = y;\n            wallPositions[index++] = z;\n            wallPositions[index++] = x;\n            wallPositions[index++] = y;\n            wallPositions[index++] = z;\n        }\n        wallPositions[index++] = positions[0];\n        wallPositions[index++] = positions[1];\n        wallPositions[index++] = positions[2];\n\n        return wallPositions;\n    }\n\n    function computePositionsExtruded(params, vertexFormat) {\n        var topVertexFormat = new VertexFormat({\n            position : vertexFormat.position,\n            normal : (vertexFormat.normal || vertexFormat.bitangent || params.shadowVolume),\n            tangent : vertexFormat.tangent,\n            bitangent : (vertexFormat.normal || vertexFormat.bitangent),\n            st : vertexFormat.st\n        });\n        var ellipsoid = params.ellipsoid;\n        var computedPositions = CorridorGeometryLibrary.computePositions(params);\n        var attr = combine(computedPositions, topVertexFormat, ellipsoid);\n        var height = params.height;\n        var extrudedHeight = params.extrudedHeight;\n        var attributes = attr.attributes;\n        var indices = attr.indices;\n        var positions = attributes.position.values;\n        var length = positions.length;\n        var newPositions = new Float64Array(length * 6);\n        var extrudedPositions = new Float64Array(length);\n        extrudedPositions.set(positions);\n        var wallPositions = new Float64Array(length * 4);\n\n        positions = PolygonPipeline.scaleToGeodeticHeight(positions, height, ellipsoid);\n        wallPositions = addWallPositions(positions, 0, wallPositions);\n        extrudedPositions = PolygonPipeline.scaleToGeodeticHeight(extrudedPositions, extrudedHeight, ellipsoid);\n        wallPositions = addWallPositions(extrudedPositions, length * 2, wallPositions);\n        newPositions.set(positions);\n        newPositions.set(extrudedPositions, length);\n        newPositions.set(wallPositions, length * 2);\n        attributes.position.values = newPositions;\n\n        attributes = extrudedAttributes(attributes, vertexFormat);\n        var i;\n        var size = length / 3;\n        if (params.shadowVolume) {\n            var topNormals = attributes.normal.values;\n            length = topNormals.length;\n\n            var extrudeNormals = new Float32Array(length * 6);\n            for (i = 0; i < length; i ++) {\n                topNormals[i] = -topNormals[i];\n            }\n            //only get normals for bottom layer that's going to be pushed down\n            extrudeNormals.set(topNormals, length); //bottom face\n            extrudeNormals = addWallPositions(topNormals, length*4, extrudeNormals); //bottom wall\n            attributes.extrudeDirection = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.FLOAT,\n                componentsPerAttribute : 3,\n                values : extrudeNormals\n            });\n            if (!vertexFormat.normal) {\n                attributes.normal = undefined;\n            }\n        }\n        if (defined(params.offsetAttribute)) {\n            var applyOffset = new Uint8Array(size * 6);\n            if (params.offsetAttribute === GeometryOffsetAttribute.TOP) {\n                applyOffset = arrayFill(applyOffset, 1, 0, size); // top face\n                applyOffset = arrayFill(applyOffset, 1, size*2, size * 4); // top wall\n            } else {\n                var applyOffsetValue = params.offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;\n                applyOffset = arrayFill(applyOffset, applyOffsetValue);\n            }\n            attributes.applyOffset = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.UNSIGNED_BYTE,\n                componentsPerAttribute : 1,\n                values: applyOffset\n            });\n        }\n\n        var iLength = indices.length;\n        var twoSize = size + size;\n        var newIndices = IndexDatatype.createTypedArray(newPositions.length / 3, iLength * 2 + twoSize * 3);\n        newIndices.set(indices);\n        var index = iLength;\n        for (i = 0; i < iLength; i += 3) { // bottom indices\n            var v0 = indices[i];\n            var v1 = indices[i + 1];\n            var v2 = indices[i + 2];\n            newIndices[index++] = v2 + size;\n            newIndices[index++] = v1 + size;\n            newIndices[index++] = v0 + size;\n        }\n\n        var UL, LL, UR, LR;\n\n        for (i = 0; i < twoSize; i += 2) { //wall indices\n            UL = i + twoSize;\n            LL = UL + twoSize;\n            UR = UL + 1;\n            LR = LL + 1;\n            newIndices[index++] = UL;\n            newIndices[index++] = LL;\n            newIndices[index++] = UR;\n            newIndices[index++] = UR;\n            newIndices[index++] = LL;\n            newIndices[index++] = LR;\n        }\n\n        return {\n            attributes : attributes,\n            indices : newIndices\n        };\n    }\n\n    var scratchCartesian1 = new Cartesian3();\n    var scratchCartesian2 = new Cartesian3();\n    var scratchCartographic = new Cartographic();\n\n    function computeOffsetPoints(position1, position2, ellipsoid, halfWidth, min, max) {\n        // Compute direction of offset the point\n        var direction = Cartesian3.subtract(position2, position1, scratchCartesian1);\n        Cartesian3.normalize(direction, direction);\n        var normal = ellipsoid.geodeticSurfaceNormal(position1, scratchCartesian2);\n        var offsetDirection = Cartesian3.cross(direction, normal, scratchCartesian1);\n        Cartesian3.multiplyByScalar(offsetDirection, halfWidth, offsetDirection);\n\n        var minLat = min.latitude;\n        var minLon = min.longitude;\n        var maxLat = max.latitude;\n        var maxLon = max.longitude;\n\n        // Compute 2 offset points\n        Cartesian3.add(position1, offsetDirection, scratchCartesian2);\n        ellipsoid.cartesianToCartographic(scratchCartesian2, scratchCartographic);\n\n        var lat = scratchCartographic.latitude;\n        var lon = scratchCartographic.longitude;\n        minLat = Math.min(minLat, lat);\n        minLon = Math.min(minLon, lon);\n        maxLat = Math.max(maxLat, lat);\n        maxLon = Math.max(maxLon, lon);\n\n        Cartesian3.subtract(position1, offsetDirection, scratchCartesian2);\n        ellipsoid.cartesianToCartographic(scratchCartesian2, scratchCartographic);\n\n        lat = scratchCartographic.latitude;\n        lon = scratchCartographic.longitude;\n        minLat = Math.min(minLat, lat);\n        minLon = Math.min(minLon, lon);\n        maxLat = Math.max(maxLat, lat);\n        maxLon = Math.max(maxLon, lon);\n\n        min.latitude = minLat;\n        min.longitude = minLon;\n        max.latitude = maxLat;\n        max.longitude = maxLon;\n    }\n\n    var scratchCartesianOffset = new Cartesian3();\n    var scratchCartesianEnds = new Cartesian3();\n    var scratchCartographicMin = new Cartographic();\n    var scratchCartographicMax = new Cartographic();\n\n    function computeRectangle(positions, ellipsoid, width, cornerType, result) {\n        positions = scaleToSurface(positions, ellipsoid);\n        var cleanPositions = arrayRemoveDuplicates(positions, Cartesian3.equalsEpsilon);\n        var length = cleanPositions.length;\n        if (length < 2 || width <= 0) {\n            return new Rectangle();\n        }\n        var halfWidth = width * 0.5;\n\n        scratchCartographicMin.latitude = Number.POSITIVE_INFINITY;\n        scratchCartographicMin.longitude = Number.POSITIVE_INFINITY;\n        scratchCartographicMax.latitude = Number.NEGATIVE_INFINITY;\n        scratchCartographicMax.longitude = Number.NEGATIVE_INFINITY;\n\n        var lat, lon;\n        if (cornerType === CornerType.ROUNDED) {\n            // Compute start cap\n            var first = cleanPositions[0];\n            Cartesian3.subtract(first, cleanPositions[1], scratchCartesianOffset);\n            Cartesian3.normalize(scratchCartesianOffset, scratchCartesianOffset);\n            Cartesian3.multiplyByScalar(scratchCartesianOffset, halfWidth, scratchCartesianOffset);\n            Cartesian3.add(first, scratchCartesianOffset, scratchCartesianEnds);\n\n            ellipsoid.cartesianToCartographic(scratchCartesianEnds, scratchCartographic);\n            lat = scratchCartographic.latitude;\n            lon = scratchCartographic.longitude;\n            scratchCartographicMin.latitude = Math.min(scratchCartographicMin.latitude, lat);\n            scratchCartographicMin.longitude = Math.min(scratchCartographicMin.longitude, lon);\n            scratchCartographicMax.latitude = Math.max(scratchCartographicMax.latitude, lat);\n            scratchCartographicMax.longitude = Math.max(scratchCartographicMax.longitude, lon);\n        }\n\n        // Compute the rest\n        for (var i = 0; i < length-1; ++i) {\n            computeOffsetPoints(cleanPositions[i], cleanPositions[i+1], ellipsoid, halfWidth,\n                scratchCartographicMin, scratchCartographicMax);\n        }\n\n        // Compute ending point\n        var last = cleanPositions[length-1];\n        Cartesian3.subtract(last, cleanPositions[length-2], scratchCartesianOffset);\n        Cartesian3.normalize(scratchCartesianOffset, scratchCartesianOffset);\n        Cartesian3.multiplyByScalar(scratchCartesianOffset, halfWidth, scratchCartesianOffset);\n        Cartesian3.add(last, scratchCartesianOffset, scratchCartesianEnds);\n        computeOffsetPoints(last, scratchCartesianEnds, ellipsoid, halfWidth,\n            scratchCartographicMin, scratchCartographicMax);\n\n        if (cornerType === CornerType.ROUNDED) {\n            // Compute end cap\n            ellipsoid.cartesianToCartographic(scratchCartesianEnds, scratchCartographic);\n            lat = scratchCartographic.latitude;\n            lon = scratchCartographic.longitude;\n            scratchCartographicMin.latitude = Math.min(scratchCartographicMin.latitude, lat);\n            scratchCartographicMin.longitude = Math.min(scratchCartographicMin.longitude, lon);\n            scratchCartographicMax.latitude = Math.max(scratchCartographicMax.latitude, lat);\n            scratchCartographicMax.longitude = Math.max(scratchCartographicMax.longitude, lon);\n        }\n\n        var rectangle = defined(result) ? result : new Rectangle();\n        rectangle.north = scratchCartographicMax.latitude;\n        rectangle.south = scratchCartographicMin.latitude;\n        rectangle.east = scratchCartographicMax.longitude;\n        rectangle.west = scratchCartographicMin.longitude;\n\n        return rectangle;\n    }\n\n    /**\n     * A description of a corridor. Corridor geometry can be rendered with both {@link Primitive} and {@link GroundPrimitive}.\n     *\n     * @alias CorridorGeometry\n     * @constructor\n     *\n     * @param {Object} options Object with the following properties:\n     * @param {Cartesian3[]} options.positions An array of positions that define the center of the corridor.\n     * @param {Number} options.width The distance between the edges of the corridor in meters.\n     * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid to be used as a reference.\n     * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n     * @param {Number} [options.height=0] The distance in meters between the ellipsoid surface and the positions.\n     * @param {Number} [options.extrudedHeight] The distance in meters between the ellipsoid surface and the extruded face.\n     * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\n     * @param {CornerType} [options.cornerType=CornerType.ROUNDED] Determines the style of the corners.\n     *\n     * @see CorridorGeometry.createGeometry\n     * @see Packable\n     *\n     * @demo {@link https://sandcastle.cesium.com/index.html?src=Corridor.html|Cesium Sandcastle Corridor Demo}\n     *\n     * @example\n     * var corridor = new Cesium.CorridorGeometry({\n     *   vertexFormat : Cesium.VertexFormat.POSITION_ONLY,\n     *   positions : Cesium.Cartesian3.fromDegreesArray([-72.0, 40.0, -70.0, 35.0]),\n     *   width : 100000\n     * });\n     */\n    function CorridorGeometry(options) {\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n        var positions = options.positions;\n        var width = options.width;\n\n        \n\n        var height = defaultValue(options.height, 0.0);\n        var extrudedHeight = defaultValue(options.extrudedHeight, height);\n\n        this._positions = positions;\n        this._ellipsoid = Ellipsoid.clone(defaultValue(options.ellipsoid, Ellipsoid.WGS84));\n        this._vertexFormat = VertexFormat.clone(defaultValue(options.vertexFormat, VertexFormat.DEFAULT));\n        this._width = width;\n        this._height = Math.max(height, extrudedHeight);\n        this._extrudedHeight = Math.min(height, extrudedHeight);\n        this._cornerType = defaultValue(options.cornerType, CornerType.ROUNDED);\n        this._granularity = defaultValue(options.granularity, CesiumMath.RADIANS_PER_DEGREE);\n        this._shadowVolume = defaultValue(options.shadowVolume, false);\n        this._workerName = 'createCorridorGeometry';\n        this._offsetAttribute = options.offsetAttribute;\n        this._rectangle = undefined;\n\n        /**\n         * The number of elements used to pack the object into an array.\n         * @type {Number}\n         */\n        this.packedLength = 1 + positions.length * Cartesian3.packedLength + Ellipsoid.packedLength + VertexFormat.packedLength + 7;\n    }\n\n    /**\n     * Stores the provided instance into the provided array.\n     *\n     * @param {CorridorGeometry} value The value to pack.\n     * @param {Number[]} array The array to pack into.\n     * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n     *\n     * @returns {Number[]} The array that was packed into\n     */\n    CorridorGeometry.pack = function(value, array, startingIndex) {\n        \n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        var positions = value._positions;\n        var length = positions.length;\n        array[startingIndex++] = length;\n\n        for (var i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {\n            Cartesian3.pack(positions[i], array, startingIndex);\n        }\n\n        Ellipsoid.pack(value._ellipsoid, array, startingIndex);\n        startingIndex += Ellipsoid.packedLength;\n\n        VertexFormat.pack(value._vertexFormat, array, startingIndex);\n        startingIndex += VertexFormat.packedLength;\n\n        array[startingIndex++] = value._width;\n        array[startingIndex++] = value._height;\n        array[startingIndex++] = value._extrudedHeight;\n        array[startingIndex++] = value._cornerType;\n        array[startingIndex++] = value._granularity;\n        array[startingIndex++] = value._shadowVolume ? 1.0 : 0.0;\n        array[startingIndex] = defaultValue(value._offsetAttribute, -1);\n\n        return array;\n    };\n\n    var scratchEllipsoid = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);\n    var scratchVertexFormat = new VertexFormat();\n    var scratchOptions = {\n        positions : undefined,\n        ellipsoid : scratchEllipsoid,\n        vertexFormat : scratchVertexFormat,\n        width : undefined,\n        height : undefined,\n        extrudedHeight : undefined,\n        cornerType : undefined,\n        granularity : undefined,\n        shadowVolume: undefined,\n        offsetAttribute: undefined\n    };\n\n    /**\n     * Retrieves an instance from a packed array.\n     *\n     * @param {Number[]} array The packed array.\n     * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n     * @param {CorridorGeometry} [result] The object into which to store the result.\n     * @returns {CorridorGeometry} The modified result parameter or a new CorridorGeometry instance if one was not provided.\n     */\n    CorridorGeometry.unpack = function(array, startingIndex, result) {\n        \n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        var length = array[startingIndex++];\n        var positions = new Array(length);\n\n        for (var i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {\n            positions[i] = Cartesian3.unpack(array, startingIndex);\n        }\n\n        var ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);\n        startingIndex += Ellipsoid.packedLength;\n\n        var vertexFormat = VertexFormat.unpack(array, startingIndex, scratchVertexFormat);\n        startingIndex += VertexFormat.packedLength;\n\n        var width = array[startingIndex++];\n        var height = array[startingIndex++];\n        var extrudedHeight = array[startingIndex++];\n        var cornerType = array[startingIndex++];\n        var granularity = array[startingIndex++];\n        var shadowVolume = array[startingIndex++] === 1.0;\n        var offsetAttribute = array[startingIndex];\n\n        if (!defined(result)) {\n            scratchOptions.positions = positions;\n            scratchOptions.width = width;\n            scratchOptions.height = height;\n            scratchOptions.extrudedHeight = extrudedHeight;\n            scratchOptions.cornerType = cornerType;\n            scratchOptions.granularity = granularity;\n            scratchOptions.shadowVolume = shadowVolume;\n            scratchOptions.offsetAttribute = offsetAttribute === -1 ? undefined : offsetAttribute;\n\n            return new CorridorGeometry(scratchOptions);\n        }\n\n        result._positions = positions;\n        result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);\n        result._vertexFormat = VertexFormat.clone(vertexFormat, result._vertexFormat);\n        result._width = width;\n        result._height = height;\n        result._extrudedHeight = extrudedHeight;\n        result._cornerType = cornerType;\n        result._granularity = granularity;\n        result._shadowVolume = shadowVolume;\n        result._offsetAttribute = offsetAttribute === -1 ? undefined : offsetAttribute;\n\n        return result;\n    };\n\n    /**\n     * Computes the bounding rectangle given the provided options\n     *\n     * @param {Object} options Object with the following properties:\n     * @param {Cartesian3[]} options.positions An array of positions that define the center of the corridor.\n     * @param {Number} options.width The distance between the edges of the corridor in meters.\n     * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid to be used as a reference.\n     * @param {CornerType} [options.cornerType=CornerType.ROUNDED] Determines the style of the corners.\n     * @param {Rectangle} [result] An object in which to store the result.\n     *\n     * @returns {Rectangle} The result rectangle.\n     */\n    CorridorGeometry.computeRectangle = function(options, result) {\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n        var positions = options.positions;\n        var width = options.width;\n\n        \n\n        var ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\n        var cornerType = defaultValue(options.cornerType, CornerType.ROUNDED);\n\n        return computeRectangle(positions, ellipsoid, width, cornerType, result);\n    };\n\n    /**\n     * Computes the geometric representation of a corridor, including its vertices, indices, and a bounding sphere.\n     *\n     * @param {CorridorGeometry} corridorGeometry A description of the corridor.\n     * @returns {Geometry|undefined} The computed vertices and indices.\n     */\n    CorridorGeometry.createGeometry = function(corridorGeometry) {\n        var positions = corridorGeometry._positions;\n        var width = corridorGeometry._width;\n        var ellipsoid = corridorGeometry._ellipsoid;\n\n        positions = scaleToSurface(positions, ellipsoid);\n        var cleanPositions = arrayRemoveDuplicates(positions, Cartesian3.equalsEpsilon);\n\n        if ((cleanPositions.length < 2) || (width <= 0)) {\n            return;\n        }\n\n        var height = corridorGeometry._height;\n        var extrudedHeight = corridorGeometry._extrudedHeight;\n        var extrude = !CesiumMath.equalsEpsilon(height, extrudedHeight, 0, CesiumMath.EPSILON2);\n\n        var vertexFormat = corridorGeometry._vertexFormat;\n        var params = {\n            ellipsoid : ellipsoid,\n            positions : cleanPositions,\n            width : width,\n            cornerType : corridorGeometry._cornerType,\n            granularity : corridorGeometry._granularity,\n            saveAttributes: true\n        };\n        var attr;\n        if (extrude) {\n            params.height = height;\n            params.extrudedHeight = extrudedHeight;\n            params.shadowVolume = corridorGeometry._shadowVolume;\n            params.offsetAttribute = corridorGeometry._offsetAttribute;\n            attr = computePositionsExtruded(params, vertexFormat);\n        } else {\n            var computedPositions = CorridorGeometryLibrary.computePositions(params);\n            attr = combine(computedPositions, vertexFormat, ellipsoid);\n            attr.attributes.position.values = PolygonPipeline.scaleToGeodeticHeight(attr.attributes.position.values, height, ellipsoid);\n\n            if (defined(corridorGeometry._offsetAttribute)) {\n                var applyOffsetValue = corridorGeometry._offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;\n                var length = attr.attributes.position.values.length;\n                var applyOffset = new Uint8Array(length / 3);\n                arrayFill(applyOffset, applyOffsetValue);\n                attr.attributes.applyOffset = new GeometryAttribute({\n                    componentDatatype : ComponentDatatype.UNSIGNED_BYTE,\n                    componentsPerAttribute : 1,\n                    values: applyOffset\n                });\n            }\n        }\n        var attributes = attr.attributes;\n        var boundingSphere = BoundingSphere.fromVertices(attributes.position.values, undefined, 3);\n        if (!vertexFormat.position) {\n            attr.attributes.position.values = undefined;\n        }\n\n        return new Geometry({\n            attributes : attributes,\n            indices : attr.indices,\n            primitiveType : PrimitiveType.TRIANGLES,\n            boundingSphere : boundingSphere,\n            offsetAttribute : corridorGeometry._offsetAttribute\n        });\n    };\n\n    /**\n     * @private\n     */\n    CorridorGeometry.createShadowVolume = function(corridorGeometry, minHeightFunc, maxHeightFunc) {\n        var granularity = corridorGeometry._granularity;\n        var ellipsoid = corridorGeometry._ellipsoid;\n\n        var minHeight = minHeightFunc(granularity, ellipsoid);\n        var maxHeight = maxHeightFunc(granularity, ellipsoid);\n\n        return new CorridorGeometry({\n            positions : corridorGeometry._positions,\n            width : corridorGeometry._width,\n            cornerType : corridorGeometry._cornerType,\n            ellipsoid : ellipsoid,\n            granularity : granularity,\n            extrudedHeight : minHeight,\n            height : maxHeight,\n            vertexFormat : VertexFormat.POSITION_ONLY,\n            shadowVolume: true\n        });\n    };\n\n    defineProperties(CorridorGeometry.prototype, {\n        /**\n         * @private\n         */\n        rectangle : {\n            get : function() {\n                if (!defined(this._rectangle)) {\n                    this._rectangle = computeRectangle(this._positions, this._ellipsoid, this._width, this._cornerType);\n                }\n                return this._rectangle;\n            }\n        },\n        /**\n         * For remapping texture coordinates when rendering CorridorGeometries as GroundPrimitives.\n         *\n         * Corridors don't support stRotation,\n         * so just return the corners of the original system.\n         * @private\n         */\n        textureCoordinateRotationPoints : {\n            get : function() {\n                return [0, 0, 0, 1, 1, 0];\n            }\n        }\n    });\nexport default CorridorGeometry;\n","import arrayFill from './arrayFill.js';\nimport arrayRemoveDuplicates from './arrayRemoveDuplicates.js';\nimport BoundingSphere from './BoundingSphere.js';\nimport Cartesian3 from './Cartesian3.js';\nimport Check from './Check.js';\nimport ComponentDatatype from './ComponentDatatype.js';\nimport CornerType from './CornerType.js';\nimport CorridorGeometryLibrary from './CorridorGeometryLibrary.js';\nimport defaultValue from './defaultValue.js';\nimport defined from './defined.js';\nimport Ellipsoid from './Ellipsoid.js';\nimport Geometry from './Geometry.js';\nimport GeometryAttribute from './GeometryAttribute.js';\nimport GeometryAttributes from './GeometryAttributes.js';\nimport GeometryOffsetAttribute from './GeometryOffsetAttribute.js';\nimport IndexDatatype from './IndexDatatype.js';\nimport CesiumMath from './Math.js';\nimport PolygonPipeline from './PolygonPipeline.js';\nimport PrimitiveType from './PrimitiveType.js';\n\n    var cartesian1 = new Cartesian3();\n    var cartesian2 = new Cartesian3();\n    var cartesian3 = new Cartesian3();\n\n    function scaleToSurface(positions, ellipsoid) {\n        for (var i = 0; i < positions.length; i++) {\n            positions[i] = ellipsoid.scaleToGeodeticSurface(positions[i], positions[i]);\n        }\n        return positions;\n    }\n\n    function combine(computedPositions, cornerType) {\n        var wallIndices = [];\n        var positions = computedPositions.positions;\n        var corners = computedPositions.corners;\n        var endPositions = computedPositions.endPositions;\n        var attributes = new GeometryAttributes();\n        var corner;\n        var leftCount = 0;\n        var rightCount = 0;\n        var i;\n        var indicesLength = 0;\n        var length;\n        for (i = 0; i < positions.length; i += 2) {\n            length = positions[i].length - 3;\n            leftCount += length; //subtracting 3 to account for duplicate points at corners\n            indicesLength += length / 3 * 4;\n            rightCount += positions[i + 1].length - 3;\n        }\n        leftCount += 3; //add back count for end positions\n        rightCount += 3;\n        for (i = 0; i < corners.length; i++) {\n            corner = corners[i];\n            var leftSide = corners[i].leftPositions;\n            if (defined(leftSide)) {\n                length = leftSide.length;\n                leftCount += length;\n                indicesLength += length / 3 * 2;\n            } else {\n                length = corners[i].rightPositions.length;\n                rightCount += length;\n                indicesLength += length / 3 * 2;\n            }\n        }\n\n        var addEndPositions = defined(endPositions);\n        var endPositionLength;\n        if (addEndPositions) {\n            endPositionLength = endPositions[0].length - 3;\n            leftCount += endPositionLength;\n            rightCount += endPositionLength;\n            endPositionLength /= 3;\n            indicesLength += endPositionLength * 4;\n        }\n        var size = leftCount + rightCount;\n        var finalPositions = new Float64Array(size);\n        var front = 0;\n        var back = size - 1;\n        var UL, LL, UR, LR;\n        var rightPos, leftPos;\n        var halfLength = endPositionLength / 2;\n\n        var indices = IndexDatatype.createTypedArray(size / 3, indicesLength + 4);\n        var index = 0;\n\n        indices[index++] = front / 3;\n        indices[index++] = (back - 2) / 3;\n        if (addEndPositions) { // add rounded end\n            wallIndices.push(front / 3);\n            leftPos = cartesian1;\n            rightPos = cartesian2;\n            var firstEndPositions = endPositions[0];\n            for (i = 0; i < halfLength; i++) {\n                leftPos = Cartesian3.fromArray(firstEndPositions, (halfLength - 1 - i) * 3, leftPos);\n                rightPos = Cartesian3.fromArray(firstEndPositions, (halfLength + i) * 3, rightPos);\n                CorridorGeometryLibrary.addAttribute(finalPositions, rightPos, front);\n                CorridorGeometryLibrary.addAttribute(finalPositions, leftPos, undefined, back);\n\n                LL = front / 3;\n                LR = LL + 1;\n                UL = (back - 2) / 3;\n                UR = UL - 1;\n                indices[index++] = UL;\n                indices[index++] = UR;\n                indices[index++] = LL;\n                indices[index++] = LR;\n\n                front += 3;\n                back -= 3;\n            }\n        }\n\n        var posIndex = 0;\n        var rightEdge = positions[posIndex++]; //add first two edges\n        var leftEdge = positions[posIndex++];\n        finalPositions.set(rightEdge, front);\n        finalPositions.set(leftEdge, back - leftEdge.length + 1);\n\n        length = leftEdge.length - 3;\n        wallIndices.push(front / 3, (back - 2) / 3);\n        for (i = 0; i < length; i += 3) {\n            LL = front / 3;\n            LR = LL + 1;\n            UL = (back - 2) / 3;\n            UR = UL - 1;\n            indices[index++] = UL;\n            indices[index++] = UR;\n            indices[index++] = LL;\n            indices[index++] = LR;\n\n            front += 3;\n            back -= 3;\n        }\n\n        for (i = 0; i < corners.length; i++) {\n            var j;\n            corner = corners[i];\n            var l = corner.leftPositions;\n            var r = corner.rightPositions;\n            var start;\n            var outsidePoint = cartesian3;\n            if (defined(l)) {\n                back -= 3;\n                start = UR;\n                wallIndices.push(LR);\n                for (j = 0; j < l.length / 3; j++) {\n                    outsidePoint = Cartesian3.fromArray(l, j * 3, outsidePoint);\n                    indices[index++] = start - j - 1;\n                    indices[index++] = start - j;\n                    CorridorGeometryLibrary.addAttribute(finalPositions, outsidePoint, undefined, back);\n                    back -= 3;\n                }\n                wallIndices.push(start - Math.floor(l.length / 6));\n                if (cornerType === CornerType.BEVELED) {\n                    wallIndices.push((back - 2) / 3 + 1);\n                }\n                front += 3;\n            } else {\n                front += 3;\n                start = LR;\n                wallIndices.push(UR);\n                for (j = 0; j < r.length / 3; j++) {\n                    outsidePoint = Cartesian3.fromArray(r, j * 3, outsidePoint);\n                    indices[index++] = start + j;\n                    indices[index++] = start + j + 1;\n                    CorridorGeometryLibrary.addAttribute(finalPositions, outsidePoint, front);\n                    front += 3;\n                }\n                wallIndices.push(start + Math.floor(r.length / 6));\n                if (cornerType === CornerType.BEVELED) {\n                    wallIndices.push(front / 3 - 1);\n                }\n                back -= 3;\n            }\n            rightEdge = positions[posIndex++];\n            leftEdge = positions[posIndex++];\n            rightEdge.splice(0, 3); //remove duplicate points added by corner\n            leftEdge.splice(leftEdge.length - 3, 3);\n            finalPositions.set(rightEdge, front);\n            finalPositions.set(leftEdge, back - leftEdge.length + 1);\n            length = leftEdge.length - 3;\n\n            for (j = 0; j < leftEdge.length; j += 3) {\n                LR = front / 3;\n                LL = LR - 1;\n                UR = (back - 2) / 3;\n                UL = UR + 1;\n                indices[index++] = UL;\n                indices[index++] = UR;\n                indices[index++] = LL;\n                indices[index++] = LR;\n                front += 3;\n                back -= 3;\n            }\n            front -= 3;\n            back += 3;\n            wallIndices.push(front / 3, (back - 2) / 3);\n        }\n\n        if (addEndPositions) { // add rounded end\n            front += 3;\n            back -= 3;\n            leftPos = cartesian1;\n            rightPos = cartesian2;\n            var lastEndPositions = endPositions[1];\n            for (i = 0; i < halfLength; i++) {\n                leftPos = Cartesian3.fromArray(lastEndPositions, (endPositionLength - i - 1) * 3, leftPos);\n                rightPos = Cartesian3.fromArray(lastEndPositions, i * 3, rightPos);\n                CorridorGeometryLibrary.addAttribute(finalPositions, leftPos, undefined, back);\n                CorridorGeometryLibrary.addAttribute(finalPositions, rightPos, front);\n\n                LR = front / 3;\n                LL = LR - 1;\n                UR = (back - 2) / 3;\n                UL = UR + 1;\n                indices[index++] = UL;\n                indices[index++] = UR;\n                indices[index++] = LL;\n                indices[index++] = LR;\n\n                front += 3;\n                back -= 3;\n            }\n\n            wallIndices.push(front / 3);\n        } else {\n            wallIndices.push(front / 3, (back - 2) / 3);\n        }\n        indices[index++] = front / 3;\n        indices[index++] = (back - 2) / 3;\n\n        attributes.position = new GeometryAttribute({\n            componentDatatype : ComponentDatatype.DOUBLE,\n            componentsPerAttribute : 3,\n            values : finalPositions\n        });\n\n        return {\n            attributes : attributes,\n            indices : indices,\n            wallIndices : wallIndices\n        };\n    }\n\n    function computePositionsExtruded(params) {\n        var ellipsoid = params.ellipsoid;\n        var computedPositions = CorridorGeometryLibrary.computePositions(params);\n        var attr = combine(computedPositions, params.cornerType);\n        var wallIndices = attr.wallIndices;\n        var height = params.height;\n        var extrudedHeight = params.extrudedHeight;\n        var attributes = attr.attributes;\n        var indices = attr.indices;\n        var positions = attributes.position.values;\n        var length = positions.length;\n        var extrudedPositions = new Float64Array(length);\n        extrudedPositions.set(positions);\n        var newPositions = new Float64Array(length * 2);\n\n        positions = PolygonPipeline.scaleToGeodeticHeight(positions, height, ellipsoid);\n        extrudedPositions = PolygonPipeline.scaleToGeodeticHeight(extrudedPositions, extrudedHeight, ellipsoid);\n        newPositions.set(positions);\n        newPositions.set(extrudedPositions, length);\n        attributes.position.values = newPositions;\n\n        length /= 3;\n        if (defined(params.offsetAttribute)) {\n            var applyOffset = new Uint8Array(length * 2);\n            if (params.offsetAttribute === GeometryOffsetAttribute.TOP) {\n                applyOffset = arrayFill(applyOffset, 1, 0, length);\n            } else {\n                var applyOffsetValue = params.offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;\n                applyOffset = arrayFill(applyOffset, applyOffsetValue);\n            }\n\n            attributes.applyOffset = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.UNSIGNED_BYTE,\n                componentsPerAttribute : 1,\n                values: applyOffset\n            });\n        }\n\n        var i;\n        var iLength = indices.length;\n        var newIndices = IndexDatatype.createTypedArray(newPositions.length / 3, (iLength + wallIndices.length) * 2);\n        newIndices.set(indices);\n        var index = iLength;\n        for (i = 0; i < iLength; i += 2) { // bottom indices\n            var v0 = indices[i];\n            var v1 = indices[i + 1];\n            newIndices[index++] = v0 + length;\n            newIndices[index++] = v1 + length;\n        }\n\n        var UL, LL;\n        for (i = 0; i < wallIndices.length; i++) { //wall indices\n            UL = wallIndices[i];\n            LL = UL + length;\n            newIndices[index++] = UL;\n            newIndices[index++] = LL;\n        }\n\n        return {\n            attributes : attributes,\n            indices : newIndices\n        };\n    }\n\n    /**\n     * A description of a corridor outline.\n     *\n     * @alias CorridorOutlineGeometry\n     * @constructor\n     *\n     * @param {Object} options Object with the following properties:\n     * @param {Cartesian3[]} options.positions An array of positions that define the center of the corridor outline.\n     * @param {Number} options.width The distance between the edges of the corridor outline.\n     * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid to be used as a reference.\n     * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n     * @param {Number} [options.height=0] The distance in meters between the positions and the ellipsoid surface.\n     * @param {Number} [options.extrudedHeight] The distance in meters between the extruded face and the ellipsoid surface.\n     * @param {CornerType} [options.cornerType=CornerType.ROUNDED] Determines the style of the corners.\n     *\n     * @see CorridorOutlineGeometry.createGeometry\n     *\n     * @example\n     * var corridor = new Cesium.CorridorOutlineGeometry({\n     *   positions : Cesium.Cartesian3.fromDegreesArray([-72.0, 40.0, -70.0, 35.0]),\n     *   width : 100000\n     * });\n     */\n    function CorridorOutlineGeometry(options) {\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n        var positions = options.positions;\n        var width = options.width;\n\n        \n\n        var height = defaultValue(options.height, 0.0);\n        var extrudedHeight = defaultValue(options.extrudedHeight, height);\n\n        this._positions = positions;\n        this._ellipsoid = Ellipsoid.clone(defaultValue(options.ellipsoid, Ellipsoid.WGS84));\n        this._width = width;\n        this._height = Math.max(height, extrudedHeight);\n        this._extrudedHeight = Math.min(height, extrudedHeight);\n        this._cornerType = defaultValue(options.cornerType, CornerType.ROUNDED);\n        this._granularity = defaultValue(options.granularity, CesiumMath.RADIANS_PER_DEGREE);\n        this._offsetAttribute = options.offsetAttribute;\n        this._workerName = 'createCorridorOutlineGeometry';\n\n        /**\n         * The number of elements used to pack the object into an array.\n         * @type {Number}\n         */\n        this.packedLength = 1 + positions.length * Cartesian3.packedLength + Ellipsoid.packedLength + 6;\n    }\n\n    /**\n     * Stores the provided instance into the provided array.\n     *\n     * @param {CorridorOutlineGeometry} value The value to pack.\n     * @param {Number[]} array The array to pack into.\n     * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n     *\n     * @returns {Number[]} The array that was packed into\n     */\n    CorridorOutlineGeometry.pack = function(value, array, startingIndex) {\n        \n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        var positions = value._positions;\n        var length = positions.length;\n        array[startingIndex++] = length;\n\n        for (var i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {\n            Cartesian3.pack(positions[i], array, startingIndex);\n        }\n\n        Ellipsoid.pack(value._ellipsoid, array, startingIndex);\n        startingIndex += Ellipsoid.packedLength;\n\n        array[startingIndex++] = value._width;\n        array[startingIndex++] = value._height;\n        array[startingIndex++] = value._extrudedHeight;\n        array[startingIndex++] = value._cornerType;\n        array[startingIndex++] = value._granularity;\n        array[startingIndex] = defaultValue(value._offsetAttribute, -1);\n\n        return array;\n    };\n\n    var scratchEllipsoid = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);\n    var scratchOptions = {\n        positions : undefined,\n        ellipsoid : scratchEllipsoid,\n        width : undefined,\n        height : undefined,\n        extrudedHeight : undefined,\n        cornerType : undefined,\n        granularity : undefined,\n        offsetAttribute: undefined\n    };\n\n    /**\n     * Retrieves an instance from a packed array.\n     *\n     * @param {Number[]} array The packed array.\n     * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n     * @param {CorridorOutlineGeometry} [result] The object into which to store the result.\n     * @returns {CorridorOutlineGeometry} The modified result parameter or a new CorridorOutlineGeometry instance if one was not provided.\n     */\n    CorridorOutlineGeometry.unpack = function(array, startingIndex, result) {\n        \n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        var length = array[startingIndex++];\n        var positions = new Array(length);\n\n        for (var i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {\n            positions[i] = Cartesian3.unpack(array, startingIndex);\n        }\n\n        var ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);\n        startingIndex += Ellipsoid.packedLength;\n\n        var width = array[startingIndex++];\n        var height = array[startingIndex++];\n        var extrudedHeight = array[startingIndex++];\n        var cornerType = array[startingIndex++];\n        var granularity = array[startingIndex++];\n        var offsetAttribute = array[startingIndex];\n\n        if (!defined(result)) {\n            scratchOptions.positions = positions;\n            scratchOptions.width = width;\n            scratchOptions.height = height;\n            scratchOptions.extrudedHeight = extrudedHeight;\n            scratchOptions.cornerType = cornerType;\n            scratchOptions.granularity = granularity;\n            scratchOptions.offsetAttribute = offsetAttribute === -1 ? undefined : offsetAttribute;\n            return new CorridorOutlineGeometry(scratchOptions);\n        }\n\n        result._positions = positions;\n        result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);\n        result._width = width;\n        result._height = height;\n        result._extrudedHeight = extrudedHeight;\n        result._cornerType = cornerType;\n        result._granularity = granularity;\n        result._offsetAttribute = offsetAttribute === -1 ? undefined : offsetAttribute;\n\n        return result;\n    };\n\n    /**\n     * Computes the geometric representation of a corridor, including its vertices, indices, and a bounding sphere.\n     *\n     * @param {CorridorOutlineGeometry} corridorOutlineGeometry A description of the corridor.\n     * @returns {Geometry|undefined} The computed vertices and indices.\n     */\n    CorridorOutlineGeometry.createGeometry = function(corridorOutlineGeometry) {\n        var positions = corridorOutlineGeometry._positions;\n        var width = corridorOutlineGeometry._width;\n        var ellipsoid = corridorOutlineGeometry._ellipsoid;\n\n        positions = scaleToSurface(positions, ellipsoid);\n        var cleanPositions = arrayRemoveDuplicates(positions, Cartesian3.equalsEpsilon);\n\n        if ((cleanPositions.length < 2) || (width <= 0)) {\n            return;\n        }\n\n        var height = corridorOutlineGeometry._height;\n        var extrudedHeight = corridorOutlineGeometry._extrudedHeight;\n        var extrude = !CesiumMath.equalsEpsilon(height, extrudedHeight, 0, CesiumMath.EPSILON2);\n\n        var params = {\n            ellipsoid : ellipsoid,\n            positions : cleanPositions,\n            width : width,\n            cornerType : corridorOutlineGeometry._cornerType,\n            granularity : corridorOutlineGeometry._granularity,\n            saveAttributes : false\n        };\n        var attr;\n        if (extrude) {\n            params.height = height;\n            params.extrudedHeight = extrudedHeight;\n            params.offsetAttribute = corridorOutlineGeometry._offsetAttribute;\n            attr = computePositionsExtruded(params);\n        } else {\n            var computedPositions = CorridorGeometryLibrary.computePositions(params);\n            attr = combine(computedPositions, params.cornerType);\n            attr.attributes.position.values = PolygonPipeline.scaleToGeodeticHeight(attr.attributes.position.values, height, ellipsoid);\n\n            if (defined(corridorOutlineGeometry._offsetAttribute)) {\n                var length = attr.attributes.position.values.length;\n                var applyOffset = new Uint8Array(length / 3);\n                var offsetValue = corridorOutlineGeometry._offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;\n                arrayFill(applyOffset, offsetValue);\n                attr.attributes.applyOffset = new GeometryAttribute({\n                    componentDatatype : ComponentDatatype.UNSIGNED_BYTE,\n                    componentsPerAttribute : 1,\n                    values: applyOffset\n                });\n            }\n        }\n        var attributes = attr.attributes;\n        var boundingSphere = BoundingSphere.fromVertices(attributes.position.values, undefined, 3);\n\n        return new Geometry({\n            attributes : attributes,\n            indices : attr.indices,\n            primitiveType : PrimitiveType.LINES,\n            boundingSphere : boundingSphere,\n            offsetAttribute : corridorOutlineGeometry._offsetAttribute\n        });\n    };\nexport default CorridorOutlineGeometry;\n","import Check from '../Core/Check.js';\nimport defaultValue from '../Core/defaultValue.js';\nimport defined from '../Core/defined.js';\nimport defineProperties from '../Core/defineProperties.js';\nimport DeveloperError from '../Core/DeveloperError.js';\nimport GeometryOffsetAttribute from '../Core/GeometryOffsetAttribute.js';\nimport oneTimeWarning from '../Core/oneTimeWarning.js';\nimport GroundPrimitive from '../Scene/GroundPrimitive.js';\nimport HeightReference from '../Scene/HeightReference.js';\nimport CallbackProperty from './CallbackProperty.js';\nimport ConstantProperty from './ConstantProperty.js';\nimport GeometryUpdater from './GeometryUpdater.js';\nimport TerrainOffsetProperty from './TerrainOffsetProperty.js';\n\n    var defaultZIndex = new ConstantProperty(0);\n\n    /**\n     * An abstract class for updating ground geometry entities.\n     * @constructor\n     * @alias GroundGeometryUpdater\n     * @param {Object} options An object with the following properties:\n     * @param {Entity} options.entity The entity containing the geometry to be visualized.\n     * @param {Scene} options.scene The scene where visualization is taking place.\n     * @param {Object} options.geometryOptions Options for the geometry\n     * @param {String} options.geometryPropertyName The geometry property name\n     * @param {String[]} options.observedPropertyNames The entity properties this geometry cares about\n     */\n    function GroundGeometryUpdater(options) {\n        GeometryUpdater.call(this, options);\n\n        this._zIndex = 0;\n        this._terrainOffsetProperty = undefined;\n    }\n\n    if (defined(Object.create)) {\n        GroundGeometryUpdater.prototype = Object.create(GeometryUpdater.prototype);\n        GroundGeometryUpdater.prototype.constructor = GroundGeometryUpdater;\n    }\n\n    defineProperties(GroundGeometryUpdater.prototype, {\n        /**\n         * Gets the zindex\n         * @type {Number}\n         * @memberof GroundGeometryUpdater.prototype\n         * @readonly\n         */\n        zIndex: {\n            get: function() {\n                return this._zIndex;\n            }\n        },\n\n        /**\n         * Gets the terrain offset property\n         * @type {TerrainOffsetProperty}\n         * @memberof GroundGeometryUpdater.prototype\n         * @readonly\n         */\n        terrainOffsetProperty: {\n            get: function() {\n                return this._terrainOffsetProperty;\n            }\n        }\n    });\n\n    GroundGeometryUpdater.prototype._isOnTerrain = function(entity, geometry) {\n        return this._fillEnabled && !defined(geometry.height) && !defined(geometry.extrudedHeight) && GroundPrimitive.isSupported(this._scene);\n    };\n\n    GroundGeometryUpdater.prototype._getIsClosed = function(options) {\n        var height = options.height;\n        var extrudedHeight = options.extrudedHeight;\n        return height === 0 || (defined(extrudedHeight) && extrudedHeight !== height);\n    };\n\n    GroundGeometryUpdater.prototype._computeCenter = DeveloperError.throwInstantiationError;\n\n    GroundGeometryUpdater.prototype._onEntityPropertyChanged = function(entity, propertyName, newValue, oldValue) {\n        GeometryUpdater.prototype._onEntityPropertyChanged.call(this, entity, propertyName, newValue, oldValue);\n        if (this._observedPropertyNames.indexOf(propertyName) === -1) {\n            return;\n        }\n\n        var geometry = this._entity[this._geometryPropertyName];\n        if (!defined(geometry)) {\n            return;\n        }\n        if (defined(geometry.zIndex) && (defined(geometry.height) || defined(geometry.extrudedHeight))) {\n            oneTimeWarning(oneTimeWarning.geometryZIndex);\n        }\n\n        this._zIndex = defaultValue(geometry.zIndex, defaultZIndex);\n\n        if (defined(this._terrainOffsetProperty)) {\n            this._terrainOffsetProperty.destroy();\n            this._terrainOffsetProperty = undefined;\n        }\n\n        var heightReferenceProperty = geometry.heightReference;\n        var extrudedHeightReferenceProperty = geometry.extrudedHeightReference;\n\n        if (defined(heightReferenceProperty) || defined(extrudedHeightReferenceProperty)) {\n            var centerPosition = new CallbackProperty(this._computeCenter.bind(this), !this._dynamic);\n            this._terrainOffsetProperty = new TerrainOffsetProperty(this._scene, centerPosition, heightReferenceProperty, extrudedHeightReferenceProperty);\n        }\n    };\n\n    /**\n     * Destroys and resources used by the object.  Once an object is destroyed, it should not be used.\n     *\n     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n     */\n    GroundGeometryUpdater.prototype.destroy = function() {\n        if (defined(this._terrainOffsetProperty)) {\n            this._terrainOffsetProperty.destroy();\n            this._terrainOffsetProperty = undefined;\n        }\n\n        GeometryUpdater.prototype.destroy.call(this);\n    };\n\n    /**\n     * @private\n     */\n    GroundGeometryUpdater.getGeometryHeight = function(height, heightReference) {\n        \n        if (!defined(height)) {\n            if (heightReference !== HeightReference.NONE) {\n                oneTimeWarning(oneTimeWarning.geometryHeightReference);\n            }\n            return;\n        }\n\n        if (heightReference !== HeightReference.CLAMP_TO_GROUND) {\n            return height;\n        }\n        return 0.0;\n    };\n\n    /**\n     * @private\n     */\n    GroundGeometryUpdater.getGeometryExtrudedHeight = function(extrudedHeight, extrudedHeightReference) {\n        \n        if (!defined(extrudedHeight)) {\n            if (extrudedHeightReference !== HeightReference.NONE) {\n                oneTimeWarning(oneTimeWarning.geometryExtrudedHeightReference);\n            }\n            return;\n        }\n        if (extrudedHeightReference !== HeightReference.CLAMP_TO_GROUND) {\n            return extrudedHeight;\n        }\n\n        return GroundGeometryUpdater.CLAMP_TO_GROUND;\n    };\n\n    /**\n     * @private\n     */\n    GroundGeometryUpdater.CLAMP_TO_GROUND = 'clamp';\n\n    /**\n     * @private\n     */\n    GroundGeometryUpdater.computeGeometryOffsetAttribute = function(height, heightReference, extrudedHeight, extrudedHeightReference) {\n        if (!defined(height) || !defined(heightReference)) {\n            heightReference = HeightReference.NONE;\n        }\n        if (!defined(extrudedHeight) || !defined(extrudedHeightReference)) {\n            extrudedHeightReference = HeightReference.NONE;\n        }\n        var n = 0;\n        if (heightReference !== HeightReference.NONE) {\n            n++;\n        }\n        if (extrudedHeightReference === HeightReference.RELATIVE_TO_GROUND) {\n            n++;\n        }\n        if (n === 2) {\n            return GeometryOffsetAttribute.ALL;\n        }\n        if (n === 1) {\n            return GeometryOffsetAttribute.TOP;\n        }\n\n        return undefined;\n    };\nexport default GroundGeometryUpdater;\n","import ApproximateTerrainHeights from '../Core/ApproximateTerrainHeights.js';\nimport Cartesian3 from '../Core/Cartesian3.js';\nimport Check from '../Core/Check.js';\nimport Color from '../Core/Color.js';\nimport ColorGeometryInstanceAttribute from '../Core/ColorGeometryInstanceAttribute.js';\nimport CorridorGeometry from '../Core/CorridorGeometry.js';\nimport CorridorOutlineGeometry from '../Core/CorridorOutlineGeometry.js';\nimport defined from '../Core/defined.js';\nimport DeveloperError from '../Core/DeveloperError.js';\nimport DistanceDisplayConditionGeometryInstanceAttribute from '../Core/DistanceDisplayConditionGeometryInstanceAttribute.js';\nimport GeometryInstance from '../Core/GeometryInstance.js';\nimport Iso8601 from '../Core/Iso8601.js';\nimport OffsetGeometryInstanceAttribute from '../Core/OffsetGeometryInstanceAttribute.js';\nimport Rectangle from '../Core/Rectangle.js';\nimport ShowGeometryInstanceAttribute from '../Core/ShowGeometryInstanceAttribute.js';\nimport HeightReference from '../Scene/HeightReference.js';\nimport MaterialAppearance from '../Scene/MaterialAppearance.js';\nimport PerInstanceColorAppearance from '../Scene/PerInstanceColorAppearance.js';\nimport ColorMaterialProperty from './ColorMaterialProperty.js';\nimport DynamicGeometryUpdater from './DynamicGeometryUpdater.js';\nimport GeometryUpdater from './GeometryUpdater.js';\nimport GroundGeometryUpdater from './GroundGeometryUpdater.js';\nimport Property from './Property.js';\n\n    var scratchColor = new Color();\n    var defaultOffset = Cartesian3.ZERO;\n    var offsetScratch = new Cartesian3();\n    var scratchRectangle = new Rectangle();\n\n    function CorridorGeometryOptions(entity) {\n        this.id = entity;\n        this.vertexFormat = undefined;\n        this.positions = undefined;\n        this.width = undefined;\n        this.cornerType = undefined;\n        this.height = undefined;\n        this.extrudedHeight = undefined;\n        this.granularity = undefined;\n        this.offsetAttribute = undefined;\n    }\n\n    /**\n     * A {@link GeometryUpdater} for corridors.\n     * Clients do not normally create this class directly, but instead rely on {@link DataSourceDisplay}.\n     * @alias CorridorGeometryUpdater\n     * @constructor\n     *\n     * @param {Entity} entity The entity containing the geometry to be visualized.\n     * @param {Scene} scene The scene where visualization is taking place.\n     */\n    function CorridorGeometryUpdater(entity, scene) {\n        GroundGeometryUpdater.call(this, {\n            entity : entity,\n            scene : scene,\n            geometryOptions : new CorridorGeometryOptions(entity),\n            geometryPropertyName : 'corridor',\n            observedPropertyNames : ['availability', 'corridor']\n        });\n\n        this._onEntityPropertyChanged(entity, 'corridor', entity.corridor, undefined);\n    }\n\n    if (defined(Object.create)) {\n        CorridorGeometryUpdater.prototype = Object.create(GroundGeometryUpdater.prototype);\n        CorridorGeometryUpdater.prototype.constructor = CorridorGeometryUpdater;\n    }\n\n    /**\n     * Creates the geometry instance which represents the fill of the geometry.\n     *\n     * @param {JulianDate} time The time to use when retrieving initial attribute values.\n     * @returns {GeometryInstance} The geometry instance representing the filled portion of the geometry.\n     *\n     * @exception {DeveloperError} This instance does not represent a filled geometry.\n     */\n    CorridorGeometryUpdater.prototype.createFillGeometryInstance = function(time) {\n        \n\n        var entity = this._entity;\n        var isAvailable = entity.isAvailable(time);\n\n        var attributes = {\n            show : new ShowGeometryInstanceAttribute(isAvailable && entity.isShowing && this._showProperty.getValue(time) && this._fillProperty.getValue(time)),\n            distanceDisplayCondition : DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(this._distanceDisplayConditionProperty.getValue(time)),\n            offset : undefined,\n            color : undefined\n        };\n\n        if (this._materialProperty instanceof ColorMaterialProperty) {\n            var currentColor;\n            if (defined(this._materialProperty.color) && (this._materialProperty.color.isConstant || isAvailable)) {\n                currentColor = this._materialProperty.color.getValue(time, scratchColor);\n            }\n            if (!defined(currentColor)) {\n                currentColor = Color.WHITE;\n            }\n            attributes.color = ColorGeometryInstanceAttribute.fromColor(currentColor);\n        }\n\n        if (defined(this._options.offsetAttribute)) {\n            attributes.offset = OffsetGeometryInstanceAttribute.fromCartesian3(Property.getValueOrDefault(this._terrainOffsetProperty, time, defaultOffset, offsetScratch));\n        }\n\n        return new GeometryInstance({\n            id : entity,\n            geometry : new CorridorGeometry(this._options),\n            attributes : attributes\n        });\n    };\n\n    /**\n     * Creates the geometry instance which represents the outline of the geometry.\n     *\n     * @param {JulianDate} time The time to use when retrieving initial attribute values.\n     * @returns {GeometryInstance} The geometry instance representing the outline portion of the geometry.\n     *\n     * @exception {DeveloperError} This instance does not represent an outlined geometry.\n     */\n    CorridorGeometryUpdater.prototype.createOutlineGeometryInstance = function(time) {\n        \n\n        var entity = this._entity;\n        var isAvailable = entity.isAvailable(time);\n        var outlineColor = Property.getValueOrDefault(this._outlineColorProperty, time, Color.BLACK, scratchColor);\n\n        var attributes = {\n            show : new ShowGeometryInstanceAttribute(isAvailable && entity.isShowing && this._showProperty.getValue(time) && this._showOutlineProperty.getValue(time)),\n            color : ColorGeometryInstanceAttribute.fromColor(outlineColor),\n            distanceDisplayCondition : DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(this._distanceDisplayConditionProperty.getValue(time)),\n            offset : undefined\n        };\n\n        if (defined(this._options.offsetAttribute)) {\n            attributes.offset = OffsetGeometryInstanceAttribute.fromCartesian3(Property.getValueOrDefault(this._terrainOffsetProperty, time, defaultOffset, offsetScratch));\n        }\n\n        return new GeometryInstance({\n            id : entity,\n            geometry : new CorridorOutlineGeometry(this._options),\n            attributes : attributes\n        });\n    };\n\n    CorridorGeometryUpdater.prototype._computeCenter = function(time, result) {\n        var positions = Property.getValueOrUndefined(this._entity.corridor.positions, time);\n        if (!defined(positions) || positions.length === 0) {\n            return;\n        }\n        return Cartesian3.clone(positions[Math.floor(positions.length / 2.0)], result);\n    };\n\n    CorridorGeometryUpdater.prototype._isHidden = function(entity, corridor) {\n        return !defined(corridor.positions) || !defined(corridor.width) || GeometryUpdater.prototype._isHidden.call(this, entity, corridor);\n    };\n\n    CorridorGeometryUpdater.prototype._isDynamic = function(entity, corridor) {\n        return !corridor.positions.isConstant || //\n               !Property.isConstant(corridor.height) || //\n               !Property.isConstant(corridor.extrudedHeight) || //\n               !Property.isConstant(corridor.granularity) || //\n               !Property.isConstant(corridor.width) || //\n               !Property.isConstant(corridor.outlineWidth) || //\n               !Property.isConstant(corridor.cornerType) || //\n               !Property.isConstant(corridor.zIndex) || //\n               (this._onTerrain && !Property.isConstant(this._materialProperty));\n    };\n\n    CorridorGeometryUpdater.prototype._setStaticOptions = function(entity, corridor) {\n        var heightValue = Property.getValueOrUndefined(corridor.height, Iso8601.MINIMUM_VALUE);\n        var heightReferenceValue = Property.getValueOrDefault(corridor.heightReference, Iso8601.MINIMUM_VALUE, HeightReference.NONE);\n        var extrudedHeightValue = Property.getValueOrUndefined(corridor.extrudedHeight, Iso8601.MINIMUM_VALUE);\n        var extrudedHeightReferenceValue = Property.getValueOrDefault(corridor.extrudedHeightReference, Iso8601.MINIMUM_VALUE, HeightReference.NONE);\n        if (defined(extrudedHeightValue) && !defined(heightValue)) {\n            heightValue = 0;\n        }\n\n        var options = this._options;\n        options.vertexFormat = (this._materialProperty instanceof ColorMaterialProperty) ? PerInstanceColorAppearance.VERTEX_FORMAT : MaterialAppearance.MaterialSupport.TEXTURED.vertexFormat;\n        options.positions = corridor.positions.getValue(Iso8601.MINIMUM_VALUE, options.positions);\n        options.width = corridor.width.getValue(Iso8601.MINIMUM_VALUE);\n        options.granularity = Property.getValueOrUndefined(corridor.granularity, Iso8601.MINIMUM_VALUE);\n        options.cornerType = Property.getValueOrUndefined(corridor.cornerType, Iso8601.MINIMUM_VALUE);\n        options.offsetAttribute = GroundGeometryUpdater.computeGeometryOffsetAttribute(heightValue, heightReferenceValue, extrudedHeightValue, extrudedHeightReferenceValue);\n        options.height = GroundGeometryUpdater.getGeometryHeight(heightValue, heightReferenceValue);\n\n        extrudedHeightValue = GroundGeometryUpdater.getGeometryExtrudedHeight(extrudedHeightValue, extrudedHeightReferenceValue);\n        if (extrudedHeightValue === GroundGeometryUpdater.CLAMP_TO_GROUND) {\n            extrudedHeightValue = ApproximateTerrainHeights.getMinimumMaximumHeights(CorridorGeometry.computeRectangle(options, scratchRectangle)).minimumTerrainHeight;\n        }\n\n        options.extrudedHeight = extrudedHeightValue;\n    };\n\n    CorridorGeometryUpdater.DynamicGeometryUpdater = DynamicCorridorGeometryUpdater;\n\n    /**\n     * @private\n     */\n    function DynamicCorridorGeometryUpdater(geometryUpdater, primitives, groundPrimitives) {\n        DynamicGeometryUpdater.call(this, geometryUpdater, primitives, groundPrimitives);\n    }\n\n    if (defined(Object.create)) {\n        DynamicCorridorGeometryUpdater.prototype = Object.create(DynamicGeometryUpdater.prototype);\n        DynamicCorridorGeometryUpdater.prototype.constructor = DynamicCorridorGeometryUpdater;\n    }\n\n    DynamicCorridorGeometryUpdater.prototype._isHidden = function(entity, corridor, time) {\n        var options = this._options;\n        return !defined(options.positions) || !defined(options.width) || DynamicGeometryUpdater.prototype._isHidden.call(this, entity, corridor, time);\n    };\n\n    DynamicCorridorGeometryUpdater.prototype._setOptions = function(entity, corridor, time) {\n        var options = this._options;\n        var heightValue = Property.getValueOrUndefined(corridor.height, time);\n        var heightReferenceValue = Property.getValueOrDefault(corridor.heightReference, time, HeightReference.NONE);\n        var extrudedHeightValue = Property.getValueOrUndefined(corridor.extrudedHeight, time);\n        var extrudedHeightReferenceValue = Property.getValueOrDefault(corridor.extrudedHeightReference, time, HeightReference.NONE);\n        if (defined(extrudedHeightValue) && !defined(heightValue)) {\n            heightValue = 0;\n        }\n\n        options.positions = Property.getValueOrUndefined(corridor.positions, time);\n        options.width = Property.getValueOrUndefined(corridor.width, time);\n        options.granularity = Property.getValueOrUndefined(corridor.granularity, time);\n        options.cornerType = Property.getValueOrUndefined(corridor.cornerType, time);\n        options.offsetAttribute = GroundGeometryUpdater.computeGeometryOffsetAttribute(heightValue, heightReferenceValue, extrudedHeightValue, extrudedHeightReferenceValue);\n        options.height = GroundGeometryUpdater.getGeometryHeight(heightValue, heightReferenceValue);\n\n        extrudedHeightValue = GroundGeometryUpdater.getGeometryExtrudedHeight(extrudedHeightValue, extrudedHeightReferenceValue);\n        if (extrudedHeightValue === GroundGeometryUpdater.CLAMP_TO_GROUND) {\n            extrudedHeightValue = ApproximateTerrainHeights.getMinimumMaximumHeights(CorridorGeometry.computeRectangle(options, scratchRectangle)).minimumTerrainHeight;\n        }\n\n        options.extrudedHeight = extrudedHeightValue;\n    };\nexport default CorridorGeometryUpdater;\n","import CesiumMath from './Math.js';\n\n    /**\n     * @private\n     */\n    var CylinderGeometryLibrary = {};\n\n    /**\n     * @private\n     */\n    CylinderGeometryLibrary.computePositions = function(length, topRadius, bottomRadius, slices, fill){\n        var topZ = length * 0.5;\n        var bottomZ = -topZ;\n\n        var twoSlice = slices + slices;\n        var size = (fill) ? 2 * twoSlice : twoSlice;\n        var positions = new Float64Array(size*3);\n        var i;\n        var index = 0;\n        var tbIndex = 0;\n        var bottomOffset = (fill) ? twoSlice*3 : 0;\n        var topOffset = (fill) ? (twoSlice + slices)*3 : slices*3;\n\n        for (i = 0; i < slices; i++) {\n            var angle = i / slices * CesiumMath.TWO_PI;\n            var x = Math.cos(angle);\n            var y = Math.sin(angle);\n            var bottomX = x * bottomRadius;\n            var bottomY = y * bottomRadius;\n            var topX = x * topRadius;\n            var topY = y * topRadius;\n\n            positions[tbIndex + bottomOffset] = bottomX;\n            positions[tbIndex + bottomOffset + 1] = bottomY;\n            positions[tbIndex + bottomOffset + 2] = bottomZ;\n\n            positions[tbIndex + topOffset] = topX;\n            positions[tbIndex + topOffset + 1] = topY;\n            positions[tbIndex + topOffset + 2] = topZ;\n            tbIndex += 3;\n            if (fill) {\n                positions[index++] = bottomX;\n                positions[index++] = bottomY;\n                positions[index++] = bottomZ;\n                positions[index++] = topX;\n                positions[index++] = topY;\n                positions[index++] = topZ;\n            }\n        }\n\n        return positions;\n    };\nexport default CylinderGeometryLibrary;\n","import arrayFill from './arrayFill.js';\nimport BoundingSphere from './BoundingSphere.js';\nimport Cartesian2 from './Cartesian2.js';\nimport Cartesian3 from './Cartesian3.js';\nimport ComponentDatatype from './ComponentDatatype.js';\nimport CylinderGeometryLibrary from './CylinderGeometryLibrary.js';\nimport defaultValue from './defaultValue.js';\nimport defined from './defined.js';\nimport DeveloperError from './DeveloperError.js';\nimport Geometry from './Geometry.js';\nimport GeometryAttribute from './GeometryAttribute.js';\nimport GeometryAttributes from './GeometryAttributes.js';\nimport GeometryOffsetAttribute from './GeometryOffsetAttribute.js';\nimport IndexDatatype from './IndexDatatype.js';\nimport CesiumMath from './Math.js';\nimport PrimitiveType from './PrimitiveType.js';\nimport VertexFormat from './VertexFormat.js';\n\n    var radiusScratch = new Cartesian2();\n    var normalScratch = new Cartesian3();\n    var bitangentScratch = new Cartesian3();\n    var tangentScratch = new Cartesian3();\n    var positionScratch = new Cartesian3();\n\n    /**\n     * A description of a cylinder.\n     *\n     * @alias CylinderGeometry\n     * @constructor\n     *\n     * @param {Object} options Object with the following properties:\n     * @param {Number} options.length The length of the cylinder.\n     * @param {Number} options.topRadius The radius of the top of the cylinder.\n     * @param {Number} options.bottomRadius The radius of the bottom of the cylinder.\n     * @param {Number} [options.slices=128] The number of edges around the perimeter of the cylinder.\n     * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\n     *\n     * @exception {DeveloperError} options.slices must be greater than or equal to 3.\n     *\n     * @see CylinderGeometry.createGeometry\n     *\n     * @example\n     * // create cylinder geometry\n     * var cylinder = new Cesium.CylinderGeometry({\n     *     length: 200000,\n     *     topRadius: 80000,\n     *     bottomRadius: 200000,\n     * });\n     * var geometry = Cesium.CylinderGeometry.createGeometry(cylinder);\n     */\n    function CylinderGeometry(options) {\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n        var length = options.length;\n        var topRadius = options.topRadius;\n        var bottomRadius = options.bottomRadius;\n        var vertexFormat = defaultValue(options.vertexFormat, VertexFormat.DEFAULT);\n        var slices = defaultValue(options.slices, 128);\n\n        \n\n        this._length = length;\n        this._topRadius = topRadius;\n        this._bottomRadius = bottomRadius;\n        this._vertexFormat = VertexFormat.clone(vertexFormat);\n        this._slices = slices;\n        this._offsetAttribute = options.offsetAttribute;\n        this._workerName = 'createCylinderGeometry';\n    }\n\n    /**\n     * The number of elements used to pack the object into an array.\n     * @type {Number}\n     */\n    CylinderGeometry.packedLength = VertexFormat.packedLength + 5;\n\n    /**\n     * Stores the provided instance into the provided array.\n     *\n     * @param {CylinderGeometry} value The value to pack.\n     * @param {Number[]} array The array to pack into.\n     * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n     *\n     * @returns {Number[]} The array that was packed into\n     */\n    CylinderGeometry.pack = function(value, array, startingIndex) {\n        \n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        VertexFormat.pack(value._vertexFormat, array, startingIndex);\n        startingIndex += VertexFormat.packedLength;\n\n        array[startingIndex++] = value._length;\n        array[startingIndex++] = value._topRadius;\n        array[startingIndex++] = value._bottomRadius;\n        array[startingIndex++] = value._slices;\n        array[startingIndex] = defaultValue(value._offsetAttribute, -1);\n\n        return array;\n    };\n\n    var scratchVertexFormat = new VertexFormat();\n    var scratchOptions = {\n        vertexFormat : scratchVertexFormat,\n        length : undefined,\n        topRadius : undefined,\n        bottomRadius : undefined,\n        slices : undefined,\n        offsetAttribute : undefined\n    };\n\n    /**\n     * Retrieves an instance from a packed array.\n     *\n     * @param {Number[]} array The packed array.\n     * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n     * @param {CylinderGeometry} [result] The object into which to store the result.\n     * @returns {CylinderGeometry} The modified result parameter or a new CylinderGeometry instance if one was not provided.\n     */\n    CylinderGeometry.unpack = function(array, startingIndex, result) {\n        \n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        var vertexFormat = VertexFormat.unpack(array, startingIndex, scratchVertexFormat);\n        startingIndex += VertexFormat.packedLength;\n\n        var length = array[startingIndex++];\n        var topRadius = array[startingIndex++];\n        var bottomRadius = array[startingIndex++];\n        var slices = array[startingIndex++];\n        var offsetAttribute = array[startingIndex];\n\n        if (!defined(result)) {\n            scratchOptions.length = length;\n            scratchOptions.topRadius = topRadius;\n            scratchOptions.bottomRadius = bottomRadius;\n            scratchOptions.slices = slices;\n            scratchOptions.offsetAttribute = offsetAttribute === -1 ? undefined : offsetAttribute;\n            return new CylinderGeometry(scratchOptions);\n        }\n\n        result._vertexFormat = VertexFormat.clone(vertexFormat, result._vertexFormat);\n        result._length = length;\n        result._topRadius = topRadius;\n        result._bottomRadius = bottomRadius;\n        result._slices = slices;\n        result._offsetAttribute = offsetAttribute === -1 ? undefined : offsetAttribute;\n\n        return result;\n    };\n\n    /**\n     * Computes the geometric representation of a cylinder, including its vertices, indices, and a bounding sphere.\n     *\n     * @param {CylinderGeometry} cylinderGeometry A description of the cylinder.\n     * @returns {Geometry|undefined} The computed vertices and indices.\n     */\n    CylinderGeometry.createGeometry = function(cylinderGeometry) {\n        var length = cylinderGeometry._length;\n        var topRadius = cylinderGeometry._topRadius;\n        var bottomRadius = cylinderGeometry._bottomRadius;\n        var vertexFormat = cylinderGeometry._vertexFormat;\n        var slices = cylinderGeometry._slices;\n\n        if ((length <= 0) || (topRadius < 0) || (bottomRadius < 0) || ((topRadius === 0) && (bottomRadius === 0))) {\n            return;\n        }\n\n        var twoSlices = slices + slices;\n        var threeSlices = slices + twoSlices;\n        var numVertices = twoSlices + twoSlices;\n\n        var positions = CylinderGeometryLibrary.computePositions(length, topRadius, bottomRadius, slices, true);\n\n        var st = (vertexFormat.st) ? new Float32Array(numVertices * 2) : undefined;\n        var normals = (vertexFormat.normal) ? new Float32Array(numVertices * 3) : undefined;\n        var tangents = (vertexFormat.tangent) ? new Float32Array(numVertices * 3) : undefined;\n        var bitangents = (vertexFormat.bitangent) ? new Float32Array(numVertices * 3) : undefined;\n\n        var i;\n        var computeNormal = (vertexFormat.normal || vertexFormat.tangent || vertexFormat.bitangent);\n\n        if (computeNormal) {\n            var computeTangent = (vertexFormat.tangent || vertexFormat.bitangent);\n\n            var normalIndex = 0;\n            var tangentIndex = 0;\n            var bitangentIndex = 0;\n\n            var theta = Math.atan2(bottomRadius - topRadius, length);\n            var normal = normalScratch;\n            normal.z = Math.sin(theta);\n            var normalScale = Math.cos(theta);\n            var tangent = tangentScratch;\n            var bitangent = bitangentScratch;\n\n            for (i = 0; i < slices; i++) {\n                var angle = i / slices * CesiumMath.TWO_PI;\n                var x = normalScale * Math.cos(angle);\n                var y = normalScale * Math.sin(angle);\n                if (computeNormal) {\n                    normal.x = x;\n                    normal.y = y;\n\n                    if (computeTangent) {\n                        tangent = Cartesian3.normalize(Cartesian3.cross(Cartesian3.UNIT_Z, normal, tangent), tangent);\n                    }\n\n                    if (vertexFormat.normal) {\n                        normals[normalIndex++] = normal.x;\n                        normals[normalIndex++] = normal.y;\n                        normals[normalIndex++] = normal.z;\n                        normals[normalIndex++] = normal.x;\n                        normals[normalIndex++] = normal.y;\n                        normals[normalIndex++] = normal.z;\n                    }\n\n                    if (vertexFormat.tangent) {\n                        tangents[tangentIndex++] = tangent.x;\n                        tangents[tangentIndex++] = tangent.y;\n                        tangents[tangentIndex++] = tangent.z;\n                        tangents[tangentIndex++] = tangent.x;\n                        tangents[tangentIndex++] = tangent.y;\n                        tangents[tangentIndex++] = tangent.z;\n                    }\n\n                    if (vertexFormat.bitangent) {\n                        bitangent = Cartesian3.normalize(Cartesian3.cross(normal, tangent, bitangent), bitangent);\n                        bitangents[bitangentIndex++] = bitangent.x;\n                        bitangents[bitangentIndex++] = bitangent.y;\n                        bitangents[bitangentIndex++] = bitangent.z;\n                        bitangents[bitangentIndex++] = bitangent.x;\n                        bitangents[bitangentIndex++] = bitangent.y;\n                        bitangents[bitangentIndex++] = bitangent.z;\n                    }\n                }\n            }\n\n            for (i = 0; i < slices; i++) {\n                if (vertexFormat.normal) {\n                    normals[normalIndex++] = 0;\n                    normals[normalIndex++] = 0;\n                    normals[normalIndex++] = -1;\n                }\n                if (vertexFormat.tangent) {\n                    tangents[tangentIndex++] = 1;\n                    tangents[tangentIndex++] = 0;\n                    tangents[tangentIndex++] = 0;\n                }\n                if (vertexFormat.bitangent) {\n                    bitangents[bitangentIndex++] = 0;\n                    bitangents[bitangentIndex++] = -1;\n                    bitangents[bitangentIndex++] = 0;\n                }\n            }\n\n            for (i = 0; i < slices; i++) {\n                if (vertexFormat.normal) {\n                    normals[normalIndex++] = 0;\n                    normals[normalIndex++] = 0;\n                    normals[normalIndex++] = 1;\n                }\n                if (vertexFormat.tangent) {\n                    tangents[tangentIndex++] = 1;\n                    tangents[tangentIndex++] = 0;\n                    tangents[tangentIndex++] = 0;\n                }\n                if (vertexFormat.bitangent) {\n                    bitangents[bitangentIndex++] = 0;\n                    bitangents[bitangentIndex++] = 1;\n                    bitangents[bitangentIndex++] = 0;\n                }\n            }\n        }\n\n        var numIndices = 12 * slices - 12;\n        var indices = IndexDatatype.createTypedArray(numVertices, numIndices);\n        var index = 0;\n        var j = 0;\n        for (i = 0; i < slices - 1; i++) {\n            indices[index++] = j;\n            indices[index++] = j + 2;\n            indices[index++] = j + 3;\n\n            indices[index++] = j;\n            indices[index++] = j + 3;\n            indices[index++] = j + 1;\n\n            j += 2;\n        }\n\n        indices[index++] = twoSlices - 2;\n        indices[index++] = 0;\n        indices[index++] = 1;\n        indices[index++] = twoSlices - 2;\n        indices[index++] = 1;\n        indices[index++] = twoSlices - 1;\n\n        for (i = 1; i < slices - 1; i++) {\n            indices[index++] = twoSlices + i + 1;\n            indices[index++] = twoSlices + i;\n            indices[index++] = twoSlices;\n        }\n\n        for (i = 1; i < slices - 1; i++) {\n            indices[index++] = threeSlices;\n            indices[index++] = threeSlices + i;\n            indices[index++] = threeSlices + i + 1;\n        }\n\n        var textureCoordIndex = 0;\n        if (vertexFormat.st) {\n            var rad = Math.max(topRadius, bottomRadius);\n            for (i = 0; i < numVertices; i++) {\n                var position = Cartesian3.fromArray(positions, i * 3, positionScratch);\n                st[textureCoordIndex++] = (position.x + rad) / (2.0 * rad);\n                st[textureCoordIndex++] = (position.y + rad) / (2.0 * rad);\n            }\n        }\n\n        var attributes = new GeometryAttributes();\n        if (vertexFormat.position) {\n            attributes.position = new GeometryAttribute({\n                componentDatatype: ComponentDatatype.DOUBLE,\n                componentsPerAttribute: 3,\n                values: positions\n            });\n        }\n\n        if (vertexFormat.normal) {\n            attributes.normal = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.FLOAT,\n                componentsPerAttribute : 3,\n                values : normals\n            });\n        }\n\n        if (vertexFormat.tangent) {\n            attributes.tangent = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.FLOAT,\n                componentsPerAttribute : 3,\n                values : tangents\n            });\n        }\n\n        if (vertexFormat.bitangent) {\n            attributes.bitangent = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.FLOAT,\n                componentsPerAttribute : 3,\n                values : bitangents\n            });\n        }\n\n        if (vertexFormat.st) {\n            attributes.st = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.FLOAT,\n                componentsPerAttribute : 2,\n                values : st\n            });\n        }\n\n        radiusScratch.x = length * 0.5;\n        radiusScratch.y = Math.max(bottomRadius, topRadius);\n\n        var boundingSphere = new BoundingSphere(Cartesian3.ZERO, Cartesian2.magnitude(radiusScratch));\n\n        if (defined(cylinderGeometry._offsetAttribute)) {\n            length = positions.length;\n            var applyOffset = new Uint8Array(length / 3);\n            var offsetValue = cylinderGeometry._offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;\n            arrayFill(applyOffset, offsetValue);\n            attributes.applyOffset = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.UNSIGNED_BYTE,\n                componentsPerAttribute : 1,\n                values: applyOffset\n            });\n        }\n\n        return new Geometry({\n            attributes : attributes,\n            indices : indices,\n            primitiveType : PrimitiveType.TRIANGLES,\n            boundingSphere : boundingSphere,\n            offsetAttribute : cylinderGeometry._offsetAttribute\n        });\n    };\n\n    var unitCylinderGeometry;\n\n    /**\n     * Returns the geometric representation of a unit cylinder, including its vertices, indices, and a bounding sphere.\n     * @returns {Geometry} The computed vertices and indices.\n     *\n     * @private\n     */\n    CylinderGeometry.getUnitCylinder = function() {\n        if (!defined(unitCylinderGeometry)) {\n            unitCylinderGeometry = CylinderGeometry.createGeometry(new CylinderGeometry({\n                topRadius : 1.0,\n                bottomRadius : 1.0,\n                length : 1.0,\n                vertexFormat : VertexFormat.POSITION_ONLY\n            }));\n        }\n        return unitCylinderGeometry;\n    };\nexport default CylinderGeometry;\n","import arrayFill from './arrayFill.js';\nimport BoundingSphere from './BoundingSphere.js';\nimport Cartesian2 from './Cartesian2.js';\nimport Cartesian3 from './Cartesian3.js';\nimport Check from './Check.js';\nimport ComponentDatatype from './ComponentDatatype.js';\nimport CylinderGeometryLibrary from './CylinderGeometryLibrary.js';\nimport defaultValue from './defaultValue.js';\nimport defined from './defined.js';\nimport DeveloperError from './DeveloperError.js';\nimport Geometry from './Geometry.js';\nimport GeometryAttribute from './GeometryAttribute.js';\nimport GeometryAttributes from './GeometryAttributes.js';\nimport GeometryOffsetAttribute from './GeometryOffsetAttribute.js';\nimport IndexDatatype from './IndexDatatype.js';\nimport PrimitiveType from './PrimitiveType.js';\n\n    var radiusScratch = new Cartesian2();\n\n    /**\n     * A description of the outline of a cylinder.\n     *\n     * @alias CylinderOutlineGeometry\n     * @constructor\n     *\n     * @param {Object} options Object with the following properties:\n     * @param {Number} options.length The length of the cylinder.\n     * @param {Number} options.topRadius The radius of the top of the cylinder.\n     * @param {Number} options.bottomRadius The radius of the bottom of the cylinder.\n     * @param {Number} [options.slices=128] The number of edges around the perimeter of the cylinder.\n     * @param {Number} [options.numberOfVerticalLines=16] Number of lines to draw between the top and bottom surfaces of the cylinder.\n     *\n     * @exception {DeveloperError} options.length must be greater than 0.\n     * @exception {DeveloperError} options.topRadius must be greater than 0.\n     * @exception {DeveloperError} options.bottomRadius must be greater than 0.\n     * @exception {DeveloperError} bottomRadius and topRadius cannot both equal 0.\n     * @exception {DeveloperError} options.slices must be greater than or equal to 3.\n     *\n     * @see CylinderOutlineGeometry.createGeometry\n     *\n     * @example\n     * // create cylinder geometry\n     * var cylinder = new Cesium.CylinderOutlineGeometry({\n     *     length: 200000,\n     *     topRadius: 80000,\n     *     bottomRadius: 200000,\n     * });\n     * var geometry = Cesium.CylinderOutlineGeometry.createGeometry(cylinder);\n     */\n    function CylinderOutlineGeometry(options) {\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n        var length = options.length;\n        var topRadius = options.topRadius;\n        var bottomRadius = options.bottomRadius;\n        var slices = defaultValue(options.slices, 128);\n        var numberOfVerticalLines = Math.max(defaultValue(options.numberOfVerticalLines, 16), 0);\n\n        \n\n        this._length = length;\n        this._topRadius = topRadius;\n        this._bottomRadius = bottomRadius;\n        this._slices = slices;\n        this._numberOfVerticalLines = numberOfVerticalLines;\n        this._offsetAttribute = options.offsetAttribute;\n        this._workerName = 'createCylinderOutlineGeometry';\n    }\n\n    /**\n     * The number of elements used to pack the object into an array.\n     * @type {Number}\n     */\n    CylinderOutlineGeometry.packedLength = 6;\n\n    /**\n     * Stores the provided instance into the provided array.\n     *\n     * @param {CylinderOutlineGeometry} value The value to pack.\n     * @param {Number[]} array The array to pack into.\n     * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n     *\n     * @returns {Number[]} The array that was packed into\n     */\n    CylinderOutlineGeometry.pack = function(value, array, startingIndex) {\n        \n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        array[startingIndex++] = value._length;\n        array[startingIndex++] = value._topRadius;\n        array[startingIndex++] = value._bottomRadius;\n        array[startingIndex++] = value._slices;\n        array[startingIndex++] = value._numberOfVerticalLines;\n        array[startingIndex] = defaultValue(value._offsetAttribute, -1);\n\n        return array;\n    };\n\n    var scratchOptions = {\n        length : undefined,\n        topRadius : undefined,\n        bottomRadius : undefined,\n        slices : undefined,\n        numberOfVerticalLines : undefined,\n        offsetAttribute : undefined\n    };\n\n    /**\n     * Retrieves an instance from a packed array.\n     *\n     * @param {Number[]} array The packed array.\n     * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n     * @param {CylinderOutlineGeometry} [result] The object into which to store the result.\n     * @returns {CylinderOutlineGeometry} The modified result parameter or a new CylinderOutlineGeometry instance if one was not provided.\n     */\n    CylinderOutlineGeometry.unpack = function(array, startingIndex, result) {\n        \n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        var length = array[startingIndex++];\n        var topRadius = array[startingIndex++];\n        var bottomRadius = array[startingIndex++];\n        var slices = array[startingIndex++];\n        var numberOfVerticalLines = array[startingIndex++];\n        var offsetAttribute = array[startingIndex];\n\n        if (!defined(result)) {\n            scratchOptions.length = length;\n            scratchOptions.topRadius = topRadius;\n            scratchOptions.bottomRadius = bottomRadius;\n            scratchOptions.slices = slices;\n            scratchOptions.numberOfVerticalLines = numberOfVerticalLines;\n            scratchOptions.offsetAttribute = offsetAttribute === -1 ? undefined : offsetAttribute;\n            return new CylinderOutlineGeometry(scratchOptions);\n        }\n\n        result._length = length;\n        result._topRadius = topRadius;\n        result._bottomRadius = bottomRadius;\n        result._slices = slices;\n        result._numberOfVerticalLines = numberOfVerticalLines;\n        result._offsetAttribute = offsetAttribute === -1 ? undefined : offsetAttribute;\n\n        return result;\n    };\n\n    /**\n     * Computes the geometric representation of an outline of a cylinder, including its vertices, indices, and a bounding sphere.\n     *\n     * @param {CylinderOutlineGeometry} cylinderGeometry A description of the cylinder outline.\n     * @returns {Geometry|undefined} The computed vertices and indices.\n     */\n    CylinderOutlineGeometry.createGeometry = function(cylinderGeometry) {\n        var length = cylinderGeometry._length;\n        var topRadius = cylinderGeometry._topRadius;\n        var bottomRadius = cylinderGeometry._bottomRadius;\n        var slices = cylinderGeometry._slices;\n        var numberOfVerticalLines = cylinderGeometry._numberOfVerticalLines;\n\n        if ((length <= 0) || (topRadius < 0) || (bottomRadius < 0) || ((topRadius === 0) && (bottomRadius === 0))) {\n            return;\n        }\n\n        var numVertices = slices * 2;\n\n        var positions = CylinderGeometryLibrary.computePositions(length, topRadius, bottomRadius, slices, false);\n        var numIndices = slices * 2;\n        var numSide;\n        if (numberOfVerticalLines > 0) {\n            var numSideLines = Math.min(numberOfVerticalLines, slices);\n            numSide = Math.round(slices / numSideLines);\n            numIndices += numSideLines;\n        }\n\n        var indices = IndexDatatype.createTypedArray(numVertices, numIndices * 2);\n        var index = 0;\n        var i;\n        for (i = 0; i < slices - 1; i++) {\n            indices[index++] = i;\n            indices[index++] = i + 1;\n            indices[index++] = i + slices;\n            indices[index++] = i + 1 + slices;\n        }\n\n        indices[index++] = slices - 1;\n        indices[index++] = 0;\n        indices[index++] = slices + slices - 1;\n        indices[index++] = slices;\n\n        if (numberOfVerticalLines > 0) {\n            for (i = 0; i < slices; i += numSide) {\n                indices[index++] = i;\n                indices[index++] = i + slices;\n            }\n        }\n\n        var attributes = new GeometryAttributes();\n        attributes.position = new GeometryAttribute({\n            componentDatatype : ComponentDatatype.DOUBLE,\n            componentsPerAttribute : 3,\n            values : positions\n        });\n\n        radiusScratch.x = length * 0.5;\n        radiusScratch.y = Math.max(bottomRadius, topRadius);\n\n        var boundingSphere = new BoundingSphere(Cartesian3.ZERO, Cartesian2.magnitude(radiusScratch));\n\n        if (defined(cylinderGeometry._offsetAttribute)) {\n            length = positions.length;\n            var applyOffset = new Uint8Array(length / 3);\n            var offsetValue = cylinderGeometry._offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;\n            arrayFill(applyOffset, offsetValue);\n            attributes.applyOffset = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.UNSIGNED_BYTE,\n                componentsPerAttribute : 1,\n                values: applyOffset\n            });\n        }\n\n        return new Geometry({\n            attributes : attributes,\n            indices : indices,\n            primitiveType : PrimitiveType.LINES,\n            boundingSphere : boundingSphere,\n            offsetAttribute : cylinderGeometry._offsetAttribute\n        });\n    };\nexport default CylinderOutlineGeometry;\n","import Cartesian3 from '../Core/Cartesian3.js';\nimport Check from '../Core/Check.js';\nimport Color from '../Core/Color.js';\nimport ColorGeometryInstanceAttribute from '../Core/ColorGeometryInstanceAttribute.js';\nimport CylinderGeometry from '../Core/CylinderGeometry.js';\nimport CylinderOutlineGeometry from '../Core/CylinderOutlineGeometry.js';\nimport defined from '../Core/defined.js';\nimport defineProperties from '../Core/defineProperties.js';\nimport DeveloperError from '../Core/DeveloperError.js';\nimport DistanceDisplayConditionGeometryInstanceAttribute from '../Core/DistanceDisplayConditionGeometryInstanceAttribute.js';\nimport GeometryInstance from '../Core/GeometryInstance.js';\nimport GeometryOffsetAttribute from '../Core/GeometryOffsetAttribute.js';\nimport Iso8601 from '../Core/Iso8601.js';\nimport OffsetGeometryInstanceAttribute from '../Core/OffsetGeometryInstanceAttribute.js';\nimport ShowGeometryInstanceAttribute from '../Core/ShowGeometryInstanceAttribute.js';\nimport HeightReference from '../Scene/HeightReference.js';\nimport MaterialAppearance from '../Scene/MaterialAppearance.js';\nimport PerInstanceColorAppearance from '../Scene/PerInstanceColorAppearance.js';\nimport ColorMaterialProperty from './ColorMaterialProperty.js';\nimport DynamicGeometryUpdater from './DynamicGeometryUpdater.js';\nimport GeometryUpdater from './GeometryUpdater.js';\nimport heightReferenceOnEntityPropertyChanged from './heightReferenceOnEntityPropertyChanged.js';\nimport Property from './Property.js';\n\n    var defaultOffset = Cartesian3.ZERO;\n\n    var offsetScratch = new Cartesian3();\n    var positionScratch = new Cartesian3();\n    var scratchColor = new Color();\n\n    function CylinderGeometryOptions(entity) {\n        this.id = entity;\n        this.vertexFormat = undefined;\n        this.length = undefined;\n        this.topRadius = undefined;\n        this.bottomRadius = undefined;\n        this.slices = undefined;\n        this.numberOfVerticalLines = undefined;\n        this.offsetAttribute = undefined;\n    }\n\n    /**\n     * A {@link GeometryUpdater} for cylinders.\n     * Clients do not normally create this class directly, but instead rely on {@link DataSourceDisplay}.\n     * @alias CylinderGeometryUpdater\n     * @constructor\n     *\n     * @param {Entity} entity The entity containing the geometry to be visualized.\n     * @param {Scene} scene The scene where visualization is taking place.\n     */\n    function CylinderGeometryUpdater(entity, scene) {\n        GeometryUpdater.call(this, {\n            entity: entity,\n            scene: scene,\n            geometryOptions: new CylinderGeometryOptions(entity),\n            geometryPropertyName: 'cylinder',\n            observedPropertyNames: ['availability', 'position', 'orientation', 'cylinder']\n        });\n\n        this._onEntityPropertyChanged(entity, 'cylinder', entity.cylinder, undefined);\n    }\n\n    if (defined(Object.create)) {\n        CylinderGeometryUpdater.prototype = Object.create(GeometryUpdater.prototype);\n        CylinderGeometryUpdater.prototype.constructor = CylinderGeometryUpdater;\n    }\n\n    defineProperties(CylinderGeometryUpdater.prototype, {\n        /**\n         * Gets the terrain offset property\n         * @type {TerrainOffsetProperty}\n         * @memberof CylinderGeometryUpdater.prototype\n         * @readonly\n         */\n        terrainOffsetProperty: {\n            get: function() {\n                return this._terrainOffsetProperty;\n            }\n        }\n    });\n\n    /**\n     * Creates the geometry instance which represents the fill of the geometry.\n     *\n     * @param {JulianDate} time The time to use when retrieving initial attribute values.\n     * @returns {GeometryInstance} The geometry instance representing the filled portion of the geometry.\n     *\n     * @exception {DeveloperError} This instance does not represent a filled geometry.\n     */\n    CylinderGeometryUpdater.prototype.createFillGeometryInstance = function(time) {\n        \n\n        var entity = this._entity;\n        var isAvailable = entity.isAvailable(time);\n\n        var show = new ShowGeometryInstanceAttribute(isAvailable && entity.isShowing && this._showProperty.getValue(time) && this._fillProperty.getValue(time));\n        var distanceDisplayCondition = this._distanceDisplayConditionProperty.getValue(time);\n        var distanceDisplayConditionAttribute = DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(distanceDisplayCondition);\n\n        var attributes = {\n            show : show,\n            distanceDisplayCondition : distanceDisplayConditionAttribute,\n            color : undefined,\n            offset: undefined\n        };\n        if (this._materialProperty instanceof ColorMaterialProperty) {\n            var currentColor;\n            if (defined(this._materialProperty.color) && (this._materialProperty.color.isConstant || isAvailable)) {\n                currentColor = this._materialProperty.color.getValue(time, scratchColor);\n            }\n            if (!defined(currentColor)) {\n                currentColor = Color.WHITE;\n            }\n            attributes.color = ColorGeometryInstanceAttribute.fromColor(currentColor);\n        }\n\n        if (defined(this._options.offsetAttribute)) {\n            attributes.offset = OffsetGeometryInstanceAttribute.fromCartesian3(Property.getValueOrDefault(this._terrainOffsetProperty, time, defaultOffset, offsetScratch));\n        }\n\n        return new GeometryInstance({\n            id : entity,\n            geometry : new CylinderGeometry(this._options),\n            modelMatrix : entity.computeModelMatrixForHeightReference(time, entity.cylinder.heightReference, this._options.length * 0.5, this._scene.mapProjection.ellipsoid),\n            attributes : attributes\n        });\n    };\n\n    /**\n     * Creates the geometry instance which represents the outline of the geometry.\n     *\n     * @param {JulianDate} time The time to use when retrieving initial attribute values.\n     * @returns {GeometryInstance} The geometry instance representing the outline portion of the geometry.\n     *\n     * @exception {DeveloperError} This instance does not represent an outlined geometry.\n     */\n    CylinderGeometryUpdater.prototype.createOutlineGeometryInstance = function(time) {\n        \n\n        var entity = this._entity;\n        var isAvailable = entity.isAvailable(time);\n        var outlineColor = Property.getValueOrDefault(this._outlineColorProperty, time, Color.BLACK, scratchColor);\n        var distanceDisplayCondition = this._distanceDisplayConditionProperty.getValue(time);\n\n        var attributes = {\n            show : new ShowGeometryInstanceAttribute(isAvailable && entity.isShowing && this._showProperty.getValue(time) && this._showOutlineProperty.getValue(time)),\n            color : ColorGeometryInstanceAttribute.fromColor(outlineColor),\n            distanceDisplayCondition : DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(distanceDisplayCondition),\n            offset : undefined\n        };\n        if (defined(this._options.offsetAttribute)) {\n            attributes.offset = OffsetGeometryInstanceAttribute.fromCartesian3(Property.getValueOrDefault(this._terrainOffsetProperty, time, defaultOffset, offsetScratch));\n        }\n\n        return new GeometryInstance({\n            id : entity,\n            geometry : new CylinderOutlineGeometry(this._options),\n            modelMatrix : entity.computeModelMatrixForHeightReference(time, entity.cylinder.heightReference, this._options.length * 0.5, this._scene.mapProjection.ellipsoid),\n            attributes : attributes\n        });\n    };\n\n    CylinderGeometryUpdater.prototype._computeCenter = function(time, result) {\n        return Property.getValueOrUndefined(this._entity.position, time, result);\n    };\n\n    CylinderGeometryUpdater.prototype._isHidden = function(entity, cylinder) {\n        return !defined(entity.position) || !defined(cylinder.length) || !defined(cylinder.topRadius) || !defined(cylinder.bottomRadius) || GeometryUpdater.prototype._isHidden.call(this, entity, cylinder);\n    };\n\n    CylinderGeometryUpdater.prototype._isDynamic = function(entity, cylinder) {\n        return !entity.position.isConstant || //\n                !Property.isConstant(entity.orientation) || //\n                !cylinder.length.isConstant || //\n                !cylinder.topRadius.isConstant || //\n                !cylinder.bottomRadius.isConstant || //\n                !Property.isConstant(cylinder.slices) || //\n                !Property.isConstant(cylinder.outlineWidth) || //\n                !Property.isConstant(cylinder.numberOfVerticalLines);\n    };\n\n    CylinderGeometryUpdater.prototype._setStaticOptions = function(entity, cylinder) {\n        var heightReference = Property.getValueOrDefault(cylinder.heightReference, Iso8601.MINIMUM_VALUE, HeightReference.NONE);\n        var options = this._options;\n        options.vertexFormat = this._materialProperty instanceof ColorMaterialProperty ? PerInstanceColorAppearance.VERTEX_FORMAT : MaterialAppearance.MaterialSupport.TEXTURED.vertexFormat;\n        options.length = cylinder.length.getValue(Iso8601.MINIMUM_VALUE);\n        options.topRadius = cylinder.topRadius.getValue(Iso8601.MINIMUM_VALUE);\n        options.bottomRadius = cylinder.bottomRadius.getValue(Iso8601.MINIMUM_VALUE);\n        options.slices = Property.getValueOrUndefined(cylinder.slices, Iso8601.MINIMUM_VALUE);\n        options.numberOfVerticalLines = Property.getValueOrUndefined(cylinder.numberOfVerticalLines, Iso8601.MINIMUM_VALUE);\n        options.offsetAttribute = heightReference !== HeightReference.NONE ? GeometryOffsetAttribute.ALL : undefined;\n    };\n\n    CylinderGeometryUpdater.prototype._onEntityPropertyChanged = heightReferenceOnEntityPropertyChanged;\n\n    CylinderGeometryUpdater.DynamicGeometryUpdater = DynamicCylinderGeometryUpdater;\n\n    /**\n     * @private\n     */\n    function DynamicCylinderGeometryUpdater(geometryUpdater, primitives, groundPrimitives) {\n        DynamicGeometryUpdater.call(this, geometryUpdater, primitives, groundPrimitives);\n    }\n\n    if (defined(Object.create)) {\n        DynamicCylinderGeometryUpdater.prototype = Object.create(DynamicGeometryUpdater.prototype);\n        DynamicCylinderGeometryUpdater.prototype.constructor = DynamicCylinderGeometryUpdater;\n    }\n\n    DynamicCylinderGeometryUpdater.prototype._isHidden = function(entity, cylinder, time) {\n        var options = this._options;\n        var position = Property.getValueOrUndefined(entity.position, time, positionScratch);\n        return !defined(position) || !defined(options.length) || !defined(options.topRadius) || //\n               !defined(options.bottomRadius) || DynamicGeometryUpdater.prototype._isHidden.call(this, entity, cylinder, time);\n    };\n\n    DynamicCylinderGeometryUpdater.prototype._setOptions = function(entity, cylinder, time) {\n        var heightReference = Property.getValueOrDefault(cylinder.heightReference, time, HeightReference.NONE);\n        var options = this._options;\n        options.length = Property.getValueOrUndefined(cylinder.length, time);\n        options.topRadius = Property.getValueOrUndefined(cylinder.topRadius, time);\n        options.bottomRadius = Property.getValueOrUndefined(cylinder.bottomRadius, time);\n        options.slices = Property.getValueOrUndefined(cylinder.slices, time);\n        options.numberOfVerticalLines = Property.getValueOrUndefined(cylinder.numberOfVerticalLines, time);\n        options.offsetAttribute = heightReference !== HeightReference.NONE ? GeometryOffsetAttribute.ALL : undefined;\n    };\nexport default CylinderGeometryUpdater;\n","import AssociativeArray from '../Core/AssociativeArray.js';\nimport defined from '../Core/defined.js';\nimport BoundingSphereState from './BoundingSphereState.js';\n\n    /**\n     * @private\n     */\n    function DynamicGeometryBatch(primitives, orderedGroundPrimitives) {\n        this._primitives = primitives;\n        this._orderedGroundPrimitives = orderedGroundPrimitives;\n        this._dynamicUpdaters = new AssociativeArray();\n    }\n\n    DynamicGeometryBatch.prototype.add = function(time, updater) {\n        this._dynamicUpdaters.set(updater.id, updater.createDynamicUpdater(this._primitives, this._orderedGroundPrimitives));\n    };\n\n    DynamicGeometryBatch.prototype.remove = function(updater) {\n        var id = updater.id;\n        var dynamicUpdater = this._dynamicUpdaters.get(id);\n        if (defined(dynamicUpdater)) {\n            this._dynamicUpdaters.remove(id);\n            dynamicUpdater.destroy();\n        }\n    };\n\n    DynamicGeometryBatch.prototype.update = function(time) {\n        var geometries = this._dynamicUpdaters.values;\n        for (var i = 0, len = geometries.length; i < len; i++) {\n            geometries[i].update(time);\n        }\n        return true;\n    };\n\n    DynamicGeometryBatch.prototype.removeAllPrimitives = function() {\n        var geometries = this._dynamicUpdaters.values;\n        for (var i = 0, len = geometries.length; i < len; i++) {\n            geometries[i].destroy();\n        }\n        this._dynamicUpdaters.removeAll();\n    };\n\n    DynamicGeometryBatch.prototype.getBoundingSphere = function(updater, result) {\n        updater = this._dynamicUpdaters.get(updater.id);\n        if (defined(updater) && defined(updater.getBoundingSphere)) {\n            return updater.getBoundingSphere(result);\n        }\n        return BoundingSphereState.FAILED;\n    };\nexport default DynamicGeometryBatch;\n","import Cartesian3 from './Cartesian3.js';\nimport CesiumMath from './Math.js';\nimport Matrix3 from './Matrix3.js';\nimport Quaternion from './Quaternion.js';\n\n    var EllipseGeometryLibrary = {};\n\n    var rotAxis = new Cartesian3();\n    var tempVec = new Cartesian3();\n    var unitQuat = new Quaternion();\n    var rotMtx = new Matrix3();\n\n    function pointOnEllipsoid(theta, rotation, northVec, eastVec, aSqr, ab, bSqr, mag, unitPos, result) {\n        var azimuth = theta + rotation;\n\n        Cartesian3.multiplyByScalar(eastVec, Math.cos(azimuth), rotAxis);\n        Cartesian3.multiplyByScalar(northVec, Math.sin(azimuth), tempVec);\n        Cartesian3.add(rotAxis, tempVec, rotAxis);\n\n        var cosThetaSquared = Math.cos(theta);\n        cosThetaSquared = cosThetaSquared * cosThetaSquared;\n\n        var sinThetaSquared = Math.sin(theta);\n        sinThetaSquared = sinThetaSquared * sinThetaSquared;\n\n        var radius = ab / Math.sqrt(bSqr * cosThetaSquared + aSqr * sinThetaSquared);\n        var angle = radius / mag;\n\n        // Create the quaternion to rotate the position vector to the boundary of the ellipse.\n        Quaternion.fromAxisAngle(rotAxis, angle, unitQuat);\n        Matrix3.fromQuaternion(unitQuat, rotMtx);\n\n        Matrix3.multiplyByVector(rotMtx, unitPos, result);\n        Cartesian3.normalize(result, result);\n        Cartesian3.multiplyByScalar(result, mag, result);\n        return result;\n    }\n\n    var scratchCartesian1 = new Cartesian3();\n    var scratchCartesian2 = new Cartesian3();\n    var scratchCartesian3 = new Cartesian3();\n    var scratchNormal = new Cartesian3();\n    /**\n     * Returns the positions raised to the given heights\n     * @private\n     */\n    EllipseGeometryLibrary.raisePositionsToHeight = function(positions, options, extrude) {\n        var ellipsoid = options.ellipsoid;\n        var height = options.height;\n        var extrudedHeight = options.extrudedHeight;\n        var size = (extrude) ? positions.length / 3 * 2 : positions.length / 3;\n\n        var finalPositions = new Float64Array(size * 3);\n\n        var length = positions.length;\n        var bottomOffset = (extrude) ? length : 0;\n        for (var i = 0; i < length; i += 3) {\n            var i1 = i + 1;\n            var i2 = i + 2;\n\n            var position = Cartesian3.fromArray(positions, i, scratchCartesian1);\n            ellipsoid.scaleToGeodeticSurface(position, position);\n\n            var extrudedPosition = Cartesian3.clone(position, scratchCartesian2);\n            var normal = ellipsoid.geodeticSurfaceNormal(position, scratchNormal);\n            var scaledNormal = Cartesian3.multiplyByScalar(normal, height, scratchCartesian3);\n            Cartesian3.add(position, scaledNormal, position);\n\n            if (extrude) {\n                Cartesian3.multiplyByScalar(normal, extrudedHeight, scaledNormal);\n                Cartesian3.add(extrudedPosition, scaledNormal, extrudedPosition);\n\n                finalPositions[i + bottomOffset] = extrudedPosition.x;\n                finalPositions[i1 + bottomOffset] = extrudedPosition.y;\n                finalPositions[i2 + bottomOffset] = extrudedPosition.z;\n            }\n\n            finalPositions[i] = position.x;\n            finalPositions[i1] = position.y;\n            finalPositions[i2] = position.z;\n        }\n\n        return finalPositions;\n    };\n\n    var unitPosScratch = new Cartesian3();\n    var eastVecScratch = new Cartesian3();\n    var northVecScratch = new Cartesian3();\n    /**\n     * Returns an array of positions that make up the ellipse.\n     * @private\n     */\n    EllipseGeometryLibrary.computeEllipsePositions = function(options, addFillPositions, addEdgePositions) {\n        var semiMinorAxis = options.semiMinorAxis;\n        var semiMajorAxis = options.semiMajorAxis;\n        var rotation = options.rotation;\n        var center = options.center;\n\n        // Computing the arc-length of the ellipse is too expensive to be practical. Estimating it using the\n        // arc length of the sphere is too inaccurate and creates sharp edges when either the semi-major or\n        // semi-minor axis is much bigger than the other. Instead, scale the angle delta to make\n        // the distance along the ellipse boundary more closely match the granularity.\n        var granularity = options.granularity * 8.0;\n\n        var aSqr = semiMinorAxis * semiMinorAxis;\n        var bSqr = semiMajorAxis * semiMajorAxis;\n        var ab = semiMajorAxis * semiMinorAxis;\n\n        var mag = Cartesian3.magnitude(center);\n\n        var unitPos = Cartesian3.normalize(center, unitPosScratch);\n        var eastVec = Cartesian3.cross(Cartesian3.UNIT_Z, center, eastVecScratch);\n        eastVec = Cartesian3.normalize(eastVec, eastVec);\n        var northVec = Cartesian3.cross(unitPos, eastVec, northVecScratch);\n\n        // The number of points in the first quadrant\n        var numPts = 1 + Math.ceil(CesiumMath.PI_OVER_TWO / granularity);\n\n        var deltaTheta = CesiumMath.PI_OVER_TWO / (numPts - 1);\n        var theta = CesiumMath.PI_OVER_TWO - numPts * deltaTheta;\n        if (theta < 0.0) {\n            numPts -= Math.ceil(Math.abs(theta) / deltaTheta);\n        }\n\n        // If the number of points were three, the ellipse\n        // would be tessellated like below:\n        //\n        //         *---*\n        //       / | \\ | \\\n        //     *---*---*---*\n        //   / | \\ | \\ | \\ | \\\n        //  / .*---*---*---*. \\\n        // * ` | \\ | \\ | \\ | `*\n        //  \\`.*---*---*---*.`/\n        //   \\ | \\ | \\ | \\ | /\n        //     *---*---*---*\n        //       \\ | \\ | /\n        //         *---*\n        // The first and last column have one position and fan to connect to the adjacent column.\n        // Each other vertical column contains an even number of positions.\n        var size = 2 * (numPts * (numPts + 2));\n        var positions = (addFillPositions) ? new Array(size * 3) : undefined;\n        var positionIndex = 0;\n        var position = scratchCartesian1;\n        var reflectedPosition = scratchCartesian2;\n\n        var outerPositionsLength = (numPts * 4) * 3;\n        var outerRightIndex = outerPositionsLength - 1;\n        var outerLeftIndex = 0;\n        var outerPositions = (addEdgePositions) ? new Array(outerPositionsLength) : undefined;\n\n        var i;\n        var j;\n        var numInterior;\n        var t;\n        var interiorPosition;\n\n        // Compute points in the 'eastern' half of the ellipse\n        theta = CesiumMath.PI_OVER_TWO;\n        position = pointOnEllipsoid(theta, rotation, northVec, eastVec, aSqr, ab, bSqr, mag, unitPos, position);\n        if (addFillPositions) {\n            positions[positionIndex++] = position.x;\n            positions[positionIndex++] = position.y;\n            positions[positionIndex++] = position.z;\n        }\n        if (addEdgePositions) {\n            outerPositions[outerRightIndex--] = position.z;\n            outerPositions[outerRightIndex--] = position.y;\n            outerPositions[outerRightIndex--] = position.x;\n        }\n        theta = CesiumMath.PI_OVER_TWO -  deltaTheta;\n        for (i = 1; i < numPts + 1; ++i) {\n            position = pointOnEllipsoid(theta, rotation, northVec, eastVec, aSqr, ab, bSqr, mag, unitPos, position);\n            reflectedPosition = pointOnEllipsoid(Math.PI - theta, rotation, northVec, eastVec, aSqr, ab, bSqr, mag, unitPos, reflectedPosition);\n\n            if (addFillPositions) {\n                positions[positionIndex++] = position.x;\n                positions[positionIndex++] = position.y;\n                positions[positionIndex++] = position.z;\n\n                numInterior = 2 * i + 2;\n                for (j = 1; j < numInterior - 1; ++j) {\n                    t = j / (numInterior - 1);\n                    interiorPosition = Cartesian3.lerp(position, reflectedPosition, t, scratchCartesian3);\n                    positions[positionIndex++] = interiorPosition.x;\n                    positions[positionIndex++] = interiorPosition.y;\n                    positions[positionIndex++] = interiorPosition.z;\n                }\n\n                positions[positionIndex++] = reflectedPosition.x;\n                positions[positionIndex++] = reflectedPosition.y;\n                positions[positionIndex++] = reflectedPosition.z;\n            }\n\n            if (addEdgePositions) {\n                outerPositions[outerRightIndex--] = position.z;\n                outerPositions[outerRightIndex--] = position.y;\n                outerPositions[outerRightIndex--] = position.x;\n                outerPositions[outerLeftIndex++] = reflectedPosition.x;\n                outerPositions[outerLeftIndex++] = reflectedPosition.y;\n                outerPositions[outerLeftIndex++] = reflectedPosition.z;\n            }\n\n            theta = CesiumMath.PI_OVER_TWO - (i + 1) * deltaTheta;\n        }\n\n        // Compute points in the 'western' half of the ellipse\n        for (i = numPts; i > 1; --i) {\n            theta = CesiumMath.PI_OVER_TWO - (i - 1) * deltaTheta;\n\n            position = pointOnEllipsoid(-theta, rotation, northVec, eastVec, aSqr, ab, bSqr, mag, unitPos, position);\n            reflectedPosition = pointOnEllipsoid(theta + Math.PI, rotation, northVec, eastVec, aSqr, ab, bSqr, mag, unitPos, reflectedPosition);\n\n            if (addFillPositions) {\n                positions[positionIndex++] = position.x;\n                positions[positionIndex++] = position.y;\n                positions[positionIndex++] = position.z;\n\n                numInterior = 2 * (i - 1) + 2;\n                for (j = 1; j < numInterior - 1; ++j) {\n                    t = j / (numInterior - 1);\n                    interiorPosition = Cartesian3.lerp(position, reflectedPosition, t, scratchCartesian3);\n                    positions[positionIndex++] = interiorPosition.x;\n                    positions[positionIndex++] = interiorPosition.y;\n                    positions[positionIndex++] = interiorPosition.z;\n                }\n\n                positions[positionIndex++] = reflectedPosition.x;\n                positions[positionIndex++] = reflectedPosition.y;\n                positions[positionIndex++] = reflectedPosition.z;\n            }\n\n            if (addEdgePositions) {\n                outerPositions[outerRightIndex--] = position.z;\n                outerPositions[outerRightIndex--] = position.y;\n                outerPositions[outerRightIndex--] = position.x;\n                outerPositions[outerLeftIndex++] = reflectedPosition.x;\n                outerPositions[outerLeftIndex++] = reflectedPosition.y;\n                outerPositions[outerLeftIndex++] = reflectedPosition.z;\n            }\n        }\n\n        theta = CesiumMath.PI_OVER_TWO;\n        position = pointOnEllipsoid(-theta, rotation, northVec, eastVec, aSqr, ab, bSqr, mag, unitPos, position);\n\n        var r = {};\n        if (addFillPositions) {\n            positions[positionIndex++] = position.x;\n            positions[positionIndex++] = position.y;\n            positions[positionIndex++] = position.z;\n            r.positions = positions;\n            r.numPts = numPts;\n        }\n        if (addEdgePositions) {\n            outerPositions[outerRightIndex--] = position.z;\n            outerPositions[outerRightIndex--] = position.y;\n            outerPositions[outerRightIndex--] = position.x;\n            r.outerPositions = outerPositions;\n        }\n\n        return r;\n    };\nexport default EllipseGeometryLibrary;\n","import arrayFill from './arrayFill.js';\nimport BoundingSphere from './BoundingSphere.js';\nimport Cartesian2 from './Cartesian2.js';\nimport Cartesian3 from './Cartesian3.js';\nimport Cartographic from './Cartographic.js';\nimport Check from './Check.js';\nimport ComponentDatatype from './ComponentDatatype.js';\nimport defaultValue from './defaultValue.js';\nimport defined from './defined.js';\nimport defineProperties from './defineProperties.js';\nimport DeveloperError from './DeveloperError.js';\nimport EllipseGeometryLibrary from './EllipseGeometryLibrary.js';\nimport Ellipsoid from './Ellipsoid.js';\nimport GeographicProjection from './GeographicProjection.js';\nimport Geometry from './Geometry.js';\nimport GeometryAttribute from './GeometryAttribute.js';\nimport GeometryAttributes from './GeometryAttributes.js';\nimport GeometryInstance from './GeometryInstance.js';\nimport GeometryOffsetAttribute from './GeometryOffsetAttribute.js';\nimport GeometryPipeline from './GeometryPipeline.js';\nimport IndexDatatype from './IndexDatatype.js';\nimport CesiumMath from './Math.js';\nimport Matrix3 from './Matrix3.js';\nimport PrimitiveType from './PrimitiveType.js';\nimport Quaternion from './Quaternion.js';\nimport Rectangle from './Rectangle.js';\nimport VertexFormat from './VertexFormat.js';\n\n    var scratchCartesian1 = new Cartesian3();\n    var scratchCartesian2 = new Cartesian3();\n    var scratchCartesian3 = new Cartesian3();\n    var scratchCartesian4 = new Cartesian3();\n    var texCoordScratch = new Cartesian2();\n    var textureMatrixScratch = new Matrix3();\n    var tangentMatrixScratch = new Matrix3();\n    var quaternionScratch = new Quaternion();\n\n    var scratchNormal = new Cartesian3();\n    var scratchTangent = new Cartesian3();\n    var scratchBitangent = new Cartesian3();\n\n    var scratchCartographic = new Cartographic();\n    var projectedCenterScratch = new Cartesian3();\n\n    var scratchMinTexCoord = new Cartesian2();\n    var scratchMaxTexCoord = new Cartesian2();\n\n    function computeTopBottomAttributes(positions, options, extrude) {\n        var vertexFormat = options.vertexFormat;\n        var center = options.center;\n        var semiMajorAxis = options.semiMajorAxis;\n        var semiMinorAxis = options.semiMinorAxis;\n        var ellipsoid = options.ellipsoid;\n        var stRotation = options.stRotation;\n        var size = (extrude) ? positions.length / 3 * 2 : positions.length / 3;\n        var shadowVolume = options.shadowVolume;\n\n        var textureCoordinates = (vertexFormat.st) ? new Float32Array(size * 2) : undefined;\n        var normals = (vertexFormat.normal) ? new Float32Array(size * 3) : undefined;\n        var tangents = (vertexFormat.tangent) ? new Float32Array(size * 3) : undefined;\n        var bitangents = (vertexFormat.bitangent) ? new Float32Array(size * 3) : undefined;\n\n        var extrudeNormals = (shadowVolume) ? new Float32Array(size * 3) : undefined;\n\n        var textureCoordIndex = 0;\n\n        // Raise positions to a height above the ellipsoid and compute the\n        // texture coordinates, normals, tangents, and bitangents.\n        var normal = scratchNormal;\n        var tangent = scratchTangent;\n        var bitangent = scratchBitangent;\n\n        var projection = new GeographicProjection(ellipsoid);\n        var projectedCenter = projection.project(ellipsoid.cartesianToCartographic(center, scratchCartographic), projectedCenterScratch);\n\n        var geodeticNormal = ellipsoid.scaleToGeodeticSurface(center, scratchCartesian1);\n        ellipsoid.geodeticSurfaceNormal(geodeticNormal, geodeticNormal);\n\n        var textureMatrix = textureMatrixScratch;\n        var tangentMatrix = tangentMatrixScratch;\n        if (stRotation !== 0) {\n            var rotation = Quaternion.fromAxisAngle(geodeticNormal, stRotation, quaternionScratch);\n            textureMatrix = Matrix3.fromQuaternion(rotation, textureMatrix);\n\n            rotation = Quaternion.fromAxisAngle(geodeticNormal, -stRotation, quaternionScratch);\n            tangentMatrix = Matrix3.fromQuaternion(rotation, tangentMatrix);\n        } else {\n            textureMatrix = Matrix3.clone(Matrix3.IDENTITY, textureMatrix);\n            tangentMatrix = Matrix3.clone(Matrix3.IDENTITY, tangentMatrix);\n        }\n\n        var minTexCoord = Cartesian2.fromElements(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, scratchMinTexCoord);\n        var maxTexCoord = Cartesian2.fromElements(Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY, scratchMaxTexCoord);\n\n        var length = positions.length;\n        var bottomOffset = (extrude) ? length : 0;\n        var stOffset = bottomOffset / 3 * 2;\n        for (var i = 0; i < length; i += 3) {\n            var i1 = i + 1;\n            var i2 = i + 2;\n            var position = Cartesian3.fromArray(positions, i, scratchCartesian1);\n\n            if (vertexFormat.st) {\n                var rotatedPoint = Matrix3.multiplyByVector(textureMatrix, position, scratchCartesian2);\n                var projectedPoint = projection.project(ellipsoid.cartesianToCartographic(rotatedPoint, scratchCartographic), scratchCartesian3);\n                Cartesian3.subtract(projectedPoint, projectedCenter, projectedPoint);\n\n                texCoordScratch.x = (projectedPoint.x + semiMajorAxis) / (2.0 * semiMajorAxis);\n                texCoordScratch.y = (projectedPoint.y + semiMinorAxis) / (2.0 * semiMinorAxis);\n\n                minTexCoord.x = Math.min(texCoordScratch.x, minTexCoord.x);\n                minTexCoord.y = Math.min(texCoordScratch.y, minTexCoord.y);\n                maxTexCoord.x = Math.max(texCoordScratch.x, maxTexCoord.x);\n                maxTexCoord.y = Math.max(texCoordScratch.y, maxTexCoord.y);\n\n                if (extrude) {\n                    textureCoordinates[textureCoordIndex + stOffset] = texCoordScratch.x;\n                    textureCoordinates[textureCoordIndex + 1 + stOffset] = texCoordScratch.y;\n                }\n\n                textureCoordinates[textureCoordIndex++] = texCoordScratch.x;\n                textureCoordinates[textureCoordIndex++] = texCoordScratch.y;\n            }\n\n            if (vertexFormat.normal || vertexFormat.tangent || vertexFormat.bitangent || shadowVolume) {\n                normal = ellipsoid.geodeticSurfaceNormal(position, normal);\n\n                if (shadowVolume) {\n                    extrudeNormals[i + bottomOffset] = -normal.x;\n                    extrudeNormals[i1 + bottomOffset] = -normal.y;\n                    extrudeNormals[i2 + bottomOffset] = -normal.z;\n                }\n\n                if (vertexFormat.normal || vertexFormat.tangent || vertexFormat.bitangent) {\n                    if (vertexFormat.tangent || vertexFormat.bitangent) {\n                        tangent = Cartesian3.normalize(Cartesian3.cross(Cartesian3.UNIT_Z, normal, tangent), tangent);\n                        Matrix3.multiplyByVector(tangentMatrix, tangent, tangent);\n                    }\n                    if (vertexFormat.normal) {\n                        normals[i] = normal.x;\n                        normals[i1] = normal.y;\n                        normals[i2] = normal.z;\n                        if (extrude) {\n                            normals[i + bottomOffset] = -normal.x;\n                            normals[i1 + bottomOffset] = -normal.y;\n                            normals[i2 + bottomOffset] = -normal.z;\n                        }\n                    }\n\n                    if (vertexFormat.tangent) {\n                        tangents[i] = tangent.x;\n                        tangents[i1] = tangent.y;\n                        tangents[i2] = tangent.z;\n                        if (extrude) {\n                            tangents[i + bottomOffset] = -tangent.x;\n                            tangents[i1 + bottomOffset] = -tangent.y;\n                            tangents[i2 + bottomOffset] = -tangent.z;\n                        }\n                    }\n\n                    if (vertexFormat.bitangent) {\n                        bitangent = Cartesian3.normalize(Cartesian3.cross(normal, tangent, bitangent), bitangent);\n                        bitangents[i ] = bitangent.x;\n                        bitangents[i1] = bitangent.y;\n                        bitangents[i2] = bitangent.z;\n                        if (extrude) {\n                            bitangents[i + bottomOffset] = bitangent.x;\n                            bitangents[i1 + bottomOffset] = bitangent.y;\n                            bitangents[i2 + bottomOffset] = bitangent.z;\n                        }\n                    }\n                }\n            }\n        }\n\n        if (vertexFormat.st) {\n            length = textureCoordinates.length;\n            for (var k = 0; k < length; k += 2) {\n                textureCoordinates[k] = (textureCoordinates[k] - minTexCoord.x) / (maxTexCoord.x - minTexCoord.x);\n                textureCoordinates[k + 1] = (textureCoordinates[k + 1] - minTexCoord.y) / (maxTexCoord.y - minTexCoord.y);\n            }\n        }\n\n        var attributes = new GeometryAttributes();\n\n        if (vertexFormat.position) {\n            var finalPositions = EllipseGeometryLibrary.raisePositionsToHeight(positions, options, extrude);\n            attributes.position = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.DOUBLE,\n                componentsPerAttribute : 3,\n                values : finalPositions\n            });\n        }\n\n        if (vertexFormat.st) {\n            attributes.st = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.FLOAT,\n                componentsPerAttribute : 2,\n                values : textureCoordinates\n            });\n        }\n\n        if (vertexFormat.normal) {\n            attributes.normal = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.FLOAT,\n                componentsPerAttribute : 3,\n                values : normals\n            });\n        }\n\n        if (vertexFormat.tangent) {\n            attributes.tangent = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.FLOAT,\n                componentsPerAttribute : 3,\n                values : tangents\n            });\n        }\n\n        if (vertexFormat.bitangent) {\n            attributes.bitangent = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.FLOAT,\n                componentsPerAttribute : 3,\n                values : bitangents\n            });\n        }\n\n        if (shadowVolume) {\n            attributes.extrudeDirection = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.FLOAT,\n                componentsPerAttribute : 3,\n                values : extrudeNormals\n            });\n        }\n\n        if (extrude && defined(options.offsetAttribute)) {\n            var offsetAttribute = new Uint8Array(size);\n            if (options.offsetAttribute === GeometryOffsetAttribute.TOP) {\n                offsetAttribute = arrayFill(offsetAttribute, 1, 0, size / 2);\n            } else {\n                var offsetValue = options.offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;\n                offsetAttribute = arrayFill(offsetAttribute, offsetValue);\n            }\n\n            attributes.applyOffset = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.UNSIGNED_BYTE,\n                componentsPerAttribute : 1,\n                values : offsetAttribute\n            });\n        }\n\n        return attributes;\n    }\n\n    function topIndices(numPts) {\n        // numTriangles in half = 3 + 8 + 12 + ... = -1 + 4 + (4 + 4) + (4 + 4 + 4) + ... = -1 + 4 * (1 + 2 + 3 + ...)\n        //              = -1 + 4 * ((n * ( n + 1)) / 2)\n        // total triangles = 2 * numTrangles in half\n        // indices = total triangles * 3;\n        // Substitute numPts for n above\n\n        var indices = new Array(12 * (numPts * ( numPts + 1)) - 6);\n        var indicesIndex = 0;\n        var prevIndex;\n        var numInterior;\n        var positionIndex;\n        var i;\n        var j;\n        // Indices triangles to the 'right' of the north vector\n\n        prevIndex = 0;\n        positionIndex = 1;\n        for (i = 0; i < 3; i++) {\n            indices[indicesIndex++] = positionIndex++;\n            indices[indicesIndex++] = prevIndex;\n            indices[indicesIndex++] = positionIndex;\n        }\n\n        for (i = 2; i < numPts + 1; ++i) {\n            positionIndex = i * (i + 1) - 1;\n            prevIndex = (i - 1) * i - 1;\n\n            indices[indicesIndex++] = positionIndex++;\n            indices[indicesIndex++] = prevIndex;\n            indices[indicesIndex++] = positionIndex;\n\n            numInterior = 2 * i;\n            for (j = 0; j < numInterior - 1; ++j) {\n\n                indices[indicesIndex++] = positionIndex;\n                indices[indicesIndex++] = prevIndex++;\n                indices[indicesIndex++] = prevIndex;\n\n                indices[indicesIndex++] = positionIndex++;\n                indices[indicesIndex++] = prevIndex;\n                indices[indicesIndex++] = positionIndex;\n            }\n\n            indices[indicesIndex++] = positionIndex++;\n            indices[indicesIndex++] = prevIndex;\n            indices[indicesIndex++] = positionIndex;\n        }\n\n        // Indices for center column of triangles\n        numInterior = numPts * 2;\n        ++positionIndex;\n        ++prevIndex;\n        for (i = 0; i < numInterior - 1; ++i) {\n            indices[indicesIndex++] = positionIndex;\n            indices[indicesIndex++] = prevIndex++;\n            indices[indicesIndex++] = prevIndex;\n\n            indices[indicesIndex++] = positionIndex++;\n            indices[indicesIndex++] = prevIndex;\n            indices[indicesIndex++] = positionIndex;\n        }\n\n        indices[indicesIndex++] = positionIndex;\n        indices[indicesIndex++] = prevIndex++;\n        indices[indicesIndex++] = prevIndex;\n\n        indices[indicesIndex++] = positionIndex++;\n        indices[indicesIndex++] = prevIndex++;\n        indices[indicesIndex++] = prevIndex;\n\n        // Reverse the process creating indices to the 'left' of the north vector\n        ++prevIndex;\n        for (i = numPts - 1; i > 1; --i) {\n            indices[indicesIndex++] = prevIndex++;\n            indices[indicesIndex++] = prevIndex;\n            indices[indicesIndex++] = positionIndex;\n\n            numInterior = 2 * i;\n            for (j = 0; j < numInterior - 1; ++j) {\n                indices[indicesIndex++] = positionIndex;\n                indices[indicesIndex++] = prevIndex++;\n                indices[indicesIndex++] = prevIndex;\n\n                indices[indicesIndex++] = positionIndex++;\n                indices[indicesIndex++] = prevIndex;\n                indices[indicesIndex++] = positionIndex;\n            }\n\n            indices[indicesIndex++] = prevIndex++;\n            indices[indicesIndex++] = prevIndex++;\n            indices[indicesIndex++] = positionIndex++;\n        }\n\n        for (i = 0; i < 3; i++) {\n            indices[indicesIndex++] = prevIndex++;\n            indices[indicesIndex++] = prevIndex;\n            indices[indicesIndex++] = positionIndex;\n        }\n        return indices;\n    }\n\n    var boundingSphereCenter = new Cartesian3();\n\n    function computeEllipse(options) {\n        var center = options.center;\n        boundingSphereCenter = Cartesian3.multiplyByScalar(options.ellipsoid.geodeticSurfaceNormal(center, boundingSphereCenter), options.height, boundingSphereCenter);\n        boundingSphereCenter = Cartesian3.add(center, boundingSphereCenter, boundingSphereCenter);\n        var boundingSphere = new BoundingSphere(boundingSphereCenter, options.semiMajorAxis);\n        var cep = EllipseGeometryLibrary.computeEllipsePositions(options, true, false);\n        var positions = cep.positions;\n        var numPts = cep.numPts;\n        var attributes = computeTopBottomAttributes(positions, options, false);\n        var indices = topIndices(numPts);\n        indices = IndexDatatype.createTypedArray(positions.length / 3, indices);\n        return {\n            boundingSphere : boundingSphere,\n            attributes : attributes,\n            indices : indices\n        };\n    }\n\n    function computeWallAttributes(positions, options) {\n        var vertexFormat = options.vertexFormat;\n        var center = options.center;\n        var semiMajorAxis = options.semiMajorAxis;\n        var semiMinorAxis = options.semiMinorAxis;\n        var ellipsoid = options.ellipsoid;\n        var height = options.height;\n        var extrudedHeight = options.extrudedHeight;\n        var stRotation = options.stRotation;\n        var size = positions.length / 3 * 2;\n\n        var finalPositions = new Float64Array(size * 3);\n        var textureCoordinates = (vertexFormat.st) ? new Float32Array(size * 2) : undefined;\n        var normals = (vertexFormat.normal) ? new Float32Array(size * 3) : undefined;\n        var tangents = (vertexFormat.tangent) ? new Float32Array(size * 3) : undefined;\n        var bitangents = (vertexFormat.bitangent) ? new Float32Array(size * 3) : undefined;\n\n        var shadowVolume = options.shadowVolume;\n        var extrudeNormals = (shadowVolume) ? new Float32Array(size * 3) : undefined;\n\n        var textureCoordIndex = 0;\n\n        // Raise positions to a height above the ellipsoid and compute the\n        // texture coordinates, normals, tangents, and bitangents.\n        var normal = scratchNormal;\n        var tangent = scratchTangent;\n        var bitangent = scratchBitangent;\n\n        var projection = new GeographicProjection(ellipsoid);\n        var projectedCenter = projection.project(ellipsoid.cartesianToCartographic(center, scratchCartographic), projectedCenterScratch);\n\n        var geodeticNormal = ellipsoid.scaleToGeodeticSurface(center, scratchCartesian1);\n        ellipsoid.geodeticSurfaceNormal(geodeticNormal, geodeticNormal);\n        var rotation = Quaternion.fromAxisAngle(geodeticNormal, stRotation, quaternionScratch);\n        var textureMatrix = Matrix3.fromQuaternion(rotation, textureMatrixScratch);\n\n        var minTexCoord = Cartesian2.fromElements(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, scratchMinTexCoord);\n        var maxTexCoord = Cartesian2.fromElements(Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY, scratchMaxTexCoord);\n\n        var length = positions.length;\n        var stOffset = length / 3 * 2;\n        for (var i = 0; i < length; i += 3) {\n            var i1 = i + 1;\n            var i2 = i + 2;\n            var position = Cartesian3.fromArray(positions, i, scratchCartesian1);\n            var extrudedPosition;\n\n            if (vertexFormat.st) {\n                var rotatedPoint = Matrix3.multiplyByVector(textureMatrix, position, scratchCartesian2);\n                var projectedPoint = projection.project(ellipsoid.cartesianToCartographic(rotatedPoint, scratchCartographic), scratchCartesian3);\n                Cartesian3.subtract(projectedPoint, projectedCenter, projectedPoint);\n\n                texCoordScratch.x = (projectedPoint.x + semiMajorAxis) / (2.0 * semiMajorAxis);\n                texCoordScratch.y = (projectedPoint.y + semiMinorAxis) / (2.0 * semiMinorAxis);\n\n                minTexCoord.x = Math.min(texCoordScratch.x, minTexCoord.x);\n                minTexCoord.y = Math.min(texCoordScratch.y, minTexCoord.y);\n                maxTexCoord.x = Math.max(texCoordScratch.x, maxTexCoord.x);\n                maxTexCoord.y = Math.max(texCoordScratch.y, maxTexCoord.y);\n\n                textureCoordinates[textureCoordIndex + stOffset] = texCoordScratch.x;\n                textureCoordinates[textureCoordIndex + 1 + stOffset] = texCoordScratch.y;\n\n                textureCoordinates[textureCoordIndex++] = texCoordScratch.x;\n                textureCoordinates[textureCoordIndex++] = texCoordScratch.y;\n            }\n\n            position = ellipsoid.scaleToGeodeticSurface(position, position);\n            extrudedPosition = Cartesian3.clone(position, scratchCartesian2);\n            normal = ellipsoid.geodeticSurfaceNormal(position, normal);\n\n            if (shadowVolume) {\n                extrudeNormals[i + length] = -normal.x;\n                extrudeNormals[i1 + length] = -normal.y;\n                extrudeNormals[i2 + length] = -normal.z;\n            }\n\n            var scaledNormal = Cartesian3.multiplyByScalar(normal, height, scratchCartesian4);\n            position = Cartesian3.add(position, scaledNormal, position);\n            scaledNormal = Cartesian3.multiplyByScalar(normal, extrudedHeight, scaledNormal);\n            extrudedPosition = Cartesian3.add(extrudedPosition, scaledNormal, extrudedPosition);\n\n            if (vertexFormat.position) {\n                finalPositions[i + length] = extrudedPosition.x;\n                finalPositions[i1 + length] = extrudedPosition.y;\n                finalPositions[i2 + length] = extrudedPosition.z;\n\n                finalPositions[i] = position.x;\n                finalPositions[i1] = position.y;\n                finalPositions[i2] = position.z;\n            }\n\n            if (vertexFormat.normal || vertexFormat.tangent || vertexFormat.bitangent) {\n\n                bitangent = Cartesian3.clone(normal, bitangent);\n                var next = Cartesian3.fromArray(positions, (i + 3) % length, scratchCartesian4);\n                Cartesian3.subtract(next, position, next);\n                var bottom = Cartesian3.subtract(extrudedPosition, position, scratchCartesian3);\n\n                normal = Cartesian3.normalize(Cartesian3.cross(bottom, next, normal), normal);\n\n                if (vertexFormat.normal) {\n                    normals[i] = normal.x;\n                    normals[i1] = normal.y;\n                    normals[i2] = normal.z;\n\n                    normals[i + length] = normal.x;\n                    normals[i1 + length] = normal.y;\n                    normals[i2 + length] = normal.z;\n                }\n\n                if (vertexFormat.tangent) {\n                    tangent = Cartesian3.normalize(Cartesian3.cross(bitangent, normal, tangent), tangent);\n                    tangents[i] = tangent.x;\n                    tangents[i1] = tangent.y;\n                    tangents[i2] = tangent.z;\n\n                    tangents[i + length] = tangent.x;\n                    tangents[i + 1 + length] = tangent.y;\n                    tangents[i + 2 + length] = tangent.z;\n                }\n\n                if (vertexFormat.bitangent) {\n                    bitangents[i ] = bitangent.x;\n                    bitangents[i1] = bitangent.y;\n                    bitangents[i2] = bitangent.z;\n\n                    bitangents[i + length] = bitangent.x;\n                    bitangents[i1 + length] = bitangent.y;\n                    bitangents[i2 + length] = bitangent.z;\n                }\n            }\n        }\n\n        if (vertexFormat.st) {\n            length = textureCoordinates.length;\n            for (var k = 0; k < length; k += 2) {\n                textureCoordinates[k] = (textureCoordinates[k] - minTexCoord.x) / (maxTexCoord.x - minTexCoord.x);\n                textureCoordinates[k + 1] = (textureCoordinates[k + 1] - minTexCoord.y) / (maxTexCoord.y - minTexCoord.y);\n            }\n        }\n\n        var attributes = new GeometryAttributes();\n\n        if (vertexFormat.position) {\n            attributes.position = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.DOUBLE,\n                componentsPerAttribute : 3,\n                values : finalPositions\n            });\n        }\n\n        if (vertexFormat.st) {\n            attributes.st = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.FLOAT,\n                componentsPerAttribute : 2,\n                values : textureCoordinates\n            });\n        }\n\n        if (vertexFormat.normal) {\n            attributes.normal = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.FLOAT,\n                componentsPerAttribute : 3,\n                values : normals\n            });\n        }\n\n        if (vertexFormat.tangent) {\n            attributes.tangent = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.FLOAT,\n                componentsPerAttribute : 3,\n                values : tangents\n            });\n        }\n\n        if (vertexFormat.bitangent) {\n            attributes.bitangent = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.FLOAT,\n                componentsPerAttribute : 3,\n                values : bitangents\n            });\n        }\n\n        if (shadowVolume) {\n            attributes.extrudeDirection = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.FLOAT,\n                componentsPerAttribute : 3,\n                values : extrudeNormals\n            });\n        }\n\n        if (defined(options.offsetAttribute)) {\n            var offsetAttribute = new Uint8Array(size);\n            if (options.offsetAttribute === GeometryOffsetAttribute.TOP) {\n                offsetAttribute = arrayFill(offsetAttribute, 1, 0, size / 2);\n            } else {\n                var offsetValue = options.offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;\n                offsetAttribute = arrayFill(offsetAttribute, offsetValue);\n            }\n            attributes.applyOffset = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.UNSIGNED_BYTE,\n                componentsPerAttribute : 1,\n                values : offsetAttribute\n            });\n        }\n\n        return attributes;\n    }\n\n    function computeWallIndices(positions) {\n        var length = positions.length / 3;\n        var indices = IndexDatatype.createTypedArray(length, length * 6);\n        var index = 0;\n        for (var i = 0; i < length; i++) {\n            var UL = i;\n            var LL = i + length;\n            var UR = (UL + 1) % length;\n            var LR = UR + length;\n            indices[index++] = UL;\n            indices[index++] = LL;\n            indices[index++] = UR;\n            indices[index++] = UR;\n            indices[index++] = LL;\n            indices[index++] = LR;\n        }\n\n        return indices;\n    }\n\n    var topBoundingSphere = new BoundingSphere();\n    var bottomBoundingSphere = new BoundingSphere();\n\n    function computeExtrudedEllipse(options) {\n        var center = options.center;\n        var ellipsoid = options.ellipsoid;\n        var semiMajorAxis = options.semiMajorAxis;\n        var scaledNormal = Cartesian3.multiplyByScalar(ellipsoid.geodeticSurfaceNormal(center, scratchCartesian1), options.height, scratchCartesian1);\n        topBoundingSphere.center = Cartesian3.add(center, scaledNormal, topBoundingSphere.center);\n        topBoundingSphere.radius = semiMajorAxis;\n\n        scaledNormal = Cartesian3.multiplyByScalar(ellipsoid.geodeticSurfaceNormal(center, scaledNormal), options.extrudedHeight, scaledNormal);\n        bottomBoundingSphere.center = Cartesian3.add(center, scaledNormal, bottomBoundingSphere.center);\n        bottomBoundingSphere.radius = semiMajorAxis;\n\n        var cep = EllipseGeometryLibrary.computeEllipsePositions(options, true, true);\n        var positions = cep.positions;\n        var numPts = cep.numPts;\n        var outerPositions = cep.outerPositions;\n        var boundingSphere = BoundingSphere.union(topBoundingSphere, bottomBoundingSphere);\n        var topBottomAttributes = computeTopBottomAttributes(positions, options, true);\n        var indices = topIndices(numPts);\n        var length = indices.length;\n        indices.length = length * 2;\n        var posLength = positions.length / 3;\n        for (var i = 0; i < length; i += 3) {\n            indices[i + length] = indices[i + 2] + posLength;\n            indices[i + 1 + length] = indices[i + 1] + posLength;\n            indices[i + 2 + length] = indices[i] + posLength;\n        }\n\n        var topBottomIndices = IndexDatatype.createTypedArray(posLength * 2 / 3, indices);\n\n        var topBottomGeo = new Geometry({\n            attributes : topBottomAttributes,\n            indices : topBottomIndices,\n            primitiveType : PrimitiveType.TRIANGLES\n        });\n\n        var wallAttributes = computeWallAttributes(outerPositions, options);\n        indices = computeWallIndices(outerPositions);\n        var wallIndices = IndexDatatype.createTypedArray(outerPositions.length * 2 / 3, indices);\n\n        var wallGeo = new Geometry({\n            attributes : wallAttributes,\n            indices : wallIndices,\n            primitiveType : PrimitiveType.TRIANGLES\n        });\n\n        var geo = GeometryPipeline.combineInstances([\n            new GeometryInstance({\n                geometry : topBottomGeo\n            }),\n            new GeometryInstance({\n                geometry : wallGeo\n            })\n        ]);\n\n        return {\n            boundingSphere : boundingSphere,\n            attributes : geo[0].attributes,\n            indices : geo[0].indices\n        };\n    }\n\n    function computeRectangle(center, semiMajorAxis, semiMinorAxis, rotation, granularity, ellipsoid, result) {\n        var cep = EllipseGeometryLibrary.computeEllipsePositions({\n            center : center,\n            semiMajorAxis : semiMajorAxis,\n            semiMinorAxis : semiMinorAxis,\n            rotation : rotation,\n            granularity : granularity\n        }, false, true);\n        var positionsFlat = cep.outerPositions;\n        var positionsCount = positionsFlat.length / 3;\n        var positions = new Array(positionsCount);\n        for (var i = 0; i < positionsCount; ++i) {\n            positions[i] = Cartesian3.fromArray(positionsFlat, i * 3);\n        }\n        var rectangle = Rectangle.fromCartesianArray(positions, ellipsoid, result);\n        // Rectangle width goes beyond 180 degrees when the ellipse crosses a pole.\n        // When this happens, make the rectangle into a \"circle\" around the pole\n        if (rectangle.width > CesiumMath.PI) {\n            rectangle.north = rectangle.north > 0.0 ? CesiumMath.PI_OVER_TWO - CesiumMath.EPSILON7 : rectangle.north;\n            rectangle.south = rectangle.south < 0.0 ? CesiumMath.EPSILON7 - CesiumMath.PI_OVER_TWO : rectangle.south;\n            rectangle.east = CesiumMath.PI;\n            rectangle.west = -CesiumMath.PI;\n        }\n        return rectangle;\n    }\n\n    /**\n     * A description of an ellipse on an ellipsoid. Ellipse geometry can be rendered with both {@link Primitive} and {@link GroundPrimitive}.\n     *\n     * @alias EllipseGeometry\n     * @constructor\n     *\n     * @param {Object} options Object with the following properties:\n     * @param {Cartesian3} options.center The ellipse's center point in the fixed frame.\n     * @param {Number} options.semiMajorAxis The length of the ellipse's semi-major axis in meters.\n     * @param {Number} options.semiMinorAxis The length of the ellipse's semi-minor axis in meters.\n     * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid the ellipse will be on.\n     * @param {Number} [options.height=0.0] The distance in meters between the ellipse and the ellipsoid surface.\n     * @param {Number} [options.extrudedHeight] The distance in meters between the ellipse's extruded face and the ellipsoid surface.\n     * @param {Number} [options.rotation=0.0] The angle of rotation counter-clockwise from north.\n     * @param {Number} [options.stRotation=0.0] The rotation of the texture coordinates counter-clockwise from north.\n     * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The angular distance between points on the ellipse in radians.\n     * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\n     *\n     * @exception {DeveloperError} semiMajorAxis and semiMinorAxis must be greater than zero.\n     * @exception {DeveloperError} semiMajorAxis must be greater than or equal to the semiMinorAxis.\n     * @exception {DeveloperError} granularity must be greater than zero.\n     *\n     *\n     * @example\n     * // Create an ellipse.\n     * var ellipse = new Cesium.EllipseGeometry({\n     *   center : Cesium.Cartesian3.fromDegrees(-75.59777, 40.03883),\n     *   semiMajorAxis : 500000.0,\n     *   semiMinorAxis : 300000.0,\n     *   rotation : Cesium.Math.toRadians(60.0)\n     * });\n     * var geometry = Cesium.EllipseGeometry.createGeometry(ellipse);\n     *\n     * @see EllipseGeometry.createGeometry\n     */\n    function EllipseGeometry(options) {\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n        var center = options.center;\n        var ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\n        var semiMajorAxis = options.semiMajorAxis;\n        var semiMinorAxis = options.semiMinorAxis;\n        var granularity = defaultValue(options.granularity, CesiumMath.RADIANS_PER_DEGREE);\n        var vertexFormat = defaultValue(options.vertexFormat, VertexFormat.DEFAULT);\n\n        \n\n        var height = defaultValue(options.height, 0.0);\n        var extrudedHeight = defaultValue(options.extrudedHeight, height);\n\n        this._center = Cartesian3.clone(center);\n        this._semiMajorAxis = semiMajorAxis;\n        this._semiMinorAxis = semiMinorAxis;\n        this._ellipsoid = Ellipsoid.clone(ellipsoid);\n        this._rotation = defaultValue(options.rotation, 0.0);\n        this._stRotation = defaultValue(options.stRotation, 0.0);\n        this._height = Math.max(extrudedHeight, height);\n        this._granularity = granularity;\n        this._vertexFormat = VertexFormat.clone(vertexFormat);\n        this._extrudedHeight = Math.min(extrudedHeight, height);\n        this._shadowVolume = defaultValue(options.shadowVolume, false);\n        this._workerName = 'createEllipseGeometry';\n        this._offsetAttribute = options.offsetAttribute;\n\n        this._rectangle = undefined;\n        this._textureCoordinateRotationPoints = undefined;\n    }\n\n    /**\n     * The number of elements used to pack the object into an array.\n     * @type {Number}\n     */\n    EllipseGeometry.packedLength = Cartesian3.packedLength + Ellipsoid.packedLength + VertexFormat.packedLength + 9;\n\n    /**\n     * Stores the provided instance into the provided array.\n     *\n     * @param {EllipseGeometry} value The value to pack.\n     * @param {Number[]} array The array to pack into.\n     * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n     *\n     * @returns {Number[]} The array that was packed into\n     */\n    EllipseGeometry.pack = function(value, array, startingIndex) {\n        \n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        Cartesian3.pack(value._center, array, startingIndex);\n        startingIndex += Cartesian3.packedLength;\n\n        Ellipsoid.pack(value._ellipsoid, array, startingIndex);\n        startingIndex += Ellipsoid.packedLength;\n\n        VertexFormat.pack(value._vertexFormat, array, startingIndex);\n        startingIndex += VertexFormat.packedLength;\n\n        array[startingIndex++] = value._semiMajorAxis;\n        array[startingIndex++] = value._semiMinorAxis;\n        array[startingIndex++] = value._rotation;\n        array[startingIndex++] = value._stRotation;\n        array[startingIndex++] = value._height;\n        array[startingIndex++] = value._granularity;\n        array[startingIndex++] = value._extrudedHeight;\n        array[startingIndex++] = value._shadowVolume ? 1.0 : 0.0;\n        array[startingIndex] = defaultValue(value._offsetAttribute, -1);\n\n        return array;\n    };\n\n    var scratchCenter = new Cartesian3();\n    var scratchEllipsoid = new Ellipsoid();\n    var scratchVertexFormat = new VertexFormat();\n    var scratchOptions = {\n        center : scratchCenter,\n        ellipsoid : scratchEllipsoid,\n        vertexFormat : scratchVertexFormat,\n        semiMajorAxis : undefined,\n        semiMinorAxis : undefined,\n        rotation : undefined,\n        stRotation : undefined,\n        height : undefined,\n        granularity : undefined,\n        extrudedHeight : undefined,\n        shadowVolume: undefined,\n        offsetAttribute: undefined\n    };\n\n    /**\n     * Retrieves an instance from a packed array.\n     *\n     * @param {Number[]} array The packed array.\n     * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n     * @param {EllipseGeometry} [result] The object into which to store the result.\n     * @returns {EllipseGeometry} The modified result parameter or a new EllipseGeometry instance if one was not provided.\n     */\n    EllipseGeometry.unpack = function(array, startingIndex, result) {\n        \n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        var center = Cartesian3.unpack(array, startingIndex, scratchCenter);\n        startingIndex += Cartesian3.packedLength;\n\n        var ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);\n        startingIndex += Ellipsoid.packedLength;\n\n        var vertexFormat = VertexFormat.unpack(array, startingIndex, scratchVertexFormat);\n        startingIndex += VertexFormat.packedLength;\n\n        var semiMajorAxis = array[startingIndex++];\n        var semiMinorAxis = array[startingIndex++];\n        var rotation = array[startingIndex++];\n        var stRotation = array[startingIndex++];\n        var height = array[startingIndex++];\n        var granularity = array[startingIndex++];\n        var extrudedHeight = array[startingIndex++];\n        var shadowVolume = array[startingIndex++] === 1.0;\n        var offsetAttribute = array[startingIndex];\n\n        if (!defined(result)) {\n            scratchOptions.height = height;\n            scratchOptions.extrudedHeight = extrudedHeight;\n            scratchOptions.granularity = granularity;\n            scratchOptions.stRotation = stRotation;\n            scratchOptions.rotation = rotation;\n            scratchOptions.semiMajorAxis = semiMajorAxis;\n            scratchOptions.semiMinorAxis = semiMinorAxis;\n            scratchOptions.shadowVolume = shadowVolume;\n            scratchOptions.offsetAttribute = offsetAttribute === -1 ? undefined : offsetAttribute;\n\n            return new EllipseGeometry(scratchOptions);\n        }\n\n        result._center = Cartesian3.clone(center, result._center);\n        result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);\n        result._vertexFormat = VertexFormat.clone(vertexFormat, result._vertexFormat);\n        result._semiMajorAxis = semiMajorAxis;\n        result._semiMinorAxis = semiMinorAxis;\n        result._rotation = rotation;\n        result._stRotation = stRotation;\n        result._height = height;\n        result._granularity = granularity;\n        result._extrudedHeight = extrudedHeight;\n        result._shadowVolume = shadowVolume;\n        result._offsetAttribute = offsetAttribute === -1 ? undefined : offsetAttribute;\n\n        return result;\n    };\n\n    /**\n     * Computes the bounding rectangle based on the provided options\n     *\n     * @param {Object} options Object with the following properties:\n     * @param {Cartesian3} options.center The ellipse's center point in the fixed frame.\n     * @param {Number} options.semiMajorAxis The length of the ellipse's semi-major axis in meters.\n     * @param {Number} options.semiMinorAxis The length of the ellipse's semi-minor axis in meters.\n     * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid the ellipse will be on.\n     * @param {Number} [options.rotation=0.0] The angle of rotation counter-clockwise from north.\n     * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The angular distance between points on the ellipse in radians.\n     * @param {Rectangle} [result] An object in which to store the result\n     *\n     * @returns {Rectangle} The result rectangle\n     */\n    EllipseGeometry.computeRectangle = function(options, result) {\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n        var center = options.center;\n        var ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\n        var semiMajorAxis = options.semiMajorAxis;\n        var semiMinorAxis = options.semiMinorAxis;\n        var granularity = defaultValue(options.granularity, CesiumMath.RADIANS_PER_DEGREE);\n        var rotation = defaultValue(options.rotation, 0.0);\n\n        \n\n        return computeRectangle(center, semiMajorAxis, semiMinorAxis, rotation, granularity, ellipsoid, result);\n    };\n\n    /**\n     * Computes the geometric representation of a ellipse on an ellipsoid, including its vertices, indices, and a bounding sphere.\n     *\n     * @param {EllipseGeometry} ellipseGeometry A description of the ellipse.\n     * @returns {Geometry|undefined} The computed vertices and indices.\n     */\n    EllipseGeometry.createGeometry = function(ellipseGeometry) {\n        if ((ellipseGeometry._semiMajorAxis <= 0.0) || (ellipseGeometry._semiMinorAxis <= 0.0)) {\n            return;\n        }\n\n        var height = ellipseGeometry._height;\n        var extrudedHeight = ellipseGeometry._extrudedHeight;\n        var extrude = !CesiumMath.equalsEpsilon(height, extrudedHeight, 0, CesiumMath.EPSILON2);\n\n        ellipseGeometry._center = ellipseGeometry._ellipsoid.scaleToGeodeticSurface(ellipseGeometry._center, ellipseGeometry._center);\n        var options = {\n            center : ellipseGeometry._center,\n            semiMajorAxis : ellipseGeometry._semiMajorAxis,\n            semiMinorAxis : ellipseGeometry._semiMinorAxis,\n            ellipsoid : ellipseGeometry._ellipsoid,\n            rotation : ellipseGeometry._rotation,\n            height : height,\n            granularity : ellipseGeometry._granularity,\n            vertexFormat : ellipseGeometry._vertexFormat,\n            stRotation : ellipseGeometry._stRotation\n        };\n        var geometry;\n        if (extrude) {\n            options.extrudedHeight = extrudedHeight;\n            options.shadowVolume = ellipseGeometry._shadowVolume;\n            options.offsetAttribute = ellipseGeometry._offsetAttribute;\n            geometry = computeExtrudedEllipse(options);\n        } else {\n            geometry = computeEllipse(options);\n\n            if (defined(ellipseGeometry._offsetAttribute)) {\n                var length = geometry.attributes.position.values.length;\n                var applyOffset = new Uint8Array(length / 3);\n                var offsetValue = ellipseGeometry._offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;\n                arrayFill(applyOffset, offsetValue);\n                geometry.attributes.applyOffset = new GeometryAttribute({\n                    componentDatatype : ComponentDatatype.UNSIGNED_BYTE,\n                    componentsPerAttribute : 1,\n                    values: applyOffset\n                });\n            }\n        }\n\n        return new Geometry({\n            attributes : geometry.attributes,\n            indices : geometry.indices,\n            primitiveType : PrimitiveType.TRIANGLES,\n            boundingSphere : geometry.boundingSphere,\n            offsetAttribute : ellipseGeometry._offsetAttribute\n        });\n    };\n\n    /**\n     * @private\n     */\n    EllipseGeometry.createShadowVolume = function(ellipseGeometry, minHeightFunc, maxHeightFunc) {\n        var granularity = ellipseGeometry._granularity;\n        var ellipsoid = ellipseGeometry._ellipsoid;\n\n        var minHeight = minHeightFunc(granularity, ellipsoid);\n        var maxHeight = maxHeightFunc(granularity, ellipsoid);\n\n        return new EllipseGeometry({\n            center : ellipseGeometry._center,\n            semiMajorAxis : ellipseGeometry._semiMajorAxis,\n            semiMinorAxis : ellipseGeometry._semiMinorAxis,\n            ellipsoid : ellipsoid,\n            rotation : ellipseGeometry._rotation,\n            stRotation : ellipseGeometry._stRotation,\n            granularity : granularity,\n            extrudedHeight : minHeight,\n            height : maxHeight,\n            vertexFormat : VertexFormat.POSITION_ONLY,\n            shadowVolume: true\n        });\n    };\n\n    function textureCoordinateRotationPoints(ellipseGeometry) {\n        var stRotation = -ellipseGeometry._stRotation;\n        if (stRotation === 0.0) {\n            return [0, 0, 0, 1, 1, 0];\n        }\n\n        var cep = EllipseGeometryLibrary.computeEllipsePositions({\n            center : ellipseGeometry._center,\n            semiMajorAxis : ellipseGeometry._semiMajorAxis,\n            semiMinorAxis : ellipseGeometry._semiMinorAxis,\n            rotation : ellipseGeometry._rotation,\n            granularity : ellipseGeometry._granularity\n        }, false, true);\n        var positionsFlat = cep.outerPositions;\n        var positionsCount = positionsFlat.length / 3;\n        var positions = new Array(positionsCount);\n        for (var i = 0; i < positionsCount; ++i) {\n            positions[i] = Cartesian3.fromArray(positionsFlat, i * 3);\n        }\n\n        var ellipsoid = ellipseGeometry._ellipsoid;\n        var boundingRectangle = ellipseGeometry.rectangle;\n        return Geometry._textureCoordinateRotationPoints(positions, stRotation, ellipsoid, boundingRectangle);\n    }\n\n    defineProperties(EllipseGeometry.prototype, {\n        /**\n         * @private\n         */\n        rectangle : {\n            get : function() {\n                if (!defined(this._rectangle)) {\n                    this._rectangle = computeRectangle(this._center, this._semiMajorAxis, this._semiMinorAxis, this._rotation, this._granularity, this._ellipsoid);\n                }\n                return this._rectangle;\n            }\n        },\n        /**\n         * For remapping texture coordinates when rendering EllipseGeometries as GroundPrimitives.\n         * @private\n         */\n        textureCoordinateRotationPoints : {\n            get : function() {\n                if (!defined(this._textureCoordinateRotationPoints)) {\n                    this._textureCoordinateRotationPoints = textureCoordinateRotationPoints(this);\n                }\n                return this._textureCoordinateRotationPoints;\n            }\n        }\n    });\nexport default EllipseGeometry;\n","import arrayFill from './arrayFill.js';\nimport BoundingSphere from './BoundingSphere.js';\nimport Cartesian3 from './Cartesian3.js';\nimport ComponentDatatype from './ComponentDatatype.js';\nimport defaultValue from './defaultValue.js';\nimport defined from './defined.js';\nimport DeveloperError from './DeveloperError.js';\nimport EllipseGeometryLibrary from './EllipseGeometryLibrary.js';\nimport Ellipsoid from './Ellipsoid.js';\nimport Geometry from './Geometry.js';\nimport GeometryAttribute from './GeometryAttribute.js';\nimport GeometryAttributes from './GeometryAttributes.js';\nimport GeometryOffsetAttribute from './GeometryOffsetAttribute.js';\nimport IndexDatatype from './IndexDatatype.js';\nimport CesiumMath from './Math.js';\nimport PrimitiveType from './PrimitiveType.js';\n\n    var scratchCartesian1 = new Cartesian3();\n    var boundingSphereCenter = new Cartesian3();\n\n    function computeEllipse(options) {\n        var center = options.center;\n        boundingSphereCenter = Cartesian3.multiplyByScalar(options.ellipsoid.geodeticSurfaceNormal(center, boundingSphereCenter), options.height, boundingSphereCenter);\n        boundingSphereCenter = Cartesian3.add(center, boundingSphereCenter, boundingSphereCenter);\n        var boundingSphere = new BoundingSphere(boundingSphereCenter, options.semiMajorAxis);\n        var positions = EllipseGeometryLibrary.computeEllipsePositions(options, false, true).outerPositions;\n\n        var attributes = new GeometryAttributes({\n            position: new GeometryAttribute({\n                componentDatatype : ComponentDatatype.DOUBLE,\n                componentsPerAttribute : 3,\n                values : EllipseGeometryLibrary.raisePositionsToHeight(positions, options, false)\n            })\n        });\n\n        var length = positions.length / 3;\n        var indices = IndexDatatype.createTypedArray(length, length * 2);\n        var index = 0;\n        for ( var i = 0; i < length; ++i) {\n            indices[index++] = i;\n            indices[index++] = (i + 1) % length;\n        }\n\n        return {\n            boundingSphere : boundingSphere,\n            attributes : attributes,\n            indices : indices\n        };\n    }\n\n    var topBoundingSphere = new BoundingSphere();\n    var bottomBoundingSphere = new BoundingSphere();\n    function computeExtrudedEllipse(options) {\n        var center = options.center;\n        var ellipsoid = options.ellipsoid;\n        var semiMajorAxis = options.semiMajorAxis;\n        var scaledNormal = Cartesian3.multiplyByScalar(ellipsoid.geodeticSurfaceNormal(center, scratchCartesian1), options.height, scratchCartesian1);\n        topBoundingSphere.center = Cartesian3.add(center, scaledNormal, topBoundingSphere.center);\n        topBoundingSphere.radius = semiMajorAxis;\n\n        scaledNormal = Cartesian3.multiplyByScalar(ellipsoid.geodeticSurfaceNormal(center, scaledNormal), options.extrudedHeight, scaledNormal);\n        bottomBoundingSphere.center = Cartesian3.add(center, scaledNormal, bottomBoundingSphere.center);\n        bottomBoundingSphere.radius = semiMajorAxis;\n\n        var positions = EllipseGeometryLibrary.computeEllipsePositions(options, false, true).outerPositions;\n        var attributes = new GeometryAttributes({\n            position: new GeometryAttribute({\n                componentDatatype : ComponentDatatype.DOUBLE,\n                componentsPerAttribute : 3,\n                values : EllipseGeometryLibrary.raisePositionsToHeight(positions, options, true)\n            })\n        });\n\n        positions = attributes.position.values;\n        var boundingSphere = BoundingSphere.union(topBoundingSphere, bottomBoundingSphere);\n        var length = positions.length/3;\n\n        if (defined(options.offsetAttribute)) {\n            var applyOffset = new Uint8Array(length);\n            if (options.offsetAttribute === GeometryOffsetAttribute.TOP) {\n                applyOffset = arrayFill(applyOffset, 1, 0, length / 2);\n            } else {\n                var offsetValue = options.offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;\n                applyOffset = arrayFill(applyOffset, offsetValue);\n            }\n\n            attributes.applyOffset = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.UNSIGNED_BYTE,\n                componentsPerAttribute : 1,\n                values: applyOffset\n            });\n        }\n\n        var numberOfVerticalLines = defaultValue(options.numberOfVerticalLines, 16);\n        numberOfVerticalLines = CesiumMath.clamp(numberOfVerticalLines, 0, length/2);\n\n        var indices = IndexDatatype.createTypedArray(length, length * 2 + numberOfVerticalLines * 2);\n\n        length /= 2;\n        var index = 0;\n        var i;\n        for (i = 0; i < length; ++i) {\n            indices[index++] = i;\n            indices[index++] = (i + 1) % length;\n            indices[index++] = i + length;\n            indices[index++] = ((i + 1) % length) + length;\n        }\n\n        var numSide;\n        if (numberOfVerticalLines > 0) {\n            var numSideLines = Math.min(numberOfVerticalLines, length);\n            numSide = Math.round(length / numSideLines);\n\n            var maxI = Math.min(numSide * numberOfVerticalLines, length);\n            for (i = 0; i < maxI; i += numSide) {\n                indices[index++] = i;\n                indices[index++] = i + length;\n            }\n        }\n\n        return {\n            boundingSphere : boundingSphere,\n            attributes : attributes,\n            indices : indices\n        };\n    }\n\n    /**\n     * A description of the outline of an ellipse on an ellipsoid.\n     *\n     * @alias EllipseOutlineGeometry\n     * @constructor\n     *\n     * @param {Object} options Object with the following properties:\n     * @param {Cartesian3} options.center The ellipse's center point in the fixed frame.\n     * @param {Number} options.semiMajorAxis The length of the ellipse's semi-major axis in meters.\n     * @param {Number} options.semiMinorAxis The length of the ellipse's semi-minor axis in meters.\n     * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid the ellipse will be on.\n     * @param {Number} [options.height=0.0] The distance in meters between the ellipse and the ellipsoid surface.\n     * @param {Number} [options.extrudedHeight] The distance in meters between the ellipse's extruded face and the ellipsoid surface.\n     * @param {Number} [options.rotation=0.0] The angle from north (counter-clockwise) in radians.\n     * @param {Number} [options.granularity=0.02] The angular distance between points on the ellipse in radians.\n     * @param {Number} [options.numberOfVerticalLines=16] Number of lines to draw between the top and bottom surface of an extruded ellipse.\n     *\n     * @exception {DeveloperError} semiMajorAxis and semiMinorAxis must be greater than zero.\n     * @exception {DeveloperError} semiMajorAxis must be greater than or equal to the semiMinorAxis.\n     * @exception {DeveloperError} granularity must be greater than zero.\n     *\n     * @see EllipseOutlineGeometry.createGeometry\n     *\n     * @example\n     * var ellipse = new Cesium.EllipseOutlineGeometry({\n     *   center : Cesium.Cartesian3.fromDegrees(-75.59777, 40.03883),\n     *   semiMajorAxis : 500000.0,\n     *   semiMinorAxis : 300000.0,\n     *   rotation : Cesium.Math.toRadians(60.0)\n     * });\n     * var geometry = Cesium.EllipseOutlineGeometry.createGeometry(ellipse);\n     */\n    function EllipseOutlineGeometry(options) {\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n        var center = options.center;\n        var ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\n        var semiMajorAxis = options.semiMajorAxis;\n        var semiMinorAxis = options.semiMinorAxis;\n        var granularity = defaultValue(options.granularity, CesiumMath.RADIANS_PER_DEGREE);\n\n        \n\n        var height = defaultValue(options.height, 0.0);\n        var extrudedHeight = defaultValue(options.extrudedHeight, height);\n\n        this._center = Cartesian3.clone(center);\n        this._semiMajorAxis = semiMajorAxis;\n        this._semiMinorAxis = semiMinorAxis;\n        this._ellipsoid = Ellipsoid.clone(ellipsoid);\n        this._rotation = defaultValue(options.rotation, 0.0);\n        this._height = Math.max(extrudedHeight, height);\n        this._granularity = granularity;\n        this._extrudedHeight = Math.min(extrudedHeight, height);\n        this._numberOfVerticalLines = Math.max(defaultValue(options.numberOfVerticalLines, 16), 0);\n        this._offsetAttribute = options.offsetAttribute;\n        this._workerName = 'createEllipseOutlineGeometry';\n    }\n\n    /**\n     * The number of elements used to pack the object into an array.\n     * @type {Number}\n     */\n    EllipseOutlineGeometry.packedLength = Cartesian3.packedLength + Ellipsoid.packedLength + 8;\n\n    /**\n     * Stores the provided instance into the provided array.\n     *\n     * @param {EllipseOutlineGeometry} value The value to pack.\n     * @param {Number[]} array The array to pack into.\n     * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n     *\n     * @returns {Number[]} The array that was packed into\n     */\n    EllipseOutlineGeometry.pack = function(value, array, startingIndex) {\n        \n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        Cartesian3.pack(value._center, array, startingIndex);\n        startingIndex += Cartesian3.packedLength;\n\n        Ellipsoid.pack(value._ellipsoid, array, startingIndex);\n        startingIndex += Ellipsoid.packedLength;\n\n        array[startingIndex++] = value._semiMajorAxis;\n        array[startingIndex++] = value._semiMinorAxis;\n        array[startingIndex++] = value._rotation;\n        array[startingIndex++] = value._height;\n        array[startingIndex++] = value._granularity;\n        array[startingIndex++] = value._extrudedHeight;\n        array[startingIndex++]   = value._numberOfVerticalLines;\n        array[startingIndex] = defaultValue(value._offsetAttribute, -1);\n\n        return array;\n    };\n\n    var scratchCenter = new Cartesian3();\n    var scratchEllipsoid = new Ellipsoid();\n    var scratchOptions = {\n        center : scratchCenter,\n        ellipsoid : scratchEllipsoid,\n        semiMajorAxis : undefined,\n        semiMinorAxis : undefined,\n        rotation : undefined,\n        height : undefined,\n        granularity : undefined,\n        extrudedHeight : undefined,\n        numberOfVerticalLines : undefined,\n        offsetAttribute: undefined\n    };\n\n    /**\n     * Retrieves an instance from a packed array.\n     *\n     * @param {Number[]} array The packed array.\n     * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n     * @param {EllipseOutlineGeometry} [result] The object into which to store the result.\n     * @returns {EllipseOutlineGeometry} The modified result parameter or a new EllipseOutlineGeometry instance if one was not provided.\n     */\n    EllipseOutlineGeometry.unpack = function(array, startingIndex, result) {\n        \n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        var center = Cartesian3.unpack(array, startingIndex, scratchCenter);\n        startingIndex += Cartesian3.packedLength;\n\n        var ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);\n        startingIndex += Ellipsoid.packedLength;\n\n        var semiMajorAxis = array[startingIndex++];\n        var semiMinorAxis = array[startingIndex++];\n        var rotation = array[startingIndex++];\n        var height = array[startingIndex++];\n        var granularity = array[startingIndex++];\n        var extrudedHeight = array[startingIndex++];\n        var numberOfVerticalLines = array[startingIndex++];\n        var offsetAttribute = array[startingIndex];\n\n        if (!defined(result)) {\n            scratchOptions.height = height;\n            scratchOptions.extrudedHeight = extrudedHeight;\n            scratchOptions.granularity = granularity;\n            scratchOptions.rotation = rotation;\n            scratchOptions.semiMajorAxis = semiMajorAxis;\n            scratchOptions.semiMinorAxis = semiMinorAxis;\n            scratchOptions.numberOfVerticalLines = numberOfVerticalLines;\n            scratchOptions.offsetAttribute = offsetAttribute === -1 ? undefined : offsetAttribute;\n\n            return new EllipseOutlineGeometry(scratchOptions);\n        }\n\n        result._center = Cartesian3.clone(center, result._center);\n        result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);\n        result._semiMajorAxis = semiMajorAxis;\n        result._semiMinorAxis = semiMinorAxis;\n        result._rotation = rotation;\n        result._height = height;\n        result._granularity = granularity;\n        result._extrudedHeight = extrudedHeight;\n        result._numberOfVerticalLines = numberOfVerticalLines;\n        result._offsetAttribute = offsetAttribute === -1 ? undefined : offsetAttribute;\n\n        return result;\n    };\n\n    /**\n     * Computes the geometric representation of an outline of an ellipse on an ellipsoid, including its vertices, indices, and a bounding sphere.\n     *\n     * @param {EllipseOutlineGeometry} ellipseGeometry A description of the ellipse.\n     * @returns {Geometry|undefined} The computed vertices and indices.\n     */\n    EllipseOutlineGeometry.createGeometry = function(ellipseGeometry) {\n        if ((ellipseGeometry._semiMajorAxis <= 0.0) || (ellipseGeometry._semiMinorAxis <= 0.0)) {\n            return;\n        }\n\n        var height = ellipseGeometry._height;\n        var extrudedHeight = ellipseGeometry._extrudedHeight;\n        var extrude = !CesiumMath.equalsEpsilon(height, extrudedHeight, 0, CesiumMath.EPSILON2);\n\n        ellipseGeometry._center = ellipseGeometry._ellipsoid.scaleToGeodeticSurface(ellipseGeometry._center, ellipseGeometry._center);\n        var options = {\n            center : ellipseGeometry._center,\n            semiMajorAxis : ellipseGeometry._semiMajorAxis,\n            semiMinorAxis : ellipseGeometry._semiMinorAxis,\n            ellipsoid : ellipseGeometry._ellipsoid,\n            rotation : ellipseGeometry._rotation,\n            height : height,\n            granularity : ellipseGeometry._granularity,\n            numberOfVerticalLines : ellipseGeometry._numberOfVerticalLines\n        };\n        var geometry;\n        if (extrude) {\n            options.extrudedHeight = extrudedHeight;\n            options.offsetAttribute = ellipseGeometry._offsetAttribute;\n            geometry = computeExtrudedEllipse(options);\n        } else {\n            geometry = computeEllipse(options);\n\n            if (defined(ellipseGeometry._offsetAttribute)) {\n                var length = geometry.attributes.position.values.length;\n                var applyOffset = new Uint8Array(length / 3);\n                var offsetValue = ellipseGeometry._offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;\n                arrayFill(applyOffset, offsetValue);\n                geometry.attributes.applyOffset = new GeometryAttribute({\n                    componentDatatype : ComponentDatatype.UNSIGNED_BYTE,\n                    componentsPerAttribute : 1,\n                    values: applyOffset\n                });\n            }\n        }\n\n        return new Geometry({\n            attributes : geometry.attributes,\n            indices : geometry.indices,\n            primitiveType : PrimitiveType.LINES,\n            boundingSphere : geometry.boundingSphere,\n            offsetAttribute : ellipseGeometry._offsetAttribute\n        });\n    };\nexport default EllipseOutlineGeometry;\n","import ApproximateTerrainHeights from '../Core/ApproximateTerrainHeights.js';\nimport Cartesian3 from '../Core/Cartesian3.js';\nimport Check from '../Core/Check.js';\nimport Color from '../Core/Color.js';\nimport ColorGeometryInstanceAttribute from '../Core/ColorGeometryInstanceAttribute.js';\nimport defined from '../Core/defined.js';\nimport DeveloperError from '../Core/DeveloperError.js';\nimport DistanceDisplayConditionGeometryInstanceAttribute from '../Core/DistanceDisplayConditionGeometryInstanceAttribute.js';\nimport EllipseGeometry from '../Core/EllipseGeometry.js';\nimport EllipseOutlineGeometry from '../Core/EllipseOutlineGeometry.js';\nimport GeometryInstance from '../Core/GeometryInstance.js';\nimport Iso8601 from '../Core/Iso8601.js';\nimport OffsetGeometryInstanceAttribute from '../Core/OffsetGeometryInstanceAttribute.js';\nimport Rectangle from '../Core/Rectangle.js';\nimport ShowGeometryInstanceAttribute from '../Core/ShowGeometryInstanceAttribute.js';\nimport HeightReference from '../Scene/HeightReference.js';\nimport MaterialAppearance from '../Scene/MaterialAppearance.js';\nimport PerInstanceColorAppearance from '../Scene/PerInstanceColorAppearance.js';\nimport ColorMaterialProperty from './ColorMaterialProperty.js';\nimport DynamicGeometryUpdater from './DynamicGeometryUpdater.js';\nimport GeometryUpdater from './GeometryUpdater.js';\nimport GroundGeometryUpdater from './GroundGeometryUpdater.js';\nimport Property from './Property.js';\n\n    var scratchColor = new Color();\n    var defaultOffset = Cartesian3.ZERO;\n    var offsetScratch = new Cartesian3();\n    var scratchRectangle = new Rectangle();\n\n    function EllipseGeometryOptions(entity) {\n        this.id = entity;\n        this.vertexFormat = undefined;\n        this.center = undefined;\n        this.semiMajorAxis = undefined;\n        this.semiMinorAxis = undefined;\n        this.rotation = undefined;\n        this.height = undefined;\n        this.extrudedHeight = undefined;\n        this.granularity = undefined;\n        this.stRotation = undefined;\n        this.numberOfVerticalLines = undefined;\n        this.offsetAttribute = undefined;\n    }\n\n    /**\n     * A {@link GeometryUpdater} for ellipses.\n     * Clients do not normally create this class directly, but instead rely on {@link DataSourceDisplay}.\n     * @alias EllipseGeometryUpdater\n     * @constructor\n     *\n     * @param {Entity} entity The entity containing the geometry to be visualized.\n     * @param {Scene} scene The scene where visualization is taking place.\n     */\n    function EllipseGeometryUpdater(entity, scene) {\n        GroundGeometryUpdater.call(this, {\n            entity : entity,\n            scene : scene,\n            geometryOptions : new EllipseGeometryOptions(entity),\n            geometryPropertyName : 'ellipse',\n            observedPropertyNames : ['availability', 'position', 'ellipse']\n        });\n\n        this._onEntityPropertyChanged(entity, 'ellipse', entity.ellipse, undefined);\n    }\n\n    if (defined(Object.create)) {\n        EllipseGeometryUpdater.prototype = Object.create(GroundGeometryUpdater.prototype);\n        EllipseGeometryUpdater.prototype.constructor = EllipseGeometryUpdater;\n    }\n\n    /**\n     * Creates the geometry instance which represents the fill of the geometry.\n     *\n     * @param {JulianDate} time The time to use when retrieving initial attribute values.\n     * @returns {GeometryInstance} The geometry instance representing the filled portion of the geometry.\n     *\n     * @exception {DeveloperError} This instance does not represent a filled geometry.\n     */\n    EllipseGeometryUpdater.prototype.createFillGeometryInstance = function(time) {\n        \n\n        var entity = this._entity;\n        var isAvailable = entity.isAvailable(time);\n\n        var attributes = {\n            show : new ShowGeometryInstanceAttribute(isAvailable && entity.isShowing && this._showProperty.getValue(time) && this._fillProperty.getValue(time)),\n            distanceDisplayCondition : DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(this._distanceDisplayConditionProperty.getValue(time)),\n            offset : undefined,\n            color : undefined\n        };\n\n        if (this._materialProperty instanceof ColorMaterialProperty) {\n            var currentColor;\n            if (defined(this._materialProperty.color) && (this._materialProperty.color.isConstant || isAvailable)) {\n                currentColor = this._materialProperty.color.getValue(time, scratchColor);\n            }\n            if (!defined(currentColor)) {\n                currentColor = Color.WHITE;\n            }\n            attributes.color = ColorGeometryInstanceAttribute.fromColor(currentColor);\n        }\n\n        if (defined(this._options.offsetAttribute)) {\n            attributes.offset = OffsetGeometryInstanceAttribute.fromCartesian3(Property.getValueOrDefault(this._terrainOffsetProperty, time, defaultOffset, offsetScratch));\n        }\n\n        return new GeometryInstance({\n            id : entity,\n            geometry : new EllipseGeometry(this._options),\n            attributes : attributes\n        });\n    };\n\n    /**\n     * Creates the geometry instance which represents the outline of the geometry.\n     *\n     * @param {JulianDate} time The time to use when retrieving initial attribute values.\n     * @returns {GeometryInstance} The geometry instance representing the outline portion of the geometry.\n     *\n     * @exception {DeveloperError} This instance does not represent an outlined geometry.\n     */\n    EllipseGeometryUpdater.prototype.createOutlineGeometryInstance = function(time) {\n        \n\n        var entity = this._entity;\n        var isAvailable = entity.isAvailable(time);\n        var outlineColor = Property.getValueOrDefault(this._outlineColorProperty, time, Color.BLACK, scratchColor);\n        var distanceDisplayCondition = this._distanceDisplayConditionProperty.getValue(time);\n\n        var attributes = {\n            show : new ShowGeometryInstanceAttribute(isAvailable && entity.isShowing && this._showProperty.getValue(time) && this._showOutlineProperty.getValue(time)),\n            color : ColorGeometryInstanceAttribute.fromColor(outlineColor),\n            distanceDisplayCondition : DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(distanceDisplayCondition),\n            offset : undefined\n        };\n\n        if (defined(this._options.offsetAttribute)) {\n            attributes.offset = OffsetGeometryInstanceAttribute.fromCartesian3(Property.getValueOrDefault(this._terrainOffsetProperty, time, defaultOffset, offsetScratch));\n        }\n\n        return new GeometryInstance({\n            id : entity,\n            geometry : new EllipseOutlineGeometry(this._options),\n            attributes : attributes\n        });\n    };\n\n    EllipseGeometryUpdater.prototype._computeCenter = function(time, result) {\n        return Property.getValueOrUndefined(this._entity.position, time, result);\n    };\n\n    EllipseGeometryUpdater.prototype._isHidden = function(entity, ellipse) {\n        var position = entity.position;\n\n        return !defined(position) || !defined(ellipse.semiMajorAxis) || !defined(ellipse.semiMinorAxis) || GeometryUpdater.prototype._isHidden.call(this, entity, ellipse);\n    };\n\n    EllipseGeometryUpdater.prototype._isDynamic = function(entity, ellipse) {\n        return !entity.position.isConstant || //\n               !ellipse.semiMajorAxis.isConstant || //\n               !ellipse.semiMinorAxis.isConstant || //\n               !Property.isConstant(ellipse.rotation) || //\n               !Property.isConstant(ellipse.height) || //\n               !Property.isConstant(ellipse.extrudedHeight) || //\n               !Property.isConstant(ellipse.granularity) || //\n               !Property.isConstant(ellipse.stRotation) || //\n               !Property.isConstant(ellipse.outlineWidth) || //\n               !Property.isConstant(ellipse.numberOfVerticalLines) || //\n               !Property.isConstant(ellipse.zIndex) || //\n               (this._onTerrain && !Property.isConstant(this._materialProperty));\n    };\n\n    EllipseGeometryUpdater.prototype._setStaticOptions = function(entity, ellipse) {\n        var heightValue = Property.getValueOrUndefined(ellipse.height, Iso8601.MINIMUM_VALUE);\n        var heightReferenceValue = Property.getValueOrDefault(ellipse.heightReference, Iso8601.MINIMUM_VALUE, HeightReference.NONE);\n        var extrudedHeightValue = Property.getValueOrUndefined(ellipse.extrudedHeight, Iso8601.MINIMUM_VALUE);\n        var extrudedHeightReferenceValue = Property.getValueOrDefault(ellipse.extrudedHeightReference, Iso8601.MINIMUM_VALUE, HeightReference.NONE);\n        if (defined(extrudedHeightValue) && !defined(heightValue)) {\n            heightValue = 0;\n        }\n\n        var options = this._options;\n        options.vertexFormat = (this._materialProperty instanceof ColorMaterialProperty) ? PerInstanceColorAppearance.VERTEX_FORMAT : MaterialAppearance.MaterialSupport.TEXTURED.vertexFormat;\n        options.center = entity.position.getValue(Iso8601.MINIMUM_VALUE, options.center);\n        options.semiMajorAxis = ellipse.semiMajorAxis.getValue(Iso8601.MINIMUM_VALUE, options.semiMajorAxis);\n        options.semiMinorAxis = ellipse.semiMinorAxis.getValue(Iso8601.MINIMUM_VALUE, options.semiMinorAxis);\n        options.rotation = Property.getValueOrUndefined(ellipse.rotation, Iso8601.MINIMUM_VALUE);\n        options.granularity = Property.getValueOrUndefined(ellipse.granularity, Iso8601.MINIMUM_VALUE);\n        options.stRotation = Property.getValueOrUndefined(ellipse.stRotation, Iso8601.MINIMUM_VALUE);\n        options.numberOfVerticalLines = Property.getValueOrUndefined(ellipse.numberOfVerticalLines, Iso8601.MINIMUM_VALUE);\n        options.offsetAttribute = GroundGeometryUpdater.computeGeometryOffsetAttribute(heightValue, heightReferenceValue, extrudedHeightValue, extrudedHeightReferenceValue);\n        options.height = GroundGeometryUpdater.getGeometryHeight(heightValue, heightReferenceValue);\n\n        extrudedHeightValue = GroundGeometryUpdater.getGeometryExtrudedHeight(extrudedHeightValue, extrudedHeightReferenceValue);\n        if (extrudedHeightValue === GroundGeometryUpdater.CLAMP_TO_GROUND) {\n            extrudedHeightValue = ApproximateTerrainHeights.getMinimumMaximumHeights(EllipseGeometry.computeRectangle(options, scratchRectangle)).minimumTerrainHeight;\n        }\n\n        options.extrudedHeight = extrudedHeightValue;\n    };\n\n    EllipseGeometryUpdater.DynamicGeometryUpdater = DynamicEllipseGeometryUpdater;\n\n    /**\n     * @private\n     */\n    function DynamicEllipseGeometryUpdater(geometryUpdater, primitives, groundPrimitives) {\n        DynamicGeometryUpdater.call(this, geometryUpdater, primitives, groundPrimitives);\n    }\n\n    if (defined(Object.create)) {\n        DynamicEllipseGeometryUpdater.prototype = Object.create(DynamicGeometryUpdater.prototype);\n        DynamicEllipseGeometryUpdater.prototype.constructor = DynamicEllipseGeometryUpdater;\n    }\n\n    DynamicEllipseGeometryUpdater.prototype._isHidden = function(entity, ellipse, time) {\n        var options = this._options;\n        return !defined(options.center) || !defined(options.semiMajorAxis) || !defined(options.semiMinorAxis) || DynamicGeometryUpdater.prototype._isHidden.call(this, entity, ellipse, time);\n    };\n\n    DynamicEllipseGeometryUpdater.prototype._setOptions = function(entity, ellipse, time) {\n        var options = this._options;\n        var heightValue = Property.getValueOrUndefined(ellipse.height, time);\n        var heightReferenceValue = Property.getValueOrDefault(ellipse.heightReference, time, HeightReference.NONE);\n        var extrudedHeightValue = Property.getValueOrUndefined(ellipse.extrudedHeight, time);\n        var extrudedHeightReferenceValue = Property.getValueOrDefault(ellipse.extrudedHeightReference, time, HeightReference.NONE);\n        if (defined(extrudedHeightValue) && !defined(heightValue)) {\n            heightValue = 0;\n        }\n\n        options.center = Property.getValueOrUndefined(entity.position, time, options.center);\n        options.semiMajorAxis = Property.getValueOrUndefined(ellipse.semiMajorAxis, time);\n        options.semiMinorAxis = Property.getValueOrUndefined(ellipse.semiMinorAxis, time);\n        options.rotation = Property.getValueOrUndefined(ellipse.rotation, time);\n        options.granularity = Property.getValueOrUndefined(ellipse.granularity, time);\n        options.stRotation = Property.getValueOrUndefined(ellipse.stRotation, time);\n        options.numberOfVerticalLines = Property.getValueOrUndefined(ellipse.numberOfVerticalLines, time);\n        options.offsetAttribute = GroundGeometryUpdater.computeGeometryOffsetAttribute(heightValue, heightReferenceValue, extrudedHeightValue, extrudedHeightReferenceValue);\n        options.height = GroundGeometryUpdater.getGeometryHeight(heightValue, heightReferenceValue);\n\n        extrudedHeightValue = GroundGeometryUpdater.getGeometryExtrudedHeight(extrudedHeightValue, extrudedHeightReferenceValue);\n        if (extrudedHeightValue === GroundGeometryUpdater.CLAMP_TO_GROUND) {\n            extrudedHeightValue = ApproximateTerrainHeights.getMinimumMaximumHeights(EllipseGeometry.computeRectangle(options, scratchRectangle)).minimumTerrainHeight;\n        }\n\n        options.extrudedHeight = extrudedHeightValue;\n    };\nexport default EllipseGeometryUpdater;\n","import Cartesian3 from '../Core/Cartesian3.js';\nimport Check from '../Core/Check.js';\nimport Color from '../Core/Color.js';\nimport ColorGeometryInstanceAttribute from '../Core/ColorGeometryInstanceAttribute.js';\nimport defaultValue from '../Core/defaultValue.js';\nimport defined from '../Core/defined.js';\nimport defineProperties from '../Core/defineProperties.js';\nimport DistanceDisplayCondition from '../Core/DistanceDisplayCondition.js';\nimport DistanceDisplayConditionGeometryInstanceAttribute from '../Core/DistanceDisplayConditionGeometryInstanceAttribute.js';\nimport EllipsoidGeometry from '../Core/EllipsoidGeometry.js';\nimport EllipsoidOutlineGeometry from '../Core/EllipsoidOutlineGeometry.js';\nimport GeometryInstance from '../Core/GeometryInstance.js';\nimport GeometryOffsetAttribute from '../Core/GeometryOffsetAttribute.js';\nimport Iso8601 from '../Core/Iso8601.js';\nimport Matrix4 from '../Core/Matrix4.js';\nimport OffsetGeometryInstanceAttribute from '../Core/OffsetGeometryInstanceAttribute.js';\nimport ShowGeometryInstanceAttribute from '../Core/ShowGeometryInstanceAttribute.js';\nimport HeightReference from '../Scene/HeightReference.js';\nimport MaterialAppearance from '../Scene/MaterialAppearance.js';\nimport PerInstanceColorAppearance from '../Scene/PerInstanceColorAppearance.js';\nimport Primitive from '../Scene/Primitive.js';\nimport SceneMode from '../Scene/SceneMode.js';\nimport ColorMaterialProperty from './ColorMaterialProperty.js';\nimport DynamicGeometryUpdater from './DynamicGeometryUpdater.js';\nimport GeometryUpdater from './GeometryUpdater.js';\nimport heightReferenceOnEntityPropertyChanged from './heightReferenceOnEntityPropertyChanged.js';\nimport MaterialProperty from './MaterialProperty.js';\nimport Property from './Property.js';\n\n    var defaultMaterial = new ColorMaterialProperty(Color.WHITE);\n    var defaultOffset = Cartesian3.ZERO;\n\n    var offsetScratch = new Cartesian3();\n    var radiiScratch = new Cartesian3();\n    var innerRadiiScratch = new Cartesian3();\n    var scratchColor = new Color();\n    var unitSphere = new Cartesian3(1, 1, 1);\n\n    function EllipsoidGeometryOptions(entity) {\n        this.id = entity;\n        this.vertexFormat = undefined;\n        this.radii = undefined;\n        this.innerRadii = undefined;\n        this.minimumClock = undefined;\n        this.maximumClock = undefined;\n        this.minimumCone = undefined;\n        this.maximumCone = undefined;\n        this.stackPartitions = undefined;\n        this.slicePartitions = undefined;\n        this.subdivisions = undefined;\n        this.offsetAttribute = undefined;\n    }\n\n    /**\n     * A {@link GeometryUpdater} for ellipsoids.\n     * Clients do not normally create this class directly, but instead rely on {@link DataSourceDisplay}.\n     * @alias EllipsoidGeometryUpdater\n     * @constructor\n     *\n     * @param {Entity} entity The entity containing the geometry to be visualized.\n     * @param {Scene} scene The scene where visualization is taking place.\n     */\n    function EllipsoidGeometryUpdater(entity, scene) {\n        GeometryUpdater.call(this, {\n            entity : entity,\n            scene : scene,\n            geometryOptions : new EllipsoidGeometryOptions(entity),\n            geometryPropertyName : 'ellipsoid',\n            observedPropertyNames : ['availability', 'position', 'orientation', 'ellipsoid']\n        });\n\n        this._onEntityPropertyChanged(entity, 'ellipsoid', entity.ellipsoid, undefined);\n    }\n\n    if (defined(Object.create)) {\n        EllipsoidGeometryUpdater.prototype = Object.create(GeometryUpdater.prototype);\n        EllipsoidGeometryUpdater.prototype.constructor = EllipsoidGeometryUpdater;\n    }\n\n    defineProperties(EllipsoidGeometryUpdater.prototype, {\n        /**\n         * Gets the terrain offset property\n         * @type {TerrainOffsetProperty}\n         * @memberof EllipsoidGeometryUpdater.prototype\n         * @readonly\n         */\n        terrainOffsetProperty : {\n            get : function() {\n                return this._terrainOffsetProperty;\n            }\n        }\n    });\n\n    /**\n     * Creates the geometry instance which represents the fill of the geometry.\n     *\n     * @param {JulianDate} time The time to use when retrieving initial attribute values.\n     * @param {Boolean} [skipModelMatrix=false] Whether to compute a model matrix for the geometry instance\n     * @param {Matrix4} [modelMatrixResult] Used to store the result of the model matrix calculation\n     * @returns {GeometryInstance} The geometry instance representing the filled portion of the geometry.\n     *\n     * @exception {DeveloperError} This instance does not represent a filled geometry.\n     */\n    EllipsoidGeometryUpdater.prototype.createFillGeometryInstance = function(time, skipModelMatrix, modelMatrixResult) {\n        \n\n        var entity = this._entity;\n        var isAvailable = entity.isAvailable(time);\n\n        var color;\n        var show = new ShowGeometryInstanceAttribute(isAvailable && entity.isShowing && this._showProperty.getValue(time) && this._fillProperty.getValue(time));\n        var distanceDisplayCondition = this._distanceDisplayConditionProperty.getValue(time);\n        var distanceDisplayConditionAttribute = DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(distanceDisplayCondition);\n\n        var attributes = {\n            show : show,\n            distanceDisplayCondition : distanceDisplayConditionAttribute,\n            color : undefined,\n            offset : undefined\n        };\n\n        if (this._materialProperty instanceof ColorMaterialProperty) {\n            var currentColor;\n            if (defined(this._materialProperty.color) && (this._materialProperty.color.isConstant || isAvailable)) {\n                currentColor = this._materialProperty.color.getValue(time, scratchColor);\n            }\n            if (!defined(currentColor)) {\n                currentColor = Color.WHITE;\n            }\n            color = ColorGeometryInstanceAttribute.fromColor(currentColor);\n            attributes.color = color;\n        }\n        if (defined(this._options.offsetAttribute)) {\n            attributes.offset = OffsetGeometryInstanceAttribute.fromCartesian3(Property.getValueOrDefault(this._terrainOffsetProperty, time, defaultOffset, offsetScratch));\n        }\n\n        return new GeometryInstance({\n            id : entity,\n            geometry : new EllipsoidGeometry(this._options),\n            modelMatrix : skipModelMatrix ? undefined : entity.computeModelMatrixForHeightReference(time, entity.ellipsoid.heightReference, this._options.radii.z * 0.5, this._scene.mapProjection.ellipsoid, modelMatrixResult),\n            attributes : attributes\n        });\n    };\n\n    /**\n     * Creates the geometry instance which represents the outline of the geometry.\n     *\n     * @param {JulianDate} time The time to use when retrieving initial attribute values.\n     * @param {Boolean} [skipModelMatrix=false] Whether to compute a model matrix for the geometry instance\n     * @param {Matrix4} [modelMatrixResult] Used to store the result of the model matrix calculation\n     * @returns {GeometryInstance} The geometry instance representing the outline portion of the geometry.\n     *\n     * @exception {DeveloperError} This instance does not represent an outlined geometry.\n     */\n    EllipsoidGeometryUpdater.prototype.createOutlineGeometryInstance = function(time, skipModelMatrix, modelMatrixResult) {\n        \n\n        var entity = this._entity;\n        var isAvailable = entity.isAvailable(time);\n\n        var outlineColor = Property.getValueOrDefault(this._outlineColorProperty, time, Color.BLACK, scratchColor);\n        var distanceDisplayCondition = this._distanceDisplayConditionProperty.getValue(time);\n\n        var attributes = {\n            show : new ShowGeometryInstanceAttribute(isAvailable && entity.isShowing && this._showProperty.getValue(time) && this._showOutlineProperty.getValue(time)),\n            color : ColorGeometryInstanceAttribute.fromColor(outlineColor),\n            distanceDisplayCondition : DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(distanceDisplayCondition),\n            offset : undefined\n        };\n        if (defined(this._options.offsetAttribute)) {\n            attributes.offset = OffsetGeometryInstanceAttribute.fromCartesian3(Property.getValueOrDefault(this._terrainOffsetProperty, time, defaultOffset, offsetScratch));\n        }\n\n        return new GeometryInstance({\n            id : entity,\n            geometry : new EllipsoidOutlineGeometry(this._options),\n            modelMatrix : skipModelMatrix ? undefined : entity.computeModelMatrixForHeightReference(time, entity.ellipsoid.heightReference, this._options.radii.z * 0.5, this._scene.mapProjection.ellipsoid, modelMatrixResult),\n            attributes : attributes\n        });\n    };\n\n    EllipsoidGeometryUpdater.prototype._computeCenter = function(time, result) {\n        return Property.getValueOrUndefined(this._entity.position, time, result);\n    };\n\n    EllipsoidGeometryUpdater.prototype._isHidden = function(entity, ellipsoid) {\n        return !defined(entity.position) || !defined(ellipsoid.radii) || GeometryUpdater.prototype._isHidden.call(this, entity, ellipsoid);\n    };\n\n    EllipsoidGeometryUpdater.prototype._isDynamic = function(entity, ellipsoid) {\n        return !entity.position.isConstant || //\n               !Property.isConstant(entity.orientation) || //\n               !ellipsoid.radii.isConstant || //\n               !Property.isConstant(ellipsoid.innerRadii) || //\n               !Property.isConstant(ellipsoid.stackPartitions) || //\n               !Property.isConstant(ellipsoid.slicePartitions) || //\n               !Property.isConstant(ellipsoid.outlineWidth) || //\n               !Property.isConstant(ellipsoid.minimumClock) || //\n               !Property.isConstant(ellipsoid.maximumClock) || //\n               !Property.isConstant(ellipsoid.minimumCone) || //\n               !Property.isConstant(ellipsoid.maximumCone) || //\n               !Property.isConstant(ellipsoid.subdivisions);\n    };\n\n    EllipsoidGeometryUpdater.prototype._setStaticOptions = function(entity, ellipsoid) {\n        var heightReference = Property.getValueOrDefault(ellipsoid.heightReference, Iso8601.MINIMUM_VALUE, HeightReference.NONE);\n        var options = this._options;\n        options.vertexFormat = this._materialProperty instanceof ColorMaterialProperty ? PerInstanceColorAppearance.VERTEX_FORMAT : MaterialAppearance.MaterialSupport.TEXTURED.vertexFormat;\n        options.radii = ellipsoid.radii.getValue(Iso8601.MINIMUM_VALUE, options.radii);\n        options.innerRadii = Property.getValueOrUndefined(ellipsoid.innerRadii, options.radii);\n        options.minimumClock = Property.getValueOrUndefined(ellipsoid.minimumClock, Iso8601.MINIMUM_VALUE);\n        options.maximumClock = Property.getValueOrUndefined(ellipsoid.maximumClock, Iso8601.MINIMUM_VALUE);\n        options.minimumCone = Property.getValueOrUndefined(ellipsoid.minimumCone, Iso8601.MINIMUM_VALUE);\n        options.maximumCone = Property.getValueOrUndefined(ellipsoid.maximumCone, Iso8601.MINIMUM_VALUE);\n        options.stackPartitions = Property.getValueOrUndefined(ellipsoid.stackPartitions, Iso8601.MINIMUM_VALUE);\n        options.slicePartitions = Property.getValueOrUndefined(ellipsoid.slicePartitions, Iso8601.MINIMUM_VALUE);\n        options.subdivisions = Property.getValueOrUndefined(ellipsoid.subdivisions, Iso8601.MINIMUM_VALUE);\n        options.offsetAttribute = heightReference !== HeightReference.NONE ? GeometryOffsetAttribute.ALL : undefined;\n    };\n\n    EllipsoidGeometryUpdater.prototype._onEntityPropertyChanged = heightReferenceOnEntityPropertyChanged;\n\n    EllipsoidGeometryUpdater.DynamicGeometryUpdater = DynamicEllipsoidGeometryUpdater;\n\n    /**\n     * @private\n     */\n    function DynamicEllipsoidGeometryUpdater(geometryUpdater, primitives, groundPrimitives) {\n        DynamicGeometryUpdater.call(this, geometryUpdater, primitives, groundPrimitives);\n\n        this._scene = geometryUpdater._scene;\n        this._modelMatrix = new Matrix4();\n        this._attributes = undefined;\n        this._outlineAttributes = undefined;\n        this._lastSceneMode = undefined;\n        this._lastShow = undefined;\n        this._lastOutlineShow = undefined;\n        this._lastOutlineWidth = undefined;\n        this._lastOutlineColor = undefined;\n        this._lastOffset = new Cartesian3();\n        this._material = {};\n    }\n\n    if (defined(Object.create)) {\n        DynamicEllipsoidGeometryUpdater.prototype = Object.create(DynamicGeometryUpdater.prototype);\n        DynamicEllipsoidGeometryUpdater.prototype.constructor = DynamicEllipsoidGeometryUpdater;\n    }\n\n    DynamicEllipsoidGeometryUpdater.prototype.update = function(time) {\n        \n\n        var entity = this._entity;\n        var ellipsoid = entity.ellipsoid;\n        if (!entity.isShowing || !entity.isAvailable(time) || !Property.getValueOrDefault(ellipsoid.show, time, true)) {\n            if (defined(this._primitive)) {\n                this._primitive.show = false;\n            }\n\n            if (defined(this._outlinePrimitive)) {\n                this._outlinePrimitive.show = false;\n            }\n            return;\n        }\n\n        var radii = Property.getValueOrUndefined(ellipsoid.radii, time, radiiScratch);\n        var modelMatrix = defined(radii) ? entity.computeModelMatrixForHeightReference(time, ellipsoid.heightReference, radii.z * 0.5, this._scene.mapProjection.ellipsoid, this._modelMatrix) : undefined;\n        if (!defined(modelMatrix) || !defined(radii)) {\n            if (defined(this._primitive)) {\n                this._primitive.show = false;\n            }\n\n            if (defined(this._outlinePrimitive)) {\n                this._outlinePrimitive.show = false;\n            }\n            return;\n        }\n\n        //Compute attributes and material.\n        var showFill = Property.getValueOrDefault(ellipsoid.fill, time, true);\n        var showOutline = Property.getValueOrDefault(ellipsoid.outline, time, false);\n        var outlineColor = Property.getValueOrClonedDefault(ellipsoid.outlineColor, time, Color.BLACK, scratchColor);\n        var material = MaterialProperty.getValue(time, defaultValue(ellipsoid.material, defaultMaterial), this._material);\n\n        // Check properties that could trigger a primitive rebuild.\n        var innerRadii = Property.getValueOrUndefined(ellipsoid.innerRadii, time, innerRadiiScratch);\n        var minimumClock = Property.getValueOrUndefined(ellipsoid.minimumClock, time);\n        var maximumClock = Property.getValueOrUndefined(ellipsoid.maximumClock, time);\n        var minimumCone = Property.getValueOrUndefined(ellipsoid.minimumCone, time);\n        var maximumCone = Property.getValueOrUndefined(ellipsoid.maximumCone, time);\n        var stackPartitions = Property.getValueOrUndefined(ellipsoid.stackPartitions, time);\n        var slicePartitions = Property.getValueOrUndefined(ellipsoid.slicePartitions, time);\n        var subdivisions = Property.getValueOrUndefined(ellipsoid.subdivisions, time);\n        var outlineWidth = Property.getValueOrDefault(ellipsoid.outlineWidth, time, 1.0);\n        var heightReference = Property.getValueOrDefault(ellipsoid.heightReference, time, HeightReference.NONE);\n        var offsetAttribute = heightReference !== HeightReference.NONE ? GeometryOffsetAttribute.ALL : undefined;\n\n        //In 3D we use a fast path by modifying Primitive.modelMatrix instead of regenerating the primitive every frame.\n        //Also check for height reference because this method doesn't work when the height is relative to terrain.\n        var sceneMode = this._scene.mode;\n        var in3D = sceneMode === SceneMode.SCENE3D && heightReference === HeightReference.NONE;\n\n        var options = this._options;\n\n        var shadows = this._geometryUpdater.shadowsProperty.getValue(time);\n\n        var distanceDisplayConditionProperty = this._geometryUpdater.distanceDisplayConditionProperty;\n        var distanceDisplayCondition = distanceDisplayConditionProperty.getValue(time);\n\n        var offset = Property.getValueOrDefault(this._geometryUpdater.terrainOffsetProperty, time, defaultOffset, offsetScratch);\n\n        //We only rebuild the primitive if something other than the radii has changed\n        //For the radii, we use unit sphere and then deform it with a scale matrix.\n        var rebuildPrimitives = !in3D || this._lastSceneMode !== sceneMode || !defined(this._primitive) || //\n                                options.stackPartitions !== stackPartitions || options.slicePartitions !== slicePartitions || //\n                                defined(innerRadii) && !Cartesian3.equals(options.innerRadii !== innerRadii) || options.minimumClock !== minimumClock || //\n                                options.maximumClock !== maximumClock || options.minimumCone !== minimumCone || //\n                                options.maximumCone !== maximumCone || options.subdivisions !== subdivisions || //\n                                this._lastOutlineWidth !== outlineWidth || options.offsetAttribute !== offsetAttribute;\n\n        if (rebuildPrimitives) {\n            var primitives = this._primitives;\n            primitives.removeAndDestroy(this._primitive);\n            primitives.removeAndDestroy(this._outlinePrimitive);\n            this._primitive = undefined;\n            this._outlinePrimitive = undefined;\n            this._lastSceneMode = sceneMode;\n            this._lastOutlineWidth = outlineWidth;\n\n            options.stackPartitions = stackPartitions;\n            options.slicePartitions = slicePartitions;\n            options.subdivisions = subdivisions;\n            options.offsetAttribute = offsetAttribute;\n            options.radii = Cartesian3.clone(in3D ? unitSphere : radii, options.radii);\n            if (defined(innerRadii)) {\n                if (in3D) {\n                    var mag = Cartesian3.magnitude(radii);\n                    options.innerRadii = Cartesian3.fromElements(innerRadii.x / mag, innerRadii.y / mag, innerRadii.z / mag, options.innerRadii);\n                } else {\n                    options.innerRadii = Cartesian3.clone(innerRadii, options.innerRadii);\n                }\n            } else {\n                options.innerRadii = undefined;\n            }\n            options.minimumClock = minimumClock;\n            options.maximumClock = maximumClock;\n            options.minimumCone = minimumCone;\n            options.maximumCone = maximumCone;\n\n            var appearance = new MaterialAppearance({\n                material : material,\n                translucent : material.isTranslucent(),\n                closed : true\n            });\n            options.vertexFormat = appearance.vertexFormat;\n\n            var fillInstance = this._geometryUpdater.createFillGeometryInstance(time, in3D, this._modelMatrix);\n\n            this._primitive = primitives.add(new Primitive({\n                geometryInstances : fillInstance,\n                appearance : appearance,\n                asynchronous : false,\n                shadows : shadows\n            }));\n\n            var outlineInstance = this._geometryUpdater.createOutlineGeometryInstance(time, in3D, this._modelMatrix);\n            this._outlinePrimitive = primitives.add(new Primitive({\n                geometryInstances : outlineInstance,\n                appearance : new PerInstanceColorAppearance({\n                    flat : true,\n                    translucent : outlineInstance.attributes.color.value[3] !== 255,\n                    renderState : {\n                        lineWidth : this._geometryUpdater._scene.clampLineWidth(outlineWidth)\n                    }\n                }),\n                asynchronous : false,\n                shadows : shadows\n            }));\n\n            this._lastShow = showFill;\n            this._lastOutlineShow = showOutline;\n            this._lastOutlineColor = Color.clone(outlineColor, this._lastOutlineColor);\n            this._lastDistanceDisplayCondition = distanceDisplayCondition;\n            this._lastOffset = Cartesian3.clone(offset, this._lastOffset);\n        } else if (this._primitive.ready) {\n            //Update attributes only.\n            var primitive = this._primitive;\n            var outlinePrimitive = this._outlinePrimitive;\n\n            primitive.show = true;\n            outlinePrimitive.show = true;\n            primitive.appearance.material = material;\n\n            var attributes = this._attributes;\n            if (!defined(attributes)) {\n                attributes = primitive.getGeometryInstanceAttributes(entity);\n                this._attributes = attributes;\n            }\n            if (showFill !== this._lastShow) {\n                attributes.show = ShowGeometryInstanceAttribute.toValue(showFill, attributes.show);\n                this._lastShow = showFill;\n            }\n\n            var outlineAttributes = this._outlineAttributes;\n\n            if (!defined(outlineAttributes)) {\n                outlineAttributes = outlinePrimitive.getGeometryInstanceAttributes(entity);\n                this._outlineAttributes = outlineAttributes;\n            }\n\n            if (showOutline !== this._lastOutlineShow) {\n                outlineAttributes.show = ShowGeometryInstanceAttribute.toValue(showOutline, outlineAttributes.show);\n                this._lastOutlineShow = showOutline;\n            }\n\n            if (!Color.equals(outlineColor, this._lastOutlineColor)) {\n                outlineAttributes.color = ColorGeometryInstanceAttribute.toValue(outlineColor, outlineAttributes.color);\n                Color.clone(outlineColor, this._lastOutlineColor);\n            }\n\n            if (!DistanceDisplayCondition.equals(distanceDisplayCondition, this._lastDistanceDisplayCondition)) {\n                attributes.distanceDisplayCondition = DistanceDisplayConditionGeometryInstanceAttribute.toValue(distanceDisplayCondition, attributes.distanceDisplayCondition);\n                outlineAttributes.distanceDisplayCondition = DistanceDisplayConditionGeometryInstanceAttribute.toValue(distanceDisplayCondition, outlineAttributes.distanceDisplayCondition);\n                DistanceDisplayCondition.clone(distanceDisplayCondition, this._lastDistanceDisplayCondition);\n            }\n\n            if (!Cartesian3.equals(offset, this._lastOffset)) {\n                attributes.offset = OffsetGeometryInstanceAttribute.toValue(offset, attributes.offset);\n                outlineAttributes.offset = OffsetGeometryInstanceAttribute.toValue(offset, attributes.offset);\n                Cartesian3.clone(offset, this._lastOffset);\n            }\n        }\n\n        if (in3D) {\n            //Since we are scaling a unit sphere, we can't let any of the values go to zero.\n            //Instead we clamp them to a small value.  To the naked eye, this produces the same results\n            //that you get passing EllipsoidGeometry a radii with a zero component.\n            radii.x = Math.max(radii.x, 0.001);\n            radii.y = Math.max(radii.y, 0.001);\n            radii.z = Math.max(radii.z, 0.001);\n\n            modelMatrix = Matrix4.multiplyByScale(modelMatrix, radii, modelMatrix);\n            this._primitive.modelMatrix = modelMatrix;\n            this._outlinePrimitive.modelMatrix = modelMatrix;\n        }\n    };\nexport default EllipsoidGeometryUpdater;\n","import BoundingSphere from './BoundingSphere.js';\nimport Cartesian3 from './Cartesian3.js';\nimport Check from './Check.js';\nimport ComponentDatatype from './ComponentDatatype.js';\nimport defaultValue from './defaultValue.js';\nimport defined from './defined.js';\nimport Geometry from './Geometry.js';\nimport GeometryAttribute from './GeometryAttribute.js';\nimport GeometryAttributes from './GeometryAttributes.js';\nimport PrimitiveType from './PrimitiveType.js';\nimport VertexFormat from './VertexFormat.js';\n\n    /**\n     * Describes geometry representing a plane centered at the origin, with a unit width and length.\n     *\n     * @alias PlaneGeometry\n     * @constructor\n     *\n     * @param {Object} options Object with the following properties:\n     * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\n     *\n     * @example\n     * var planeGeometry = new Cesium.PlaneGeometry({\n     *   vertexFormat : Cesium.VertexFormat.POSITION_ONLY\n     * });\n     */\n    function PlaneGeometry(options) {\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n        var vertexFormat = defaultValue(options.vertexFormat, VertexFormat.DEFAULT);\n\n        this._vertexFormat = vertexFormat;\n        this._workerName = 'createPlaneGeometry';\n    }\n\n    /**\n     * The number of elements used to pack the object into an array.\n     * @type {Number}\n     */\n    PlaneGeometry.packedLength = VertexFormat.packedLength;\n\n    /**\n     * Stores the provided instance into the provided array.\n     *\n     * @param {PlaneGeometry} value The value to pack.\n     * @param {Number[]} array The array to pack into.\n     * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n     *\n     * @returns {Number[]} The array that was packed into\n     */\n    PlaneGeometry.pack = function(value, array, startingIndex) {\n        \n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        VertexFormat.pack(value._vertexFormat, array, startingIndex);\n\n        return array;\n    };\n\n    var scratchVertexFormat = new VertexFormat();\n    var scratchOptions = {\n        vertexFormat: scratchVertexFormat\n    };\n\n    /**\n     * Retrieves an instance from a packed array.\n     *\n     * @param {Number[]} array The packed array.\n     * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n     * @param {PlaneGeometry} [result] The object into which to store the result.\n     * @returns {PlaneGeometry} The modified result parameter or a new PlaneGeometry instance if one was not provided.\n     */\n    PlaneGeometry.unpack = function(array, startingIndex, result) {\n        \n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        var vertexFormat = VertexFormat.unpack(array, startingIndex, scratchVertexFormat);\n\n        if (!defined(result)) {\n            return new PlaneGeometry(scratchOptions);\n        }\n\n        result._vertexFormat = VertexFormat.clone(vertexFormat, result._vertexFormat);\n\n        return result;\n    };\n\n    var min = new Cartesian3(-0.5, -0.5, 0.0);\n    var max = new Cartesian3( 0.5,  0.5, 0.0);\n\n    /**\n     * Computes the geometric representation of a plane, including its vertices, indices, and a bounding sphere.\n     *\n     * @param {PlaneGeometry} planeGeometry A description of the plane.\n     * @returns {Geometry|undefined} The computed vertices and indices.\n     */\n    PlaneGeometry.createGeometry = function(planeGeometry) {\n        var vertexFormat = planeGeometry._vertexFormat;\n\n        var attributes = new GeometryAttributes();\n        var indices;\n        var positions;\n\n        if (vertexFormat.position) {\n            // 4 corner points.  Duplicated 3 times each for each incident edge/face.\n            positions = new Float64Array(4 * 3);\n\n            // +z face\n            positions[0]  = min.x;\n            positions[1]  = min.y;\n            positions[2]  = 0.0;\n            positions[3]  = max.x;\n            positions[4]  = min.y;\n            positions[5]  = 0.0;\n            positions[6]  = max.x;\n            positions[7]  = max.y;\n            positions[8]  = 0.0;\n            positions[9]  = min.x;\n            positions[10] = max.y;\n            positions[11] = 0.0;\n\n            attributes.position = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.DOUBLE,\n                componentsPerAttribute : 3,\n                values : positions\n            });\n\n            if (vertexFormat.normal) {\n                var normals = new Float32Array(4 * 3);\n\n                // +z face\n                normals[0]  = 0.0;\n                normals[1]  = 0.0;\n                normals[2]  = 1.0;\n                normals[3]  = 0.0;\n                normals[4]  = 0.0;\n                normals[5]  = 1.0;\n                normals[6]  = 0.0;\n                normals[7]  = 0.0;\n                normals[8]  = 1.0;\n                normals[9]  = 0.0;\n                normals[10] = 0.0;\n                normals[11] = 1.0;\n\n                attributes.normal = new GeometryAttribute({\n                    componentDatatype : ComponentDatatype.FLOAT,\n                    componentsPerAttribute : 3,\n                    values : normals\n                });\n            }\n\n            if (vertexFormat.st) {\n                var texCoords = new Float32Array(4 * 2);\n\n                // +z face\n                texCoords[0]  = 0.0;\n                texCoords[1]  = 0.0;\n                texCoords[2]  = 1.0;\n                texCoords[3]  = 0.0;\n                texCoords[4]  = 1.0;\n                texCoords[5]  = 1.0;\n                texCoords[6]  = 0.0;\n                texCoords[7]  = 1.0;\n\n                attributes.st = new GeometryAttribute({\n                    componentDatatype : ComponentDatatype.FLOAT,\n                    componentsPerAttribute : 2,\n                    values : texCoords\n                });\n            }\n\n            if (vertexFormat.tangent) {\n                var tangents = new Float32Array(4 * 3);\n\n                // +z face\n                tangents[0]  = 1.0;\n                tangents[1]  = 0.0;\n                tangents[2]  = 0.0;\n                tangents[3]  = 1.0;\n                tangents[4]  = 0.0;\n                tangents[5]  = 0.0;\n                tangents[6]  = 1.0;\n                tangents[7]  = 0.0;\n                tangents[8]  = 0.0;\n                tangents[9]  = 1.0;\n                tangents[10] = 0.0;\n                tangents[11] = 0.0;\n\n                attributes.tangent = new GeometryAttribute({\n                    componentDatatype : ComponentDatatype.FLOAT,\n                    componentsPerAttribute : 3,\n                    values : tangents\n                });\n            }\n\n            if (vertexFormat.bitangent) {\n                var bitangents = new Float32Array(4 * 3);\n\n                // +z face\n                bitangents[0] = 0.0;\n                bitangents[1] = 1.0;\n                bitangents[2] = 0.0;\n                bitangents[3] = 0.0;\n                bitangents[4] = 1.0;\n                bitangents[5] = 0.0;\n                bitangents[6] = 0.0;\n                bitangents[7] = 1.0;\n                bitangents[8] = 0.0;\n                bitangents[9] = 0.0;\n                bitangents[10] = 1.0;\n                bitangents[11] = 0.0;\n\n                attributes.bitangent = new GeometryAttribute({\n                    componentDatatype : ComponentDatatype.FLOAT,\n                    componentsPerAttribute : 3,\n                    values : bitangents\n                });\n            }\n\n            // 2 triangles\n            indices = new Uint16Array(2 * 3);\n\n            // +z face\n            indices[0] = 0;\n            indices[1] = 1;\n            indices[2] = 2;\n            indices[3] = 0;\n            indices[4] = 2;\n            indices[5] = 3;\n        }\n\n        return new Geometry({\n            attributes : attributes,\n            indices : indices,\n            primitiveType : PrimitiveType.TRIANGLES,\n            boundingSphere : new BoundingSphere(Cartesian3.ZERO, Math.sqrt(2.0))\n        });\n    };\nexport default PlaneGeometry;\n","import BoundingSphere from './BoundingSphere.js';\nimport Cartesian3 from './Cartesian3.js';\nimport Check from './Check.js';\nimport ComponentDatatype from './ComponentDatatype.js';\nimport defined from './defined.js';\nimport Geometry from './Geometry.js';\nimport GeometryAttribute from './GeometryAttribute.js';\nimport GeometryAttributes from './GeometryAttributes.js';\nimport PrimitiveType from './PrimitiveType.js';\n\n    /**\n     * Describes geometry representing the outline of a plane centered at the origin, with a unit width and length.\n     *\n     * @alias PlaneOutlineGeometry\n     * @constructor\n     *\n     */\n    function PlaneOutlineGeometry() {\n        this._workerName = 'createPlaneOutlineGeometry';\n    }\n\n    /**\n     * The number of elements used to pack the object into an array.\n     * @type {Number}\n     */\n    PlaneOutlineGeometry.packedLength = 0;\n\n    /**\n     * Stores the provided instance into the provided array.\n     *\n     * @param {PlaneOutlineGeometry} value The value to pack.\n     * @param {Number[]} array The array to pack into.\n     *\n     * @returns {Number[]} The array that was packed into\n     */\n    PlaneOutlineGeometry.pack = function(value, array) {\n        \n\n        return array;\n    };\n\n    /**\n     * Retrieves an instance from a packed array.\n     *\n     * @param {Number[]} array The packed array.\n     * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n     * @param {PlaneOutlineGeometry} [result] The object into which to store the result.\n     * @returns {PlaneOutlineGeometry} The modified result parameter or a new PlaneOutlineGeometry instance if one was not provided.\n     */\n    PlaneOutlineGeometry.unpack = function(array, startingIndex, result) {\n        \n\n        if (!defined(result)) {\n            return new PlaneOutlineGeometry();\n        }\n\n        return result;\n    };\n\n    var min = new Cartesian3(-0.5, -0.5, 0.0);\n    var max = new Cartesian3( 0.5,  0.5, 0.0);\n\n    /**\n     * Computes the geometric representation of an outline of a plane, including its vertices, indices, and a bounding sphere.\n     *\n     * @returns {Geometry|undefined} The computed vertices and indices.\n     */\n    PlaneOutlineGeometry.createGeometry = function() {\n        var attributes = new GeometryAttributes();\n        var indices = new Uint16Array(4 * 2);\n        var positions = new Float64Array(4 * 3);\n\n        positions[0] = min.x;\n        positions[1] = min.y;\n        positions[2] = min.z;\n        positions[3] = max.x;\n        positions[4] = min.y;\n        positions[5] = min.z;\n        positions[6] = max.x;\n        positions[7] = max.y;\n        positions[8] = min.z;\n        positions[9] = min.x;\n        positions[10] = max.y;\n        positions[11] = min.z;\n\n        attributes.position = new GeometryAttribute({\n            componentDatatype : ComponentDatatype.DOUBLE,\n            componentsPerAttribute : 3,\n            values : positions\n        });\n\n        indices[0] = 0;\n        indices[1] = 1;\n        indices[2] = 1;\n        indices[3] = 2;\n        indices[4] = 2;\n        indices[5] = 3;\n        indices[6] = 3;\n        indices[7] = 0;\n\n        return new Geometry({\n            attributes : attributes,\n            indices : indices,\n            primitiveType : PrimitiveType.LINES,\n            boundingSphere : new BoundingSphere(Cartesian3.ZERO, Math.sqrt(2.0))\n        });\n    };\nexport default PlaneOutlineGeometry;\n","import Cartesian2 from '../Core/Cartesian2.js';\nimport Cartesian3 from '../Core/Cartesian3.js';\nimport Check from '../Core/Check.js';\nimport Color from '../Core/Color.js';\nimport ColorGeometryInstanceAttribute from '../Core/ColorGeometryInstanceAttribute.js';\nimport defined from '../Core/defined.js';\nimport DeveloperError from '../Core/DeveloperError.js';\nimport DistanceDisplayConditionGeometryInstanceAttribute from '../Core/DistanceDisplayConditionGeometryInstanceAttribute.js';\nimport GeometryInstance from '../Core/GeometryInstance.js';\nimport Iso8601 from '../Core/Iso8601.js';\nimport CesiumMath from '../Core/Math.js';\nimport Matrix3 from '../Core/Matrix3.js';\nimport Matrix4 from '../Core/Matrix4.js';\nimport PlaneGeometry from '../Core/PlaneGeometry.js';\nimport PlaneOutlineGeometry from '../Core/PlaneOutlineGeometry.js';\nimport Quaternion from '../Core/Quaternion.js';\nimport ShowGeometryInstanceAttribute from '../Core/ShowGeometryInstanceAttribute.js';\nimport MaterialAppearance from '../Scene/MaterialAppearance.js';\nimport PerInstanceColorAppearance from '../Scene/PerInstanceColorAppearance.js';\nimport ColorMaterialProperty from './ColorMaterialProperty.js';\nimport DynamicGeometryUpdater from './DynamicGeometryUpdater.js';\nimport GeometryUpdater from './GeometryUpdater.js';\nimport Property from './Property.js';\n\n    var positionScratch = new Cartesian3();\n    var scratchColor = new Color();\n\n    function PlaneGeometryOptions(entity) {\n        this.id = entity;\n        this.vertexFormat = undefined;\n        this.plane = undefined;\n        this.dimensions = undefined;\n    }\n\n    /**\n     * A {@link GeometryUpdater} for planes.\n     * Clients do not normally create this class directly, but instead rely on {@link DataSourceDisplay}.\n     * @alias PlaneGeometryUpdater\n     * @constructor\n     *\n     * @param {Entity} entity The entity containing the geometry to be visualized.\n     * @param {Scene} scene The scene where visualization is taking place.\n     */\n    function PlaneGeometryUpdater(entity, scene) {\n        GeometryUpdater.call(this, {\n            entity : entity,\n            scene : scene,\n            geometryOptions : new PlaneGeometryOptions(entity),\n            geometryPropertyName : 'plane',\n            observedPropertyNames : ['availability', 'position', 'orientation', 'plane']\n        });\n\n        this._onEntityPropertyChanged(entity, 'plane', entity.plane, undefined);\n    }\n\n    if (defined(Object.create)) {\n        PlaneGeometryUpdater.prototype = Object.create(GeometryUpdater.prototype);\n        PlaneGeometryUpdater.prototype.constructor = PlaneGeometryUpdater;\n    }\n\n    /**\n     * Creates the geometry instance which represents the fill of the geometry.\n     *\n     * @param {JulianDate} time The time to use when retrieving initial attribute values.\n     * @returns {GeometryInstance} The geometry instance representing the filled portion of the geometry.\n     *\n     * @exception {DeveloperError} This instance does not represent a filled geometry.\n     */\n    PlaneGeometryUpdater.prototype.createFillGeometryInstance = function(time) {\n        \n\n        var entity = this._entity;\n        var isAvailable = entity.isAvailable(time);\n\n        var attributes;\n\n        var color;\n        var show = new ShowGeometryInstanceAttribute(isAvailable && entity.isShowing && this._showProperty.getValue(time) && this._fillProperty.getValue(time));\n        var distanceDisplayCondition = this._distanceDisplayConditionProperty.getValue(time);\n        var distanceDisplayConditionAttribute = DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(distanceDisplayCondition);\n        if (this._materialProperty instanceof ColorMaterialProperty) {\n            var currentColor;\n            if (defined(this._materialProperty.color) && (this._materialProperty.color.isConstant || isAvailable)) {\n                currentColor = this._materialProperty.color.getValue(time, scratchColor);\n            }\n            if (!defined(currentColor)) {\n                currentColor = Color.WHITE;\n            }\n            color = ColorGeometryInstanceAttribute.fromColor(currentColor);\n            attributes = {\n                show : show,\n                distanceDisplayCondition : distanceDisplayConditionAttribute,\n                color : color\n            };\n        } else {\n            attributes = {\n                show : show,\n                distanceDisplayCondition : distanceDisplayConditionAttribute\n            };\n        }\n\n        var planeGraphics = entity.plane;\n        var options = this._options;\n        var modelMatrix = entity.computeModelMatrix(time);\n        var plane = Property.getValueOrDefault(planeGraphics.plane, time, options.plane);\n        var dimensions = Property.getValueOrUndefined(planeGraphics.dimensions, time, options.dimensions);\n\n        options.plane = plane;\n        options.dimensions = dimensions;\n\n        modelMatrix = createPrimitiveMatrix(plane, dimensions, modelMatrix, this._scene.mapProjection.ellipsoid, modelMatrix);\n\n        return new GeometryInstance({\n            id : entity,\n            geometry : new PlaneGeometry(this._options),\n            modelMatrix : modelMatrix,\n            attributes : attributes\n        });\n    };\n\n    /**\n     * Creates the geometry instance which represents the outline of the geometry.\n     *\n     * @param {JulianDate} time The time to use when retrieving initial attribute values.\n     * @returns {GeometryInstance} The geometry instance representing the outline portion of the geometry.\n     *\n     * @exception {DeveloperError} This instance does not represent an outlined geometry.\n     */\n    PlaneGeometryUpdater.prototype.createOutlineGeometryInstance = function(time) {\n        \n\n        var entity = this._entity;\n        var isAvailable = entity.isAvailable(time);\n        var outlineColor = Property.getValueOrDefault(this._outlineColorProperty, time, Color.BLACK, scratchColor);\n        var distanceDisplayCondition = this._distanceDisplayConditionProperty.getValue(time);\n\n        var planeGraphics = entity.plane;\n        var options = this._options;\n        var modelMatrix = entity.computeModelMatrix(time);\n        var plane = Property.getValueOrDefault(planeGraphics.plane, time, options.plane);\n        var dimensions = Property.getValueOrUndefined(planeGraphics.dimensions, time, options.dimensions);\n\n        options.plane = plane;\n        options.dimensions = dimensions;\n\n        modelMatrix = createPrimitiveMatrix(plane, dimensions, modelMatrix, this._scene.mapProjection.ellipsoid, modelMatrix);\n\n        return new GeometryInstance({\n            id : entity,\n            geometry : new PlaneOutlineGeometry(),\n            modelMatrix : modelMatrix,\n            attributes : {\n                show : new ShowGeometryInstanceAttribute(isAvailable && entity.isShowing && this._showProperty.getValue(time) && this._showOutlineProperty.getValue(time)),\n                color : ColorGeometryInstanceAttribute.fromColor(outlineColor),\n                distanceDisplayCondition : DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(distanceDisplayCondition)\n            }\n        });\n    };\n\n    PlaneGeometryUpdater.prototype._isHidden = function(entity, plane) {\n        return !defined(plane.plane) || !defined(plane.dimensions) || !defined(entity.position) || GeometryUpdater.prototype._isHidden.call(this, entity, plane);\n    };\n\n    PlaneGeometryUpdater.prototype._getIsClosed = function(options) {\n        return false;\n    };\n\n    PlaneGeometryUpdater.prototype._isDynamic = function(entity, plane) {\n        return !entity.position.isConstant || //\n               !Property.isConstant(entity.orientation) || //\n               !plane.plane.isConstant || //\n               !plane.dimensions.isConstant || //\n               !Property.isConstant(plane.outlineWidth);\n    };\n\n    PlaneGeometryUpdater.prototype._setStaticOptions = function(entity, plane) {\n        var isColorMaterial = this._materialProperty instanceof ColorMaterialProperty;\n\n        var options = this._options;\n        options.vertexFormat = isColorMaterial ? PerInstanceColorAppearance.VERTEX_FORMAT : MaterialAppearance.MaterialSupport.TEXTURED.vertexFormat;\n        options.plane = plane.plane.getValue(Iso8601.MINIMUM_VALUE, options.plane);\n        options.dimensions = plane.dimensions.getValue(Iso8601.MINIMUM_VALUE, options.dimensions);\n    };\n\n    PlaneGeometryUpdater.DynamicGeometryUpdater = DynamicPlaneGeometryUpdater;\n\n    /**\n     * @private\n     */\n    function DynamicPlaneGeometryUpdater(geometryUpdater, primitives, groundPrimitives) {\n        DynamicGeometryUpdater.call(this, geometryUpdater, primitives, groundPrimitives);\n    }\n\n    if (defined(Object.create)) {\n        DynamicPlaneGeometryUpdater.prototype = Object.create(DynamicGeometryUpdater.prototype);\n        DynamicPlaneGeometryUpdater.prototype.constructor = DynamicPlaneGeometryUpdater;\n    }\n\n    DynamicPlaneGeometryUpdater.prototype._isHidden = function(entity, plane, time) {\n        var options = this._options;\n        var position = Property.getValueOrUndefined(entity.position, time, positionScratch);\n        return !defined(position) || !defined(options.plane) || !defined(options.dimensions) || DynamicGeometryUpdater.prototype._isHidden.call(this, entity, plane, time);\n    };\n\n    DynamicPlaneGeometryUpdater.prototype._setOptions = function(entity, plane, time) {\n        var options = this._options;\n        options.plane = Property.getValueOrDefault(plane.plane, time, options.plane);\n        options.dimensions = Property.getValueOrUndefined(plane.dimensions, time, options.dimensions);\n    };\n\n    var scratchAxis = new Cartesian3();\n    var scratchAxis2 = new Cartesian3();\n    var scratchTranslation = new Cartesian3();\n    var scratchNormal = new Cartesian3();\n    var scratchScale = new Cartesian3();\n    var scratchQuaternion = new Quaternion();\n    var scratchMatrix3 = new Matrix3();\n    function createPrimitiveMatrix(plane, dimensions, transform, ellipsoid, result) {\n        var normal = plane.normal;\n        var distance = plane.distance;\n\n        var translation = Cartesian3.multiplyByScalar(normal, -distance, scratchTranslation);\n        translation = Matrix4.multiplyByPoint(transform, translation, translation);\n\n        var transformedNormal = Matrix4.multiplyByPointAsVector(transform, normal, scratchNormal);\n        Cartesian3.normalize(transformedNormal, transformedNormal);\n\n        var up = ellipsoid.geodeticSurfaceNormal(translation, scratchAxis2);\n        if (CesiumMath.equalsEpsilon(Math.abs(Cartesian3.dot(up, transformedNormal)), 1.0, CesiumMath.EPSILON8)) {\n            up = Cartesian3.clone(Cartesian3.UNIT_Z, up);\n            if (CesiumMath.equalsEpsilon(Math.abs(Cartesian3.dot(up, transformedNormal)), 1.0, CesiumMath.EPSILON8)) {\n                up = Cartesian3.clone(Cartesian3.UNIT_X, up);\n            }\n        }\n\n        var left = Cartesian3.cross(up, transformedNormal, scratchAxis);\n        up = Cartesian3.cross(transformedNormal, left, up);\n        Cartesian3.normalize(left, left);\n        Cartesian3.normalize(up, up);\n\n        var rotationMatrix = scratchMatrix3;\n        Matrix3.setColumn(rotationMatrix, 0, left, rotationMatrix);\n        Matrix3.setColumn(rotationMatrix, 1, up, rotationMatrix);\n        Matrix3.setColumn(rotationMatrix, 2, transformedNormal, rotationMatrix);\n        var rotation = Quaternion.fromRotationMatrix(rotationMatrix, scratchQuaternion);\n\n        var scale = Cartesian2.clone(dimensions, scratchScale);\n        scale.z = 1.0;\n\n        return Matrix4.fromTranslationQuaternionRotationScale(translation, rotation, scale, result);\n    }\n\n    /**\n     * @private\n     */\n    PlaneGeometryUpdater.createPrimitiveMatrix = createPrimitiveMatrix;\nexport default PlaneGeometryUpdater;\n","import Cartesian2 from './Cartesian2.js';\nimport Cartesian3 from './Cartesian3.js';\nimport Check from './Check.js';\nimport Matrix3 from './Matrix3.js';\nimport OrientedBoundingBox from './OrientedBoundingBox.js';\n\n    /**\n     * @private\n     */\n    var CoplanarPolygonGeometryLibrary = {};\n\n    var scratchIntersectionPoint = new Cartesian3();\n    var scratchXAxis = new Cartesian3();\n    var scratchYAxis = new Cartesian3();\n    var scratchZAxis = new Cartesian3();\n    var obbScratch = new OrientedBoundingBox();\n\n    CoplanarPolygonGeometryLibrary.validOutline = function(positions) {\n        \n\n        var orientedBoundingBox = OrientedBoundingBox.fromPoints(positions, obbScratch);\n        var halfAxes = orientedBoundingBox.halfAxes;\n        var xAxis = Matrix3.getColumn(halfAxes, 0, scratchXAxis);\n        var yAxis = Matrix3.getColumn(halfAxes, 1, scratchYAxis);\n        var zAxis = Matrix3.getColumn(halfAxes, 2, scratchZAxis);\n\n        var xMag = Cartesian3.magnitude(xAxis);\n        var yMag = Cartesian3.magnitude(yAxis);\n        var zMag = Cartesian3.magnitude(zAxis);\n\n        // If all the points are on a line return undefined because we can't draw a polygon\n        return !((xMag === 0 && (yMag === 0 || zMag === 0)) || (yMag === 0 && zMag === 0));\n    };\n\n    // call after removeDuplicates\n    CoplanarPolygonGeometryLibrary.computeProjectTo2DArguments = function(positions, centerResult, planeAxis1Result, planeAxis2Result) {\n        \n\n        var orientedBoundingBox = OrientedBoundingBox.fromPoints(positions, obbScratch);\n        var halfAxes = orientedBoundingBox.halfAxes;\n        var xAxis = Matrix3.getColumn(halfAxes, 0, scratchXAxis);\n        var yAxis = Matrix3.getColumn(halfAxes, 1, scratchYAxis);\n        var zAxis = Matrix3.getColumn(halfAxes, 2, scratchZAxis);\n\n        var xMag = Cartesian3.magnitude(xAxis);\n        var yMag = Cartesian3.magnitude(yAxis);\n        var zMag = Cartesian3.magnitude(zAxis);\n        var min = Math.min(xMag, yMag, zMag);\n\n        // If all the points are on a line return undefined because we can't draw a polygon\n        if ((xMag === 0 && (yMag === 0 || zMag === 0)) || (yMag === 0 && zMag === 0)) {\n            return false;\n        }\n\n        var planeAxis1;\n        var planeAxis2;\n\n        if (min === yMag || min === zMag) {\n            planeAxis1 = xAxis;\n        }\n        if (min === xMag) {\n            planeAxis1 = yAxis;\n        } else if (min === zMag) {\n            planeAxis2 = yAxis;\n        }\n        if (min === xMag || min === yMag) {\n            planeAxis2 = zAxis;\n        }\n\n        Cartesian3.normalize(planeAxis1, planeAxis1Result);\n        Cartesian3.normalize(planeAxis2, planeAxis2Result);\n        Cartesian3.clone(orientedBoundingBox.center, centerResult);\n        return true;\n    };\n\n    function projectTo2D(position, center, axis1, axis2, result) {\n        var v = Cartesian3.subtract(position, center, scratchIntersectionPoint);\n        var x = Cartesian3.dot(axis1, v);\n        var y = Cartesian3.dot(axis2, v);\n\n        return Cartesian2.fromElements(x, y, result);\n    }\n\n    CoplanarPolygonGeometryLibrary.createProjectPointsTo2DFunction = function(center, axis1, axis2) {\n        return function(positions) {\n            var positionResults = new Array(positions.length);\n            for (var i = 0; i < positions.length; i++) {\n                positionResults[i] = projectTo2D(positions[i], center, axis1, axis2);\n            }\n\n            return positionResults;\n        };\n    };\n\n    CoplanarPolygonGeometryLibrary.createProjectPointTo2DFunction = function(center, axis1, axis2) {\n        return function(position, result) {\n            return projectTo2D(position, center, axis1, axis2, result);\n        };\n    };\nexport default CoplanarPolygonGeometryLibrary;\n","import arrayRemoveDuplicates from './arrayRemoveDuplicates.js';\nimport BoundingRectangle from './BoundingRectangle.js';\nimport BoundingSphere from './BoundingSphere.js';\nimport Cartesian2 from './Cartesian2.js';\nimport Cartesian3 from './Cartesian3.js';\nimport Check from './Check.js';\nimport ComponentDatatype from './ComponentDatatype.js';\nimport CoplanarPolygonGeometryLibrary from './CoplanarPolygonGeometryLibrary.js';\nimport defaultValue from './defaultValue.js';\nimport defined from './defined.js';\nimport Ellipsoid from './Ellipsoid.js';\nimport Geometry from './Geometry.js';\nimport GeometryAttribute from './GeometryAttribute.js';\nimport GeometryAttributes from './GeometryAttributes.js';\nimport GeometryInstance from './GeometryInstance.js';\nimport GeometryPipeline from './GeometryPipeline.js';\nimport IndexDatatype from './IndexDatatype.js';\nimport CesiumMath from './Math.js';\nimport Matrix3 from './Matrix3.js';\nimport PolygonGeometryLibrary from './PolygonGeometryLibrary.js';\nimport PolygonPipeline from './PolygonPipeline.js';\nimport PrimitiveType from './PrimitiveType.js';\nimport Quaternion from './Quaternion.js';\nimport VertexFormat from './VertexFormat.js';\n\n    var scratchPosition = new Cartesian3();\n    var scratchBR = new BoundingRectangle();\n    var stScratch = new Cartesian2();\n    var textureCoordinatesOrigin = new Cartesian2();\n    var scratchNormal = new Cartesian3();\n    var scratchTangent = new Cartesian3();\n    var scratchBitangent = new Cartesian3();\n    var centerScratch = new Cartesian3();\n    var axis1Scratch = new Cartesian3();\n    var axis2Scratch = new Cartesian3();\n    var quaternionScratch = new Quaternion();\n    var textureMatrixScratch = new Matrix3();\n    var tangentRotationScratch = new Matrix3();\n    var surfaceNormalScratch = new Cartesian3();\n\n    function createGeometryFromPolygon(polygon, vertexFormat, boundingRectangle, stRotation, projectPointTo2D, normal, tangent, bitangent) {\n        var positions = polygon.positions;\n        var indices = PolygonPipeline.triangulate(polygon.positions2D, polygon.holes);\n\n        /* If polygon is completely unrenderable, just use the first three vertices */\n        if (indices.length < 3) {\n            indices = [0, 1, 2];\n        }\n\n        var newIndices = IndexDatatype.createTypedArray(positions.length, indices.length);\n        newIndices.set(indices);\n\n        var textureMatrix = textureMatrixScratch;\n        if (stRotation !== 0.0) {\n            var rotation = Quaternion.fromAxisAngle(normal, stRotation, quaternionScratch);\n            textureMatrix = Matrix3.fromQuaternion(rotation, textureMatrix);\n\n            if (vertexFormat.tangent || vertexFormat.bitangent) {\n                rotation = Quaternion.fromAxisAngle(normal, -stRotation, quaternionScratch);\n                var tangentRotation = Matrix3.fromQuaternion(rotation, tangentRotationScratch);\n\n                tangent = Cartesian3.normalize(Matrix3.multiplyByVector(tangentRotation, tangent, tangent), tangent);\n                if (vertexFormat.bitangent) {\n                    bitangent = Cartesian3.normalize(Cartesian3.cross(normal, tangent, bitangent), bitangent);\n                }\n            }\n        } else {\n            textureMatrix = Matrix3.clone(Matrix3.IDENTITY, textureMatrix);\n        }\n\n        var stOrigin = textureCoordinatesOrigin;\n        if (vertexFormat.st) {\n            stOrigin.x = boundingRectangle.x;\n            stOrigin.y = boundingRectangle.y;\n        }\n\n        var length = positions.length;\n        var size = length * 3;\n        var flatPositions = new Float64Array(size);\n        var normals = vertexFormat.normal ? new Float32Array(size) : undefined;\n        var tangents = vertexFormat.tangent ? new Float32Array(size) : undefined;\n        var bitangents = vertexFormat.bitangent ? new Float32Array(size) : undefined;\n        var textureCoordinates = vertexFormat.st ? new Float32Array(length * 2) : undefined;\n\n        var positionIndex = 0;\n        var normalIndex = 0;\n        var bitangentIndex = 0;\n        var tangentIndex = 0;\n        var stIndex = 0;\n\n        for (var i = 0; i < length; i++) {\n            var position = positions[i];\n            flatPositions[positionIndex++] = position.x;\n            flatPositions[positionIndex++] = position.y;\n            flatPositions[positionIndex++] = position.z;\n\n            if (vertexFormat.st) {\n                var p = Matrix3.multiplyByVector(textureMatrix, position, scratchPosition);\n                var st = projectPointTo2D(p, stScratch);\n                Cartesian2.subtract(st, stOrigin, st);\n\n                var stx = CesiumMath.clamp(st.x / boundingRectangle.width, 0, 1);\n                var sty = CesiumMath.clamp(st.y / boundingRectangle.height, 0, 1);\n                textureCoordinates[stIndex++] = stx;\n                textureCoordinates[stIndex++] = sty;\n            }\n\n            if (vertexFormat.normal) {\n                normals[normalIndex++] = normal.x;\n                normals[normalIndex++] = normal.y;\n                normals[normalIndex++] = normal.z;\n            }\n\n            if (vertexFormat.tangent) {\n                tangents[tangentIndex++] = tangent.x;\n                tangents[tangentIndex++] = tangent.y;\n                tangents[tangentIndex++] = tangent.z;\n            }\n\n            if (vertexFormat.bitangent) {\n                bitangents[bitangentIndex++] = bitangent.x;\n                bitangents[bitangentIndex++] = bitangent.y;\n                bitangents[bitangentIndex++] = bitangent.z;\n            }\n        }\n\n        var attributes = new GeometryAttributes();\n\n        if (vertexFormat.position) {\n            attributes.position = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.DOUBLE,\n                componentsPerAttribute : 3,\n                values : flatPositions\n            });\n        }\n\n        if (vertexFormat.normal) {\n            attributes.normal = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.FLOAT,\n                componentsPerAttribute : 3,\n                values : normals\n            });\n        }\n\n        if (vertexFormat.tangent) {\n            attributes.tangent = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.FLOAT,\n                componentsPerAttribute : 3,\n                values : tangents\n            });\n        }\n\n        if (vertexFormat.bitangent) {\n            attributes.bitangent = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.FLOAT,\n                componentsPerAttribute : 3,\n                values : bitangents\n            });\n        }\n\n        if (vertexFormat.st) {\n            attributes.st = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.FLOAT,\n                componentsPerAttribute : 2,\n                values : textureCoordinates\n            });\n        }\n\n        return new Geometry({\n            attributes : attributes,\n            indices : newIndices,\n            primitiveType : PrimitiveType.TRIANGLES\n        });\n    }\n\n    /**\n     * A description of a polygon composed of arbitrary coplanar positions.\n     *\n     * @alias CoplanarPolygonGeometry\n     * @constructor\n     *\n     * @param {Object} options Object with the following properties:\n     * @param {PolygonHierarchy} options.polygonHierarchy A polygon hierarchy that can include holes.\n     * @param {Number} [options.stRotation=0.0] The rotation of the texture coordinates, in radians. A positive rotation is counter-clockwise.\n     * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\n     * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid to be used as a reference.\n     *\n     * @example\n     * var polygon = new Cesium.CoplanarPolygonGeometry({\n     *   positions : Cesium.Cartesian3.fromDegreesArrayHeights([\n     *      -90.0, 30.0, 0.0,\n     *      -90.0, 30.0, 1000.0,\n     *      -80.0, 30.0, 1000.0,\n     *      -80.0, 30.0, 0.0\n     *   ])\n     * });\n     * var geometry = Cesium.CoplanarPolygonGeometry.createGeometry(polygon);\n     *\n     * @see CoplanarPolygonGeometry.createGeometry\n     */\n    function CoplanarPolygonGeometry(options) {\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n        var polygonHierarchy = options.polygonHierarchy;\n        \n\n        var vertexFormat = defaultValue(options.vertexFormat, VertexFormat.DEFAULT);\n        this._vertexFormat = VertexFormat.clone(vertexFormat);\n        this._polygonHierarchy = polygonHierarchy;\n        this._stRotation = defaultValue(options.stRotation, 0.0);\n        this._ellipsoid = Ellipsoid.clone(defaultValue(options.ellipsoid, Ellipsoid.WGS84));\n        this._workerName = 'createCoplanarPolygonGeometry';\n\n        /**\n         * The number of elements used to pack the object into an array.\n         * @type {Number}\n         */\n        this.packedLength = PolygonGeometryLibrary.computeHierarchyPackedLength(polygonHierarchy) + VertexFormat.packedLength + Ellipsoid.packedLength + 2;\n    }\n\n    /**\n     * A description of a coplanar polygon from an array of positions.\n     *\n     * @param {Object} options Object with the following properties:\n     * @param {Cartesian3[]} options.positions An array of positions that defined the corner points of the polygon.\n     * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\n     * @param {Number} [options.stRotation=0.0] The rotation of the texture coordinates, in radians. A positive rotation is counter-clockwise.\n     * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid to be used as a reference.\n     * @returns {CoplanarPolygonGeometry}\n     *\n     * @example\n     * // create a polygon from points\n     * var polygon = Cesium.CoplanarPolygonGeometry.fromPositions({\n     *   positions : Cesium.Cartesian3.fromDegreesArray([\n     *     -72.0, 40.0,\n     *     -70.0, 35.0,\n     *     -75.0, 30.0,\n     *     -70.0, 30.0,\n     *     -68.0, 40.0\n     *   ])\n     * });\n     * var geometry = Cesium.PolygonGeometry.createGeometry(polygon);\n     *\n     * @see PolygonGeometry#createGeometry\n     */\n    CoplanarPolygonGeometry.fromPositions = function(options) {\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n        \n\n        var newOptions = {\n            polygonHierarchy : {\n                positions : options.positions\n            },\n            vertexFormat : options.vertexFormat,\n            stRotation : options.stRotation,\n            ellipsoid : options.ellipsoid\n        };\n        return new CoplanarPolygonGeometry(newOptions);\n    };\n\n    /**\n     * Stores the provided instance into the provided array.\n     *\n     * @param {CoplanarPolygonGeometry} value The value to pack.\n     * @param {Number[]} array The array to pack into.\n     * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n     *\n     * @returns {Number[]} The array that was packed into\n     */\n    CoplanarPolygonGeometry.pack = function(value, array, startingIndex) {\n        \n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        startingIndex = PolygonGeometryLibrary.packPolygonHierarchy(value._polygonHierarchy, array, startingIndex);\n\n        Ellipsoid.pack(value._ellipsoid, array, startingIndex);\n        startingIndex += Ellipsoid.packedLength;\n\n        VertexFormat.pack(value._vertexFormat, array, startingIndex);\n        startingIndex += VertexFormat.packedLength;\n\n        array[startingIndex++] = value._stRotation;\n        array[startingIndex] = value.packedLength;\n\n        return array;\n    };\n\n    var scratchEllipsoid = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);\n    var scratchVertexFormat = new VertexFormat();\n    var scratchOptions = {\n        polygonHierarchy : {}\n    };\n    /**\n     * Retrieves an instance from a packed array.\n     *\n     * @param {Number[]} array The packed array.\n     * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n     * @param {CoplanarPolygonGeometry} [result] The object into which to store the result.\n     * @returns {CoplanarPolygonGeometry} The modified result parameter or a new CoplanarPolygonGeometry instance if one was not provided.\n     */\n    CoplanarPolygonGeometry.unpack = function(array, startingIndex, result) {\n        \n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        var polygonHierarchy = PolygonGeometryLibrary.unpackPolygonHierarchy(array, startingIndex);\n        startingIndex = polygonHierarchy.startingIndex;\n        delete polygonHierarchy.startingIndex;\n\n        var ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);\n        startingIndex += Ellipsoid.packedLength;\n\n        var vertexFormat = VertexFormat.unpack(array, startingIndex, scratchVertexFormat);\n        startingIndex += VertexFormat.packedLength;\n\n        var stRotation = array[startingIndex++];\n        var packedLength = array[startingIndex];\n\n        if (!defined(result)) {\n            result = new CoplanarPolygonGeometry(scratchOptions);\n        }\n\n        result._polygonHierarchy = polygonHierarchy;\n        result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);\n        result._vertexFormat = VertexFormat.clone(vertexFormat, result._vertexFormat);\n        result._stRotation = stRotation;\n        result.packedLength = packedLength;\n        return result;\n    };\n\n    /**\n     * Computes the geometric representation of an arbitrary coplanar polygon, including its vertices, indices, and a bounding sphere.\n     *\n     * @param {CoplanarPolygonGeometry} polygonGeometry A description of the polygon.\n     * @returns {Geometry|undefined} The computed vertices and indices.\n     */\n    CoplanarPolygonGeometry.createGeometry = function(polygonGeometry) {\n        var vertexFormat = polygonGeometry._vertexFormat;\n        var polygonHierarchy = polygonGeometry._polygonHierarchy;\n        var stRotation = polygonGeometry._stRotation;\n\n        var outerPositions = polygonHierarchy.positions;\n        outerPositions = arrayRemoveDuplicates(outerPositions, Cartesian3.equalsEpsilon, true);\n        if (outerPositions.length < 3) {\n            return;\n        }\n\n        var normal = scratchNormal;\n        var tangent = scratchTangent;\n        var bitangent = scratchBitangent;\n        var axis1 = axis1Scratch;\n        var axis2 = axis2Scratch;\n\n        var validGeometry = CoplanarPolygonGeometryLibrary.computeProjectTo2DArguments(outerPositions, centerScratch, axis1, axis2);\n        if (!validGeometry) {\n            return undefined;\n        }\n\n        normal = Cartesian3.cross(axis1, axis2, normal);\n        normal = Cartesian3.normalize(normal, normal);\n\n        if (!Cartesian3.equalsEpsilon(centerScratch, Cartesian3.ZERO, CesiumMath.EPSILON6)) {\n            var surfaceNormal = polygonGeometry._ellipsoid.geodeticSurfaceNormal(centerScratch, surfaceNormalScratch);\n            if (Cartesian3.dot(normal, surfaceNormal) < 0) {\n                normal = Cartesian3.negate(normal, normal);\n                axis1 = Cartesian3.negate(axis1, axis1);\n            }\n        }\n\n        var projectPoints = CoplanarPolygonGeometryLibrary.createProjectPointsTo2DFunction(centerScratch, axis1, axis2);\n        var projectPoint = CoplanarPolygonGeometryLibrary.createProjectPointTo2DFunction(centerScratch, axis1, axis2);\n\n        if (vertexFormat.tangent) {\n            tangent = Cartesian3.clone(axis1, tangent);\n        }\n        if (vertexFormat.bitangent) {\n            bitangent = Cartesian3.clone(axis2, bitangent);\n        }\n\n        var results = PolygonGeometryLibrary.polygonsFromHierarchy(polygonHierarchy, projectPoints, false);\n        var hierarchy = results.hierarchy;\n        var polygons = results.polygons;\n\n        if (hierarchy.length === 0) {\n            return;\n        }\n        outerPositions = hierarchy[0].outerRing;\n\n        var boundingSphere = BoundingSphere.fromPoints(outerPositions);\n        var boundingRectangle = PolygonGeometryLibrary.computeBoundingRectangle(normal, projectPoint, outerPositions, stRotation, scratchBR);\n\n        var geometries = [];\n        for (var i = 0; i < polygons.length; i++) {\n            var geometryInstance = new GeometryInstance({\n                geometry : createGeometryFromPolygon(polygons[i], vertexFormat, boundingRectangle, stRotation, projectPoint, normal, tangent, bitangent)\n            });\n\n            geometries.push(geometryInstance);\n        }\n\n        var geometry = GeometryPipeline.combineInstances(geometries)[0];\n        geometry.attributes.position.values = new Float64Array(geometry.attributes.position.values);\n        geometry.indices = IndexDatatype.createTypedArray(geometry.attributes.position.values.length / 3, geometry.indices);\n\n        var attributes = geometry.attributes;\n        if (!vertexFormat.position) {\n            delete attributes.position;\n        }\n        return new Geometry({\n            attributes : attributes,\n            indices : geometry.indices,\n            primitiveType : geometry.primitiveType,\n            boundingSphere : boundingSphere\n        });\n    };\nexport default CoplanarPolygonGeometry;\n","import arrayRemoveDuplicates from './arrayRemoveDuplicates.js';\nimport BoundingSphere from './BoundingSphere.js';\nimport Cartesian3 from './Cartesian3.js';\nimport Check from './Check.js';\nimport ComponentDatatype from './ComponentDatatype.js';\nimport CoplanarPolygonGeometryLibrary from './CoplanarPolygonGeometryLibrary.js';\nimport defaultValue from './defaultValue.js';\nimport defined from './defined.js';\nimport Geometry from './Geometry.js';\nimport GeometryAttribute from './GeometryAttribute.js';\nimport GeometryAttributes from './GeometryAttributes.js';\nimport GeometryInstance from './GeometryInstance.js';\nimport GeometryPipeline from './GeometryPipeline.js';\nimport IndexDatatype from './IndexDatatype.js';\nimport PolygonGeometryLibrary from './PolygonGeometryLibrary.js';\nimport PrimitiveType from './PrimitiveType.js';\n\n    function createGeometryFromPositions(positions){\n        var length = positions.length;\n        var flatPositions = new Float64Array(length * 3);\n        var indices = IndexDatatype.createTypedArray(length, length * 2);\n\n        var positionIndex = 0;\n        var index = 0;\n\n        for (var i = 0; i < length; i++) {\n            var position = positions[i];\n            flatPositions[positionIndex++] = position.x;\n            flatPositions[positionIndex++] = position.y;\n            flatPositions[positionIndex++] = position.z;\n\n            indices[index++] = i;\n            indices[index++] = (i + 1) % length;\n        }\n\n        var attributes = new GeometryAttributes({\n            position: new GeometryAttribute({\n                componentDatatype : ComponentDatatype.DOUBLE,\n                componentsPerAttribute : 3,\n                values : flatPositions\n            })\n        });\n\n        return new Geometry({\n            attributes : attributes,\n            indices : indices,\n            primitiveType : PrimitiveType.LINES\n        });\n    }\n\n    /**\n     * A description of the outline of a polygon composed of arbitrary coplanar positions.\n     *\n     * @alias CoplanarPolygonOutlineGeometry\n     * @constructor\n     *\n     * @param {Object} options Object with the following properties:\n     * @param {PolygonHierarchy} options.polygonHierarchy A polygon hierarchy that can include holes.\n     *\n     * @see CoplanarPolygonOutlineGeometry.createGeometry\n     *\n     * @example\n     * var polygonOutline = new Cesium.CoplanarPolygonOutlineGeometry({\n     *   positions : Cesium.Cartesian3.fromDegreesArrayHeights([\n     *      -90.0, 30.0, 0.0,\n     *      -90.0, 30.0, 1000.0,\n     *      -80.0, 30.0, 1000.0,\n     *      -80.0, 30.0, 0.0\n     *   ])\n     * });\n     * var geometry = Cesium.CoplanarPolygonOutlineGeometry.createGeometry(polygonOutline);\n     */\n    function CoplanarPolygonOutlineGeometry(options) {\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n        var polygonHierarchy = options.polygonHierarchy;\n        \n\n        this._polygonHierarchy = polygonHierarchy;\n        this._workerName = 'createCoplanarPolygonOutlineGeometry';\n\n        /**\n         * The number of elements used to pack the object into an array.\n         * @type {Number}\n         */\n        this.packedLength = PolygonGeometryLibrary.computeHierarchyPackedLength(polygonHierarchy) + 1;\n    }\n\n    /**\n     * A description of a coplanar polygon outline from an array of positions.\n     *\n     * @param {Object} options Object with the following properties:\n     * @param {Cartesian3[]} options.positions An array of positions that defined the corner points of the polygon.\n     * @returns {CoplanarPolygonOutlineGeometry}\n     */\n    CoplanarPolygonOutlineGeometry.fromPositions = function(options) {\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n        \n\n        var newOptions = {\n            polygonHierarchy : {\n                positions : options.positions\n            }\n        };\n        return new CoplanarPolygonOutlineGeometry(newOptions);\n    };\n\n    /**\n     * Stores the provided instance into the provided array.\n     *\n     * @param {CoplanarPolygonOutlineGeometry} value The value to pack.\n     * @param {Number[]} array The array to pack into.\n     * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n     *\n     * @returns {Number[]} The array that was packed into\n     */\n    CoplanarPolygonOutlineGeometry.pack = function(value, array, startingIndex) {\n        \n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        startingIndex = PolygonGeometryLibrary.packPolygonHierarchy(value._polygonHierarchy, array, startingIndex);\n\n        array[startingIndex] = value.packedLength;\n\n        return array;\n    };\n\n    var scratchOptions = {\n        polygonHierarchy : {}\n    };\n    /**\n     * Retrieves an instance from a packed array.\n     *\n     * @param {Number[]} array The packed array.\n     * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n     * @param {CoplanarPolygonOutlineGeometry} [result] The object into which to store the result.\n     * @returns {CoplanarPolygonOutlineGeometry} The modified result parameter or a new CoplanarPolygonOutlineGeometry instance if one was not provided.\n     */\n    CoplanarPolygonOutlineGeometry.unpack = function(array, startingIndex, result) {\n        \n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        var polygonHierarchy = PolygonGeometryLibrary.unpackPolygonHierarchy(array, startingIndex);\n        startingIndex = polygonHierarchy.startingIndex;\n        delete polygonHierarchy.startingIndex;\n        var packedLength = array[startingIndex];\n\n        if (!defined(result)) {\n            result = new CoplanarPolygonOutlineGeometry(scratchOptions);\n        }\n\n        result._polygonHierarchy = polygonHierarchy;\n        result.packedLength = packedLength;\n\n        return result;\n    };\n\n    /**\n     * Computes the geometric representation of an arbitrary coplanar polygon, including its vertices, indices, and a bounding sphere.\n     *\n     * @param {CoplanarPolygonOutlineGeometry} polygonGeometry A description of the polygon.\n     * @returns {Geometry|undefined} The computed vertices and indices.\n     */\n    CoplanarPolygonOutlineGeometry.createGeometry = function(polygonGeometry) {\n        var polygonHierarchy = polygonGeometry._polygonHierarchy;\n\n        var outerPositions = polygonHierarchy.positions;\n        outerPositions = arrayRemoveDuplicates(outerPositions, Cartesian3.equalsEpsilon, true);\n        if (outerPositions.length < 3) {\n            return;\n        }\n        var isValid = CoplanarPolygonGeometryLibrary.validOutline(outerPositions);\n        if (!isValid) {\n            return undefined;\n        }\n\n        var polygons = PolygonGeometryLibrary.polygonOutlinesFromHierarchy(polygonHierarchy, false);\n\n        if (polygons.length === 0) {\n            return undefined;\n        }\n\n        var geometries = [];\n\n        for (var i = 0; i < polygons.length; i++) {\n            var geometryInstance = new GeometryInstance({\n                geometry : createGeometryFromPositions(polygons[i])\n            });\n            geometries.push(geometryInstance);\n        }\n\n        var geometry = GeometryPipeline.combineInstances(geometries)[0];\n        var boundingSphere = BoundingSphere.fromPoints(polygonHierarchy.positions);\n\n        return new Geometry({\n            attributes : geometry.attributes,\n            indices : geometry.indices,\n            primitiveType : geometry.primitiveType,\n            boundingSphere : boundingSphere\n        });\n    };\nexport default CoplanarPolygonOutlineGeometry;\n","import ArcType from './ArcType.js';\nimport arrayFill from './arrayFill.js';\nimport BoundingRectangle from './BoundingRectangle.js';\nimport BoundingSphere from './BoundingSphere.js';\nimport Cartesian2 from './Cartesian2.js';\nimport Cartesian3 from './Cartesian3.js';\nimport Cartographic from './Cartographic.js';\nimport Check from './Check.js';\nimport ComponentDatatype from './ComponentDatatype.js';\nimport defaultValue from './defaultValue.js';\nimport defined from './defined.js';\nimport defineProperties from './defineProperties.js';\nimport DeveloperError from './DeveloperError.js';\nimport Ellipsoid from './Ellipsoid.js';\nimport EllipsoidGeodesic from './EllipsoidGeodesic.js';\nimport EllipsoidTangentPlane from './EllipsoidTangentPlane.js';\nimport Geometry from './Geometry.js';\nimport GeometryAttribute from './GeometryAttribute.js';\nimport GeometryInstance from './GeometryInstance.js';\nimport GeometryOffsetAttribute from './GeometryOffsetAttribute.js';\nimport GeometryPipeline from './GeometryPipeline.js';\nimport IndexDatatype from './IndexDatatype.js';\nimport CesiumMath from './Math.js';\nimport Matrix3 from './Matrix3.js';\nimport PolygonGeometryLibrary from './PolygonGeometryLibrary.js';\nimport PolygonPipeline from './PolygonPipeline.js';\nimport Quaternion from './Quaternion.js';\nimport Rectangle from './Rectangle.js';\nimport VertexFormat from './VertexFormat.js';\nimport WindingOrder from './WindingOrder.js';\n\n    var scratchCarto1 = new Cartographic();\n    var scratchCarto2 = new Cartographic();\n    function adjustPosHeightsForNormal(position, p1, p2, ellipsoid) {\n        var carto1 = ellipsoid.cartesianToCartographic(position, scratchCarto1);\n        var height = carto1.height;\n        var p1Carto = ellipsoid.cartesianToCartographic(p1, scratchCarto2);\n        p1Carto.height = height;\n        ellipsoid.cartographicToCartesian(p1Carto, p1);\n\n        var p2Carto = ellipsoid.cartesianToCartographic(p2, scratchCarto2);\n        p2Carto.height = height - 100;\n        ellipsoid.cartographicToCartesian(p2Carto, p2);\n    }\n\n    var scratchBoundingRectangle = new BoundingRectangle();\n    var scratchPosition = new Cartesian3();\n    var scratchNormal = new Cartesian3();\n    var scratchTangent = new Cartesian3();\n    var scratchBitangent = new Cartesian3();\n    var p1Scratch = new Cartesian3();\n    var p2Scratch = new Cartesian3();\n    var scratchPerPosNormal = new Cartesian3();\n    var scratchPerPosTangent = new Cartesian3();\n    var scratchPerPosBitangent = new Cartesian3();\n\n    var appendTextureCoordinatesOrigin = new Cartesian2();\n    var appendTextureCoordinatesCartesian2 = new Cartesian2();\n    var appendTextureCoordinatesCartesian3 = new Cartesian3();\n    var appendTextureCoordinatesQuaternion = new Quaternion();\n    var appendTextureCoordinatesMatrix3 = new Matrix3();\n    var tangentMatrixScratch = new Matrix3();\n\n    function computeAttributes(options) {\n        var vertexFormat = options.vertexFormat;\n        var geometry = options.geometry;\n        var shadowVolume = options.shadowVolume;\n        var flatPositions = geometry.attributes.position.values;\n        var length = flatPositions.length;\n        var wall = options.wall;\n        var top = options.top || wall;\n        var bottom = options.bottom || wall;\n        if (vertexFormat.st || vertexFormat.normal || vertexFormat.tangent || vertexFormat.bitangent || shadowVolume) {\n            // PERFORMANCE_IDEA: Compute before subdivision, then just interpolate during subdivision.\n            // PERFORMANCE_IDEA: Compute with createGeometryFromPositions() for fast path when there's no holes.\n            var boundingRectangle = options.boundingRectangle;\n            var tangentPlane = options.tangentPlane;\n            var ellipsoid = options.ellipsoid;\n            var stRotation = options.stRotation;\n            var perPositionHeight = options.perPositionHeight;\n\n            var origin = appendTextureCoordinatesOrigin;\n            origin.x = boundingRectangle.x;\n            origin.y = boundingRectangle.y;\n\n            var textureCoordinates = vertexFormat.st ? new Float32Array(2 * (length / 3)) : undefined;\n            var normals;\n            if (vertexFormat.normal) {\n                if (perPositionHeight && top && !wall) {\n                    normals = geometry.attributes.normal.values;\n                } else {\n                    normals = new Float32Array(length);\n                }\n            }\n            var tangents = vertexFormat.tangent ? new Float32Array(length) : undefined;\n            var bitangents = vertexFormat.bitangent ? new Float32Array(length) : undefined;\n            var extrudeNormals = shadowVolume ? new Float32Array(length) : undefined;\n\n            var textureCoordIndex = 0;\n            var attrIndex = 0;\n\n            var normal = scratchNormal;\n            var tangent = scratchTangent;\n            var bitangent = scratchBitangent;\n            var recomputeNormal = true;\n\n            var textureMatrix = appendTextureCoordinatesMatrix3;\n            var tangentRotationMatrix = tangentMatrixScratch;\n            if (stRotation !== 0.0) {\n                var rotation = Quaternion.fromAxisAngle(tangentPlane._plane.normal, stRotation, appendTextureCoordinatesQuaternion);\n                textureMatrix = Matrix3.fromQuaternion(rotation, textureMatrix);\n\n                rotation = Quaternion.fromAxisAngle(tangentPlane._plane.normal, -stRotation, appendTextureCoordinatesQuaternion);\n                tangentRotationMatrix = Matrix3.fromQuaternion(rotation, tangentRotationMatrix);\n            } else {\n                textureMatrix = Matrix3.clone(Matrix3.IDENTITY, textureMatrix);\n                tangentRotationMatrix = Matrix3.clone(Matrix3.IDENTITY, tangentRotationMatrix);\n            }\n\n            var bottomOffset = 0;\n            var bottomOffset2 = 0;\n\n            if (top && bottom) {\n                bottomOffset = length / 2;\n                bottomOffset2 = length / 3;\n\n                length /= 2;\n            }\n\n            for ( var i = 0; i < length; i += 3) {\n                var position = Cartesian3.fromArray(flatPositions, i, appendTextureCoordinatesCartesian3);\n\n                if (vertexFormat.st) {\n                    var p = Matrix3.multiplyByVector(textureMatrix, position, scratchPosition);\n                    p = ellipsoid.scaleToGeodeticSurface(p,p);\n                    var st = tangentPlane.projectPointOntoPlane(p, appendTextureCoordinatesCartesian2);\n                    Cartesian2.subtract(st, origin, st);\n\n                    var stx = CesiumMath.clamp(st.x / boundingRectangle.width, 0, 1);\n                    var sty = CesiumMath.clamp(st.y / boundingRectangle.height, 0, 1);\n                    if (bottom) {\n                        textureCoordinates[textureCoordIndex + bottomOffset2] = stx;\n                        textureCoordinates[textureCoordIndex + 1 + bottomOffset2] = sty;\n                    }\n                    if (top) {\n                        textureCoordinates[textureCoordIndex] = stx;\n                        textureCoordinates[textureCoordIndex + 1] = sty;\n                    }\n\n                    textureCoordIndex += 2;\n                }\n\n                if (vertexFormat.normal || vertexFormat.tangent || vertexFormat.bitangent || shadowVolume) {\n                    var attrIndex1 = attrIndex + 1;\n                    var attrIndex2 = attrIndex + 2;\n\n                    if (wall) {\n                        if (i + 3 < length) {\n                            var p1 = Cartesian3.fromArray(flatPositions, i + 3, p1Scratch);\n\n                            if (recomputeNormal) {\n                                var p2 = Cartesian3.fromArray(flatPositions, i + length, p2Scratch);\n                                if (perPositionHeight) {\n                                    adjustPosHeightsForNormal(position, p1, p2, ellipsoid);\n                                }\n                                Cartesian3.subtract(p1, position, p1);\n                                Cartesian3.subtract(p2, position, p2);\n                                normal = Cartesian3.normalize(Cartesian3.cross(p2, p1, normal), normal);\n                                recomputeNormal = false;\n                            }\n\n                            if (Cartesian3.equalsEpsilon(p1, position, CesiumMath.EPSILON10)) { // if we've reached a corner\n                                recomputeNormal = true;\n                            }\n                        }\n\n                        if (vertexFormat.tangent || vertexFormat.bitangent) {\n                            bitangent = ellipsoid.geodeticSurfaceNormal(position, bitangent);\n                            if (vertexFormat.tangent) {\n                                tangent = Cartesian3.normalize(Cartesian3.cross(bitangent, normal, tangent), tangent);\n                            }\n                        }\n                    } else {\n                        normal = ellipsoid.geodeticSurfaceNormal(position, normal);\n                        if (vertexFormat.tangent || vertexFormat.bitangent) {\n                            if (perPositionHeight) {\n                                scratchPerPosNormal = Cartesian3.fromArray(normals, attrIndex, scratchPerPosNormal);\n                                scratchPerPosTangent = Cartesian3.cross(Cartesian3.UNIT_Z, scratchPerPosNormal, scratchPerPosTangent);\n                                scratchPerPosTangent = Cartesian3.normalize(Matrix3.multiplyByVector(tangentRotationMatrix, scratchPerPosTangent, scratchPerPosTangent), scratchPerPosTangent);\n                                if (vertexFormat.bitangent) {\n                                    scratchPerPosBitangent = Cartesian3.normalize(Cartesian3.cross(scratchPerPosNormal, scratchPerPosTangent, scratchPerPosBitangent), scratchPerPosBitangent);\n                                }\n                            }\n\n                            tangent = Cartesian3.cross(Cartesian3.UNIT_Z, normal, tangent);\n                            tangent = Cartesian3.normalize(Matrix3.multiplyByVector(tangentRotationMatrix, tangent, tangent), tangent);\n                            if (vertexFormat.bitangent) {\n                                bitangent = Cartesian3.normalize(Cartesian3.cross(normal, tangent, bitangent), bitangent);\n                            }\n                        }\n                    }\n\n                    if (vertexFormat.normal) {\n                        if (options.wall) {\n                            normals[attrIndex + bottomOffset] = normal.x;\n                            normals[attrIndex1 + bottomOffset] = normal.y;\n                            normals[attrIndex2 + bottomOffset] = normal.z;\n                        } else if (bottom){\n                            normals[attrIndex + bottomOffset] = -normal.x;\n                            normals[attrIndex1 + bottomOffset] = -normal.y;\n                            normals[attrIndex2 + bottomOffset] = -normal.z;\n                        }\n\n                        if ((top && !perPositionHeight) || wall) {\n                            normals[attrIndex] = normal.x;\n                            normals[attrIndex1] = normal.y;\n                            normals[attrIndex2] = normal.z;\n                        }\n                    }\n\n                    if (shadowVolume) {\n                        if (wall) {\n                            normal = ellipsoid.geodeticSurfaceNormal(position, normal);\n                        }\n                        extrudeNormals[attrIndex + bottomOffset] = -normal.x;\n                        extrudeNormals[attrIndex1 + bottomOffset] = -normal.y;\n                        extrudeNormals[attrIndex2 + bottomOffset] = -normal.z;\n                    }\n\n                    if (vertexFormat.tangent) {\n                        if (options.wall) {\n                            tangents[attrIndex + bottomOffset] = tangent.x;\n                            tangents[attrIndex1 + bottomOffset] = tangent.y;\n                            tangents[attrIndex2 + bottomOffset] = tangent.z;\n                        } else if (bottom) {\n                            tangents[attrIndex + bottomOffset] = -tangent.x;\n                            tangents[attrIndex1 + bottomOffset] = -tangent.y;\n                            tangents[attrIndex2 + bottomOffset] = -tangent.z;\n                        }\n\n                        if(top) {\n                            if (perPositionHeight) {\n                                tangents[attrIndex] = scratchPerPosTangent.x;\n                                tangents[attrIndex1] = scratchPerPosTangent.y;\n                                tangents[attrIndex2] = scratchPerPosTangent.z;\n                            } else {\n                                tangents[attrIndex] = tangent.x;\n                                tangents[attrIndex1] = tangent.y;\n                                tangents[attrIndex2] = tangent.z;\n                            }\n                        }\n                    }\n\n                    if (vertexFormat.bitangent) {\n                        if (bottom) {\n                            bitangents[attrIndex + bottomOffset] = bitangent.x;\n                            bitangents[attrIndex1 + bottomOffset] = bitangent.y;\n                            bitangents[attrIndex2 + bottomOffset] = bitangent.z;\n                        }\n                        if (top) {\n                            if (perPositionHeight) {\n                                bitangents[attrIndex] = scratchPerPosBitangent.x;\n                                bitangents[attrIndex1] = scratchPerPosBitangent.y;\n                                bitangents[attrIndex2] = scratchPerPosBitangent.z;\n                            } else {\n                                bitangents[attrIndex] = bitangent.x;\n                                bitangents[attrIndex1] = bitangent.y;\n                                bitangents[attrIndex2] = bitangent.z;\n                            }\n                        }\n                    }\n                    attrIndex += 3;\n                }\n            }\n\n            if (vertexFormat.st) {\n                geometry.attributes.st = new GeometryAttribute({\n                    componentDatatype : ComponentDatatype.FLOAT,\n                    componentsPerAttribute : 2,\n                    values : textureCoordinates\n                });\n            }\n\n            if (vertexFormat.normal) {\n                geometry.attributes.normal = new GeometryAttribute({\n                    componentDatatype : ComponentDatatype.FLOAT,\n                    componentsPerAttribute : 3,\n                    values : normals\n                });\n            }\n\n            if (vertexFormat.tangent) {\n                geometry.attributes.tangent = new GeometryAttribute({\n                    componentDatatype : ComponentDatatype.FLOAT,\n                    componentsPerAttribute : 3,\n                    values : tangents\n                });\n            }\n\n            if (vertexFormat.bitangent) {\n                geometry.attributes.bitangent = new GeometryAttribute({\n                    componentDatatype : ComponentDatatype.FLOAT,\n                    componentsPerAttribute : 3,\n                    values : bitangents\n                });\n            }\n\n            if (shadowVolume) {\n                geometry.attributes.extrudeDirection = new GeometryAttribute({\n                    componentDatatype : ComponentDatatype.FLOAT,\n                    componentsPerAttribute : 3,\n                    values : extrudeNormals\n                });\n            }\n        }\n\n        if (options.extrude && defined(options.offsetAttribute)) {\n            var size = flatPositions.length / 3;\n            var offsetAttribute = new Uint8Array(size);\n\n            if (options.offsetAttribute === GeometryOffsetAttribute.TOP) {\n                if ((top && bottom) || wall) {\n                    offsetAttribute = arrayFill(offsetAttribute, 1, 0, size / 2);\n                } else if (top) {\n                    offsetAttribute = arrayFill(offsetAttribute, 1);\n                }\n            } else {\n                var offsetValue = options.offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;\n                offsetAttribute = arrayFill(offsetAttribute, offsetValue);\n            }\n\n            geometry.attributes.applyOffset = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.UNSIGNED_BYTE,\n                componentsPerAttribute : 1,\n                values : offsetAttribute\n            });\n        }\n\n        return geometry;\n    }\n\n    var startCartographicScratch = new Cartographic();\n    var endCartographicScratch = new Cartographic();\n    var idlCross = {\n        westOverIDL : 0.0,\n        eastOverIDL : 0.0\n    };\n    var ellipsoidGeodesic = new EllipsoidGeodesic();\n    function computeRectangle(positions, ellipsoid, arcType, granularity, result) {\n        result = defaultValue(result, new Rectangle());\n        if (!defined(positions) || positions.length < 3) {\n            result.west = 0.0;\n            result.north = 0.0;\n            result.south = 0.0;\n            result.east = 0.0;\n            return result;\n        }\n\n        if (arcType === ArcType.RHUMB) {\n            return Rectangle.fromCartesianArray(positions, ellipsoid, result);\n        }\n\n        if (!ellipsoidGeodesic.ellipsoid.equals(ellipsoid)) {\n            ellipsoidGeodesic = new EllipsoidGeodesic(undefined, undefined, ellipsoid);\n        }\n\n        result.west = Number.POSITIVE_INFINITY;\n        result.east = Number.NEGATIVE_INFINITY;\n        result.south = Number.POSITIVE_INFINITY;\n        result.north = Number.NEGATIVE_INFINITY;\n\n        idlCross.westOverIDL = Number.POSITIVE_INFINITY;\n        idlCross.eastOverIDL = Number.NEGATIVE_INFINITY;\n\n        var inverseChordLength = 1.0 / CesiumMath.chordLength(granularity, ellipsoid.maximumRadius);\n        var positionsLength = positions.length;\n        var endCartographic = ellipsoid.cartesianToCartographic(positions[0], endCartographicScratch);\n        var startCartographic = startCartographicScratch;\n        var swap;\n\n        for (var i = 1; i < positionsLength; i++) {\n            swap = startCartographic;\n            startCartographic = endCartographic;\n            endCartographic = ellipsoid.cartesianToCartographic(positions[i], swap);\n            ellipsoidGeodesic.setEndPoints(startCartographic, endCartographic);\n            interpolateAndGrowRectangle(ellipsoidGeodesic, inverseChordLength, result, idlCross);\n        }\n\n        swap = startCartographic;\n        startCartographic = endCartographic;\n        endCartographic = ellipsoid.cartesianToCartographic(positions[0], swap);\n        ellipsoidGeodesic.setEndPoints(startCartographic, endCartographic);\n        interpolateAndGrowRectangle(ellipsoidGeodesic, inverseChordLength, result, idlCross);\n\n        if (result.east - result.west > idlCross.eastOverIDL - idlCross.westOverIDL) {\n            result.west = idlCross.westOverIDL;\n            result.east = idlCross.eastOverIDL;\n\n            if (result.east > CesiumMath.PI) {\n                result.east = result.east - CesiumMath.TWO_PI;\n            }\n            if (result.west > CesiumMath.PI) {\n                result.west = result.west - CesiumMath.TWO_PI;\n            }\n        }\n\n        return result;\n    }\n\n    var interpolatedCartographicScratch = new Cartographic();\n    function interpolateAndGrowRectangle(ellipsoidGeodesic, inverseChordLength, result, idlCross) {\n        var segmentLength = ellipsoidGeodesic.surfaceDistance;\n\n        var numPoints = Math.ceil(segmentLength * inverseChordLength);\n        var subsegmentDistance = numPoints > 0 ? segmentLength / (numPoints - 1) : Number.POSITIVE_INFINITY;\n        var interpolationDistance = 0.0;\n\n        for (var i = 0; i < numPoints; i++) {\n            var interpolatedCartographic = ellipsoidGeodesic.interpolateUsingSurfaceDistance(interpolationDistance, interpolatedCartographicScratch);\n            interpolationDistance += subsegmentDistance;\n            var longitude = interpolatedCartographic.longitude;\n            var latitude = interpolatedCartographic.latitude;\n\n            result.west = Math.min(result.west, longitude);\n            result.east = Math.max(result.east, longitude);\n            result.south = Math.min(result.south, latitude);\n            result.north = Math.max(result.north, latitude);\n\n            var lonAdjusted = longitude >= 0 ?  longitude : longitude +  CesiumMath.TWO_PI;\n            idlCross.westOverIDL = Math.min(idlCross.westOverIDL, lonAdjusted);\n            idlCross.eastOverIDL = Math.max(idlCross.eastOverIDL, lonAdjusted);\n        }\n    }\n\n    var createGeometryFromPositionsExtrudedPositions = [];\n\n    function createGeometryFromPositionsExtruded(ellipsoid, polygon, granularity, hierarchy, perPositionHeight, closeTop, closeBottom, vertexFormat, arcType) {\n        var geos = {\n            walls : []\n        };\n        var i;\n\n        if (closeTop || closeBottom) {\n            var topGeo = PolygonGeometryLibrary.createGeometryFromPositions(ellipsoid, polygon, granularity, perPositionHeight, vertexFormat, arcType);\n\n            var edgePoints = topGeo.attributes.position.values;\n            var indices = topGeo.indices;\n            var numPositions;\n            var newIndices;\n\n            if (closeTop && closeBottom) {\n                var topBottomPositions = edgePoints.concat(edgePoints);\n\n                numPositions = topBottomPositions.length / 3;\n\n                newIndices = IndexDatatype.createTypedArray(numPositions, indices.length * 2);\n                newIndices.set(indices);\n                var ilength = indices.length;\n\n                var length = numPositions / 2;\n\n                for (i = 0; i < ilength; i += 3) {\n                    var i0 = newIndices[i] + length;\n                    var i1 = newIndices[i + 1] + length;\n                    var i2 = newIndices[i + 2] + length;\n\n                    newIndices[i + ilength] = i2;\n                    newIndices[i + 1 + ilength] = i1;\n                    newIndices[i + 2 + ilength] = i0;\n                }\n\n                topGeo.attributes.position.values = topBottomPositions;\n                if (perPositionHeight && vertexFormat.normal) {\n                    var normals = topGeo.attributes.normal.values;\n                    topGeo.attributes.normal.values = new Float32Array(topBottomPositions.length);\n                    topGeo.attributes.normal.values.set(normals);\n                }\n                topGeo.indices = newIndices;\n            } else if (closeBottom) {\n                numPositions = edgePoints.length / 3;\n                newIndices = IndexDatatype.createTypedArray(numPositions, indices.length);\n\n                for (i = 0; i < indices.length; i += 3) {\n                    newIndices[i] = indices[i + 2];\n                    newIndices[i + 1] = indices[i + 1];\n                    newIndices[i + 2] = indices[i];\n                }\n\n                topGeo.indices = newIndices;\n            }\n\n            geos.topAndBottom = new GeometryInstance({\n                geometry : topGeo\n            });\n        }\n\n        var outerRing = hierarchy.outerRing;\n        var tangentPlane = EllipsoidTangentPlane.fromPoints(outerRing, ellipsoid);\n        var positions2D = tangentPlane.projectPointsOntoPlane(outerRing, createGeometryFromPositionsExtrudedPositions);\n\n        var windingOrder = PolygonPipeline.computeWindingOrder2D(positions2D);\n        if (windingOrder === WindingOrder.CLOCKWISE) {\n            outerRing = outerRing.slice().reverse();\n        }\n\n        var wallGeo = PolygonGeometryLibrary.computeWallGeometry(outerRing, ellipsoid, granularity, perPositionHeight, arcType);\n        geos.walls.push(new GeometryInstance({\n            geometry : wallGeo\n        }));\n\n        var holes = hierarchy.holes;\n        for (i = 0; i < holes.length; i++) {\n            var hole = holes[i];\n\n            tangentPlane = EllipsoidTangentPlane.fromPoints(hole, ellipsoid);\n            positions2D = tangentPlane.projectPointsOntoPlane(hole, createGeometryFromPositionsExtrudedPositions);\n\n            windingOrder = PolygonPipeline.computeWindingOrder2D(positions2D);\n            if (windingOrder === WindingOrder.COUNTER_CLOCKWISE) {\n                hole = hole.slice().reverse();\n            }\n\n            wallGeo = PolygonGeometryLibrary.computeWallGeometry(hole, ellipsoid, granularity, perPositionHeight, arcType);\n            geos.walls.push(new GeometryInstance({\n                geometry : wallGeo\n            }));\n        }\n\n        return geos;\n    }\n\n    /**\n     * A description of a polygon on the ellipsoid. The polygon is defined by a polygon hierarchy. Polygon geometry can be rendered with both {@link Primitive} and {@link GroundPrimitive}.\n     *\n     * @alias PolygonGeometry\n     * @constructor\n     *\n     * @param {Object} options Object with the following properties:\n     * @param {PolygonHierarchy} options.polygonHierarchy A polygon hierarchy that can include holes.\n     * @param {Number} [options.height=0.0] The distance in meters between the polygon and the ellipsoid surface.\n     * @param {Number} [options.extrudedHeight] The distance in meters between the polygon's extruded face and the ellipsoid surface.\n     * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\n     * @param {Number} [options.stRotation=0.0] The rotation of the texture coordinates, in radians. A positive rotation is counter-clockwise.\n     * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid to be used as a reference.\n     * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n     * @param {Boolean} [options.perPositionHeight=false] Use the height of options.positions for each position instead of using options.height to determine the height.\n     * @param {Boolean} [options.closeTop=true] When false, leaves off the top of an extruded polygon open.\n     * @param {Boolean} [options.closeBottom=true] When false, leaves off the bottom of an extruded polygon open.\n     * @param {ArcType} [options.arcType=ArcType.GEODESIC] The type of line the polygon edges must follow. Valid options are {@link ArcType.GEODESIC} and {@link ArcType.RHUMB}.\n     *\n     * @see PolygonGeometry#createGeometry\n     * @see PolygonGeometry#fromPositions\n     *\n     * @demo {@link https://sandcastle.cesium.com/index.html?src=Polygon.html|Cesium Sandcastle Polygon Demo}\n     *\n     * @example\n     * // 1. create a polygon from points\n     * var polygon = new Cesium.PolygonGeometry({\n     *   polygonHierarchy : new Cesium.PolygonHierarchy(\n     *     Cesium.Cartesian3.fromDegreesArray([\n     *       -72.0, 40.0,\n     *       -70.0, 35.0,\n     *       -75.0, 30.0,\n     *       -70.0, 30.0,\n     *       -68.0, 40.0\n     *     ])\n     *   )\n     * });\n     * var geometry = Cesium.PolygonGeometry.createGeometry(polygon);\n     *\n     * // 2. create a nested polygon with holes\n     * var polygonWithHole = new Cesium.PolygonGeometry({\n     *   polygonHierarchy : new Cesium.PolygonHierarchy(\n     *     Cesium.Cartesian3.fromDegreesArray([\n     *       -109.0, 30.0,\n     *       -95.0, 30.0,\n     *       -95.0, 40.0,\n     *       -109.0, 40.0\n     *     ]),\n     *     [new Cesium.PolygonHierarchy(\n     *       Cesium.Cartesian3.fromDegreesArray([\n     *         -107.0, 31.0,\n     *         -107.0, 39.0,\n     *         -97.0, 39.0,\n     *         -97.0, 31.0\n     *       ]),\n     *       [new Cesium.PolygonHierarchy(\n     *         Cesium.Cartesian3.fromDegreesArray([\n     *           -105.0, 33.0,\n     *           -99.0, 33.0,\n     *           -99.0, 37.0,\n     *           -105.0, 37.0\n     *         ]),\n     *         [new Cesium.PolygonHierarchy(\n     *           Cesium.Cartesian3.fromDegreesArray([\n     *             -103.0, 34.0,\n     *             -101.0, 34.0,\n     *             -101.0, 36.0,\n     *             -103.0, 36.0\n     *           ])\n     *         )]\n     *       )]\n     *     )]\n     *   )\n     * });\n     * var geometry = Cesium.PolygonGeometry.createGeometry(polygonWithHole);\n     *\n     * // 3. create extruded polygon\n     * var extrudedPolygon = new Cesium.PolygonGeometry({\n     *   polygonHierarchy : new Cesium.PolygonHierarchy(\n     *     Cesium.Cartesian3.fromDegreesArray([\n     *       -72.0, 40.0,\n     *       -70.0, 35.0,\n     *       -75.0, 30.0,\n     *       -70.0, 30.0,\n     *       -68.0, 40.0\n     *     ])\n     *   ),\n     *   extrudedHeight: 300000\n     * });\n     * var geometry = Cesium.PolygonGeometry.createGeometry(extrudedPolygon);\n     */\n    function PolygonGeometry(options) {\n        \n\n        var polygonHierarchy = options.polygonHierarchy;\n        var vertexFormat = defaultValue(options.vertexFormat, VertexFormat.DEFAULT);\n        var ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\n        var granularity = defaultValue(options.granularity, CesiumMath.RADIANS_PER_DEGREE);\n        var stRotation = defaultValue(options.stRotation, 0.0);\n        var perPositionHeight = defaultValue(options.perPositionHeight, false);\n        var perPositionHeightExtrude = perPositionHeight && defined(options.extrudedHeight);\n        var height = defaultValue(options.height, 0.0);\n        var extrudedHeight = defaultValue(options.extrudedHeight, height);\n\n        if (!perPositionHeightExtrude) {\n            var h = Math.max(height, extrudedHeight);\n            extrudedHeight = Math.min(height, extrudedHeight);\n            height = h;\n        }\n\n        this._vertexFormat = VertexFormat.clone(vertexFormat);\n        this._ellipsoid = Ellipsoid.clone(ellipsoid);\n        this._granularity = granularity;\n        this._stRotation = stRotation;\n        this._height = height;\n        this._extrudedHeight = extrudedHeight;\n        this._closeTop = defaultValue(options.closeTop, true);\n        this._closeBottom = defaultValue(options.closeBottom, true);\n        this._polygonHierarchy = polygonHierarchy;\n        this._perPositionHeight = perPositionHeight;\n        this._perPositionHeightExtrude = perPositionHeightExtrude;\n        this._shadowVolume = defaultValue(options.shadowVolume, false);\n        this._workerName = 'createPolygonGeometry';\n        this._offsetAttribute = options.offsetAttribute;\n        this._arcType = defaultValue(options.arcType, ArcType.GEODESIC);\n\n        this._rectangle = undefined;\n        this._textureCoordinateRotationPoints = undefined;\n\n        /**\n         * The number of elements used to pack the object into an array.\n         * @type {Number}\n         */\n        this.packedLength = PolygonGeometryLibrary.computeHierarchyPackedLength(polygonHierarchy) + Ellipsoid.packedLength + VertexFormat.packedLength + 12;\n    }\n\n    /**\n     * A description of a polygon from an array of positions. Polygon geometry can be rendered with both {@link Primitive} and {@link GroundPrimitive}.\n     *\n     * @param {Object} options Object with the following properties:\n     * @param {Cartesian3[]} options.positions An array of positions that defined the corner points of the polygon.\n     * @param {Number} [options.height=0.0] The height of the polygon.\n     * @param {Number} [options.extrudedHeight] The height of the polygon extrusion.\n     * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\n     * @param {Number} [options.stRotation=0.0] The rotation of the texture coordinates, in radians. A positive rotation is counter-clockwise.\n     * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid to be used as a reference.\n     * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n     * @param {Boolean} [options.perPositionHeight=false] Use the height of options.positions for each position instead of using options.height to determine the height.\n     * @param {Boolean} [options.closeTop=true] When false, leaves off the top of an extruded polygon open.\n     * @param {Boolean} [options.closeBottom=true] When false, leaves off the bottom of an extruded polygon open.\n     * @param {ArcType} [options.arcType=ArcType.GEODESIC] The type of line the polygon edges must follow. Valid options are {@link ArcType.GEODESIC} and {@link ArcType.RHUMB}.\n     * @returns {PolygonGeometry}\n     *\n     *\n     * @example\n     * // create a polygon from points\n     * var polygon = Cesium.PolygonGeometry.fromPositions({\n     *   positions : Cesium.Cartesian3.fromDegreesArray([\n     *     -72.0, 40.0,\n     *     -70.0, 35.0,\n     *     -75.0, 30.0,\n     *     -70.0, 30.0,\n     *     -68.0, 40.0\n     *   ])\n     * });\n     * var geometry = Cesium.PolygonGeometry.createGeometry(polygon);\n     *\n     * @see PolygonGeometry#createGeometry\n     */\n    PolygonGeometry.fromPositions = function(options) {\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n        \n\n        var newOptions = {\n            polygonHierarchy : {\n                positions : options.positions\n            },\n            height : options.height,\n            extrudedHeight : options.extrudedHeight,\n            vertexFormat : options.vertexFormat,\n            stRotation : options.stRotation,\n            ellipsoid : options.ellipsoid,\n            granularity : options.granularity,\n            perPositionHeight : options.perPositionHeight,\n            closeTop : options.closeTop,\n            closeBottom : options.closeBottom,\n            offsetAttribute : options.offsetAttribute,\n            arcType : options.arcType\n        };\n        return new PolygonGeometry(newOptions);\n    };\n\n    /**\n     * Stores the provided instance into the provided array.\n     *\n     * @param {PolygonGeometry} value The value to pack.\n     * @param {Number[]} array The array to pack into.\n     * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n     *\n     * @returns {Number[]} The array that was packed into\n     */\n    PolygonGeometry.pack = function(value, array, startingIndex) {\n        \n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        startingIndex = PolygonGeometryLibrary.packPolygonHierarchy(value._polygonHierarchy, array, startingIndex);\n\n        Ellipsoid.pack(value._ellipsoid, array, startingIndex);\n        startingIndex += Ellipsoid.packedLength;\n\n        VertexFormat.pack(value._vertexFormat, array, startingIndex);\n        startingIndex += VertexFormat.packedLength;\n\n        array[startingIndex++] = value._height;\n        array[startingIndex++] = value._extrudedHeight;\n        array[startingIndex++] = value._granularity;\n        array[startingIndex++] = value._stRotation;\n        array[startingIndex++] = value._perPositionHeightExtrude ? 1.0 : 0.0;\n        array[startingIndex++] = value._perPositionHeight ? 1.0 : 0.0;\n        array[startingIndex++] = value._closeTop ? 1.0 : 0.0;\n        array[startingIndex++] = value._closeBottom ? 1.0 : 0.0;\n        array[startingIndex++] = value._shadowVolume ? 1.0 : 0.0;\n        array[startingIndex++] = defaultValue(value._offsetAttribute, -1);\n        array[startingIndex++] = value._arcType;\n        array[startingIndex] = value.packedLength;\n\n        return array;\n    };\n\n    var scratchEllipsoid = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);\n    var scratchVertexFormat = new VertexFormat();\n\n    //Only used to avoid inability to default construct.\n    var dummyOptions = {\n        polygonHierarchy : {}\n    };\n\n    /**\n     * Retrieves an instance from a packed array.\n     *\n     * @param {Number[]} array The packed array.\n     * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n     * @param {PolygonGeometry} [result] The object into which to store the result.\n     */\n    PolygonGeometry.unpack = function(array, startingIndex, result) {\n        \n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        var polygonHierarchy = PolygonGeometryLibrary.unpackPolygonHierarchy(array, startingIndex);\n        startingIndex = polygonHierarchy.startingIndex;\n        delete polygonHierarchy.startingIndex;\n\n        var ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);\n        startingIndex += Ellipsoid.packedLength;\n\n        var vertexFormat = VertexFormat.unpack(array, startingIndex, scratchVertexFormat);\n        startingIndex += VertexFormat.packedLength;\n\n        var height = array[startingIndex++];\n        var extrudedHeight = array[startingIndex++];\n        var granularity = array[startingIndex++];\n        var stRotation = array[startingIndex++];\n        var perPositionHeightExtrude = array[startingIndex++] === 1.0;\n        var perPositionHeight = array[startingIndex++] === 1.0;\n        var closeTop = array[startingIndex++] === 1.0;\n        var closeBottom = array[startingIndex++] === 1.0;\n        var shadowVolume = array[startingIndex++] === 1.0;\n        var offsetAttribute = array[startingIndex++];\n        var arcType = array[startingIndex++];\n        var packedLength = array[startingIndex];\n\n        if (!defined(result)) {\n            result = new PolygonGeometry(dummyOptions);\n        }\n\n        result._polygonHierarchy = polygonHierarchy;\n        result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);\n        result._vertexFormat = VertexFormat.clone(vertexFormat, result._vertexFormat);\n        result._height = height;\n        result._extrudedHeight = extrudedHeight;\n        result._granularity = granularity;\n        result._stRotation = stRotation;\n        result._perPositionHeightExtrude = perPositionHeightExtrude;\n        result._perPositionHeight = perPositionHeight;\n        result._closeTop = closeTop;\n        result._closeBottom = closeBottom;\n        result._shadowVolume = shadowVolume;\n        result._offsetAttribute = offsetAttribute === -1 ? undefined : offsetAttribute;\n        result._arcType = arcType;\n        result.packedLength = packedLength;\n        return result;\n    };\n\n    /**\n     * Returns the bounding rectangle given the provided options\n     *\n     * @param {Object} options Object with the following properties:\n     * @param {PolygonHierarchy} options.polygonHierarchy A polygon hierarchy that can include holes.\n     * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions sampled.\n     * @param {ArcType} [options.arcType=ArcType.GEODESIC] The type of line the polygon edges must follow. Valid options are {@link ArcType.GEODESIC} and {@link ArcType.RHUMB}.\n     * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid to be used as a reference.\n     * @param {Rectangle} [result] An object in which to store the result.\n     *\n     * @returns {Rectangle} The result rectangle\n     */\n    PolygonGeometry.computeRectangle = function(options, result) {\n        \n\n        var granularity = defaultValue(options.granularity, CesiumMath.RADIANS_PER_DEGREE);\n        var arcType = defaultValue(options.arcType, ArcType.GEODESIC);\n        \n\n        var polygonHierarchy = options.polygonHierarchy;\n        var ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\n\n        return computeRectangle(polygonHierarchy.positions, ellipsoid, arcType, granularity, result);\n    };\n\n    /**\n     * Computes the geometric representation of a polygon, including its vertices, indices, and a bounding sphere.\n     *\n     * @param {PolygonGeometry} polygonGeometry A description of the polygon.\n     * @returns {Geometry|undefined} The computed vertices and indices.\n     */\n    PolygonGeometry.createGeometry = function(polygonGeometry) {\n        var vertexFormat = polygonGeometry._vertexFormat;\n        var ellipsoid = polygonGeometry._ellipsoid;\n        var granularity = polygonGeometry._granularity;\n        var stRotation = polygonGeometry._stRotation;\n        var polygonHierarchy = polygonGeometry._polygonHierarchy;\n        var perPositionHeight = polygonGeometry._perPositionHeight;\n        var closeTop = polygonGeometry._closeTop;\n        var closeBottom = polygonGeometry._closeBottom;\n        var arcType = polygonGeometry._arcType;\n\n        var outerPositions = polygonHierarchy.positions;\n        if (outerPositions.length < 3) {\n            return;\n        }\n\n        var tangentPlane = EllipsoidTangentPlane.fromPoints(outerPositions, ellipsoid);\n\n        var results = PolygonGeometryLibrary.polygonsFromHierarchy(polygonHierarchy, tangentPlane.projectPointsOntoPlane.bind(tangentPlane), !perPositionHeight, ellipsoid);\n\n        var hierarchy = results.hierarchy;\n        var polygons = results.polygons;\n\n        if (hierarchy.length === 0) {\n            return;\n        }\n\n        outerPositions = hierarchy[0].outerRing;\n        var boundingRectangle = PolygonGeometryLibrary.computeBoundingRectangle(tangentPlane.plane.normal, tangentPlane.projectPointOntoPlane.bind(tangentPlane), outerPositions, stRotation, scratchBoundingRectangle);\n\n        var geometries = [];\n\n        var height = polygonGeometry._height;\n        var extrudedHeight = polygonGeometry._extrudedHeight;\n        var extrude = polygonGeometry._perPositionHeightExtrude || !CesiumMath.equalsEpsilon(height, extrudedHeight, 0, CesiumMath.EPSILON2);\n\n        var options = {\n            perPositionHeight: perPositionHeight,\n            vertexFormat: vertexFormat,\n            geometry: undefined,\n            tangentPlane: tangentPlane,\n            boundingRectangle: boundingRectangle,\n            ellipsoid: ellipsoid,\n            stRotation: stRotation,\n            bottom: false,\n            top: true,\n            wall: false,\n            extrude: false,\n            arcType: arcType\n        };\n\n        var i;\n\n        if (extrude) {\n            options.extrude = true;\n            options.top = closeTop;\n            options.bottom = closeBottom;\n            options.shadowVolume = polygonGeometry._shadowVolume;\n            options.offsetAttribute = polygonGeometry._offsetAttribute;\n            for (i = 0; i < polygons.length; i++) {\n                var splitGeometry = createGeometryFromPositionsExtruded(ellipsoid, polygons[i], granularity, hierarchy[i], perPositionHeight, closeTop, closeBottom, vertexFormat, arcType);\n\n                var topAndBottom;\n                if (closeTop && closeBottom) {\n                    topAndBottom = splitGeometry.topAndBottom;\n                    options.geometry = PolygonGeometryLibrary.scaleToGeodeticHeightExtruded(topAndBottom.geometry, height, extrudedHeight, ellipsoid, perPositionHeight);\n                } else if (closeTop) {\n                    topAndBottom = splitGeometry.topAndBottom;\n                    topAndBottom.geometry.attributes.position.values = PolygonPipeline.scaleToGeodeticHeight(topAndBottom.geometry.attributes.position.values, height, ellipsoid, !perPositionHeight);\n                    options.geometry = topAndBottom.geometry;\n                } else if (closeBottom) {\n                    topAndBottom = splitGeometry.topAndBottom;\n                    topAndBottom.geometry.attributes.position.values = PolygonPipeline.scaleToGeodeticHeight(topAndBottom.geometry.attributes.position.values, extrudedHeight, ellipsoid, true);\n                    options.geometry = topAndBottom.geometry;\n                }\n                if (closeTop || closeBottom) {\n                    options.wall = false;\n                    topAndBottom.geometry = computeAttributes(options);\n                    geometries.push(topAndBottom);\n                }\n\n                var walls = splitGeometry.walls;\n                options.wall = true;\n                for ( var k = 0; k < walls.length; k++) {\n                    var wall = walls[k];\n                    options.geometry = PolygonGeometryLibrary.scaleToGeodeticHeightExtruded(wall.geometry, height, extrudedHeight, ellipsoid, perPositionHeight);\n                    wall.geometry = computeAttributes(options);\n                    geometries.push(wall);\n                }\n            }\n        } else {\n            for (i = 0; i < polygons.length; i++) {\n                var geometryInstance = new GeometryInstance({\n                    geometry : PolygonGeometryLibrary.createGeometryFromPositions(ellipsoid, polygons[i], granularity, perPositionHeight, vertexFormat, arcType)\n                });\n                geometryInstance.geometry.attributes.position.values = PolygonPipeline.scaleToGeodeticHeight(geometryInstance.geometry.attributes.position.values, height, ellipsoid, !perPositionHeight);\n                options.geometry = geometryInstance.geometry;\n                geometryInstance.geometry = computeAttributes(options);\n\n                if (defined(polygonGeometry._offsetAttribute)) {\n                    var length = geometryInstance.geometry.attributes.position.values.length;\n                    var applyOffset = new Uint8Array(length / 3);\n                    var offsetValue = polygonGeometry._offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;\n                    arrayFill(applyOffset, offsetValue);\n                    geometryInstance.geometry.attributes.applyOffset = new GeometryAttribute({\n                        componentDatatype : ComponentDatatype.UNSIGNED_BYTE,\n                        componentsPerAttribute : 1,\n                        values: applyOffset\n                    });\n                }\n\n                geometries.push(geometryInstance);\n            }\n        }\n\n        var geometry = GeometryPipeline.combineInstances(geometries)[0];\n        geometry.attributes.position.values = new Float64Array(geometry.attributes.position.values);\n        geometry.indices = IndexDatatype.createTypedArray(geometry.attributes.position.values.length / 3, geometry.indices);\n\n        var attributes = geometry.attributes;\n        var boundingSphere = BoundingSphere.fromVertices(attributes.position.values);\n\n        if (!vertexFormat.position) {\n            delete attributes.position;\n        }\n\n        return new Geometry({\n            attributes : attributes,\n            indices : geometry.indices,\n            primitiveType : geometry.primitiveType,\n            boundingSphere : boundingSphere,\n            offsetAttribute : polygonGeometry._offsetAttribute\n        });\n    };\n\n    /**\n     * @private\n     */\n    PolygonGeometry.createShadowVolume = function(polygonGeometry, minHeightFunc, maxHeightFunc) {\n        var granularity = polygonGeometry._granularity;\n        var ellipsoid = polygonGeometry._ellipsoid;\n\n        var minHeight = minHeightFunc(granularity, ellipsoid);\n        var maxHeight = maxHeightFunc(granularity, ellipsoid);\n\n        return new PolygonGeometry({\n            polygonHierarchy : polygonGeometry._polygonHierarchy,\n            ellipsoid : ellipsoid,\n            stRotation : polygonGeometry._stRotation,\n            granularity : granularity,\n            perPositionHeight : false,\n            extrudedHeight : minHeight,\n            height : maxHeight,\n            vertexFormat : VertexFormat.POSITION_ONLY,\n            shadowVolume: true,\n            arcType : polygonGeometry._arcType\n        });\n    };\n\n    function textureCoordinateRotationPoints(polygonGeometry) {\n        var stRotation = -polygonGeometry._stRotation;\n        if (stRotation === 0.0) {\n            return [0, 0, 0, 1, 1, 0];\n        }\n        var ellipsoid = polygonGeometry._ellipsoid;\n        var positions = polygonGeometry._polygonHierarchy.positions;\n        var boundingRectangle = polygonGeometry.rectangle;\n        return Geometry._textureCoordinateRotationPoints(positions, stRotation, ellipsoid, boundingRectangle);\n    }\n\n    defineProperties(PolygonGeometry.prototype, {\n        /**\n         * @private\n         */\n        rectangle : {\n            get : function() {\n                if (!defined(this._rectangle)) {\n                    var positions = this._polygonHierarchy.positions;\n                    this._rectangle = computeRectangle(positions, this._ellipsoid, this._arcType, this._granularity);\n                }\n\n                return this._rectangle;\n            }\n        },\n        /**\n         * For remapping texture coordinates when rendering PolygonGeometries as GroundPrimitives.\n         * @private\n         */\n        textureCoordinateRotationPoints : {\n            get : function() {\n                if (!defined(this._textureCoordinateRotationPoints)) {\n                    this._textureCoordinateRotationPoints = textureCoordinateRotationPoints(this);\n                }\n                return this._textureCoordinateRotationPoints;\n            }\n        }\n    });\nexport default PolygonGeometry;\n","import ArcType from './ArcType.js';\nimport arrayFill from './arrayFill.js';\nimport BoundingSphere from './BoundingSphere.js';\nimport Check from './Check.js';\nimport ComponentDatatype from './ComponentDatatype.js';\nimport defaultValue from './defaultValue.js';\nimport defined from './defined.js';\nimport DeveloperError from './DeveloperError.js';\nimport Ellipsoid from './Ellipsoid.js';\nimport EllipsoidTangentPlane from './EllipsoidTangentPlane.js';\nimport Geometry from './Geometry.js';\nimport GeometryAttribute from './GeometryAttribute.js';\nimport GeometryAttributes from './GeometryAttributes.js';\nimport GeometryInstance from './GeometryInstance.js';\nimport GeometryOffsetAttribute from './GeometryOffsetAttribute.js';\nimport GeometryPipeline from './GeometryPipeline.js';\nimport IndexDatatype from './IndexDatatype.js';\nimport CesiumMath from './Math.js';\nimport PolygonGeometryLibrary from './PolygonGeometryLibrary.js';\nimport PolygonPipeline from './PolygonPipeline.js';\nimport PrimitiveType from './PrimitiveType.js';\nimport WindingOrder from './WindingOrder.js';\n    var createGeometryFromPositionsPositions = [];\n    var createGeometryFromPositionsSubdivided = [];\n\n    function createGeometryFromPositions(ellipsoid, positions, minDistance, perPositionHeight, arcType) {\n        var tangentPlane = EllipsoidTangentPlane.fromPoints(positions, ellipsoid);\n        var positions2D = tangentPlane.projectPointsOntoPlane(positions, createGeometryFromPositionsPositions);\n\n        var originalWindingOrder = PolygonPipeline.computeWindingOrder2D(positions2D);\n        if (originalWindingOrder === WindingOrder.CLOCKWISE) {\n            positions2D.reverse();\n            positions = positions.slice().reverse();\n        }\n\n        var subdividedPositions;\n        var i;\n\n        var length = positions.length;\n        var index = 0;\n\n        if (!perPositionHeight) {\n            var numVertices = 0;\n            if (arcType === ArcType.GEODESIC) {\n                for (i = 0; i < length; i++) {\n                    numVertices += PolygonGeometryLibrary.subdivideLineCount(positions[i], positions[(i + 1) % length], minDistance);\n                }\n            } else if (arcType === ArcType.RHUMB) {\n                for (i = 0; i < length; i++) {\n                    numVertices += PolygonGeometryLibrary.subdivideRhumbLineCount(ellipsoid, positions[i], positions[(i + 1) % length], minDistance);\n                }\n            }\n            subdividedPositions = new Float64Array(numVertices * 3);\n            for (i = 0; i < length; i++) {\n                var tempPositions;\n                if (arcType === ArcType.GEODESIC) {\n                    tempPositions = PolygonGeometryLibrary.subdivideLine(positions[i], positions[(i + 1) % length], minDistance, createGeometryFromPositionsSubdivided);\n                } else if (arcType === ArcType.RHUMB) {\n                    tempPositions = PolygonGeometryLibrary.subdivideRhumbLine(ellipsoid, positions[i], positions[(i + 1) % length], minDistance, createGeometryFromPositionsSubdivided);\n                }\n                var tempPositionsLength = tempPositions.length;\n                for (var j = 0; j < tempPositionsLength; ++j) {\n                    subdividedPositions[index++] = tempPositions[j];\n                }\n            }\n        } else {\n            subdividedPositions = new Float64Array(length * 2 * 3);\n            for (i = 0; i < length; i++) {\n                var p0 = positions[i];\n                var p1 = positions[(i + 1) % length];\n                subdividedPositions[index++] = p0.x;\n                subdividedPositions[index++] = p0.y;\n                subdividedPositions[index++] = p0.z;\n                subdividedPositions[index++] = p1.x;\n                subdividedPositions[index++] = p1.y;\n                subdividedPositions[index++] = p1.z;\n            }\n        }\n\n        length = subdividedPositions.length / 3;\n        var indicesSize = length * 2;\n        var indices = IndexDatatype.createTypedArray(length, indicesSize);\n        index = 0;\n        for (i = 0; i < length - 1; i++) {\n            indices[index++] = i;\n            indices[index++] = i + 1;\n        }\n        indices[index++] = length - 1;\n        indices[index++] = 0;\n\n        return new GeometryInstance({\n            geometry : new Geometry({\n                attributes : new GeometryAttributes({\n                    position : new GeometryAttribute({\n                        componentDatatype : ComponentDatatype.DOUBLE,\n                        componentsPerAttribute : 3,\n                        values : subdividedPositions\n                    })\n                }),\n                indices : indices,\n                primitiveType : PrimitiveType.LINES\n            })\n        });\n    }\n\n    function createGeometryFromPositionsExtruded(ellipsoid, positions, minDistance, perPositionHeight, arcType) {\n        var tangentPlane = EllipsoidTangentPlane.fromPoints(positions, ellipsoid);\n        var positions2D = tangentPlane.projectPointsOntoPlane(positions, createGeometryFromPositionsPositions);\n\n        var originalWindingOrder = PolygonPipeline.computeWindingOrder2D(positions2D);\n        if (originalWindingOrder === WindingOrder.CLOCKWISE) {\n            positions2D.reverse();\n            positions = positions.slice().reverse();\n        }\n\n        var subdividedPositions;\n        var i;\n\n        var length = positions.length;\n        var corners = new Array(length);\n        var index = 0;\n\n        if (!perPositionHeight) {\n            var numVertices = 0;\n            if (arcType === ArcType.GEODESIC) {\n                for (i = 0; i < length; i++) {\n                    numVertices += PolygonGeometryLibrary.subdivideLineCount(positions[i], positions[(i + 1) % length], minDistance);\n                }\n            } else if (arcType === ArcType.RHUMB) {\n                for (i = 0; i < length; i++) {\n                    numVertices += PolygonGeometryLibrary.subdivideRhumbLineCount(ellipsoid, positions[i], positions[(i + 1) % length], minDistance);\n                }\n            }\n\n            subdividedPositions = new Float64Array(numVertices * 3 * 2);\n            for (i = 0; i < length; ++i) {\n                corners[i] = index / 3;\n                var tempPositions;\n                if (arcType === ArcType.GEODESIC) {\n                    tempPositions = PolygonGeometryLibrary.subdivideLine(positions[i], positions[(i + 1) % length], minDistance, createGeometryFromPositionsSubdivided);\n                } else if (arcType === ArcType.RHUMB) {\n                    tempPositions = PolygonGeometryLibrary.subdivideRhumbLine(ellipsoid, positions[i], positions[(i + 1) % length], minDistance, createGeometryFromPositionsSubdivided);\n                }\n                var tempPositionsLength = tempPositions.length;\n                for (var j = 0; j < tempPositionsLength; ++j) {\n                    subdividedPositions[index++] = tempPositions[j];\n                }\n            }\n        } else {\n            subdividedPositions = new Float64Array(length * 2 * 3 * 2);\n            for (i = 0; i < length; ++i) {\n                corners[i] = index / 3;\n                var p0 = positions[i];\n                var p1 = positions[(i + 1) % length];\n\n                subdividedPositions[index++] = p0.x;\n                subdividedPositions[index++] = p0.y;\n                subdividedPositions[index++] = p0.z;\n                subdividedPositions[index++] = p1.x;\n                subdividedPositions[index++] = p1.y;\n                subdividedPositions[index++] = p1.z;\n            }\n        }\n\n        length = subdividedPositions.length / (3 * 2);\n        var cornersLength = corners.length;\n\n        var indicesSize = ((length * 2) + cornersLength) * 2;\n        var indices = IndexDatatype.createTypedArray(length + cornersLength, indicesSize);\n\n        index = 0;\n        for (i = 0; i < length; ++i) {\n            indices[index++] = i;\n            indices[index++] = (i + 1) % length;\n            indices[index++] = i + length;\n            indices[index++] = ((i + 1) % length) + length;\n        }\n\n        for (i = 0; i < cornersLength; i++) {\n            var corner = corners[i];\n            indices[index++] = corner;\n            indices[index++] = corner + length;\n        }\n\n        return new GeometryInstance({\n            geometry : new Geometry({\n                attributes : new GeometryAttributes({\n                    position : new GeometryAttribute({\n                        componentDatatype : ComponentDatatype.DOUBLE,\n                        componentsPerAttribute : 3,\n                        values : subdividedPositions\n                    })\n                }),\n                indices : indices,\n                primitiveType : PrimitiveType.LINES\n            })\n        });\n    }\n\n    /**\n     * A description of the outline of a polygon on the ellipsoid. The polygon is defined by a polygon hierarchy.\n     *\n     * @alias PolygonOutlineGeometry\n     * @constructor\n     *\n     * @param {Object} options Object with the following properties:\n     * @param {PolygonHierarchy} options.polygonHierarchy A polygon hierarchy that can include holes.\n     * @param {Number} [options.height=0.0] The distance in meters between the polygon and the ellipsoid surface.\n     * @param {Number} [options.extrudedHeight] The distance in meters between the polygon's extruded face and the ellipsoid surface.\n     * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\n     * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid to be used as a reference.\n     * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n     * @param {Boolean} [options.perPositionHeight=false] Use the height of options.positions for each position instead of using options.height to determine the height.\n     * @param {ArcType} [options.arcType=ArcType.GEODESIC] The type of path the outline must follow. Valid options are {@link ArcType.GEODESIC} and {@link ArcType.RHUMB}.\n     *\n     * @see PolygonOutlineGeometry#createGeometry\n     * @see PolygonOutlineGeometry#fromPositions\n     *\n     * @example\n     * // 1. create a polygon outline from points\n     * var polygon = new Cesium.PolygonOutlineGeometry({\n     *   polygonHierarchy : new Cesium.PolygonHierarchy(\n     *     Cesium.Cartesian3.fromDegreesArray([\n     *       -72.0, 40.0,\n     *       -70.0, 35.0,\n     *       -75.0, 30.0,\n     *       -70.0, 30.0,\n     *       -68.0, 40.0\n     *     ])\n     *   )\n     * });\n     * var geometry = Cesium.PolygonOutlineGeometry.createGeometry(polygon);\n     *\n     * // 2. create a nested polygon with holes outline\n     * var polygonWithHole = new Cesium.PolygonOutlineGeometry({\n     *   polygonHierarchy : new Cesium.PolygonHierarchy(\n     *     Cesium.Cartesian3.fromDegreesArray([\n     *       -109.0, 30.0,\n     *       -95.0, 30.0,\n     *       -95.0, 40.0,\n     *       -109.0, 40.0\n     *     ]),\n     *     [new Cesium.PolygonHierarchy(\n     *       Cesium.Cartesian3.fromDegreesArray([\n     *         -107.0, 31.0,\n     *         -107.0, 39.0,\n     *         -97.0, 39.0,\n     *         -97.0, 31.0\n     *       ]),\n     *       [new Cesium.PolygonHierarchy(\n     *         Cesium.Cartesian3.fromDegreesArray([\n     *           -105.0, 33.0,\n     *           -99.0, 33.0,\n     *           -99.0, 37.0,\n     *           -105.0, 37.0\n     *         ]),\n     *         [new Cesium.PolygonHierarchy(\n     *           Cesium.Cartesian3.fromDegreesArray([\n     *             -103.0, 34.0,\n     *             -101.0, 34.0,\n     *             -101.0, 36.0,\n     *             -103.0, 36.0\n     *           ])\n     *         )]\n     *       )]\n     *     )]\n     *   )\n     * });\n     * var geometry = Cesium.PolygonOutlineGeometry.createGeometry(polygonWithHole);\n     *\n     * // 3. create extruded polygon outline\n     * var extrudedPolygon = new Cesium.PolygonOutlineGeometry({\n     *   polygonHierarchy : new Cesium.PolygonHierarchy(\n     *     Cesium.Cartesian3.fromDegreesArray([\n     *       -72.0, 40.0,\n     *       -70.0, 35.0,\n     *       -75.0, 30.0,\n     *       -70.0, 30.0,\n     *       -68.0, 40.0\n     *     ])\n     *   ),\n     *   extrudedHeight: 300000\n     * });\n     * var geometry = Cesium.PolygonOutlineGeometry.createGeometry(extrudedPolygon);\n     */\n    function PolygonOutlineGeometry(options) {\n        \n\n        var polygonHierarchy = options.polygonHierarchy;\n        var ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\n        var granularity = defaultValue(options.granularity, CesiumMath.RADIANS_PER_DEGREE);\n        var perPositionHeight = defaultValue(options.perPositionHeight, false);\n        var perPositionHeightExtrude = perPositionHeight && defined(options.extrudedHeight);\n        var arcType = defaultValue(options.arcType, ArcType.GEODESIC);\n\n        var height = defaultValue(options.height, 0.0);\n        var extrudedHeight = defaultValue(options.extrudedHeight, height);\n\n        if (!perPositionHeightExtrude) {\n            var h = Math.max(height, extrudedHeight);\n            extrudedHeight = Math.min(height, extrudedHeight);\n            height = h;\n        }\n\n        this._ellipsoid = Ellipsoid.clone(ellipsoid);\n        this._granularity = granularity;\n        this._height = height;\n        this._extrudedHeight = extrudedHeight;\n        this._arcType = arcType;\n        this._polygonHierarchy = polygonHierarchy;\n        this._perPositionHeight = perPositionHeight;\n        this._perPositionHeightExtrude = perPositionHeightExtrude;\n        this._offsetAttribute = options.offsetAttribute;\n        this._workerName = 'createPolygonOutlineGeometry';\n\n        /**\n         * The number of elements used to pack the object into an array.\n         * @type {Number}\n         */\n        this.packedLength = PolygonGeometryLibrary.computeHierarchyPackedLength(polygonHierarchy) + Ellipsoid.packedLength + 8;\n    }\n\n    /**\n     * Stores the provided instance into the provided array.\n     *\n     * @param {PolygonOutlineGeometry} value The value to pack.\n     * @param {Number[]} array The array to pack into.\n     * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n     *\n     * @returns {Number[]} The array that was packed into\n     */\n    PolygonOutlineGeometry.pack = function(value, array, startingIndex) {\n        \n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        startingIndex = PolygonGeometryLibrary.packPolygonHierarchy(value._polygonHierarchy, array, startingIndex);\n\n        Ellipsoid.pack(value._ellipsoid, array, startingIndex);\n        startingIndex += Ellipsoid.packedLength;\n\n        array[startingIndex++] = value._height;\n        array[startingIndex++] = value._extrudedHeight;\n        array[startingIndex++] = value._granularity;\n        array[startingIndex++] = value._perPositionHeightExtrude ? 1.0 : 0.0;\n        array[startingIndex++] = value._perPositionHeight ? 1.0 : 0.0;\n        array[startingIndex++] = value._arcType;\n        array[startingIndex++] = defaultValue(value._offsetAttribute, -1);\n        array[startingIndex] = value.packedLength;\n\n        return array;\n    };\n\n    var scratchEllipsoid = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);\n    var dummyOptions = {\n        polygonHierarchy : {}\n    };\n\n    /**\n     * Retrieves an instance from a packed array.\n     *\n     * @param {Number[]} array The packed array.\n     * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n     * @param {PolygonOutlineGeometry} [result] The object into which to store the result.\n     * @returns {PolygonOutlineGeometry} The modified result parameter or a new PolygonOutlineGeometry instance if one was not provided.\n     */\n    PolygonOutlineGeometry.unpack = function(array, startingIndex, result) {\n        \n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        var polygonHierarchy = PolygonGeometryLibrary.unpackPolygonHierarchy(array, startingIndex);\n        startingIndex = polygonHierarchy.startingIndex;\n        delete polygonHierarchy.startingIndex;\n\n        var ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);\n        startingIndex += Ellipsoid.packedLength;\n\n        var height = array[startingIndex++];\n        var extrudedHeight = array[startingIndex++];\n        var granularity = array[startingIndex++];\n        var perPositionHeightExtrude = array[startingIndex++] === 1.0;\n        var perPositionHeight = array[startingIndex++] === 1.0;\n        var arcType = array[startingIndex++];\n        var offsetAttribute = array[startingIndex++];\n        var packedLength = array[startingIndex];\n\n        if (!defined(result)) {\n            result = new PolygonOutlineGeometry(dummyOptions);\n        }\n\n        result._polygonHierarchy = polygonHierarchy;\n        result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);\n        result._height = height;\n        result._extrudedHeight = extrudedHeight;\n        result._granularity = granularity;\n        result._perPositionHeight = perPositionHeight;\n        result._perPositionHeightExtrude = perPositionHeightExtrude;\n        result._arcType = arcType;\n        result._offsetAttribute = offsetAttribute === -1 ? undefined : offsetAttribute;\n        result.packedLength = packedLength;\n\n        return result;\n    };\n\n    /**\n     * A description of a polygon outline from an array of positions.\n     *\n     * @param {Object} options Object with the following properties:\n     * @param {Cartesian3[]} options.positions An array of positions that defined the corner points of the polygon.\n     * @param {Number} [options.height=0.0] The height of the polygon.\n     * @param {Number} [options.extrudedHeight] The height of the polygon extrusion.\n     * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid to be used as a reference.\n     * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n     * @param {Boolean} [options.perPositionHeight=false] Use the height of options.positions for each position instead of using options.height to determine the height.\n     * @param {ArcType} [options.arcType=ArcType.GEODESIC] The type of path the outline must follow. Valid options are {@link LinkType.GEODESIC} and {@link ArcType.RHUMB}.\n     * @returns {PolygonOutlineGeometry}\n     *\n     *\n     * @example\n     * // create a polygon from points\n     * var polygon = Cesium.PolygonOutlineGeometry.fromPositions({\n     *   positions : Cesium.Cartesian3.fromDegreesArray([\n     *     -72.0, 40.0,\n     *     -70.0, 35.0,\n     *     -75.0, 30.0,\n     *     -70.0, 30.0,\n     *     -68.0, 40.0\n     *   ])\n     * });\n     * var geometry = Cesium.PolygonOutlineGeometry.createGeometry(polygon);\n     *\n     * @see PolygonOutlineGeometry#createGeometry\n     */\n    PolygonOutlineGeometry.fromPositions = function(options) {\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n        \n\n        var newOptions = {\n            polygonHierarchy : {\n                positions : options.positions\n            },\n            height : options.height,\n            extrudedHeight : options.extrudedHeight,\n            ellipsoid : options.ellipsoid,\n            granularity : options.granularity,\n            perPositionHeight : options.perPositionHeight,\n            arcType: options.arcType,\n            offsetAttribute : options.offsetAttribute\n        };\n        return new PolygonOutlineGeometry(newOptions);\n    };\n\n    /**\n     * Computes the geometric representation of a polygon outline, including its vertices, indices, and a bounding sphere.\n     *\n     * @param {PolygonOutlineGeometry} polygonGeometry A description of the polygon outline.\n     * @returns {Geometry|undefined} The computed vertices and indices.\n     */\n    PolygonOutlineGeometry.createGeometry = function(polygonGeometry) {\n        var ellipsoid = polygonGeometry._ellipsoid;\n        var granularity = polygonGeometry._granularity;\n        var polygonHierarchy = polygonGeometry._polygonHierarchy;\n        var perPositionHeight = polygonGeometry._perPositionHeight;\n        var arcType = polygonGeometry._arcType;\n\n        var polygons = PolygonGeometryLibrary.polygonOutlinesFromHierarchy(polygonHierarchy, !perPositionHeight, ellipsoid);\n\n        if (polygons.length === 0) {\n            return undefined;\n        }\n\n        var geometryInstance;\n        var geometries = [];\n        var minDistance = CesiumMath.chordLength(granularity, ellipsoid.maximumRadius);\n\n        var height = polygonGeometry._height;\n        var extrudedHeight = polygonGeometry._extrudedHeight;\n        var extrude = polygonGeometry._perPositionHeightExtrude || !CesiumMath.equalsEpsilon(height, extrudedHeight, 0, CesiumMath.EPSILON2);\n        var offsetValue;\n        var i;\n        if (extrude) {\n            for (i = 0; i < polygons.length; i++) {\n                geometryInstance = createGeometryFromPositionsExtruded(ellipsoid, polygons[i], minDistance, perPositionHeight, arcType);\n                geometryInstance.geometry = PolygonGeometryLibrary.scaleToGeodeticHeightExtruded(geometryInstance.geometry, height, extrudedHeight, ellipsoid, perPositionHeight);\n                if (defined(polygonGeometry._offsetAttribute)) {\n                    var size = geometryInstance.geometry.attributes.position.values.length / 3;\n                    var offsetAttribute = new Uint8Array(size);\n                    if (polygonGeometry._offsetAttribute === GeometryOffsetAttribute.TOP) {\n                        offsetAttribute = arrayFill(offsetAttribute, 1, 0, size / 2);\n                    } else {\n                        offsetValue = polygonGeometry._offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;\n                        offsetAttribute = arrayFill(offsetAttribute, offsetValue);\n                    }\n\n                    geometryInstance.geometry.attributes.applyOffset = new GeometryAttribute({\n                        componentDatatype : ComponentDatatype.UNSIGNED_BYTE,\n                        componentsPerAttribute : 1,\n                        values : offsetAttribute\n                    });\n                }\n                geometries.push(geometryInstance);\n            }\n        } else {\n            for (i = 0; i < polygons.length; i++) {\n                geometryInstance = createGeometryFromPositions(ellipsoid, polygons[i], minDistance, perPositionHeight, arcType);\n                geometryInstance.geometry.attributes.position.values = PolygonPipeline.scaleToGeodeticHeight(geometryInstance.geometry.attributes.position.values, height, ellipsoid, !perPositionHeight);\n\n                if (defined(polygonGeometry._offsetAttribute)) {\n                    var length = geometryInstance.geometry.attributes.position.values.length;\n                    var applyOffset = new Uint8Array(length / 3);\n                    offsetValue = polygonGeometry._offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;\n                    arrayFill(applyOffset, offsetValue);\n                    geometryInstance.geometry.attributes.applyOffset = new GeometryAttribute({\n                        componentDatatype : ComponentDatatype.UNSIGNED_BYTE,\n                        componentsPerAttribute : 1,\n                        values: applyOffset\n                    });\n                }\n\n                geometries.push(geometryInstance);\n            }\n        }\n\n        var geometry = GeometryPipeline.combineInstances(geometries)[0];\n        var boundingSphere = BoundingSphere.fromVertices(geometry.attributes.position.values);\n\n        return new Geometry({\n            attributes : geometry.attributes,\n            indices : geometry.indices,\n            primitiveType : geometry.primitiveType,\n            boundingSphere : boundingSphere,\n            offsetAttribute : polygonGeometry._offsetAttribute\n        });\n    };\nexport default PolygonOutlineGeometry;\n","import ApproximateTerrainHeights from '../Core/ApproximateTerrainHeights.js';\nimport ArcType from '../Core/ArcType.js';\nimport Cartesian2 from '../Core/Cartesian2.js';\nimport Cartesian3 from '../Core/Cartesian3.js';\nimport Check from '../Core/Check.js';\nimport Color from '../Core/Color.js';\nimport ColorGeometryInstanceAttribute from '../Core/ColorGeometryInstanceAttribute.js';\nimport CoplanarPolygonGeometry from '../Core/CoplanarPolygonGeometry.js';\nimport CoplanarPolygonOutlineGeometry from '../Core/CoplanarPolygonOutlineGeometry.js';\nimport defined from '../Core/defined.js';\nimport DeveloperError from '../Core/DeveloperError.js';\nimport DistanceDisplayConditionGeometryInstanceAttribute from '../Core/DistanceDisplayConditionGeometryInstanceAttribute.js';\nimport EllipsoidTangentPlane from '../Core/EllipsoidTangentPlane.js';\nimport GeometryInstance from '../Core/GeometryInstance.js';\nimport Iso8601 from '../Core/Iso8601.js';\nimport OffsetGeometryInstanceAttribute from '../Core/OffsetGeometryInstanceAttribute.js';\nimport oneTimeWarning from '../Core/oneTimeWarning.js';\nimport PolygonGeometry from '../Core/PolygonGeometry.js';\nimport PolygonOutlineGeometry from '../Core/PolygonOutlineGeometry.js';\nimport Rectangle from '../Core/Rectangle.js';\nimport ShowGeometryInstanceAttribute from '../Core/ShowGeometryInstanceAttribute.js';\nimport HeightReference from '../Scene/HeightReference.js';\nimport MaterialAppearance from '../Scene/MaterialAppearance.js';\nimport PerInstanceColorAppearance from '../Scene/PerInstanceColorAppearance.js';\nimport ColorMaterialProperty from './ColorMaterialProperty.js';\nimport DynamicGeometryUpdater from './DynamicGeometryUpdater.js';\nimport GeometryUpdater from './GeometryUpdater.js';\nimport GroundGeometryUpdater from './GroundGeometryUpdater.js';\nimport Property from './Property.js';\n\n    var heightAndPerPositionHeightWarning = 'Entity polygons cannot have both height and perPositionHeight.  height will be ignored';\n    var heightReferenceAndPerPositionHeightWarning = 'heightReference is not supported for entity polygons with perPositionHeight. heightReference will be ignored';\n\n    var scratchColor = new Color();\n    var defaultOffset = Cartesian3.ZERO;\n    var offsetScratch = new Cartesian3();\n    var scratchRectangle = new Rectangle();\n    var scratch2DPositions = [];\n    var cart2Scratch = new Cartesian2();\n\n    function PolygonGeometryOptions(entity) {\n        this.id = entity;\n        this.vertexFormat = undefined;\n        this.polygonHierarchy = undefined;\n        this.perPositionHeight = undefined;\n        this.closeTop = undefined;\n        this.closeBottom = undefined;\n        this.height = undefined;\n        this.extrudedHeight = undefined;\n        this.granularity = undefined;\n        this.stRotation = undefined;\n        this.offsetAttribute = undefined;\n        this.arcType = undefined;\n    }\n\n    /**\n     * A {@link GeometryUpdater} for polygons.\n     * Clients do not normally create this class directly, but instead rely on {@link DataSourceDisplay}.\n     * @alias PolygonGeometryUpdater\n     * @constructor\n     *\n     * @param {Entity} entity The entity containing the geometry to be visualized.\n     * @param {Scene} scene The scene where visualization is taking place.\n     */\n    function PolygonGeometryUpdater(entity, scene) {\n        GroundGeometryUpdater.call(this, {\n            entity : entity,\n            scene : scene,\n            geometryOptions : new PolygonGeometryOptions(entity),\n            geometryPropertyName : 'polygon',\n            observedPropertyNames : ['availability', 'polygon']\n        });\n\n        this._onEntityPropertyChanged(entity, 'polygon', entity.polygon, undefined);\n    }\n\n    if (defined(Object.create)) {\n        PolygonGeometryUpdater.prototype = Object.create(GroundGeometryUpdater.prototype);\n        PolygonGeometryUpdater.prototype.constructor = PolygonGeometryUpdater;\n    }\n\n    /**\n     * Creates the geometry instance which represents the fill of the geometry.\n     *\n     * @param {JulianDate} time The time to use when retrieving initial attribute values.\n     * @returns {GeometryInstance} The geometry instance representing the filled portion of the geometry.\n     *\n     * @exception {DeveloperError} This instance does not represent a filled geometry.\n     */\n    PolygonGeometryUpdater.prototype.createFillGeometryInstance = function(time) {\n        \n\n        var entity = this._entity;\n        var isAvailable = entity.isAvailable(time);\n        var options = this._options;\n\n        var attributes = {\n            show : new ShowGeometryInstanceAttribute(isAvailable && entity.isShowing && this._showProperty.getValue(time) && this._fillProperty.getValue(time)),\n            distanceDisplayCondition : DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(this._distanceDisplayConditionProperty.getValue(time)),\n            offset : undefined,\n            color : undefined\n        };\n\n        if (this._materialProperty instanceof ColorMaterialProperty) {\n            var currentColor;\n            if (defined(this._materialProperty.color) && (this._materialProperty.color.isConstant || isAvailable)) {\n                currentColor = this._materialProperty.color.getValue(time, scratchColor);\n            }\n            if (!defined(currentColor)) {\n                currentColor = Color.WHITE;\n            }\n            attributes.color = ColorGeometryInstanceAttribute.fromColor(currentColor);\n        }\n        if (defined(options.offsetAttribute)) {\n            attributes.offset = OffsetGeometryInstanceAttribute.fromCartesian3(Property.getValueOrDefault(this._terrainOffsetProperty, time, defaultOffset, offsetScratch));\n        }\n\n        var geometry;\n        if (options.perPositionHeight && !defined(options.extrudedHeight)) {\n            geometry = new CoplanarPolygonGeometry(options);\n        } else {\n            geometry = new PolygonGeometry(options);\n        }\n\n        return new GeometryInstance({\n            id : entity,\n            geometry : geometry,\n            attributes : attributes\n        });\n    };\n\n    /**\n     * Creates the geometry instance which represents the outline of the geometry.\n     *\n     * @param {JulianDate} time The time to use when retrieving initial attribute values.\n     * @returns {GeometryInstance} The geometry instance representing the outline portion of the geometry.\n     *\n     * @exception {DeveloperError} This instance does not represent an outlined geometry.\n     */\n    PolygonGeometryUpdater.prototype.createOutlineGeometryInstance = function(time) {\n        \n\n        var entity = this._entity;\n        var isAvailable = entity.isAvailable(time);\n        var options = this._options;\n        var outlineColor = Property.getValueOrDefault(this._outlineColorProperty, time, Color.BLACK, scratchColor);\n        var distanceDisplayCondition = this._distanceDisplayConditionProperty.getValue(time);\n\n        var attributes = {\n            show : new ShowGeometryInstanceAttribute(isAvailable && entity.isShowing && this._showProperty.getValue(time) && this._showOutlineProperty.getValue(time)),\n            color : ColorGeometryInstanceAttribute.fromColor(outlineColor),\n            distanceDisplayCondition : DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(distanceDisplayCondition),\n            offset : undefined\n        };\n\n        if (defined(options.offsetAttribute)) {\n            attributes.offset = OffsetGeometryInstanceAttribute.fromCartesian3(Property.getValueOrDefault(this._terrainOffsetProperty, time, defaultOffset, offsetScratch));\n        }\n\n        var geometry;\n        if (options.perPositionHeight && !defined(options.extrudedHeight)) {\n            geometry = new CoplanarPolygonOutlineGeometry(options);\n        } else {\n            geometry = new PolygonOutlineGeometry(options);\n        }\n        return new GeometryInstance({\n            id : entity,\n            geometry : geometry,\n            attributes : attributes\n        });\n    };\n\n    PolygonGeometryUpdater.prototype._computeCenter = function(time, result) {\n        var hierarchy = Property.getValueOrUndefined(this._entity.polygon.hierarchy, time);\n        if (!defined(hierarchy)) {\n            return;\n        }\n        var positions = hierarchy.positions;\n        if (positions.length === 0) {\n            return;\n        }\n        var ellipsoid = this._scene.mapProjection.ellipsoid;\n\n        var tangentPlane = EllipsoidTangentPlane.fromPoints(positions, ellipsoid);\n        var positions2D = tangentPlane.projectPointsOntoPlane(positions, scratch2DPositions);\n\n        var length = positions2D.length;\n        var area = 0;\n        var j = length - 1;\n        var centroid2D = new Cartesian2();\n        for (var i = 0; i < length; j = i++) {\n            var p1 = positions2D[i];\n            var p2 = positions2D[j];\n            var f = p1.x * p2.y - p2.x * p1.y;\n\n            var sum = Cartesian2.add(p1, p2, cart2Scratch);\n            sum = Cartesian2.multiplyByScalar(sum, f, sum);\n            centroid2D = Cartesian2.add(centroid2D, sum, centroid2D);\n\n            area += f;\n        }\n\n        var a = 1.0 / (area * 3.0);\n        centroid2D = Cartesian2.multiplyByScalar(centroid2D, a, centroid2D);\n        return tangentPlane.projectPointOntoEllipsoid(centroid2D, result);\n    };\n\n    PolygonGeometryUpdater.prototype._isHidden = function(entity, polygon) {\n        return !defined(polygon.hierarchy) || GeometryUpdater.prototype._isHidden.call(this, entity, polygon);\n    };\n\n    PolygonGeometryUpdater.prototype._isOnTerrain = function(entity, polygon) {\n        var onTerrain = GroundGeometryUpdater.prototype._isOnTerrain.call(this, entity, polygon);\n        var perPositionHeightProperty = polygon.perPositionHeight;\n        var perPositionHeightEnabled = defined(perPositionHeightProperty) && (perPositionHeightProperty.isConstant ? perPositionHeightProperty.getValue(Iso8601.MINIMUM_VALUE) : true);\n        return onTerrain && !perPositionHeightEnabled;\n    };\n\n    PolygonGeometryUpdater.prototype._isDynamic = function(entity, polygon) {\n        return !polygon.hierarchy.isConstant || //\n               !Property.isConstant(polygon.height) || //\n               !Property.isConstant(polygon.extrudedHeight) || //\n               !Property.isConstant(polygon.granularity) || //\n               !Property.isConstant(polygon.stRotation) || //\n               !Property.isConstant(polygon.outlineWidth) || //\n               !Property.isConstant(polygon.perPositionHeight) || //\n               !Property.isConstant(polygon.closeTop) || //\n               !Property.isConstant(polygon.closeBottom) || //\n               !Property.isConstant(polygon.zIndex) || //\n               !Property.isConstant(polygon.arcType) || //\n               (this._onTerrain && !Property.isConstant(this._materialProperty));\n    };\n\n    PolygonGeometryUpdater.prototype._setStaticOptions = function(entity, polygon) {\n        var isColorMaterial = this._materialProperty instanceof ColorMaterialProperty;\n\n        var options = this._options;\n        options.vertexFormat = isColorMaterial ? PerInstanceColorAppearance.VERTEX_FORMAT : MaterialAppearance.MaterialSupport.TEXTURED.vertexFormat;\n\n        var hierarchyValue = polygon.hierarchy.getValue(Iso8601.MINIMUM_VALUE);\n        var heightValue = Property.getValueOrUndefined(polygon.height, Iso8601.MINIMUM_VALUE);\n        var heightReferenceValue = Property.getValueOrDefault(polygon.heightReference, Iso8601.MINIMUM_VALUE, HeightReference.NONE);\n        var extrudedHeightValue = Property.getValueOrUndefined(polygon.extrudedHeight, Iso8601.MINIMUM_VALUE);\n        var extrudedHeightReferenceValue = Property.getValueOrDefault(polygon.extrudedHeightReference, Iso8601.MINIMUM_VALUE, HeightReference.NONE);\n        var perPositionHeightValue = Property.getValueOrDefault(polygon.perPositionHeight, Iso8601.MINIMUM_VALUE, false);\n\n        heightValue = GroundGeometryUpdater.getGeometryHeight(heightValue, heightReferenceValue);\n\n        var offsetAttribute;\n        if (perPositionHeightValue) {\n            if (defined(heightValue)) {\n                heightValue = undefined;\n                oneTimeWarning(heightAndPerPositionHeightWarning);\n            }\n            if (heightReferenceValue !== HeightReference.NONE && perPositionHeightValue) {\n                heightValue = undefined;\n                oneTimeWarning(heightReferenceAndPerPositionHeightWarning);\n            }\n        } else {\n            if (defined(extrudedHeightValue) && !defined(heightValue)) {\n                heightValue = 0;\n            }\n            offsetAttribute = GroundGeometryUpdater.computeGeometryOffsetAttribute(heightValue, heightReferenceValue, extrudedHeightValue, extrudedHeightReferenceValue);\n        }\n\n        options.polygonHierarchy = hierarchyValue;\n        options.granularity = Property.getValueOrUndefined(polygon.granularity, Iso8601.MINIMUM_VALUE);\n        options.stRotation = Property.getValueOrUndefined(polygon.stRotation, Iso8601.MINIMUM_VALUE);\n        options.perPositionHeight = perPositionHeightValue;\n        options.closeTop = Property.getValueOrDefault(polygon.closeTop, Iso8601.MINIMUM_VALUE, true);\n        options.closeBottom = Property.getValueOrDefault(polygon.closeBottom, Iso8601.MINIMUM_VALUE, true);\n        options.offsetAttribute = offsetAttribute;\n        options.height = heightValue;\n        options.arcType = Property.getValueOrDefault(polygon.arcType, Iso8601.MINIMUM_VALUE, ArcType.GEODESIC);\n\n        extrudedHeightValue = GroundGeometryUpdater.getGeometryExtrudedHeight(extrudedHeightValue, extrudedHeightReferenceValue);\n        if (extrudedHeightValue === GroundGeometryUpdater.CLAMP_TO_GROUND) {\n            extrudedHeightValue = ApproximateTerrainHeights.getMinimumMaximumHeights(PolygonGeometry.computeRectangle(options, scratchRectangle)).minimumTerrainHeight;\n        }\n\n        options.extrudedHeight = extrudedHeightValue;\n    };\n\n    PolygonGeometryUpdater.prototype._getIsClosed = function(options) {\n        var height = options.height;\n        var extrudedHeight = options.extrudedHeight;\n        var isExtruded = defined(extrudedHeight) && extrudedHeight !== height;\n        return !options.perPositionHeight && (!isExtruded && height === 0 || (isExtruded && options.closeTop && options.closeBottom));\n    };\n\n    PolygonGeometryUpdater.DynamicGeometryUpdater = DyanmicPolygonGeometryUpdater;\n\n    /**\n     * @private\n     */\n    function DyanmicPolygonGeometryUpdater(geometryUpdater, primitives, groundPrimitives) {\n        DynamicGeometryUpdater.call(this, geometryUpdater, primitives, groundPrimitives);\n    }\n\n    if (defined(Object.create)) {\n        DyanmicPolygonGeometryUpdater.prototype = Object.create(DynamicGeometryUpdater.prototype);\n        DyanmicPolygonGeometryUpdater.prototype.constructor = DyanmicPolygonGeometryUpdater;\n    }\n\n    DyanmicPolygonGeometryUpdater.prototype._isHidden = function(entity, polygon, time) {\n        return !defined(this._options.polygonHierarchy) || DynamicGeometryUpdater.prototype._isHidden.call(this, entity, polygon, time);\n    };\n\n    DyanmicPolygonGeometryUpdater.prototype._setOptions = function(entity, polygon, time) {\n        var options = this._options;\n\n        options.polygonHierarchy = Property.getValueOrUndefined(polygon.hierarchy, time);\n\n        var heightValue = Property.getValueOrUndefined(polygon.height, time);\n        var heightReferenceValue = Property.getValueOrDefault(polygon.heightReference, time, HeightReference.NONE);\n        var extrudedHeightReferenceValue = Property.getValueOrDefault(polygon.extrudedHeightReference, time, HeightReference.NONE);\n        var extrudedHeightValue = Property.getValueOrUndefined(polygon.extrudedHeight, time);\n        var perPositionHeightValue = Property.getValueOrUndefined(polygon.perPositionHeight, time);\n\n        heightValue = GroundGeometryUpdater.getGeometryHeight(heightValue, extrudedHeightReferenceValue);\n\n        var offsetAttribute;\n        if (perPositionHeightValue) {\n            if (defined(heightValue)) {\n                heightValue = undefined;\n                oneTimeWarning(heightAndPerPositionHeightWarning);\n            }\n            if (heightReferenceValue !== HeightReference.NONE && perPositionHeightValue) {\n                heightValue = undefined;\n                oneTimeWarning(heightReferenceAndPerPositionHeightWarning);\n            }\n        } else {\n            if (defined(extrudedHeightValue) && !defined(heightValue)) {\n                heightValue = 0;\n            }\n\n            offsetAttribute = GroundGeometryUpdater.computeGeometryOffsetAttribute(heightValue, heightReferenceValue, extrudedHeightValue, extrudedHeightReferenceValue);\n        }\n\n        options.granularity = Property.getValueOrUndefined(polygon.granularity, time);\n        options.stRotation = Property.getValueOrUndefined(polygon.stRotation, time);\n        options.perPositionHeight = Property.getValueOrUndefined(polygon.perPositionHeight, time);\n        options.closeTop = Property.getValueOrDefault(polygon.closeTop, time, true);\n        options.closeBottom = Property.getValueOrDefault(polygon.closeBottom, time, true);\n        options.offsetAttribute = offsetAttribute;\n        options.height = heightValue;\n        options.arcType = Property.getValueOrDefault(polygon.arcType, time, ArcType.GEODESIC);\n\n        extrudedHeightValue = GroundGeometryUpdater.getGeometryExtrudedHeight(extrudedHeightValue, extrudedHeightReferenceValue);\n        if (extrudedHeightValue === GroundGeometryUpdater.CLAMP_TO_GROUND) {\n            extrudedHeightValue = ApproximateTerrainHeights.getMinimumMaximumHeights(PolygonGeometry.computeRectangle(options, scratchRectangle)).minimumTerrainHeight;\n        }\n\n        options.extrudedHeight = extrudedHeightValue;\n    };\nexport default PolygonGeometryUpdater;\n","import arrayRemoveDuplicates from './arrayRemoveDuplicates.js';\nimport BoundingRectangle from './BoundingRectangle.js';\nimport BoundingSphere from './BoundingSphere.js';\nimport Cartesian2 from './Cartesian2.js';\nimport Cartesian3 from './Cartesian3.js';\nimport ComponentDatatype from './ComponentDatatype.js';\nimport CornerType from './CornerType.js';\nimport defaultValue from './defaultValue.js';\nimport defined from './defined.js';\nimport DeveloperError from './DeveloperError.js';\nimport Ellipsoid from './Ellipsoid.js';\nimport Geometry from './Geometry.js';\nimport GeometryAttribute from './GeometryAttribute.js';\nimport GeometryAttributes from './GeometryAttributes.js';\nimport GeometryPipeline from './GeometryPipeline.js';\nimport IndexDatatype from './IndexDatatype.js';\nimport CesiumMath from './Math.js';\nimport oneTimeWarning from './oneTimeWarning.js';\nimport PolygonPipeline from './PolygonPipeline.js';\nimport PolylineVolumeGeometryLibrary from './PolylineVolumeGeometryLibrary.js';\nimport PrimitiveType from './PrimitiveType.js';\nimport VertexFormat from './VertexFormat.js';\nimport WindingOrder from './WindingOrder.js';\n\n    function computeAttributes(combinedPositions, shape, boundingRectangle, vertexFormat) {\n        var attributes = new GeometryAttributes();\n        if (vertexFormat.position) {\n            attributes.position = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.DOUBLE,\n                componentsPerAttribute : 3,\n                values : combinedPositions\n            });\n        }\n        var shapeLength = shape.length;\n        var vertexCount = combinedPositions.length / 3;\n        var length = (vertexCount - shapeLength * 2) / (shapeLength * 2);\n        var firstEndIndices = PolygonPipeline.triangulate(shape);\n\n        var indicesCount = (length - 1) * (shapeLength) * 6 + firstEndIndices.length * 2;\n        var indices = IndexDatatype.createTypedArray(vertexCount, indicesCount);\n        var i, j;\n        var ll, ul, ur, lr;\n        var offset = shapeLength * 2;\n        var index = 0;\n        for (i = 0; i < length - 1; i++) {\n            for (j = 0; j < shapeLength - 1; j++) {\n                ll = j * 2 + i * shapeLength * 2;\n                lr = ll + offset;\n                ul = ll + 1;\n                ur = ul + offset;\n\n                indices[index++] = ul;\n                indices[index++] = ll;\n                indices[index++] = ur;\n                indices[index++] = ur;\n                indices[index++] = ll;\n                indices[index++] = lr;\n            }\n            ll = shapeLength * 2 - 2 + i * shapeLength * 2;\n            ul = ll + 1;\n            ur = ul + offset;\n            lr = ll + offset;\n\n            indices[index++] = ul;\n            indices[index++] = ll;\n            indices[index++] = ur;\n            indices[index++] = ur;\n            indices[index++] = ll;\n            indices[index++] = lr;\n        }\n\n        if (vertexFormat.st || vertexFormat.tangent || vertexFormat.bitangent) { // st required for tangent/bitangent calculation\n            var st = new Float32Array(vertexCount * 2);\n            var lengthSt = 1 / (length - 1);\n            var heightSt = 1 / (boundingRectangle.height);\n            var heightOffset = boundingRectangle.height / 2;\n            var s, t;\n            var stindex = 0;\n            for (i = 0; i < length; i++) {\n                s = i * lengthSt;\n                t = heightSt * (shape[0].y + heightOffset);\n                st[stindex++] = s;\n                st[stindex++] = t;\n                for (j = 1; j < shapeLength; j++) {\n                    t = heightSt * (shape[j].y + heightOffset);\n                    st[stindex++] = s;\n                    st[stindex++] = t;\n                    st[stindex++] = s;\n                    st[stindex++] = t;\n                }\n                t = heightSt * (shape[0].y + heightOffset);\n                st[stindex++] = s;\n                st[stindex++] = t;\n            }\n            for (j = 0; j < shapeLength; j++) {\n                s = 0;\n                t = heightSt * (shape[j].y + heightOffset);\n                st[stindex++] = s;\n                st[stindex++] = t;\n            }\n            for (j = 0; j < shapeLength; j++) {\n                s = (length - 1) * lengthSt;\n                t = heightSt * (shape[j].y + heightOffset);\n                st[stindex++] = s;\n                st[stindex++] = t;\n            }\n\n            attributes.st = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.FLOAT,\n                componentsPerAttribute : 2,\n                values : new Float32Array(st)\n            });\n        }\n\n        var endOffset = vertexCount - shapeLength * 2;\n        for (i = 0; i < firstEndIndices.length; i += 3) {\n            var v0 = firstEndIndices[i] + endOffset;\n            var v1 = firstEndIndices[i + 1] + endOffset;\n            var v2 = firstEndIndices[i + 2] + endOffset;\n\n            indices[index++] = v0;\n            indices[index++] = v1;\n            indices[index++] = v2;\n            indices[index++] = v2 + shapeLength;\n            indices[index++] = v1 + shapeLength;\n            indices[index++] = v0 + shapeLength;\n        }\n\n        var geometry = new Geometry({\n            attributes : attributes,\n            indices : indices,\n            boundingSphere : BoundingSphere.fromVertices(combinedPositions),\n            primitiveType : PrimitiveType.TRIANGLES\n        });\n\n        if (vertexFormat.normal) {\n            geometry = GeometryPipeline.computeNormal(geometry);\n        }\n\n        if (vertexFormat.tangent || vertexFormat.bitangent) {\n            try {\n                geometry = GeometryPipeline.computeTangentAndBitangent(geometry);\n            } catch (e) {\n                oneTimeWarning('polyline-volume-tangent-bitangent', 'Unable to compute tangents and bitangents for polyline volume geometry');\n                //TODO https://github.com/AnalyticalGraphicsInc/cesium/issues/3609\n            }\n\n            if (!vertexFormat.tangent) {\n                geometry.attributes.tangent = undefined;\n            }\n            if (!vertexFormat.bitangent) {\n                geometry.attributes.bitangent = undefined;\n            }\n            if (!vertexFormat.st) {\n                geometry.attributes.st = undefined;\n            }\n        }\n\n        return geometry;\n    }\n\n    /**\n     * A description of a polyline with a volume (a 2D shape extruded along a polyline).\n     *\n     * @alias PolylineVolumeGeometry\n     * @constructor\n     *\n     * @param {Object} options Object with the following properties:\n     * @param {Cartesian3[]} options.polylinePositions An array of {@link Cartesain3} positions that define the center of the polyline volume.\n     * @param {Cartesian2[]} options.shapePositions An array of {@link Cartesian2} positions that define the shape to be extruded along the polyline\n     * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid to be used as a reference.\n     * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n     * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\n     * @param {CornerType} [options.cornerType=CornerType.ROUNDED] Determines the style of the corners.\n     *\n     * @see PolylineVolumeGeometry#createGeometry\n     *\n     * @demo {@link https://sandcastle.cesium.com/index.html?src=Polyline%20Volume.html|Cesium Sandcastle Polyline Volume Demo}\n     *\n     * @example\n     * function computeCircle(radius) {\n     *   var positions = [];\n     *   for (var i = 0; i < 360; i++) {\n     *     var radians = Cesium.Math.toRadians(i);\n     *     positions.push(new Cesium.Cartesian2(radius * Math.cos(radians), radius * Math.sin(radians)));\n     *   }\n     *   return positions;\n     * }\n     *\n     * var volume = new Cesium.PolylineVolumeGeometry({\n     *   vertexFormat : Cesium.VertexFormat.POSITION_ONLY,\n     *   polylinePositions : Cesium.Cartesian3.fromDegreesArray([\n     *     -72.0, 40.0,\n     *     -70.0, 35.0\n     *   ]),\n     *   shapePositions : computeCircle(100000.0)\n     * });\n     */\n    function PolylineVolumeGeometry(options) {\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n        var positions = options.polylinePositions;\n        var shape = options.shapePositions;\n\n        \n\n        this._positions = positions;\n        this._shape = shape;\n        this._ellipsoid = Ellipsoid.clone(defaultValue(options.ellipsoid, Ellipsoid.WGS84));\n        this._cornerType = defaultValue(options.cornerType, CornerType.ROUNDED);\n        this._vertexFormat = VertexFormat.clone(defaultValue(options.vertexFormat, VertexFormat.DEFAULT));\n        this._granularity = defaultValue(options.granularity, CesiumMath.RADIANS_PER_DEGREE);\n        this._workerName = 'createPolylineVolumeGeometry';\n\n        var numComponents = 1 + positions.length * Cartesian3.packedLength;\n        numComponents += 1 + shape.length * Cartesian2.packedLength;\n\n        /**\n         * The number of elements used to pack the object into an array.\n         * @type {Number}\n         */\n        this.packedLength = numComponents + Ellipsoid.packedLength + VertexFormat.packedLength + 2;\n    }\n\n    /**\n     * Stores the provided instance into the provided array.\n     *\n     * @param {PolylineVolumeGeometry} value The value to pack.\n     * @param {Number[]} array The array to pack into.\n     * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n     *\n     * @returns {Number[]} The array that was packed into\n     */\n    PolylineVolumeGeometry.pack = function(value, array, startingIndex) {\n        \n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        var i;\n\n        var positions = value._positions;\n        var length = positions.length;\n        array[startingIndex++] = length;\n\n        for (i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {\n            Cartesian3.pack(positions[i], array, startingIndex);\n        }\n\n        var shape = value._shape;\n        length = shape.length;\n        array[startingIndex++] = length;\n\n        for (i = 0; i < length; ++i, startingIndex += Cartesian2.packedLength) {\n            Cartesian2.pack(shape[i], array, startingIndex);\n        }\n\n        Ellipsoid.pack(value._ellipsoid, array, startingIndex);\n        startingIndex += Ellipsoid.packedLength;\n\n        VertexFormat.pack(value._vertexFormat, array, startingIndex);\n        startingIndex += VertexFormat.packedLength;\n\n        array[startingIndex++] = value._cornerType;\n        array[startingIndex]   = value._granularity;\n\n        return array;\n    };\n\n    var scratchEllipsoid = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);\n    var scratchVertexFormat = new VertexFormat();\n    var scratchOptions = {\n        polylinePositions : undefined,\n        shapePositions : undefined,\n        ellipsoid : scratchEllipsoid,\n        vertexFormat : scratchVertexFormat,\n        cornerType : undefined,\n        granularity : undefined\n    };\n\n    /**\n     * Retrieves an instance from a packed array.\n     *\n     * @param {Number[]} array The packed array.\n     * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n     * @param {PolylineVolumeGeometry} [result] The object into which to store the result.\n     * @returns {PolylineVolumeGeometry} The modified result parameter or a new PolylineVolumeGeometry instance if one was not provided.\n     */\n    PolylineVolumeGeometry.unpack = function(array, startingIndex, result) {\n        \n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        var i;\n\n        var length = array[startingIndex++];\n        var positions = new Array(length);\n\n        for (i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {\n            positions[i] = Cartesian3.unpack(array, startingIndex);\n        }\n\n        length = array[startingIndex++];\n        var shape = new Array(length);\n\n        for (i = 0; i < length; ++i, startingIndex += Cartesian2.packedLength) {\n            shape[i] = Cartesian2.unpack(array, startingIndex);\n        }\n\n        var ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);\n        startingIndex += Ellipsoid.packedLength;\n\n        var vertexFormat = VertexFormat.unpack(array, startingIndex, scratchVertexFormat);\n        startingIndex += VertexFormat.packedLength;\n\n        var cornerType = array[startingIndex++];\n        var granularity = array[startingIndex];\n\n        if (!defined(result)) {\n            scratchOptions.polylinePositions = positions;\n            scratchOptions.shapePositions = shape;\n            scratchOptions.cornerType = cornerType;\n            scratchOptions.granularity = granularity;\n            return new PolylineVolumeGeometry(scratchOptions);\n        }\n\n        result._positions = positions;\n        result._shape = shape;\n        result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);\n        result._vertexFormat = VertexFormat.clone(vertexFormat, result._vertexFormat);\n        result._cornerType = cornerType;\n        result._granularity = granularity;\n\n        return result;\n    };\n\n    var brScratch = new BoundingRectangle();\n\n    /**\n     * Computes the geometric representation of a polyline with a volume, including its vertices, indices, and a bounding sphere.\n     *\n     * @param {PolylineVolumeGeometry} polylineVolumeGeometry A description of the polyline volume.\n     * @returns {Geometry|undefined} The computed vertices and indices.\n     */\n    PolylineVolumeGeometry.createGeometry = function(polylineVolumeGeometry) {\n        var positions = polylineVolumeGeometry._positions;\n        var cleanPositions = arrayRemoveDuplicates(positions, Cartesian3.equalsEpsilon);\n        var shape2D = polylineVolumeGeometry._shape;\n        shape2D = PolylineVolumeGeometryLibrary.removeDuplicatesFromShape(shape2D);\n\n        if (cleanPositions.length < 2 || shape2D.length < 3) {\n            return undefined;\n        }\n\n        if (PolygonPipeline.computeWindingOrder2D(shape2D) === WindingOrder.CLOCKWISE) {\n            shape2D.reverse();\n        }\n        var boundingRectangle = BoundingRectangle.fromPoints(shape2D, brScratch);\n\n        var computedPositions = PolylineVolumeGeometryLibrary.computePositions(cleanPositions, shape2D, boundingRectangle, polylineVolumeGeometry, true);\n        return computeAttributes(computedPositions, shape2D, boundingRectangle, polylineVolumeGeometry._vertexFormat);\n    };\nexport default PolylineVolumeGeometry;\n","import arrayRemoveDuplicates from './arrayRemoveDuplicates.js';\nimport BoundingRectangle from './BoundingRectangle.js';\nimport BoundingSphere from './BoundingSphere.js';\nimport Cartesian2 from './Cartesian2.js';\nimport Cartesian3 from './Cartesian3.js';\nimport ComponentDatatype from './ComponentDatatype.js';\nimport CornerType from './CornerType.js';\nimport defaultValue from './defaultValue.js';\nimport defined from './defined.js';\nimport DeveloperError from './DeveloperError.js';\nimport Ellipsoid from './Ellipsoid.js';\nimport Geometry from './Geometry.js';\nimport GeometryAttribute from './GeometryAttribute.js';\nimport GeometryAttributes from './GeometryAttributes.js';\nimport IndexDatatype from './IndexDatatype.js';\nimport CesiumMath from './Math.js';\nimport PolygonPipeline from './PolygonPipeline.js';\nimport PolylineVolumeGeometryLibrary from './PolylineVolumeGeometryLibrary.js';\nimport PrimitiveType from './PrimitiveType.js';\nimport WindingOrder from './WindingOrder.js';\n\n    function computeAttributes(positions, shape) {\n        var attributes = new GeometryAttributes();\n        attributes.position = new GeometryAttribute({\n            componentDatatype : ComponentDatatype.DOUBLE,\n            componentsPerAttribute : 3,\n            values : positions\n        });\n\n        var shapeLength = shape.length;\n        var vertexCount = attributes.position.values.length / 3;\n        var positionLength = positions.length / 3;\n        var shapeCount = positionLength / shapeLength;\n        var indices = IndexDatatype.createTypedArray(vertexCount, 2 * shapeLength * (shapeCount + 1));\n        var i, j;\n        var index = 0;\n        i = 0;\n        var offset = i * shapeLength;\n        for (j = 0; j < shapeLength - 1; j++) {\n            indices[index++] = j + offset;\n            indices[index++] = j + offset + 1;\n        }\n        indices[index++] = shapeLength - 1 + offset;\n        indices[index++] = offset;\n\n        i = shapeCount - 1;\n        offset = i * shapeLength;\n        for (j = 0; j < shapeLength - 1; j++) {\n            indices[index++] = j + offset;\n            indices[index++] = j + offset + 1;\n        }\n        indices[index++] = shapeLength - 1 + offset;\n        indices[index++] = offset;\n\n        for (i = 0; i < shapeCount - 1; i++) {\n            var firstOffset = shapeLength * i;\n            var secondOffset = firstOffset + shapeLength;\n            for (j = 0; j < shapeLength; j++) {\n                indices[index++] = j + firstOffset;\n                indices[index++] = j + secondOffset;\n            }\n        }\n\n        var geometry = new Geometry({\n            attributes : attributes,\n            indices : IndexDatatype.createTypedArray(vertexCount, indices),\n            boundingSphere : BoundingSphere.fromVertices(positions),\n            primitiveType : PrimitiveType.LINES\n        });\n\n        return geometry;\n    }\n\n    /**\n     * A description of a polyline with a volume (a 2D shape extruded along a polyline).\n     *\n     * @alias PolylineVolumeOutlineGeometry\n     * @constructor\n     *\n     * @param {Object} options Object with the following properties:\n     * @param {Cartesian3[]} options.polylinePositions An array of positions that define the center of the polyline volume.\n     * @param {Cartesian2[]} options.shapePositions An array of positions that define the shape to be extruded along the polyline\n     * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid to be used as a reference.\n     * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n     * @param {CornerType} [options.cornerType=CornerType.ROUNDED] Determines the style of the corners.\n     *\n     * @see PolylineVolumeOutlineGeometry#createGeometry\n     *\n     * @example\n     * function computeCircle(radius) {\n     *   var positions = [];\n     *   for (var i = 0; i < 360; i++) {\n     *     var radians = Cesium.Math.toRadians(i);\n     *     positions.push(new Cesium.Cartesian2(radius * Math.cos(radians), radius * Math.sin(radians)));\n     *   }\n     *   return positions;\n     * }\n     *\n     * var volumeOutline = new Cesium.PolylineVolumeOutlineGeometry({\n     *   polylinePositions : Cesium.Cartesian3.fromDegreesArray([\n     *     -72.0, 40.0,\n     *     -70.0, 35.0\n     *   ]),\n     *   shapePositions : computeCircle(100000.0)\n     * });\n     */\n    function PolylineVolumeOutlineGeometry(options) {\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n        var positions = options.polylinePositions;\n        var shape = options.shapePositions;\n\n        \n\n        this._positions = positions;\n        this._shape = shape;\n        this._ellipsoid = Ellipsoid.clone(defaultValue(options.ellipsoid, Ellipsoid.WGS84));\n        this._cornerType = defaultValue(options.cornerType, CornerType.ROUNDED);\n        this._granularity = defaultValue(options.granularity, CesiumMath.RADIANS_PER_DEGREE);\n        this._workerName = 'createPolylineVolumeOutlineGeometry';\n\n        var numComponents = 1 + positions.length * Cartesian3.packedLength;\n        numComponents += 1 + shape.length * Cartesian2.packedLength;\n\n        /**\n         * The number of elements used to pack the object into an array.\n         * @type {Number}\n         */\n        this.packedLength = numComponents + Ellipsoid.packedLength + 2;\n    }\n\n    /**\n     * Stores the provided instance into the provided array.\n     *\n     * @param {PolylineVolumeOutlineGeometry} value The value to pack.\n     * @param {Number[]} array The array to pack into.\n     * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n     *\n     * @returns {Number[]} The array that was packed into\n     */\n    PolylineVolumeOutlineGeometry.pack = function(value, array, startingIndex) {\n        \n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        var i;\n\n        var positions = value._positions;\n        var length = positions.length;\n        array[startingIndex++] = length;\n\n        for (i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {\n            Cartesian3.pack(positions[i], array, startingIndex);\n        }\n\n        var shape = value._shape;\n        length = shape.length;\n        array[startingIndex++] = length;\n\n        for (i = 0; i < length; ++i, startingIndex += Cartesian2.packedLength) {\n            Cartesian2.pack(shape[i], array, startingIndex);\n        }\n\n        Ellipsoid.pack(value._ellipsoid, array, startingIndex);\n        startingIndex += Ellipsoid.packedLength;\n\n        array[startingIndex++] = value._cornerType;\n        array[startingIndex]   = value._granularity;\n\n        return array;\n    };\n\n    var scratchEllipsoid = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);\n    var scratchOptions = {\n        polylinePositions : undefined,\n        shapePositions : undefined,\n        ellipsoid : scratchEllipsoid,\n        height : undefined,\n        cornerType : undefined,\n        granularity : undefined\n    };\n\n    /**\n     * Retrieves an instance from a packed array.\n     *\n     * @param {Number[]} array The packed array.\n     * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n     * @param {PolylineVolumeOutlineGeometry} [result] The object into which to store the result.\n     * @returns {PolylineVolumeOutlineGeometry} The modified result parameter or a new PolylineVolumeOutlineGeometry instance if one was not provided.\n     */\n    PolylineVolumeOutlineGeometry.unpack = function(array, startingIndex, result) {\n        \n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        var i;\n\n        var length = array[startingIndex++];\n        var positions = new Array(length);\n\n        for (i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {\n            positions[i] = Cartesian3.unpack(array, startingIndex);\n        }\n\n        length = array[startingIndex++];\n        var shape = new Array(length);\n\n        for (i = 0; i < length; ++i, startingIndex += Cartesian2.packedLength) {\n            shape[i] = Cartesian2.unpack(array, startingIndex);\n        }\n\n        var ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);\n        startingIndex += Ellipsoid.packedLength;\n\n        var cornerType = array[startingIndex++];\n        var granularity = array[startingIndex];\n\n        if (!defined(result)) {\n            scratchOptions.polylinePositions = positions;\n            scratchOptions.shapePositions = shape;\n            scratchOptions.cornerType = cornerType;\n            scratchOptions.granularity = granularity;\n            return new PolylineVolumeOutlineGeometry(scratchOptions);\n        }\n\n        result._positions = positions;\n        result._shape = shape;\n        result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);\n        result._cornerType = cornerType;\n        result._granularity = granularity;\n\n        return result;\n    };\n\n    var brScratch = new BoundingRectangle();\n\n    /**\n     * Computes the geometric representation of the outline of a polyline with a volume, including its vertices, indices, and a bounding sphere.\n     *\n     * @param {PolylineVolumeOutlineGeometry} polylineVolumeOutlineGeometry A description of the polyline volume outline.\n     * @returns {Geometry|undefined} The computed vertices and indices.\n     */\n    PolylineVolumeOutlineGeometry.createGeometry = function(polylineVolumeOutlineGeometry) {\n        var positions = polylineVolumeOutlineGeometry._positions;\n        var cleanPositions = arrayRemoveDuplicates(positions, Cartesian3.equalsEpsilon);\n        var shape2D = polylineVolumeOutlineGeometry._shape;\n        shape2D = PolylineVolumeGeometryLibrary.removeDuplicatesFromShape(shape2D);\n\n        if (cleanPositions.length < 2 || shape2D.length < 3) {\n            return undefined;\n        }\n\n        if (PolygonPipeline.computeWindingOrder2D(shape2D) === WindingOrder.CLOCKWISE) {\n            shape2D.reverse();\n        }\n        var boundingRectangle = BoundingRectangle.fromPoints(shape2D, brScratch);\n\n        var computedPositions = PolylineVolumeGeometryLibrary.computePositions(cleanPositions, shape2D, boundingRectangle, polylineVolumeOutlineGeometry, false);\n        return computeAttributes(computedPositions, shape2D);\n    };\nexport default PolylineVolumeOutlineGeometry;\n","import Check from '../Core/Check.js';\nimport Color from '../Core/Color.js';\nimport ColorGeometryInstanceAttribute from '../Core/ColorGeometryInstanceAttribute.js';\nimport defined from '../Core/defined.js';\nimport DeveloperError from '../Core/DeveloperError.js';\nimport DistanceDisplayConditionGeometryInstanceAttribute from '../Core/DistanceDisplayConditionGeometryInstanceAttribute.js';\nimport GeometryInstance from '../Core/GeometryInstance.js';\nimport Iso8601 from '../Core/Iso8601.js';\nimport PolylineVolumeGeometry from '../Core/PolylineVolumeGeometry.js';\nimport PolylineVolumeOutlineGeometry from '../Core/PolylineVolumeOutlineGeometry.js';\nimport ShowGeometryInstanceAttribute from '../Core/ShowGeometryInstanceAttribute.js';\nimport MaterialAppearance from '../Scene/MaterialAppearance.js';\nimport PerInstanceColorAppearance from '../Scene/PerInstanceColorAppearance.js';\nimport ColorMaterialProperty from './ColorMaterialProperty.js';\nimport DynamicGeometryUpdater from './DynamicGeometryUpdater.js';\nimport GeometryUpdater from './GeometryUpdater.js';\nimport Property from './Property.js';\n\n    var scratchColor = new Color();\n\n    function PolylineVolumeGeometryOptions(entity) {\n        this.id = entity;\n        this.vertexFormat = undefined;\n        this.polylinePositions = undefined;\n        this.shapePositions = undefined;\n        this.cornerType = undefined;\n        this.granularity = undefined;\n    }\n\n    /**\n     * A {@link GeometryUpdater} for polyline volumes.\n     * Clients do not normally create this class directly, but instead rely on {@link DataSourceDisplay}.\n     * @alias PolylineVolumeGeometryUpdater\n     * @constructor\n     *\n     * @param {Entity} entity The entity containing the geometry to be visualized.\n     * @param {Scene} scene The scene where visualization is taking place.\n     */\n    function PolylineVolumeGeometryUpdater(entity, scene) {\n        GeometryUpdater.call(this, {\n            entity : entity,\n            scene : scene,\n            geometryOptions : new PolylineVolumeGeometryOptions(entity),\n            geometryPropertyName : 'polylineVolume',\n            observedPropertyNames : ['availability', 'polylineVolume']\n        });\n\n        this._onEntityPropertyChanged(entity, 'polylineVolume', entity.polylineVolume, undefined);\n    }\n\n    if (defined(Object.create)) {\n        PolylineVolumeGeometryUpdater.prototype = Object.create(GeometryUpdater.prototype);\n        PolylineVolumeGeometryUpdater.prototype.constructor = PolylineVolumeGeometryUpdater;\n    }\n\n    /**\n     * Creates the geometry instance which represents the fill of the geometry.\n     *\n     * @param {JulianDate} time The time to use when retrieving initial attribute values.\n     * @returns {GeometryInstance} The geometry instance representing the filled portion of the geometry.\n     *\n     * @exception {DeveloperError} This instance does not represent a filled geometry.\n     */\n    PolylineVolumeGeometryUpdater.prototype.createFillGeometryInstance = function(time) {\n        \n\n        var entity = this._entity;\n        var isAvailable = entity.isAvailable(time);\n\n        var attributes;\n\n        var color;\n        var show = new ShowGeometryInstanceAttribute(isAvailable && entity.isShowing && this._showProperty.getValue(time) && this._fillProperty.getValue(time));\n        var distanceDisplayCondition = this._distanceDisplayConditionProperty.getValue(time);\n        var distanceDisplayConditionAttribute = DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(distanceDisplayCondition);\n        if (this._materialProperty instanceof ColorMaterialProperty) {\n            var currentColor;\n            if (defined(this._materialProperty.color) && (this._materialProperty.color.isConstant || isAvailable)) {\n                currentColor = this._materialProperty.color.getValue(time, scratchColor);\n            }\n            if (!defined(currentColor)) {\n                currentColor = Color.WHITE;\n            }\n            color = ColorGeometryInstanceAttribute.fromColor(currentColor);\n            attributes = {\n                show : show,\n                distanceDisplayCondition : distanceDisplayConditionAttribute,\n                color : color\n            };\n        } else {\n            attributes = {\n                show : show,\n                distanceDisplayCondition : distanceDisplayConditionAttribute\n            };\n        }\n\n        return new GeometryInstance({\n            id : entity,\n            geometry : new PolylineVolumeGeometry(this._options),\n            attributes : attributes\n        });\n    };\n\n    /**\n     * Creates the geometry instance which represents the outline of the geometry.\n     *\n     * @param {JulianDate} time The time to use when retrieving initial attribute values.\n     * @returns {GeometryInstance} The geometry instance representing the outline portion of the geometry.\n     *\n     * @exception {DeveloperError} This instance does not represent an outlined geometry.\n     */\n    PolylineVolumeGeometryUpdater.prototype.createOutlineGeometryInstance = function(time) {\n        \n\n        var entity = this._entity;\n        var isAvailable = entity.isAvailable(time);\n        var outlineColor = Property.getValueOrDefault(this._outlineColorProperty, time, Color.BLACK, scratchColor);\n        var distanceDisplayCondition = this._distanceDisplayConditionProperty.getValue(time);\n\n        return new GeometryInstance({\n            id : entity,\n            geometry : new PolylineVolumeOutlineGeometry(this._options),\n            attributes : {\n                show : new ShowGeometryInstanceAttribute(isAvailable && entity.isShowing && this._showProperty.getValue(time) && this._showOutlineProperty.getValue(time)),\n                color : ColorGeometryInstanceAttribute.fromColor(outlineColor),\n                distanceDisplayCondition : DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(distanceDisplayCondition)\n            }\n        });\n    };\n\n    PolylineVolumeGeometryUpdater.prototype._isHidden = function(entity, polylineVolume) {\n        return !defined(polylineVolume.positions) || !defined(polylineVolume.shape) || GeometryUpdater.prototype._isHidden.call(this, entity, polylineVolume);\n    };\n\n    PolylineVolumeGeometryUpdater.prototype._isDynamic = function(entity, polylineVolume) {\n        return !polylineVolume.positions.isConstant || //\n               !polylineVolume.shape.isConstant || //\n               !Property.isConstant(polylineVolume.granularity) || //\n               !Property.isConstant(polylineVolume.outlineWidth) || //\n               !Property.isConstant(polylineVolume.cornerType);\n    };\n\n    PolylineVolumeGeometryUpdater.prototype._setStaticOptions = function(entity, polylineVolume) {\n        var granularity = polylineVolume.granularity;\n        var cornerType = polylineVolume.cornerType;\n\n        var options = this._options;\n        var isColorMaterial = this._materialProperty instanceof ColorMaterialProperty;\n        options.vertexFormat = isColorMaterial ? PerInstanceColorAppearance.VERTEX_FORMAT : MaterialAppearance.MaterialSupport.TEXTURED.vertexFormat;\n        options.polylinePositions = polylineVolume.positions.getValue(Iso8601.MINIMUM_VALUE, options.polylinePositions);\n        options.shapePositions = polylineVolume.shape.getValue(Iso8601.MINIMUM_VALUE, options.shape);\n        options.granularity = defined(granularity) ? granularity.getValue(Iso8601.MINIMUM_VALUE) : undefined;\n        options.cornerType = defined(cornerType) ? cornerType.getValue(Iso8601.MINIMUM_VALUE) : undefined;\n    };\n\n    PolylineVolumeGeometryUpdater.DynamicGeometryUpdater = DynamicPolylineVolumeGeometryUpdater;\n\n    /**\n     * @private\n     */\n    function DynamicPolylineVolumeGeometryUpdater(geometryUpdater, primitives, groundPrimitives) {\n        DynamicGeometryUpdater.call(this, geometryUpdater, primitives, groundPrimitives);\n    }\n\n    if (defined(Object.create)) {\n        DynamicPolylineVolumeGeometryUpdater.prototype = Object.create(DynamicGeometryUpdater.prototype);\n        DynamicPolylineVolumeGeometryUpdater.prototype.constructor = DynamicPolylineVolumeGeometryUpdater;\n    }\n\n    DynamicPolylineVolumeGeometryUpdater.prototype._isHidden = function(entity, polylineVolume, time) {\n        var options = this._options;\n        return !defined(options.polylinePositions) || !defined(options.shapePositions) || DynamicGeometryUpdater.prototype._isHidden.call(this, entity, polylineVolume, time);\n    };\n\n    DynamicPolylineVolumeGeometryUpdater.prototype._setOptions = function(entity, polylineVolume, time) {\n        var options = this._options;\n        options.polylinePositions = Property.getValueOrUndefined(polylineVolume.positions, time, options.polylinePositions);\n        options.shapePositions = Property.getValueOrUndefined(polylineVolume.shape, time);\n        options.granularity = Property.getValueOrUndefined(polylineVolume.granularity, time);\n        options.cornerType = Property.getValueOrUndefined(polylineVolume.cornerType, time);\n    };\nexport default PolylineVolumeGeometryUpdater;\n","import arrayFill from './arrayFill.js';\nimport BoundingSphere from './BoundingSphere.js';\nimport Cartesian2 from './Cartesian2.js';\nimport Cartesian3 from './Cartesian3.js';\nimport Cartographic from './Cartographic.js';\nimport Check from './Check.js';\nimport ComponentDatatype from './ComponentDatatype.js';\nimport defaultValue from './defaultValue.js';\nimport defined from './defined.js';\nimport defineProperties from './defineProperties.js';\nimport DeveloperError from './DeveloperError.js';\nimport Ellipsoid from './Ellipsoid.js';\nimport Geometry from './Geometry.js';\nimport GeometryAttribute from './GeometryAttribute.js';\nimport GeometryAttributes from './GeometryAttributes.js';\nimport GeometryInstance from './GeometryInstance.js';\nimport GeometryOffsetAttribute from './GeometryOffsetAttribute.js';\nimport GeometryPipeline from './GeometryPipeline.js';\nimport IndexDatatype from './IndexDatatype.js';\nimport CesiumMath from './Math.js';\nimport Matrix2 from './Matrix2.js';\nimport Matrix3 from './Matrix3.js';\nimport PolygonPipeline from './PolygonPipeline.js';\nimport PrimitiveType from './PrimitiveType.js';\nimport Quaternion from './Quaternion.js';\nimport Rectangle from './Rectangle.js';\nimport RectangleGeometryLibrary from './RectangleGeometryLibrary.js';\nimport VertexFormat from './VertexFormat.js';\n\n    var positionScratch = new Cartesian3();\n    var normalScratch = new Cartesian3();\n    var tangentScratch = new Cartesian3();\n    var bitangentScratch = new Cartesian3();\n    var rectangleScratch = new Rectangle();\n    var stScratch = new Cartesian2();\n    var bottomBoundingSphere = new BoundingSphere();\n    var topBoundingSphere = new BoundingSphere();\n\n    function createAttributes(vertexFormat, attributes) {\n        var geo = new Geometry({\n            attributes : new GeometryAttributes(),\n            primitiveType : PrimitiveType.TRIANGLES\n        });\n\n        geo.attributes.position = new GeometryAttribute({\n            componentDatatype : ComponentDatatype.DOUBLE,\n            componentsPerAttribute : 3,\n            values : attributes.positions\n        });\n        if (vertexFormat.normal) {\n            geo.attributes.normal = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.FLOAT,\n                componentsPerAttribute : 3,\n                values : attributes.normals\n            });\n        }\n        if (vertexFormat.tangent) {\n            geo.attributes.tangent = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.FLOAT,\n                componentsPerAttribute : 3,\n                values : attributes.tangents\n            });\n        }\n        if (vertexFormat.bitangent) {\n            geo.attributes.bitangent = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.FLOAT,\n                componentsPerAttribute : 3,\n                values : attributes.bitangents\n            });\n        }\n        return geo;\n    }\n\n    function calculateAttributes(positions, vertexFormat, ellipsoid, tangentRotationMatrix) {\n        var length = positions.length;\n\n        var normals = (vertexFormat.normal) ? new Float32Array(length) : undefined;\n        var tangents = (vertexFormat.tangent) ? new Float32Array(length) : undefined;\n        var bitangents = (vertexFormat.bitangent) ? new Float32Array(length) : undefined;\n\n        var attrIndex = 0;\n        var bitangent = bitangentScratch;\n        var tangent = tangentScratch;\n        var normal = normalScratch;\n        if (vertexFormat.normal || vertexFormat.tangent || vertexFormat.bitangent) {\n            for (var i = 0; i < length; i += 3) {\n                var p = Cartesian3.fromArray(positions, i, positionScratch);\n                var attrIndex1 = attrIndex + 1;\n                var attrIndex2 = attrIndex + 2;\n\n                normal = ellipsoid.geodeticSurfaceNormal(p, normal);\n                if (vertexFormat.tangent || vertexFormat.bitangent) {\n                    Cartesian3.cross(Cartesian3.UNIT_Z, normal, tangent);\n                    Matrix3.multiplyByVector(tangentRotationMatrix, tangent, tangent);\n                    Cartesian3.normalize(tangent, tangent);\n\n                    if (vertexFormat.bitangent) {\n                        Cartesian3.normalize(Cartesian3.cross(normal, tangent, bitangent), bitangent);\n                    }\n                }\n\n                if (vertexFormat.normal) {\n                    normals[attrIndex] = normal.x;\n                    normals[attrIndex1] = normal.y;\n                    normals[attrIndex2] = normal.z;\n                }\n                if (vertexFormat.tangent) {\n                    tangents[attrIndex] = tangent.x;\n                    tangents[attrIndex1] = tangent.y;\n                    tangents[attrIndex2] = tangent.z;\n                }\n                if (vertexFormat.bitangent) {\n                    bitangents[attrIndex] = bitangent.x;\n                    bitangents[attrIndex1] = bitangent.y;\n                    bitangents[attrIndex2] = bitangent.z;\n                }\n                attrIndex += 3;\n            }\n        }\n        return createAttributes(vertexFormat, {\n            positions : positions,\n            normals : normals,\n            tangents : tangents,\n            bitangents : bitangents\n        });\n    }\n\n    var v1Scratch = new Cartesian3();\n    var v2Scratch = new Cartesian3();\n\n    function calculateAttributesWall(positions, vertexFormat, ellipsoid) {\n        var length = positions.length;\n\n        var normals = (vertexFormat.normal) ? new Float32Array(length) : undefined;\n        var tangents = (vertexFormat.tangent) ? new Float32Array(length) : undefined;\n        var bitangents = (vertexFormat.bitangent) ? new Float32Array(length) : undefined;\n\n        var normalIndex = 0;\n        var tangentIndex = 0;\n        var bitangentIndex = 0;\n        var recomputeNormal = true;\n\n        var bitangent = bitangentScratch;\n        var tangent = tangentScratch;\n        var normal = normalScratch;\n        if (vertexFormat.normal || vertexFormat.tangent || vertexFormat.bitangent) {\n            for (var i = 0; i < length; i += 6) {\n                var p = Cartesian3.fromArray(positions, i, positionScratch);\n                var p1 = Cartesian3.fromArray(positions, (i + 6) % length, v1Scratch);\n                if (recomputeNormal) {\n                    var p2 = Cartesian3.fromArray(positions, (i + 3) % length, v2Scratch);\n                    Cartesian3.subtract(p1, p, p1);\n                    Cartesian3.subtract(p2, p, p2);\n                    normal = Cartesian3.normalize(Cartesian3.cross(p2, p1, normal), normal);\n                    recomputeNormal = false;\n                }\n\n                if (Cartesian3.equalsEpsilon(p1, p, CesiumMath.EPSILON10)) { // if we've reached a corner\n                    recomputeNormal = true;\n                }\n\n                if (vertexFormat.tangent || vertexFormat.bitangent) {\n                    bitangent = ellipsoid.geodeticSurfaceNormal(p, bitangent);\n                    if (vertexFormat.tangent) {\n                        tangent = Cartesian3.normalize(Cartesian3.cross(bitangent, normal, tangent), tangent);\n                    }\n                }\n\n                if (vertexFormat.normal) {\n                    normals[normalIndex++] = normal.x;\n                    normals[normalIndex++] = normal.y;\n                    normals[normalIndex++] = normal.z;\n                    normals[normalIndex++] = normal.x;\n                    normals[normalIndex++] = normal.y;\n                    normals[normalIndex++] = normal.z;\n                }\n\n                if (vertexFormat.tangent) {\n                    tangents[tangentIndex++] = tangent.x;\n                    tangents[tangentIndex++] = tangent.y;\n                    tangents[tangentIndex++] = tangent.z;\n                    tangents[tangentIndex++] = tangent.x;\n                    tangents[tangentIndex++] = tangent.y;\n                    tangents[tangentIndex++] = tangent.z;\n                }\n\n                if (vertexFormat.bitangent) {\n                    bitangents[bitangentIndex++] = bitangent.x;\n                    bitangents[bitangentIndex++] = bitangent.y;\n                    bitangents[bitangentIndex++] = bitangent.z;\n                    bitangents[bitangentIndex++] = bitangent.x;\n                    bitangents[bitangentIndex++] = bitangent.y;\n                    bitangents[bitangentIndex++] = bitangent.z;\n                }\n            }\n        }\n\n        return createAttributes(vertexFormat, {\n            positions : positions,\n            normals : normals,\n            tangents : tangents,\n            bitangents : bitangents\n        });\n    }\n\n    function constructRectangle(rectangleGeometry, computedOptions) {\n        var vertexFormat = rectangleGeometry._vertexFormat;\n        var ellipsoid = rectangleGeometry._ellipsoid;\n        var height = computedOptions.height;\n        var width = computedOptions.width;\n        var northCap = computedOptions.northCap;\n        var southCap = computedOptions.southCap;\n\n        var rowStart = 0;\n        var rowEnd = height;\n        var rowHeight = height;\n        var size = 0;\n        if (northCap) {\n            rowStart = 1;\n            rowHeight -= 1;\n            size += 1;\n        }\n        if (southCap) {\n            rowEnd -= 1;\n            rowHeight -= 1;\n            size += 1;\n        }\n        size += (width * rowHeight);\n\n        var positions = (vertexFormat.position) ? new Float64Array(size * 3) : undefined;\n        var textureCoordinates = (vertexFormat.st) ? new Float32Array(size * 2) : undefined;\n\n        var posIndex = 0;\n        var stIndex = 0;\n\n        var position = positionScratch;\n        var st = stScratch;\n\n        var minX = Number.MAX_VALUE;\n        var minY = Number.MAX_VALUE;\n        var maxX = -Number.MAX_VALUE;\n        var maxY = -Number.MAX_VALUE;\n\n        for (var row = rowStart; row < rowEnd; ++row) {\n            for (var col = 0; col < width; ++col) {\n                RectangleGeometryLibrary.computePosition(computedOptions, ellipsoid, vertexFormat.st, row, col, position, st);\n\n                positions[posIndex++] = position.x;\n                positions[posIndex++] = position.y;\n                positions[posIndex++] = position.z;\n\n                if (vertexFormat.st) {\n                    textureCoordinates[stIndex++] = st.x;\n                    textureCoordinates[stIndex++] = st.y;\n\n                    minX = Math.min(minX, st.x);\n                    minY = Math.min(minY, st.y);\n                    maxX = Math.max(maxX, st.x);\n                    maxY = Math.max(maxY, st.y);\n                }\n            }\n        }\n        if (northCap) {\n            RectangleGeometryLibrary.computePosition(computedOptions, ellipsoid, vertexFormat.st, 0, 0, position, st);\n\n            positions[posIndex++] = position.x;\n            positions[posIndex++] = position.y;\n            positions[posIndex++] = position.z;\n\n            if (vertexFormat.st) {\n                textureCoordinates[stIndex++] = st.x;\n                textureCoordinates[stIndex++] = st.y;\n\n                minX = st.x;\n                minY = st.y;\n                maxX = st.x;\n                maxY = st.y;\n            }\n        }\n        if (southCap) {\n            RectangleGeometryLibrary.computePosition(computedOptions, ellipsoid, vertexFormat.st, height - 1, 0, position, st);\n\n            positions[posIndex++] = position.x;\n            positions[posIndex++] = position.y;\n            positions[posIndex] = position.z;\n\n            if (vertexFormat.st) {\n                textureCoordinates[stIndex++] = st.x;\n                textureCoordinates[stIndex] = st.y;\n\n                minX = Math.min(minX, st.x);\n                minY = Math.min(minY, st.y);\n                maxX = Math.max(maxX, st.x);\n                maxY = Math.max(maxY, st.y);\n            }\n        }\n\n        if (vertexFormat.st && (minX < 0.0 || minY < 0.0 || maxX > 1.0 || maxY > 1.0)) {\n            for (var k = 0; k < textureCoordinates.length; k += 2) {\n                textureCoordinates[k] = (textureCoordinates[k] - minX) / (maxX - minX);\n                textureCoordinates[k + 1] = (textureCoordinates[k + 1] - minY) / (maxY - minY);\n            }\n        }\n\n        var geo = calculateAttributes(positions, vertexFormat, ellipsoid, computedOptions.tangentRotationMatrix);\n\n        var indicesSize = 6 * (width - 1) * (rowHeight - 1);\n        if (northCap) {\n            indicesSize += 3 * (width - 1);\n        }\n        if (southCap) {\n            indicesSize += 3 * (width - 1);\n        }\n        var indices = IndexDatatype.createTypedArray(size, indicesSize);\n        var index = 0;\n        var indicesIndex = 0;\n        var i;\n        for (i = 0; i < rowHeight - 1; ++i) {\n            for (var j = 0; j < width - 1; ++j) {\n                var upperLeft = index;\n                var lowerLeft = upperLeft + width;\n                var lowerRight = lowerLeft + 1;\n                var upperRight = upperLeft + 1;\n                indices[indicesIndex++] = upperLeft;\n                indices[indicesIndex++] = lowerLeft;\n                indices[indicesIndex++] = upperRight;\n                indices[indicesIndex++] = upperRight;\n                indices[indicesIndex++] = lowerLeft;\n                indices[indicesIndex++] = lowerRight;\n                ++index;\n            }\n            ++index;\n        }\n        if (northCap || southCap) {\n            var northIndex = size - 1;\n            var southIndex = size - 1;\n            if (northCap && southCap) {\n                northIndex = size - 2;\n            }\n\n            var p1;\n            var p2;\n            index = 0;\n\n            if (northCap) {\n                for (i = 0; i < width - 1; i++) {\n                    p1 = index;\n                    p2 = p1 + 1;\n                    indices[indicesIndex++] = northIndex;\n                    indices[indicesIndex++] = p1;\n                    indices[indicesIndex++] = p2;\n                    ++index;\n                }\n            }\n            if (southCap) {\n                index = (rowHeight - 1) * (width);\n                for (i = 0; i < width - 1; i++) {\n                    p1 = index;\n                    p2 = p1 + 1;\n                    indices[indicesIndex++] = p1;\n                    indices[indicesIndex++] = southIndex;\n                    indices[indicesIndex++] = p2;\n                    ++index;\n                }\n            }\n        }\n\n        geo.indices = indices;\n        if (vertexFormat.st) {\n            geo.attributes.st = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.FLOAT,\n                componentsPerAttribute : 2,\n                values : textureCoordinates\n            });\n        }\n\n        return geo;\n    }\n\n    function addWallPositions(wallPositions, posIndex, i, topPositions, bottomPositions) {\n        wallPositions[posIndex++] = topPositions[i];\n        wallPositions[posIndex++] = topPositions[i + 1];\n        wallPositions[posIndex++] = topPositions[i + 2];\n        wallPositions[posIndex++] = bottomPositions[i];\n        wallPositions[posIndex++] = bottomPositions[i + 1];\n        wallPositions[posIndex] = bottomPositions[i + 2];\n        return wallPositions;\n    }\n\n    function addWallTextureCoordinates(wallTextures, stIndex, i, st) {\n        wallTextures[stIndex++] = st[i];\n        wallTextures[stIndex++] = st[i + 1];\n        wallTextures[stIndex++] = st[i];\n        wallTextures[stIndex] = st[i + 1];\n        return wallTextures;\n    }\n\n    var scratchVertexFormat = new VertexFormat();\n\n    function constructExtrudedRectangle(rectangleGeometry, computedOptions) {\n        var shadowVolume = rectangleGeometry._shadowVolume;\n        var offsetAttributeValue = rectangleGeometry._offsetAttribute;\n        var vertexFormat = rectangleGeometry._vertexFormat;\n        var minHeight = rectangleGeometry._extrudedHeight;\n        var maxHeight = rectangleGeometry._surfaceHeight;\n        var ellipsoid = rectangleGeometry._ellipsoid;\n\n        var height = computedOptions.height;\n        var width = computedOptions.width;\n\n        var i;\n\n        if (shadowVolume) {\n            var newVertexFormat = VertexFormat.clone(vertexFormat, scratchVertexFormat);\n            newVertexFormat.normal = true;\n            rectangleGeometry._vertexFormat = newVertexFormat;\n        }\n\n        var topBottomGeo = constructRectangle(rectangleGeometry, computedOptions);\n\n        if (shadowVolume) {\n            rectangleGeometry._vertexFormat = vertexFormat;\n        }\n\n        var topPositions = PolygonPipeline.scaleToGeodeticHeight(topBottomGeo.attributes.position.values, maxHeight, ellipsoid, false);\n        topPositions = new Float64Array(topPositions);\n        var length = topPositions.length;\n        var newLength = length * 2;\n        var positions = new Float64Array(newLength);\n        positions.set(topPositions);\n        var bottomPositions = PolygonPipeline.scaleToGeodeticHeight(topBottomGeo.attributes.position.values, minHeight, ellipsoid);\n        positions.set(bottomPositions, length);\n        topBottomGeo.attributes.position.values = positions;\n\n        var normals = (vertexFormat.normal) ? new Float32Array(newLength) : undefined;\n        var tangents = (vertexFormat.tangent) ? new Float32Array(newLength) : undefined;\n        var bitangents = (vertexFormat.bitangent) ? new Float32Array(newLength) : undefined;\n        var textures = (vertexFormat.st) ? new Float32Array(newLength / 3 * 2) : undefined;\n        var topSt;\n        var topNormals;\n        if (vertexFormat.normal) {\n            topNormals = topBottomGeo.attributes.normal.values;\n            normals.set(topNormals);\n            for (i = 0; i < length; i++) {\n                topNormals[i] = -topNormals[i];\n            }\n            normals.set(topNormals, length);\n            topBottomGeo.attributes.normal.values = normals;\n        }\n        if (shadowVolume) {\n            topNormals = topBottomGeo.attributes.normal.values;\n            if (!vertexFormat.normal) {\n                topBottomGeo.attributes.normal = undefined;\n            }\n            var extrudeNormals = new Float32Array(newLength);\n            for (i = 0; i < length; i++) {\n                topNormals[i] = -topNormals[i];\n            }\n            extrudeNormals.set(topNormals, length); //only get normals for bottom layer that's going to be pushed down\n            topBottomGeo.attributes.extrudeDirection = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.FLOAT,\n                componentsPerAttribute : 3,\n                values : extrudeNormals\n            });\n        }\n\n        var offsetValue;\n        var hasOffsets = defined(offsetAttributeValue);\n        if (hasOffsets) {\n            var size = length / 3 * 2;\n            var offsetAttribute = new Uint8Array(size);\n            if (offsetAttributeValue === GeometryOffsetAttribute.TOP) {\n                offsetAttribute = arrayFill(offsetAttribute, 1, 0, size / 2);\n            } else {\n                offsetValue = offsetAttributeValue === GeometryOffsetAttribute.NONE ? 0 : 1;\n                offsetAttribute = arrayFill(offsetAttribute, offsetValue);\n            }\n\n            topBottomGeo.attributes.applyOffset = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.UNSIGNED_BYTE,\n                componentsPerAttribute : 1,\n                values : offsetAttribute\n            });\n        }\n\n        if (vertexFormat.tangent) {\n            var topTangents = topBottomGeo.attributes.tangent.values;\n            tangents.set(topTangents);\n            for (i = 0; i < length; i++) {\n                topTangents[i] = -topTangents[i];\n            }\n            tangents.set(topTangents, length);\n            topBottomGeo.attributes.tangent.values = tangents;\n        }\n        if (vertexFormat.bitangent) {\n            var topBitangents = topBottomGeo.attributes.bitangent.values;\n            bitangents.set(topBitangents);\n            bitangents.set(topBitangents, length);\n            topBottomGeo.attributes.bitangent.values = bitangents;\n        }\n        if (vertexFormat.st) {\n            topSt = topBottomGeo.attributes.st.values;\n            textures.set(topSt);\n            textures.set(topSt, length / 3 * 2);\n            topBottomGeo.attributes.st.values = textures;\n        }\n\n        var indices = topBottomGeo.indices;\n        var indicesLength = indices.length;\n        var posLength = length / 3;\n        var newIndices = IndexDatatype.createTypedArray(newLength / 3, indicesLength * 2);\n        newIndices.set(indices);\n        for (i = 0; i < indicesLength; i += 3) {\n            newIndices[i + indicesLength] = indices[i + 2] + posLength;\n            newIndices[i + 1 + indicesLength] = indices[i + 1] + posLength;\n            newIndices[i + 2 + indicesLength] = indices[i] + posLength;\n        }\n        topBottomGeo.indices = newIndices;\n\n        var northCap = computedOptions.northCap;\n        var southCap = computedOptions.southCap;\n\n        var rowHeight = height;\n        var widthMultiplier = 2;\n        var perimeterPositions = 0;\n        var corners = 4;\n        var dupliateCorners = 4;\n        if (northCap) {\n            widthMultiplier -= 1;\n            rowHeight -= 1;\n            perimeterPositions += 1;\n            corners -= 2;\n            dupliateCorners -= 1;\n        }\n        if (southCap) {\n            widthMultiplier -= 1;\n            rowHeight -= 1;\n            perimeterPositions += 1;\n            corners -= 2;\n            dupliateCorners -= 1;\n        }\n        perimeterPositions += (widthMultiplier * width + 2 * rowHeight - corners);\n\n        var wallCount = (perimeterPositions + dupliateCorners) * 2;\n\n        var wallPositions = new Float64Array(wallCount * 3);\n        var wallExtrudeNormals = shadowVolume ? new Float32Array(wallCount * 3) : undefined;\n        var wallOffsetAttribute = hasOffsets ? new Uint8Array(wallCount) : undefined;\n        var wallTextures = (vertexFormat.st) ? new Float32Array(wallCount * 2) : undefined;\n\n        var computeTopOffsets = offsetAttributeValue === GeometryOffsetAttribute.TOP;\n        if (hasOffsets && !computeTopOffsets) {\n            offsetValue = offsetAttributeValue === GeometryOffsetAttribute.ALL ? 1 : 0;\n            wallOffsetAttribute = arrayFill(wallOffsetAttribute, offsetValue);\n        }\n\n        var posIndex = 0;\n        var stIndex = 0;\n        var extrudeNormalIndex = 0;\n        var wallOffsetIndex = 0;\n        var area = width * rowHeight;\n        var threeI;\n        for (i = 0; i < area; i += width) {\n            threeI = i * 3;\n            wallPositions = addWallPositions(wallPositions, posIndex, threeI, topPositions, bottomPositions);\n            posIndex += 6;\n            if (vertexFormat.st) {\n                wallTextures = addWallTextureCoordinates(wallTextures, stIndex, i * 2, topSt);\n                stIndex += 4;\n            }\n            if (shadowVolume) {\n                extrudeNormalIndex += 3;\n                wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI];\n                wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI + 1];\n                wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI + 2];\n            }\n            if (computeTopOffsets) {\n                wallOffsetAttribute[wallOffsetIndex++] = 1;\n                wallOffsetIndex += 1;\n            }\n        }\n\n        if (!southCap) {\n            for (i = area - width; i < area; i++) {\n                threeI = i * 3;\n                wallPositions = addWallPositions(wallPositions, posIndex, threeI, topPositions, bottomPositions);\n                posIndex += 6;\n                if (vertexFormat.st) {\n                    wallTextures = addWallTextureCoordinates(wallTextures, stIndex, i * 2, topSt);\n                    stIndex += 4;\n                }\n                if (shadowVolume) {\n                    extrudeNormalIndex += 3;\n                    wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI];\n                    wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI + 1];\n                    wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI + 2];\n                }\n                if (computeTopOffsets) {\n                    wallOffsetAttribute[wallOffsetIndex++] = 1;\n                    wallOffsetIndex += 1;\n                }\n            }\n        } else {\n            var southIndex = northCap ? area + 1 : area;\n            threeI = southIndex * 3;\n\n            for (i = 0; i < 2; i++) { // duplicate corner points\n                wallPositions = addWallPositions(wallPositions, posIndex, threeI, topPositions, bottomPositions);\n                posIndex += 6;\n                if (vertexFormat.st) {\n                    wallTextures = addWallTextureCoordinates(wallTextures, stIndex, southIndex * 2, topSt);\n                    stIndex += 4;\n                }\n                if (shadowVolume) {\n                    extrudeNormalIndex += 3;\n                    wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI];\n                    wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI + 1];\n                    wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI + 2];\n                }\n                if (computeTopOffsets) {\n                    wallOffsetAttribute[wallOffsetIndex++] = 1;\n                    wallOffsetIndex += 1;\n                }\n            }\n        }\n\n        for (i = area - 1; i > 0; i -= width) {\n            threeI = i * 3;\n            wallPositions = addWallPositions(wallPositions, posIndex, threeI, topPositions, bottomPositions);\n            posIndex += 6;\n            if (vertexFormat.st) {\n                wallTextures = addWallTextureCoordinates(wallTextures, stIndex, i * 2, topSt);\n                stIndex += 4;\n            }\n            if (shadowVolume) {\n                extrudeNormalIndex += 3;\n                wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI];\n                wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI + 1];\n                wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI + 2];\n            }\n            if (computeTopOffsets) {\n                wallOffsetAttribute[wallOffsetIndex++] = 1;\n                wallOffsetIndex += 1;\n            }\n\n        }\n\n        if (!northCap) {\n            for (i = width - 1; i >= 0; i--) {\n                threeI = i * 3;\n                wallPositions = addWallPositions(wallPositions, posIndex, threeI, topPositions, bottomPositions);\n                posIndex += 6;\n                if (vertexFormat.st) {\n                    wallTextures = addWallTextureCoordinates(wallTextures, stIndex, i * 2, topSt);\n                    stIndex += 4;\n                }\n                if (shadowVolume) {\n                    extrudeNormalIndex += 3;\n                    wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI];\n                    wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI + 1];\n                    wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI + 2];\n                }\n                if (computeTopOffsets) {\n                    wallOffsetAttribute[wallOffsetIndex++] = 1;\n                    wallOffsetIndex += 1;\n                }\n            }\n        } else {\n            var northIndex = area;\n            threeI = northIndex * 3;\n\n            for (i = 0; i < 2; i++) { // duplicate corner points\n                wallPositions = addWallPositions(wallPositions, posIndex, threeI, topPositions, bottomPositions);\n                posIndex += 6;\n                if (vertexFormat.st) {\n                    wallTextures = addWallTextureCoordinates(wallTextures, stIndex, northIndex * 2, topSt);\n                    stIndex += 4;\n                }\n                if (shadowVolume) {\n                    extrudeNormalIndex += 3;\n                    wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI];\n                    wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI + 1];\n                    wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI + 2];\n                }\n                if (computeTopOffsets) {\n                    wallOffsetAttribute[wallOffsetIndex++] = 1;\n                    wallOffsetIndex += 1;\n                }\n            }\n        }\n\n        var geo = calculateAttributesWall(wallPositions, vertexFormat, ellipsoid);\n\n        if (vertexFormat.st) {\n            geo.attributes.st = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.FLOAT,\n                componentsPerAttribute : 2,\n                values : wallTextures\n            });\n        }\n        if (shadowVolume) {\n            geo.attributes.extrudeDirection = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.FLOAT,\n                componentsPerAttribute : 3,\n                values : wallExtrudeNormals\n            });\n        }\n        if (hasOffsets) {\n            geo.attributes.applyOffset = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.UNSIGNED_BYTE,\n                componentsPerAttribute : 1,\n                values : wallOffsetAttribute\n            });\n        }\n\n        var wallIndices = IndexDatatype.createTypedArray(wallCount, perimeterPositions * 6);\n\n        var upperLeft;\n        var lowerLeft;\n        var lowerRight;\n        var upperRight;\n        length = wallPositions.length / 3;\n        var index = 0;\n        for (i = 0; i < length - 1; i += 2) {\n            upperLeft = i;\n            upperRight = (upperLeft + 2) % length;\n            var p1 = Cartesian3.fromArray(wallPositions, upperLeft * 3, v1Scratch);\n            var p2 = Cartesian3.fromArray(wallPositions, upperRight * 3, v2Scratch);\n            if (Cartesian3.equalsEpsilon(p1, p2, CesiumMath.EPSILON10)) {\n                continue;\n            }\n            lowerLeft = (upperLeft + 1) % length;\n            lowerRight = (lowerLeft + 2) % length;\n            wallIndices[index++] = upperLeft;\n            wallIndices[index++] = lowerLeft;\n            wallIndices[index++] = upperRight;\n            wallIndices[index++] = upperRight;\n            wallIndices[index++] = lowerLeft;\n            wallIndices[index++] = lowerRight;\n        }\n\n        geo.indices = wallIndices;\n\n        geo = GeometryPipeline.combineInstances([\n            new GeometryInstance({\n                geometry : topBottomGeo\n            }),\n            new GeometryInstance({\n                geometry : geo\n            })\n        ]);\n\n        return geo[0];\n    }\n\n    var scratchRectanglePoints = [new Cartesian3(), new Cartesian3(), new Cartesian3(), new Cartesian3()];\n    var nwScratch = new Cartographic();\n    var stNwScratch = new Cartographic();\n    function computeRectangle(rectangle, granularity, rotation, ellipsoid, result) {\n        if (rotation === 0.0) {\n            return Rectangle.clone(rectangle, result);\n        }\n\n        var computedOptions = RectangleGeometryLibrary.computeOptions(rectangle, granularity, rotation, 0, rectangleScratch, nwScratch);\n\n        var height = computedOptions.height;\n        var width = computedOptions.width;\n\n        var positions = scratchRectanglePoints;\n        RectangleGeometryLibrary.computePosition(computedOptions, ellipsoid, false, 0, 0, positions[0]);\n        RectangleGeometryLibrary.computePosition(computedOptions, ellipsoid, false, 0, width - 1, positions[1]);\n        RectangleGeometryLibrary.computePosition(computedOptions, ellipsoid, false, height - 1, 0, positions[2]);\n        RectangleGeometryLibrary.computePosition(computedOptions, ellipsoid, false, height - 1, width - 1, positions[3]);\n\n        return Rectangle.fromCartesianArray(positions, ellipsoid, result);\n    }\n\n    /**\n     * A description of a cartographic rectangle on an ellipsoid centered at the origin. Rectangle geometry can be rendered with both {@link Primitive} and {@link GroundPrimitive}.\n     *\n     * @alias RectangleGeometry\n     * @constructor\n     *\n     * @param {Object} options Object with the following properties:\n     * @param {Rectangle} options.rectangle A cartographic rectangle with north, south, east and west properties in radians.\n     * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\n     * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the rectangle lies.\n     * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n     * @param {Number} [options.height=0.0] The distance in meters between the rectangle and the ellipsoid surface.\n     * @param {Number} [options.rotation=0.0] The rotation of the rectangle, in radians. A positive rotation is counter-clockwise.\n     * @param {Number} [options.stRotation=0.0] The rotation of the texture coordinates, in radians. A positive rotation is counter-clockwise.\n     * @param {Number} [options.extrudedHeight] The distance in meters between the rectangle's extruded face and the ellipsoid surface.\n     *\n     * @exception {DeveloperError} <code>options.rectangle.north</code> must be in the interval [<code>-Pi/2</code>, <code>Pi/2</code>].\n     * @exception {DeveloperError} <code>options.rectangle.south</code> must be in the interval [<code>-Pi/2</code>, <code>Pi/2</code>].\n     * @exception {DeveloperError} <code>options.rectangle.east</code> must be in the interval [<code>-Pi</code>, <code>Pi</code>].\n     * @exception {DeveloperError} <code>options.rectangle.west</code> must be in the interval [<code>-Pi</code>, <code>Pi</code>].\n     * @exception {DeveloperError} <code>options.rectangle.north</code> must be greater than <code>options.rectangle.south</code>.\n     *\n     * @see RectangleGeometry#createGeometry\n     *\n     * @demo {@link https://sandcastle.cesium.com/index.html?src=Rectangle.html|Cesium Sandcastle Rectangle Demo}\n     *\n     * @example\n     * // 1. create a rectangle\n     * var rectangle = new Cesium.RectangleGeometry({\n     *   ellipsoid : Cesium.Ellipsoid.WGS84,\n     *   rectangle : Cesium.Rectangle.fromDegrees(-80.0, 39.0, -74.0, 42.0),\n     *   height : 10000.0\n     * });\n     * var geometry = Cesium.RectangleGeometry.createGeometry(rectangle);\n     *\n     * // 2. create an extruded rectangle without a top\n     * var rectangle = new Cesium.RectangleGeometry({\n     *   ellipsoid : Cesium.Ellipsoid.WGS84,\n     *   rectangle : Cesium.Rectangle.fromDegrees(-80.0, 39.0, -74.0, 42.0),\n     *   height : 10000.0,\n     *   extrudedHeight: 300000\n     * });\n     * var geometry = Cesium.RectangleGeometry.createGeometry(rectangle);\n     */\n    function RectangleGeometry(options) {\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n        var rectangle = options.rectangle;\n\n        \n\n        var height = defaultValue(options.height, 0.0);\n        var extrudedHeight = defaultValue(options.extrudedHeight, height);\n\n        this._rectangle = Rectangle.clone(rectangle);\n        this._granularity = defaultValue(options.granularity, CesiumMath.RADIANS_PER_DEGREE);\n        this._ellipsoid = Ellipsoid.clone(defaultValue(options.ellipsoid, Ellipsoid.WGS84));\n        this._surfaceHeight = Math.max(height, extrudedHeight);\n        this._rotation = defaultValue(options.rotation, 0.0);\n        this._stRotation = defaultValue(options.stRotation, 0.0);\n        this._vertexFormat = VertexFormat.clone(defaultValue(options.vertexFormat, VertexFormat.DEFAULT));\n        this._extrudedHeight = Math.min(height, extrudedHeight);\n        this._shadowVolume = defaultValue(options.shadowVolume, false);\n        this._workerName = 'createRectangleGeometry';\n        this._offsetAttribute = options.offsetAttribute;\n        this._rotatedRectangle = undefined;\n\n        this._textureCoordinateRotationPoints = undefined;\n    }\n\n    /**\n     * The number of elements used to pack the object into an array.\n     * @type {Number}\n     */\n    RectangleGeometry.packedLength = Rectangle.packedLength + Ellipsoid.packedLength + VertexFormat.packedLength + 7;\n\n    /**\n     * Stores the provided instance into the provided array.\n     *\n     * @param {RectangleGeometry} value The value to pack.\n     * @param {Number[]} array The array to pack into.\n     * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n     *\n     * @returns {Number[]} The array that was packed into\n     */\n    RectangleGeometry.pack = function(value, array, startingIndex) {\n        \n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        Rectangle.pack(value._rectangle, array, startingIndex);\n        startingIndex += Rectangle.packedLength;\n\n        Ellipsoid.pack(value._ellipsoid, array, startingIndex);\n        startingIndex += Ellipsoid.packedLength;\n\n        VertexFormat.pack(value._vertexFormat, array, startingIndex);\n        startingIndex += VertexFormat.packedLength;\n\n        array[startingIndex++] = value._granularity;\n        array[startingIndex++] = value._surfaceHeight;\n        array[startingIndex++] = value._rotation;\n        array[startingIndex++] = value._stRotation;\n        array[startingIndex++] = value._extrudedHeight;\n        array[startingIndex++] = value._shadowVolume ? 1.0 : 0.0;\n        array[startingIndex] = defaultValue(value._offsetAttribute, -1);\n\n        return array;\n    };\n\n    var scratchRectangle = new Rectangle();\n    var scratchEllipsoid = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);\n    var scratchOptions = {\n        rectangle : scratchRectangle,\n        ellipsoid : scratchEllipsoid,\n        vertexFormat : scratchVertexFormat,\n        granularity : undefined,\n        height : undefined,\n        rotation : undefined,\n        stRotation : undefined,\n        extrudedHeight : undefined,\n        shadowVolume : undefined,\n        offsetAttribute: undefined\n    };\n\n    /**\n     * Retrieves an instance from a packed array.\n     *\n     * @param {Number[]} array The packed array.\n     * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n     * @param {RectangleGeometry} [result] The object into which to store the result.\n     * @returns {RectangleGeometry} The modified result parameter or a new RectangleGeometry instance if one was not provided.\n     */\n    RectangleGeometry.unpack = function(array, startingIndex, result) {\n        \n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        var rectangle = Rectangle.unpack(array, startingIndex, scratchRectangle);\n        startingIndex += Rectangle.packedLength;\n\n        var ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);\n        startingIndex += Ellipsoid.packedLength;\n\n        var vertexFormat = VertexFormat.unpack(array, startingIndex, scratchVertexFormat);\n        startingIndex += VertexFormat.packedLength;\n\n        var granularity = array[startingIndex++];\n        var surfaceHeight = array[startingIndex++];\n        var rotation = array[startingIndex++];\n        var stRotation = array[startingIndex++];\n        var extrudedHeight = array[startingIndex++];\n        var shadowVolume = array[startingIndex++] === 1.0;\n        var offsetAttribute = array[startingIndex];\n\n        if (!defined(result)) {\n            scratchOptions.granularity = granularity;\n            scratchOptions.height = surfaceHeight;\n            scratchOptions.rotation = rotation;\n            scratchOptions.stRotation = stRotation;\n            scratchOptions.extrudedHeight = extrudedHeight;\n            scratchOptions.shadowVolume = shadowVolume;\n            scratchOptions.offsetAttribute = offsetAttribute === -1 ? undefined : offsetAttribute;\n\n            return new RectangleGeometry(scratchOptions);\n        }\n\n        result._rectangle = Rectangle.clone(rectangle, result._rectangle);\n        result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);\n        result._vertexFormat = VertexFormat.clone(vertexFormat, result._vertexFormat);\n        result._granularity = granularity;\n        result._surfaceHeight = surfaceHeight;\n        result._rotation = rotation;\n        result._stRotation = stRotation;\n        result._extrudedHeight = extrudedHeight;\n        result._shadowVolume = shadowVolume;\n        result._offsetAttribute = offsetAttribute === -1 ? undefined : offsetAttribute;\n\n        return result;\n    };\n\n    /**\n     * Computes the bounding rectangle based on the provided options\n     *\n     * @param {Object} options Object with the following properties:\n     * @param {Rectangle} options.rectangle A cartographic rectangle with north, south, east and west properties in radians.\n     * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the rectangle lies.\n     * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n     * @param {Number} [options.rotation=0.0] The rotation of the rectangle, in radians. A positive rotation is counter-clockwise.\n     * @param {Rectangle} [result] An object in which to store the result.\n     *\n     * @returns {Rectangle} The result rectangle\n     */\n    RectangleGeometry.computeRectangle = function(options, result) {\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n        var rectangle = options.rectangle;\n\n        \n\n        var granularity = defaultValue(options.granularity, CesiumMath.RADIANS_PER_DEGREE);\n        var ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\n        var rotation = defaultValue(options.rotation, 0.0);\n\n        return computeRectangle(rectangle, granularity, rotation, ellipsoid, result);\n    };\n\n    var tangentRotationMatrixScratch = new Matrix3();\n    var quaternionScratch = new Quaternion();\n    var centerScratch = new Cartographic();\n    /**\n     * Computes the geometric representation of a rectangle, including its vertices, indices, and a bounding sphere.\n     *\n     * @param {RectangleGeometry} rectangleGeometry A description of the rectangle.\n     * @returns {Geometry|undefined} The computed vertices and indices.\n     *\n     * @exception {DeveloperError} Rotated rectangle is invalid.\n     */\n    RectangleGeometry.createGeometry = function(rectangleGeometry) {\n        if ((CesiumMath.equalsEpsilon(rectangleGeometry._rectangle.north, rectangleGeometry._rectangle.south, CesiumMath.EPSILON10) ||\n             (CesiumMath.equalsEpsilon(rectangleGeometry._rectangle.east, rectangleGeometry._rectangle.west, CesiumMath.EPSILON10)))) {\n            return undefined;\n        }\n\n        var rectangle = rectangleGeometry._rectangle;\n        var ellipsoid = rectangleGeometry._ellipsoid;\n        var rotation = rectangleGeometry._rotation;\n        var stRotation = rectangleGeometry._stRotation;\n        var vertexFormat = rectangleGeometry._vertexFormat;\n\n        var computedOptions = RectangleGeometryLibrary.computeOptions(rectangle, rectangleGeometry._granularity, rotation, stRotation, rectangleScratch, nwScratch, stNwScratch);\n\n        var tangentRotationMatrix = tangentRotationMatrixScratch;\n        if (stRotation !== 0 || rotation !== 0) {\n            var center = Rectangle.center(rectangle, centerScratch);\n            var axis = ellipsoid.geodeticSurfaceNormalCartographic(center, v1Scratch);\n            Quaternion.fromAxisAngle(axis, -stRotation, quaternionScratch);\n            Matrix3.fromQuaternion(quaternionScratch, tangentRotationMatrix);\n        } else {\n            Matrix3.clone(Matrix3.IDENTITY, tangentRotationMatrix);\n        }\n\n        var surfaceHeight = rectangleGeometry._surfaceHeight;\n        var extrudedHeight = rectangleGeometry._extrudedHeight;\n        var extrude = !CesiumMath.equalsEpsilon(surfaceHeight, extrudedHeight, 0, CesiumMath.EPSILON2);\n\n        computedOptions.lonScalar = 1.0 / rectangleGeometry._rectangle.width;\n        computedOptions.latScalar = 1.0 / rectangleGeometry._rectangle.height;\n        computedOptions.tangentRotationMatrix = tangentRotationMatrix;\n\n        var geometry;\n        var boundingSphere;\n        rectangle = rectangleGeometry._rectangle;\n        if (extrude) {\n            geometry = constructExtrudedRectangle(rectangleGeometry, computedOptions);\n            var topBS = BoundingSphere.fromRectangle3D(rectangle, ellipsoid, surfaceHeight, topBoundingSphere);\n            var bottomBS = BoundingSphere.fromRectangle3D(rectangle, ellipsoid, extrudedHeight, bottomBoundingSphere);\n            boundingSphere = BoundingSphere.union(topBS, bottomBS);\n        } else {\n            geometry = constructRectangle(rectangleGeometry, computedOptions);\n            geometry.attributes.position.values = PolygonPipeline.scaleToGeodeticHeight(geometry.attributes.position.values, surfaceHeight, ellipsoid, false);\n\n            if (defined(rectangleGeometry._offsetAttribute)) {\n                var length = geometry.attributes.position.values.length;\n                var applyOffset = new Uint8Array(length / 3);\n                var offsetValue = rectangleGeometry._offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;\n                arrayFill(applyOffset, offsetValue);\n                geometry.attributes.applyOffset = new GeometryAttribute({\n                    componentDatatype : ComponentDatatype.UNSIGNED_BYTE,\n                    componentsPerAttribute : 1,\n                    values: applyOffset\n                });\n            }\n\n            boundingSphere = BoundingSphere.fromRectangle3D(rectangle, ellipsoid, surfaceHeight);\n        }\n\n        if (!vertexFormat.position) {\n            delete geometry.attributes.position;\n        }\n\n        return new Geometry({\n            attributes : geometry.attributes,\n            indices : geometry.indices,\n            primitiveType : geometry.primitiveType,\n            boundingSphere : boundingSphere,\n            offsetAttribute : rectangleGeometry._offsetAttribute\n        });\n    };\n\n    /**\n     * @private\n     */\n    RectangleGeometry.createShadowVolume = function(rectangleGeometry, minHeightFunc, maxHeightFunc) {\n        var granularity = rectangleGeometry._granularity;\n        var ellipsoid = rectangleGeometry._ellipsoid;\n\n        var minHeight = minHeightFunc(granularity, ellipsoid);\n        var maxHeight = maxHeightFunc(granularity, ellipsoid);\n\n        return new RectangleGeometry({\n            rectangle : rectangleGeometry._rectangle,\n            rotation : rectangleGeometry._rotation,\n            ellipsoid : ellipsoid,\n            stRotation : rectangleGeometry._stRotation,\n            granularity : granularity,\n            extrudedHeight : maxHeight,\n            height : minHeight,\n            vertexFormat : VertexFormat.POSITION_ONLY,\n            shadowVolume : true\n        });\n    };\n\n    var unrotatedTextureRectangleScratch = new Rectangle();\n    var points2DScratch = [new Cartesian2(), new Cartesian2(), new Cartesian2()];\n    var rotation2DScratch = new Matrix2();\n    var rectangleCenterScratch = new Cartographic();\n\n    function textureCoordinateRotationPoints(rectangleGeometry) {\n        if (rectangleGeometry._stRotation === 0.0) {\n            return [0, 0, 0, 1, 1, 0];\n        }\n\n        var rectangle = Rectangle.clone(rectangleGeometry._rectangle, unrotatedTextureRectangleScratch);\n        var granularity = rectangleGeometry._granularity;\n        var ellipsoid = rectangleGeometry._ellipsoid;\n\n        // Rotate to align the texture coordinates with ENU\n        var rotation = rectangleGeometry._rotation - rectangleGeometry._stRotation;\n\n        var unrotatedTextureRectangle = computeRectangle(rectangle, granularity, rotation, ellipsoid, unrotatedTextureRectangleScratch);\n\n        // Assume a computed \"east-north\" texture coordinate system based on spherical or planar tricks, bounded by `boundingRectangle`.\n        // The \"desired\" texture coordinate system forms an oriented rectangle (un-oriented computed) around the geometry that completely and tightly bounds it.\n        // We want to map from the \"east-north\" texture coordinate system into the \"desired\" system using a pair of lines (analagous planes in 2D)\n        // Compute 3 corners of the \"desired\" texture coordinate system in \"east-north\" texture space by the following in cartographic space:\n        // - rotate 3 of the corners in unrotatedTextureRectangle by stRotation around the center of the bounding rectangle\n        // - apply the \"east-north\" system's normalization formula to the rotated cartographics, even though this is likely to produce values outside [0-1].\n        // This gives us a set of points in the \"east-north\" texture coordinate system that can be used to map \"east-north\" texture coordinates to \"desired.\"\n\n        var points2D = points2DScratch;\n        points2D[0].x = unrotatedTextureRectangle.west;\n        points2D[0].y = unrotatedTextureRectangle.south;\n\n        points2D[1].x = unrotatedTextureRectangle.west;\n        points2D[1].y = unrotatedTextureRectangle.north;\n\n        points2D[2].x = unrotatedTextureRectangle.east;\n        points2D[2].y = unrotatedTextureRectangle.south;\n\n        var boundingRectangle = rectangleGeometry.rectangle;\n        var toDesiredInComputed = Matrix2.fromRotation(rectangleGeometry._stRotation, rotation2DScratch);\n        var boundingRectangleCenter = Rectangle.center(boundingRectangle, rectangleCenterScratch);\n\n        for (var i = 0; i < 3; ++i) {\n            var point2D = points2D[i];\n            point2D.x -= boundingRectangleCenter.longitude;\n            point2D.y -= boundingRectangleCenter.latitude;\n            Matrix2.multiplyByVector(toDesiredInComputed, point2D, point2D);\n            point2D.x += boundingRectangleCenter.longitude;\n            point2D.y += boundingRectangleCenter.latitude;\n\n            // Convert point into east-north texture coordinate space\n            point2D.x = (point2D.x - boundingRectangle.west) / boundingRectangle.width;\n            point2D.y = (point2D.y - boundingRectangle.south) / boundingRectangle.height;\n        }\n\n        var minXYCorner = points2D[0];\n        var maxYCorner = points2D[1];\n        var maxXCorner = points2D[2];\n        var result = new Array(6);\n        Cartesian2.pack(minXYCorner, result);\n        Cartesian2.pack(maxYCorner, result, 2);\n        Cartesian2.pack(maxXCorner, result, 4);\n        return result;\n    }\n\n    defineProperties(RectangleGeometry.prototype, {\n        /**\n         * @private\n         */\n        rectangle : {\n            get : function() {\n                if (!defined(this._rotatedRectangle)) {\n                    this._rotatedRectangle = computeRectangle(this._rectangle, this._granularity, this._rotation, this._ellipsoid);\n                }\n                return this._rotatedRectangle;\n            }\n        },\n        /**\n         * For remapping texture coordinates when rendering RectangleGeometries as GroundPrimitives.\n         * This version permits skew in textures by computing offsets directly in cartographic space and\n         * more accurately approximates rendering RectangleGeometries with height as standard Primitives.\n         * @see Geometry#_textureCoordinateRotationPoints\n         * @private\n         */\n        textureCoordinateRotationPoints : {\n            get : function() {\n                if (!defined(this._textureCoordinateRotationPoints)) {\n                    this._textureCoordinateRotationPoints = textureCoordinateRotationPoints(this);\n                }\n                return this._textureCoordinateRotationPoints;\n            }\n        }\n    });\nexport default RectangleGeometry;\n","import ApproximateTerrainHeights from '../Core/ApproximateTerrainHeights.js';\nimport Cartesian3 from '../Core/Cartesian3.js';\nimport Cartographic from '../Core/Cartographic.js';\nimport Check from '../Core/Check.js';\nimport Color from '../Core/Color.js';\nimport ColorGeometryInstanceAttribute from '../Core/ColorGeometryInstanceAttribute.js';\nimport defined from '../Core/defined.js';\nimport DeveloperError from '../Core/DeveloperError.js';\nimport DistanceDisplayConditionGeometryInstanceAttribute from '../Core/DistanceDisplayConditionGeometryInstanceAttribute.js';\nimport Ellipsoid from '../Core/Ellipsoid.js';\nimport GeometryInstance from '../Core/GeometryInstance.js';\nimport Iso8601 from '../Core/Iso8601.js';\nimport OffsetGeometryInstanceAttribute from '../Core/OffsetGeometryInstanceAttribute.js';\nimport Rectangle from '../Core/Rectangle.js';\nimport RectangleGeometry from '../Core/RectangleGeometry.js';\nimport RectangleOutlineGeometry from '../Core/RectangleOutlineGeometry.js';\nimport ShowGeometryInstanceAttribute from '../Core/ShowGeometryInstanceAttribute.js';\nimport HeightReference from '../Scene/HeightReference.js';\nimport MaterialAppearance from '../Scene/MaterialAppearance.js';\nimport PerInstanceColorAppearance from '../Scene/PerInstanceColorAppearance.js';\nimport ColorMaterialProperty from './ColorMaterialProperty.js';\nimport DynamicGeometryUpdater from './DynamicGeometryUpdater.js';\nimport GeometryUpdater from './GeometryUpdater.js';\nimport GroundGeometryUpdater from './GroundGeometryUpdater.js';\nimport Property from './Property.js';\n\n    var scratchColor = new Color();\n    var defaultOffset = Cartesian3.ZERO;\n    var offsetScratch = new Cartesian3();\n    var scratchRectangle = new Rectangle();\n    var scratchCenterRect = new Rectangle();\n    var scratchCarto = new Cartographic();\n\n    function RectangleGeometryOptions(entity) {\n        this.id = entity;\n        this.vertexFormat = undefined;\n        this.rectangle = undefined;\n        this.height = undefined;\n        this.extrudedHeight = undefined;\n        this.granularity = undefined;\n        this.stRotation = undefined;\n        this.rotation = undefined;\n        this.offsetAttribute = undefined;\n    }\n\n    /**\n     * A {@link GeometryUpdater} for rectangles.\n     * Clients do not normally create this class directly, but instead rely on {@link DataSourceDisplay}.\n     * @alias RectangleGeometryUpdater\n     * @constructor\n     *\n     * @param {Entity} entity The entity containing the geometry to be visualized.\n     * @param {Scene} scene The scene where visualization is taking place.\n     */\n    function RectangleGeometryUpdater(entity, scene) {\n        GroundGeometryUpdater.call(this, {\n            entity : entity,\n            scene : scene,\n            geometryOptions : new RectangleGeometryOptions(entity),\n            geometryPropertyName : 'rectangle',\n            observedPropertyNames : ['availability', 'rectangle']\n        });\n\n        this._onEntityPropertyChanged(entity, 'rectangle', entity.rectangle, undefined);\n    }\n\n    if (defined(Object.create)) {\n        RectangleGeometryUpdater.prototype = Object.create(GroundGeometryUpdater.prototype);\n        RectangleGeometryUpdater.prototype.constructor = RectangleGeometryUpdater;\n    }\n\n    /**\n     * Creates the geometry instance which represents the fill of the geometry.\n     *\n     * @param {JulianDate} time The time to use when retrieving initial attribute values.\n     * @returns {GeometryInstance} The geometry instance representing the filled portion of the geometry.\n     *\n     * @exception {DeveloperError} This instance does not represent a filled geometry.\n     */\n    RectangleGeometryUpdater.prototype.createFillGeometryInstance = function(time) {\n        \n\n        var entity = this._entity;\n        var isAvailable = entity.isAvailable(time);\n\n        var attributes = {\n            show : new ShowGeometryInstanceAttribute(isAvailable && entity.isShowing && this._showProperty.getValue(time) && this._fillProperty.getValue(time)),\n            distanceDisplayCondition : DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(this._distanceDisplayConditionProperty.getValue(time)),\n            offset : undefined,\n            color : undefined\n        };\n\n        if (this._materialProperty instanceof ColorMaterialProperty) {\n            var currentColor;\n            if (defined(this._materialProperty.color) && (this._materialProperty.color.isConstant || isAvailable)) {\n                currentColor = this._materialProperty.color.getValue(time, scratchColor);\n            }\n            if (!defined(currentColor)) {\n                currentColor = Color.WHITE;\n            }\n            attributes.color = ColorGeometryInstanceAttribute.fromColor(currentColor);\n        }\n        if (defined(this._options.offsetAttribute)) {\n            attributes.offset = OffsetGeometryInstanceAttribute.fromCartesian3(Property.getValueOrDefault(this._terrainOffsetProperty, time, defaultOffset, offsetScratch));\n        }\n\n        return new GeometryInstance({\n            id : entity,\n            geometry : new RectangleGeometry(this._options),\n            attributes : attributes\n        });\n    };\n\n    /**\n     * Creates the geometry instance which represents the outline of the geometry.\n     *\n     * @param {JulianDate} time The time to use when retrieving initial attribute values.\n     * @returns {GeometryInstance} The geometry instance representing the outline portion of the geometry.\n     *\n     * @exception {DeveloperError} This instance does not represent an outlined geometry.\n     */\n    RectangleGeometryUpdater.prototype.createOutlineGeometryInstance = function(time) {\n        \n\n        var entity = this._entity;\n        var isAvailable = entity.isAvailable(time);\n        var outlineColor = Property.getValueOrDefault(this._outlineColorProperty, time, Color.BLACK, scratchColor);\n        var distanceDisplayCondition = this._distanceDisplayConditionProperty.getValue(time);\n\n        var attributes = {\n            show : new ShowGeometryInstanceAttribute(isAvailable && entity.isShowing && this._showProperty.getValue(time) && this._showOutlineProperty.getValue(time)),\n            color : ColorGeometryInstanceAttribute.fromColor(outlineColor),\n            distanceDisplayCondition : DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(distanceDisplayCondition),\n            offset : undefined\n        };\n\n        if (defined(this._options.offsetAttribute)) {\n            attributes.offset = OffsetGeometryInstanceAttribute.fromCartesian3(Property.getValueOrDefault(this._terrainOffsetProperty, time, defaultOffset, offsetScratch));\n        }\n\n        return new GeometryInstance({\n            id : entity,\n            geometry : new RectangleOutlineGeometry(this._options),\n            attributes : attributes\n        });\n    };\n\n    RectangleGeometryUpdater.prototype._computeCenter = function(time, result) {\n        var rect = Property.getValueOrUndefined(this._entity.rectangle.coordinates, time, scratchCenterRect);\n        if (!defined(rect)) {\n            return;\n        }\n        var center = Rectangle.center(rect, scratchCarto);\n        return Cartographic.toCartesian(center, Ellipsoid.WGS84, result);\n    };\n\n    RectangleGeometryUpdater.prototype._isHidden = function(entity, rectangle) {\n        return !defined(rectangle.coordinates) || GeometryUpdater.prototype._isHidden.call(this, entity, rectangle);\n    };\n\n    RectangleGeometryUpdater.prototype._isDynamic = function(entity, rectangle) {\n        return !rectangle.coordinates.isConstant || //\n               !Property.isConstant(rectangle.height) || //\n               !Property.isConstant(rectangle.extrudedHeight) || //\n               !Property.isConstant(rectangle.granularity) || //\n               !Property.isConstant(rectangle.stRotation) || //\n               !Property.isConstant(rectangle.rotation) || //\n               !Property.isConstant(rectangle.outlineWidth) || //\n               !Property.isConstant(rectangle.zIndex) || //\n               (this._onTerrain && !Property.isConstant(this._materialProperty));\n    };\n\n    RectangleGeometryUpdater.prototype._setStaticOptions = function(entity, rectangle) {\n        var isColorMaterial = this._materialProperty instanceof ColorMaterialProperty;\n\n        var heightValue = Property.getValueOrUndefined(rectangle.height, Iso8601.MINIMUM_VALUE);\n        var heightReferenceValue = Property.getValueOrDefault(rectangle.heightReference, Iso8601.MINIMUM_VALUE, HeightReference.NONE);\n        var extrudedHeightValue = Property.getValueOrUndefined(rectangle.extrudedHeight, Iso8601.MINIMUM_VALUE);\n        var extrudedHeightReferenceValue = Property.getValueOrDefault(rectangle.extrudedHeightReference, Iso8601.MINIMUM_VALUE, HeightReference.NONE);\n        if (defined(extrudedHeightValue) && !defined(heightValue)) {\n            heightValue = 0;\n        }\n\n        var options = this._options;\n        options.vertexFormat = isColorMaterial ? PerInstanceColorAppearance.VERTEX_FORMAT : MaterialAppearance.MaterialSupport.TEXTURED.vertexFormat;\n        options.rectangle = rectangle.coordinates.getValue(Iso8601.MINIMUM_VALUE, options.rectangle);\n        options.granularity = Property.getValueOrUndefined(rectangle.granularity, Iso8601.MINIMUM_VALUE);\n        options.stRotation = Property.getValueOrUndefined(rectangle.stRotation, Iso8601.MINIMUM_VALUE);\n        options.rotation = Property.getValueOrUndefined(rectangle.rotation, Iso8601.MINIMUM_VALUE);\n        options.offsetAttribute = GroundGeometryUpdater.computeGeometryOffsetAttribute(heightValue, heightReferenceValue, extrudedHeightValue, extrudedHeightReferenceValue);\n        options.height = GroundGeometryUpdater.getGeometryHeight(heightValue, heightReferenceValue);\n\n        extrudedHeightValue = GroundGeometryUpdater.getGeometryExtrudedHeight(extrudedHeightValue, extrudedHeightReferenceValue);\n        if (extrudedHeightValue === GroundGeometryUpdater.CLAMP_TO_GROUND) {\n            extrudedHeightValue = ApproximateTerrainHeights.getMinimumMaximumHeights(RectangleGeometry.computeRectangle(options, scratchRectangle)).minimumTerrainHeight;\n        }\n\n        options.extrudedHeight = extrudedHeightValue;\n    };\n\n    RectangleGeometryUpdater.DynamicGeometryUpdater = DynamicRectangleGeometryUpdater;\n\n    /**\n     * @private\n     */\n    function DynamicRectangleGeometryUpdater(geometryUpdater, primitives, groundPrimitives) {\n        DynamicGeometryUpdater.call(this, geometryUpdater, primitives, groundPrimitives);\n    }\n\n    if (defined(Object.create)) {\n        DynamicRectangleGeometryUpdater.prototype = Object.create(DynamicGeometryUpdater.prototype);\n        DynamicRectangleGeometryUpdater.prototype.constructor = DynamicRectangleGeometryUpdater;\n    }\n\n    DynamicRectangleGeometryUpdater.prototype._isHidden = function(entity, rectangle, time) {\n        return  !defined(this._options.rectangle) || DynamicGeometryUpdater.prototype._isHidden.call(this, entity, rectangle, time);\n    };\n\n    DynamicRectangleGeometryUpdater.prototype._setOptions = function(entity, rectangle, time) {\n        var options = this._options;\n        var heightValue = Property.getValueOrUndefined(rectangle.height, time);\n        var heightReferenceValue = Property.getValueOrDefault(rectangle.heightReference, time, HeightReference.NONE);\n        var extrudedHeightValue = Property.getValueOrUndefined(rectangle.extrudedHeight, time);\n        var extrudedHeightReferenceValue = Property.getValueOrDefault(rectangle.extrudedHeightReference, time, HeightReference.NONE);\n        if (defined(extrudedHeightValue) && !defined(heightValue)) {\n            heightValue = 0;\n        }\n\n        options.rectangle = Property.getValueOrUndefined(rectangle.coordinates, time, options.rectangle);\n        options.granularity = Property.getValueOrUndefined(rectangle.granularity, time);\n        options.stRotation = Property.getValueOrUndefined(rectangle.stRotation, time);\n        options.rotation = Property.getValueOrUndefined(rectangle.rotation, time);\n        options.offsetAttribute = GroundGeometryUpdater.computeGeometryOffsetAttribute(heightValue, heightReferenceValue, extrudedHeightValue, extrudedHeightReferenceValue);\n        options.height = GroundGeometryUpdater.getGeometryHeight(heightValue, heightReferenceValue);\n\n        extrudedHeightValue = GroundGeometryUpdater.getGeometryExtrudedHeight(extrudedHeightValue, extrudedHeightReferenceValue);\n        if (extrudedHeightValue === GroundGeometryUpdater.CLAMP_TO_GROUND) {\n            extrudedHeightValue = ApproximateTerrainHeights.getMinimumMaximumHeights(RectangleGeometry.computeRectangle(options, scratchRectangle)).minimumTerrainHeight;\n        }\n\n        options.extrudedHeight = extrudedHeightValue;\n    };\nexport default RectangleGeometryUpdater;\n","import AssociativeArray from '../Core/AssociativeArray.js';\nimport Cartesian3 from '../Core/Cartesian3.js';\nimport Color from '../Core/Color.js';\nimport ColorGeometryInstanceAttribute from '../Core/ColorGeometryInstanceAttribute.js';\nimport defined from '../Core/defined.js';\nimport DistanceDisplayCondition from '../Core/DistanceDisplayCondition.js';\nimport DistanceDisplayConditionGeometryInstanceAttribute from '../Core/DistanceDisplayConditionGeometryInstanceAttribute.js';\nimport OffsetGeometryInstanceAttribute from '../Core/OffsetGeometryInstanceAttribute.js';\nimport ShowGeometryInstanceAttribute from '../Core/ShowGeometryInstanceAttribute.js';\nimport Primitive from '../Scene/Primitive.js';\nimport BoundingSphereState from './BoundingSphereState.js';\nimport ColorMaterialProperty from './ColorMaterialProperty.js';\nimport MaterialProperty from './MaterialProperty.js';\nimport Property from './Property.js';\n\n    var colorScratch = new Color();\n    var distanceDisplayConditionScratch = new DistanceDisplayCondition();\n    var defaultDistanceDisplayCondition = new DistanceDisplayCondition();\n    var defaultOffset = Cartesian3.ZERO;\n    var offsetScratch = new Cartesian3();\n\n    function Batch(primitives, translucent, appearanceType, depthFailAppearanceType, depthFailMaterialProperty, closed, shadows) {\n        this.translucent = translucent;\n        this.appearanceType = appearanceType;\n        this.depthFailAppearanceType = depthFailAppearanceType;\n        this.depthFailMaterialProperty = depthFailMaterialProperty;\n        this.depthFailMaterial = undefined;\n        this.closed = closed;\n        this.shadows = shadows;\n        this.primitives = primitives;\n        this.createPrimitive = false;\n        this.waitingOnCreate = false;\n        this.primitive = undefined;\n        this.oldPrimitive = undefined;\n        this.geometry = new AssociativeArray();\n        this.updaters = new AssociativeArray();\n        this.updatersWithAttributes = new AssociativeArray();\n        this.attributes = new AssociativeArray();\n        this.subscriptions = new AssociativeArray();\n        this.showsUpdated = new AssociativeArray();\n        this.itemsToRemove = [];\n        this.invalidated = false;\n\n        var removeMaterialSubscription;\n        if (defined(depthFailMaterialProperty)) {\n            removeMaterialSubscription = depthFailMaterialProperty.definitionChanged.addEventListener(Batch.prototype.onMaterialChanged, this);\n        }\n        this.removeMaterialSubscription = removeMaterialSubscription;\n    }\n\n    Batch.prototype.onMaterialChanged = function() {\n        this.invalidated = true;\n    };\n\n    Batch.prototype.isMaterial = function(updater) {\n        var material = this.depthFailMaterialProperty;\n        var updaterMaterial = updater.depthFailMaterialProperty;\n        if (updaterMaterial === material) {\n            return true;\n        }\n        if (defined(material)) {\n            return material.equals(updaterMaterial);\n        }\n        return false;\n    };\n\n    Batch.prototype.add = function(updater, instance) {\n        var id = updater.id;\n        this.createPrimitive = true;\n        this.geometry.set(id, instance);\n        this.updaters.set(id, updater);\n        if (!updater.hasConstantFill || !updater.fillMaterialProperty.isConstant || !Property.isConstant(updater.distanceDisplayConditionProperty) || !Property.isConstant(updater.terrainOffsetProperty)) {\n            this.updatersWithAttributes.set(id, updater);\n        } else {\n            var that = this;\n            this.subscriptions.set(id, updater.entity.definitionChanged.addEventListener(function(entity, propertyName, newValue, oldValue) {\n                if (propertyName === 'isShowing') {\n                    that.showsUpdated.set(updater.id, updater);\n                }\n            }));\n        }\n    };\n\n    Batch.prototype.remove = function(updater) {\n        var id = updater.id;\n        this.createPrimitive = this.geometry.remove(id) || this.createPrimitive;\n        if (this.updaters.remove(id)) {\n            this.updatersWithAttributes.remove(id);\n            var unsubscribe = this.subscriptions.get(id);\n            if (defined(unsubscribe)) {\n                unsubscribe();\n                this.subscriptions.remove(id);\n                this.showsUpdated.remove(id);\n            }\n            return true;\n        }\n        return false;\n    };\n\n    Batch.prototype.update = function(time) {\n        var isUpdated = true;\n        var removedCount = 0;\n        var primitive = this.primitive;\n        var primitives = this.primitives;\n        var i;\n\n        if (this.createPrimitive) {\n            var geometries = this.geometry.values;\n            var geometriesLength = geometries.length;\n            if (geometriesLength > 0) {\n                if (defined(primitive)) {\n                    if (!defined(this.oldPrimitive)) {\n                        this.oldPrimitive = primitive;\n                    } else {\n                        primitives.remove(primitive);\n                    }\n                }\n\n                var depthFailAppearance;\n                if (defined(this.depthFailAppearanceType)) {\n                    if (defined(this.depthFailMaterialProperty)) {\n                        this.depthFailMaterial = MaterialProperty.getValue(time, this.depthFailMaterialProperty, this.depthFailMaterial);\n                    }\n                    depthFailAppearance = new this.depthFailAppearanceType({\n                        material : this.depthFailMaterial,\n                        translucent : this.translucent,\n                        closed : this.closed\n                    });\n                }\n\n                primitive = new Primitive({\n                    show : false,\n                    asynchronous : true,\n                    geometryInstances : geometries.slice(),\n                    appearance : new this.appearanceType({\n                        translucent : this.translucent,\n                        closed : this.closed\n                    }),\n                    depthFailAppearance : depthFailAppearance,\n                    shadows : this.shadows\n                });\n                primitives.add(primitive);\n                isUpdated = false;\n            } else {\n                if (defined(primitive)) {\n                    primitives.remove(primitive);\n                    primitive = undefined;\n                }\n                var oldPrimitive = this.oldPrimitive;\n                if (defined(oldPrimitive)) {\n                    primitives.remove(oldPrimitive);\n                    this.oldPrimitive = undefined;\n                }\n            }\n\n            this.attributes.removeAll();\n            this.primitive = primitive;\n            this.createPrimitive = false;\n            this.waitingOnCreate = true;\n        } else if (defined(primitive) && primitive.ready) {\n            primitive.show = true;\n            if (defined(this.oldPrimitive)) {\n                primitives.remove(this.oldPrimitive);\n                this.oldPrimitive = undefined;\n            }\n\n            if (defined(this.depthFailAppearanceType) && !(this.depthFailMaterialProperty instanceof ColorMaterialProperty)) {\n                this.depthFailMaterial = MaterialProperty.getValue(time, this.depthFailMaterialProperty, this.depthFailMaterial);\n                this.primitive.depthFailAppearance.material = this.depthFailMaterial;\n            }\n\n            var updatersWithAttributes = this.updatersWithAttributes.values;\n            var length = updatersWithAttributes.length;\n            var waitingOnCreate = this.waitingOnCreate;\n            for (i = 0; i < length; i++) {\n                var updater = updatersWithAttributes[i];\n                var instance = this.geometry.get(updater.id);\n\n                var attributes = this.attributes.get(instance.id.id);\n                if (!defined(attributes)) {\n                    attributes = primitive.getGeometryInstanceAttributes(instance.id);\n                    this.attributes.set(instance.id.id, attributes);\n                }\n\n                if (!updater.fillMaterialProperty.isConstant || waitingOnCreate) {\n                    var colorProperty = updater.fillMaterialProperty.color;\n                    var resultColor = Property.getValueOrDefault(colorProperty, time, Color.WHITE, colorScratch);\n                    if (!Color.equals(attributes._lastColor, resultColor)) {\n                        attributes._lastColor = Color.clone(resultColor, attributes._lastColor);\n                        attributes.color = ColorGeometryInstanceAttribute.toValue(resultColor, attributes.color);\n                        if ((this.translucent && attributes.color[3] === 255) || (!this.translucent && attributes.color[3] !== 255)) {\n                            this.itemsToRemove[removedCount++] = updater;\n                        }\n                    }\n                }\n\n                if (defined(this.depthFailAppearanceType) && updater.depthFailMaterialProperty instanceof ColorMaterialProperty && (!updater.depthFailMaterialProperty.isConstant || waitingOnCreate)) {\n                    var depthFailColorProperty = updater.depthFailMaterialProperty.color;\n                    var depthColor = Property.getValueOrDefault(depthFailColorProperty, time, Color.WHITE, colorScratch);\n                    if (!Color.equals(attributes._lastDepthFailColor, depthColor)) {\n                        attributes._lastDepthFailColor = Color.clone(depthColor, attributes._lastDepthFailColor);\n                        attributes.depthFailColor = ColorGeometryInstanceAttribute.toValue(depthColor, attributes.depthFailColor);\n                    }\n                }\n\n                var show = updater.entity.isShowing && (updater.hasConstantFill || updater.isFilled(time));\n                var currentShow = attributes.show[0] === 1;\n                if (show !== currentShow) {\n                    attributes.show = ShowGeometryInstanceAttribute.toValue(show, attributes.show);\n                }\n\n                var distanceDisplayConditionProperty = updater.distanceDisplayConditionProperty;\n                if (!Property.isConstant(distanceDisplayConditionProperty)) {\n                    var distanceDisplayCondition = Property.getValueOrDefault(distanceDisplayConditionProperty, time, defaultDistanceDisplayCondition, distanceDisplayConditionScratch);\n                    if (!DistanceDisplayCondition.equals(distanceDisplayCondition, attributes._lastDistanceDisplayCondition)) {\n                        attributes._lastDistanceDisplayCondition = DistanceDisplayCondition.clone(distanceDisplayCondition, attributes._lastDistanceDisplayCondition);\n                        attributes.distanceDisplayCondition = DistanceDisplayConditionGeometryInstanceAttribute.toValue(distanceDisplayCondition, attributes.distanceDisplayCondition);\n                    }\n                }\n\n                var offsetProperty = updater.terrainOffsetProperty;\n                if (!Property.isConstant(offsetProperty)) {\n                    var offset = Property.getValueOrDefault(offsetProperty, time, defaultOffset, offsetScratch);\n                    if (!Cartesian3.equals(offset, attributes._lastOffset)) {\n                        attributes._lastOffset = Cartesian3.clone(offset, attributes._lastOffset);\n                        attributes.offset = OffsetGeometryInstanceAttribute.toValue(offset, attributes.offset);\n                    }\n                }\n            }\n\n            this.updateShows(primitive);\n            this.waitingOnCreate = false;\n        } else if (defined(primitive) && !primitive.ready) {\n            isUpdated = false;\n        }\n        this.itemsToRemove.length = removedCount;\n        return isUpdated;\n    };\n\n    Batch.prototype.updateShows = function(primitive) {\n        var showsUpdated = this.showsUpdated.values;\n        var length = showsUpdated.length;\n        for (var i = 0; i < length; i++) {\n            var updater = showsUpdated[i];\n            var instance = this.geometry.get(updater.id);\n\n            var attributes = this.attributes.get(instance.id.id);\n            if (!defined(attributes)) {\n                attributes = primitive.getGeometryInstanceAttributes(instance.id);\n                this.attributes.set(instance.id.id, attributes);\n            }\n\n            var show = updater.entity.isShowing;\n            var currentShow = attributes.show[0] === 1;\n            if (show !== currentShow) {\n                attributes.show = ShowGeometryInstanceAttribute.toValue(show, attributes.show);\n                instance.attributes.show.value[0] = attributes.show[0];\n            }\n        }\n        this.showsUpdated.removeAll();\n    };\n\n    Batch.prototype.contains = function(updater) {\n        return this.updaters.contains(updater.id);\n    };\n\n    Batch.prototype.getBoundingSphere = function(updater, result) {\n        var primitive = this.primitive;\n        if (!primitive.ready) {\n            return BoundingSphereState.PENDING;\n        }\n        var attributes = primitive.getGeometryInstanceAttributes(updater.entity);\n        if (!defined(attributes) || !defined(attributes.boundingSphere) ||//\n            (defined(attributes.show) && attributes.show[0] === 0)) {\n            return BoundingSphereState.FAILED;\n        }\n        attributes.boundingSphere.clone(result);\n        return BoundingSphereState.DONE;\n    };\n\n    Batch.prototype.destroy = function() {\n        var primitive = this.primitive;\n        var primitives = this.primitives;\n        if (defined(primitive)) {\n            primitives.remove(primitive);\n        }\n        var oldPrimitive = this.oldPrimitive;\n        if (defined(oldPrimitive)) {\n            primitives.remove(oldPrimitive);\n        }\n        if (defined(this.removeMaterialSubscription)) {\n            this.removeMaterialSubscription();\n        }\n    };\n\n    /**\n     * @private\n     */\n    function StaticGeometryColorBatch(primitives, appearanceType, depthFailAppearanceType, closed, shadows) {\n        this._solidItems = [];\n        this._translucentItems = [];\n        this._primitives = primitives;\n        this._appearanceType = appearanceType;\n        this._depthFailAppearanceType = depthFailAppearanceType;\n        this._closed = closed;\n        this._shadows = shadows;\n    }\n\n    StaticGeometryColorBatch.prototype.add = function(time, updater) {\n        var items;\n        var translucent;\n        var instance = updater.createFillGeometryInstance(time);\n        if (instance.attributes.color.value[3] === 255) {\n            items = this._solidItems;\n            translucent = false;\n        } else {\n            items = this._translucentItems;\n            translucent = true;\n        }\n\n        var length = items.length;\n        for (var i = 0; i < length; i++) {\n            var item = items[i];\n            if (item.isMaterial(updater)) {\n                item.add(updater, instance);\n                return;\n            }\n        }\n        var batch = new Batch(this._primitives, translucent, this._appearanceType, this._depthFailAppearanceType, updater.depthFailMaterialProperty, this._closed, this._shadows);\n        batch.add(updater, instance);\n        items.push(batch);\n    };\n\n    function removeItem(items, updater) {\n        var length = items.length;\n        for (var i = length - 1; i >= 0; i--) {\n            var item = items[i];\n            if (item.remove(updater)) {\n                if (item.updaters.length === 0) {\n                    items.splice(i, 1);\n                    item.destroy();\n                }\n                return true;\n            }\n        }\n        return false;\n    }\n\n    StaticGeometryColorBatch.prototype.remove = function(updater) {\n        if (!removeItem(this._solidItems, updater)) {\n            removeItem(this._translucentItems, updater);\n        }\n    };\n\n    function moveItems(batch, items, time) {\n        var itemsMoved = false;\n        var length = items.length;\n        for (var i = 0; i < length; ++i) {\n            var item = items[i];\n            var itemsToRemove = item.itemsToRemove;\n            var itemsToMoveLength = itemsToRemove.length;\n            if (itemsToMoveLength > 0) {\n                for (i = 0; i < itemsToMoveLength; i++) {\n                    var updater = itemsToRemove[i];\n                    item.remove(updater);\n                    batch.add(time, updater);\n                    itemsMoved = true;\n                }\n            }\n        }\n        return itemsMoved;\n    }\n\n    function updateItems(batch, items, time, isUpdated) {\n        var length = items.length;\n        var i;\n        for (i = length - 1; i >= 0; i--) {\n            var item = items[i];\n            if (item.invalidated) {\n                items.splice(i, 1);\n                var updaters = item.updaters.values;\n                var updatersLength = updaters.length;\n                for (var h = 0; h < updatersLength; h++) {\n                    batch.add(time, updaters[h]);\n                }\n                item.destroy();\n            }\n        }\n\n        length = items.length;\n        for (i = 0; i < length; ++i) {\n            isUpdated = items[i].update(time) && isUpdated;\n        }\n        return isUpdated;\n    }\n\n    StaticGeometryColorBatch.prototype.update = function(time) {\n        //Perform initial update\n        var isUpdated = updateItems(this, this._solidItems, time, true);\n        isUpdated = updateItems(this, this._translucentItems, time, isUpdated) && isUpdated;\n\n        //If any items swapped between solid/translucent, we need to\n        //move them between batches\n        var solidsMoved = moveItems(this, this._solidItems, time);\n        var translucentsMoved = moveItems(this, this._translucentItems, time);\n\n        //If we moved anything around, we need to re-build the primitive\n        if (solidsMoved || translucentsMoved) {\n            isUpdated = updateItems(this, this._solidItems, time, isUpdated) && isUpdated;\n            isUpdated = updateItems(this, this._translucentItems, time, isUpdated)&& isUpdated;\n        }\n\n        return isUpdated;\n    };\n\n    function getBoundingSphere(items, updater, result) {\n        var length = items.length;\n        for (var i = 0; i < length; i++) {\n            var item = items[i];\n            if (item.contains(updater)){\n                return item.getBoundingSphere(updater, result);\n            }\n        }\n        return BoundingSphereState.FAILED;\n    }\n\n    StaticGeometryColorBatch.prototype.getBoundingSphere = function(updater, result) {\n        var boundingSphere = getBoundingSphere(this._solidItems, updater, result);\n        if (boundingSphere === BoundingSphereState.FAILED) {\n            return getBoundingSphere(this._translucentItems, updater, result);\n        }\n        return boundingSphere;\n    };\n\n    function removeAllPrimitives(items) {\n        var length = items.length;\n        for (var i = 0; i < length; i++) {\n            items[i].destroy();\n        }\n        items.length = 0;\n    }\n\n    StaticGeometryColorBatch.prototype.removeAllPrimitives = function() {\n        removeAllPrimitives(this._solidItems);\n        removeAllPrimitives(this._translucentItems);\n    };\nexport default StaticGeometryColorBatch;\n","import AssociativeArray from '../Core/AssociativeArray.js';\nimport Cartesian3 from '../Core/Cartesian3.js';\nimport Color from '../Core/Color.js';\nimport ColorGeometryInstanceAttribute from '../Core/ColorGeometryInstanceAttribute.js';\nimport defined from '../Core/defined.js';\nimport DistanceDisplayCondition from '../Core/DistanceDisplayCondition.js';\nimport DistanceDisplayConditionGeometryInstanceAttribute from '../Core/DistanceDisplayConditionGeometryInstanceAttribute.js';\nimport OffsetGeometryInstanceAttribute from '../Core/OffsetGeometryInstanceAttribute.js';\nimport ShowGeometryInstanceAttribute from '../Core/ShowGeometryInstanceAttribute.js';\nimport Primitive from '../Scene/Primitive.js';\nimport BoundingSphereState from './BoundingSphereState.js';\nimport ColorMaterialProperty from './ColorMaterialProperty.js';\nimport MaterialProperty from './MaterialProperty.js';\nimport Property from './Property.js';\n\n    var distanceDisplayConditionScratch = new DistanceDisplayCondition();\n    var defaultDistanceDisplayCondition = new DistanceDisplayCondition();\n    var defaultOffset = Cartesian3.ZERO;\n    var offsetScratch = new Cartesian3();\n\n    function Batch(primitives, appearanceType, materialProperty, depthFailAppearanceType, depthFailMaterialProperty, closed, shadows) {\n        this.primitives = primitives;\n        this.appearanceType = appearanceType;\n        this.materialProperty = materialProperty;\n        this.depthFailAppearanceType = depthFailAppearanceType;\n        this.depthFailMaterialProperty = depthFailMaterialProperty;\n        this.closed = closed;\n        this.shadows = shadows;\n        this.updaters = new AssociativeArray();\n        this.createPrimitive = true;\n        this.primitive = undefined;\n        this.oldPrimitive = undefined;\n        this.geometry = new AssociativeArray();\n        this.material = undefined;\n        this.depthFailMaterial = undefined;\n        this.updatersWithAttributes = new AssociativeArray();\n        this.attributes = new AssociativeArray();\n        this.invalidated = false;\n        this.removeMaterialSubscription = materialProperty.definitionChanged.addEventListener(Batch.prototype.onMaterialChanged, this);\n        this.subscriptions = new AssociativeArray();\n        this.showsUpdated = new AssociativeArray();\n    }\n\n    Batch.prototype.onMaterialChanged = function() {\n        this.invalidated = true;\n    };\n\n    Batch.prototype.isMaterial = function(updater) {\n        var material = this.materialProperty;\n        var updaterMaterial = updater.fillMaterialProperty;\n        var depthFailMaterial = this.depthFailMaterialProperty;\n        var updaterDepthFailMaterial = updater.depthFailMaterialProperty;\n\n        if (updaterMaterial === material && updaterDepthFailMaterial === depthFailMaterial) {\n            return true;\n        }\n        var equals = defined(material) && material.equals(updaterMaterial);\n        equals = ((!defined(depthFailMaterial) && !defined(updaterDepthFailMaterial)) || (defined(depthFailMaterial) && depthFailMaterial.equals(updaterDepthFailMaterial))) && equals;\n        return equals;\n    };\n\n    Batch.prototype.add = function(time, updater) {\n        var id = updater.id;\n        this.updaters.set(id, updater);\n        this.geometry.set(id, updater.createFillGeometryInstance(time));\n        if (!updater.hasConstantFill || !updater.fillMaterialProperty.isConstant || !Property.isConstant(updater.distanceDisplayConditionProperty)  || !Property.isConstant(updater.terrainOffsetProperty)) {\n            this.updatersWithAttributes.set(id, updater);\n        } else {\n            var that = this;\n            this.subscriptions.set(id, updater.entity.definitionChanged.addEventListener(function(entity, propertyName, newValue, oldValue) {\n                if (propertyName === 'isShowing') {\n                    that.showsUpdated.set(updater.id, updater);\n                }\n            }));\n        }\n        this.createPrimitive = true;\n    };\n\n    Batch.prototype.remove = function(updater) {\n        var id = updater.id;\n        this.createPrimitive = this.geometry.remove(id) || this.createPrimitive;\n        if (this.updaters.remove(id)) {\n            this.updatersWithAttributes.remove(id);\n            var unsubscribe = this.subscriptions.get(id);\n            if (defined(unsubscribe)) {\n                unsubscribe();\n                this.subscriptions.remove(id);\n                this.showsUpdated.remove(id);\n            }\n            return true;\n        }\n        return false;\n    };\n\n    var colorScratch = new Color();\n\n    Batch.prototype.update = function(time) {\n        var isUpdated = true;\n        var primitive = this.primitive;\n        var primitives = this.primitives;\n        var geometries = this.geometry.values;\n        var i;\n\n        if (this.createPrimitive) {\n            var geometriesLength = geometries.length;\n            if (geometriesLength > 0) {\n                if (defined(primitive)) {\n                    if (!defined(this.oldPrimitive)) {\n                        this.oldPrimitive = primitive;\n                    } else {\n                        primitives.remove(primitive);\n                    }\n                }\n\n                this.material = MaterialProperty.getValue(time, this.materialProperty, this.material);\n\n                var depthFailAppearance;\n                if (defined(this.depthFailMaterialProperty)) {\n                    this.depthFailMaterial = MaterialProperty.getValue(time, this.depthFailMaterialProperty, this.depthFailMaterial);\n                    depthFailAppearance = new this.depthFailAppearanceType({\n                        material : this.depthFailMaterial,\n                        translucent : this.depthFailMaterial.isTranslucent(),\n                        closed : this.closed\n                    });\n                }\n\n                primitive = new Primitive({\n                    show : false,\n                    asynchronous : true,\n                    geometryInstances : geometries.slice(),\n                    appearance : new this.appearanceType({\n                        material : this.material,\n                        translucent : this.material.isTranslucent(),\n                        closed : this.closed\n                    }),\n                    depthFailAppearance : depthFailAppearance,\n                    shadows : this.shadows\n                });\n\n                primitives.add(primitive);\n                isUpdated = false;\n            } else {\n                if (defined(primitive)) {\n                    primitives.remove(primitive);\n                    primitive = undefined;\n                }\n                var oldPrimitive = this.oldPrimitive;\n                if (defined(oldPrimitive)) {\n                    primitives.remove(oldPrimitive);\n                    this.oldPrimitive = undefined;\n                }\n            }\n\n            this.attributes.removeAll();\n            this.primitive = primitive;\n            this.createPrimitive = false;\n        } else if (defined(primitive) && primitive.ready) {\n            primitive.show = true;\n            if (defined(this.oldPrimitive)) {\n                primitives.remove(this.oldPrimitive);\n                this.oldPrimitive = undefined;\n            }\n\n            this.material = MaterialProperty.getValue(time, this.materialProperty, this.material);\n            this.primitive.appearance.material = this.material;\n\n            if (defined(this.depthFailAppearanceType) && !(this.depthFailMaterialProperty instanceof ColorMaterialProperty)) {\n                this.depthFailMaterial = MaterialProperty.getValue(time, this.depthFailMaterialProperty, this.depthFailMaterial);\n                this.primitive.depthFailAppearance.material = this.depthFailMaterial;\n            }\n\n            var updatersWithAttributes = this.updatersWithAttributes.values;\n            var length = updatersWithAttributes.length;\n            for (i = 0; i < length; i++) {\n                var updater = updatersWithAttributes[i];\n                var entity = updater.entity;\n                var instance = this.geometry.get(updater.id);\n\n                var attributes = this.attributes.get(instance.id.id);\n                if (!defined(attributes)) {\n                    attributes = primitive.getGeometryInstanceAttributes(instance.id);\n                    this.attributes.set(instance.id.id, attributes);\n                }\n\n                if (defined(this.depthFailAppearanceType) && this.depthFailMaterialProperty instanceof ColorMaterialProperty && !updater.depthFailMaterialProperty.isConstant) {\n                    var depthFailColorProperty = updater.depthFailMaterialProperty.color;\n                    var depthFailColor = Property.getValueOrDefault(depthFailColorProperty, time, Color.WHITE, colorScratch);\n                    if (!Color.equals(attributes._lastDepthFailColor, depthFailColor)) {\n                        attributes._lastDepthFailColor = Color.clone(depthFailColor, attributes._lastDepthFailColor);\n                        attributes.depthFailColor = ColorGeometryInstanceAttribute.toValue(depthFailColor, attributes.depthFailColor);\n                    }\n                }\n\n                var show = entity.isShowing && (updater.hasConstantFill || updater.isFilled(time));\n                var currentShow = attributes.show[0] === 1;\n                if (show !== currentShow) {\n                    attributes.show = ShowGeometryInstanceAttribute.toValue(show, attributes.show);\n                }\n\n                var distanceDisplayConditionProperty = updater.distanceDisplayConditionProperty;\n                if (!Property.isConstant(distanceDisplayConditionProperty)) {\n                    var distanceDisplayCondition = Property.getValueOrDefault(distanceDisplayConditionProperty, time, defaultDistanceDisplayCondition, distanceDisplayConditionScratch);\n                    if (!DistanceDisplayCondition.equals(distanceDisplayCondition, attributes._lastDistanceDisplayCondition)) {\n                        attributes._lastDistanceDisplayCondition = DistanceDisplayCondition.clone(distanceDisplayCondition, attributes._lastDistanceDisplayCondition);\n                        attributes.distanceDisplayCondition = DistanceDisplayConditionGeometryInstanceAttribute.toValue(distanceDisplayCondition, attributes.distanceDisplayCondition);\n                    }\n                }\n\n                var offsetProperty = updater.terrainOffsetProperty;\n                if (!Property.isConstant(offsetProperty)) {\n                    var offset = Property.getValueOrDefault(offsetProperty, time, defaultOffset, offsetScratch);\n                    if (!Cartesian3.equals(offset, attributes._lastOffset)) {\n                        attributes._lastOffset = Cartesian3.clone(offset, attributes._lastOffset);\n                        attributes.offset = OffsetGeometryInstanceAttribute.toValue(offset, attributes.offset);\n                    }\n                }\n            }\n\n            this.updateShows(primitive);\n        } else if (defined(primitive) && !primitive.ready) {\n            isUpdated = false;\n        }\n        return isUpdated;\n    };\n\n    Batch.prototype.updateShows = function(primitive) {\n        var showsUpdated = this.showsUpdated.values;\n        var length = showsUpdated.length;\n        for (var i = 0; i < length; i++) {\n            var updater = showsUpdated[i];\n            var entity = updater.entity;\n            var instance = this.geometry.get(updater.id);\n\n            var attributes = this.attributes.get(instance.id.id);\n            if (!defined(attributes)) {\n                attributes = primitive.getGeometryInstanceAttributes(instance.id);\n                this.attributes.set(instance.id.id, attributes);\n            }\n\n            var show = entity.isShowing;\n            var currentShow = attributes.show[0] === 1;\n            if (show !== currentShow) {\n                attributes.show = ShowGeometryInstanceAttribute.toValue(show, attributes.show);\n                instance.attributes.show.value[0] = attributes.show[0];\n            }\n        }\n        this.showsUpdated.removeAll();\n    };\n\n    Batch.prototype.contains = function(updater) {\n        return this.updaters.contains(updater.id);\n    };\n\n    Batch.prototype.getBoundingSphere = function(updater, result) {\n        var primitive = this.primitive;\n        if (!primitive.ready) {\n            return BoundingSphereState.PENDING;\n        }\n        var attributes = primitive.getGeometryInstanceAttributes(updater.entity);\n        if (!defined(attributes) || !defined(attributes.boundingSphere) ||\n            (defined(attributes.show) && attributes.show[0] === 0)) {\n            return BoundingSphereState.FAILED;\n        }\n        attributes.boundingSphere.clone(result);\n        return BoundingSphereState.DONE;\n    };\n\n    Batch.prototype.destroy = function() {\n        var primitive = this.primitive;\n        var primitives = this.primitives;\n        if (defined(primitive)) {\n            primitives.remove(primitive);\n        }\n        var oldPrimitive = this.oldPrimitive;\n        if (defined(oldPrimitive)) {\n            primitives.remove(oldPrimitive);\n        }\n        this.removeMaterialSubscription();\n    };\n\n    /**\n     * @private\n     */\n    function StaticGeometryPerMaterialBatch(primitives, appearanceType, depthFailAppearanceType, closed, shadows) {\n        this._items = [];\n        this._primitives = primitives;\n        this._appearanceType = appearanceType;\n        this._depthFailAppearanceType = depthFailAppearanceType;\n        this._closed = closed;\n        this._shadows = shadows;\n    }\n\n    StaticGeometryPerMaterialBatch.prototype.add = function(time, updater) {\n        var items = this._items;\n        var length = items.length;\n        for (var i = 0; i < length; i++) {\n            var item = items[i];\n            if (item.isMaterial(updater)) {\n                item.add(time, updater);\n                return;\n            }\n        }\n        var batch = new Batch(this._primitives, this._appearanceType, updater.fillMaterialProperty, this._depthFailAppearanceType, updater.depthFailMaterialProperty, this._closed, this._shadows);\n        batch.add(time, updater);\n        items.push(batch);\n    };\n\n    StaticGeometryPerMaterialBatch.prototype.remove = function(updater) {\n        var items = this._items;\n        var length = items.length;\n        for (var i = length - 1; i >= 0; i--) {\n            var item = items[i];\n            if (item.remove(updater)) {\n                if (item.updaters.length === 0) {\n                    items.splice(i, 1);\n                    item.destroy();\n                }\n                break;\n            }\n        }\n    };\n\n    StaticGeometryPerMaterialBatch.prototype.update = function(time) {\n        var i;\n        var items = this._items;\n        var length = items.length;\n\n        for (i = length - 1; i >= 0; i--) {\n            var item = items[i];\n            if (item.invalidated) {\n                items.splice(i, 1);\n                var updaters = item.updaters.values;\n                var updatersLength = updaters.length;\n                for (var h = 0; h < updatersLength; h++) {\n                    this.add(time, updaters[h]);\n                }\n                item.destroy();\n            }\n        }\n\n        var isUpdated = true;\n        for (i = 0; i < items.length; i++) {\n            isUpdated = items[i].update(time) && isUpdated;\n        }\n        return isUpdated;\n    };\n\n    StaticGeometryPerMaterialBatch.prototype.getBoundingSphere = function(updater, result) {\n        var items = this._items;\n        var length = items.length;\n        for (var i = 0; i < length; i++) {\n            var item = items[i];\n            if (item.contains(updater)){\n                return item.getBoundingSphere(updater, result);\n            }\n        }\n        return BoundingSphereState.FAILED;\n    };\n\n    StaticGeometryPerMaterialBatch.prototype.removeAllPrimitives = function() {\n        var items = this._items;\n        var length = items.length;\n        for (var i = 0; i < length; i++) {\n            items[i].destroy();\n        }\n        this._items.length = 0;\n    };\nexport default StaticGeometryPerMaterialBatch;\n","import AssociativeArray from '../Core/AssociativeArray.js';\nimport Color from '../Core/Color.js';\nimport defined from '../Core/defined.js';\nimport DistanceDisplayCondition from '../Core/DistanceDisplayCondition.js';\nimport DistanceDisplayConditionGeometryInstanceAttribute from '../Core/DistanceDisplayConditionGeometryInstanceAttribute.js';\nimport ShowGeometryInstanceAttribute from '../Core/ShowGeometryInstanceAttribute.js';\nimport GroundPrimitive from '../Scene/GroundPrimitive.js';\nimport BoundingSphereState from './BoundingSphereState.js';\nimport Property from './Property.js';\n\n    var colorScratch = new Color();\n    var distanceDisplayConditionScratch = new DistanceDisplayCondition();\n    var defaultDistanceDisplayCondition = new DistanceDisplayCondition();\n\n    function Batch(primitives, classificationType, color, key, zIndex) {\n        this.primitives = primitives;\n        this.zIndex = zIndex;\n        this.classificationType = classificationType;\n        this.color = color;\n        this.key = key;\n        this.createPrimitive = false;\n        this.waitingOnCreate = false;\n        this.primitive = undefined;\n        this.oldPrimitive = undefined;\n        this.geometry = new AssociativeArray();\n        this.updaters = new AssociativeArray();\n        this.updatersWithAttributes = new AssociativeArray();\n        this.attributes = new AssociativeArray();\n        this.subscriptions = new AssociativeArray();\n        this.showsUpdated = new AssociativeArray();\n        this.itemsToRemove = [];\n        this.isDirty = false;\n    }\n\n    Batch.prototype.add = function(updater, instance) {\n        var id = updater.id;\n        this.createPrimitive = true;\n        this.geometry.set(id, instance);\n        this.updaters.set(id, updater);\n        if (!updater.hasConstantFill || !updater.fillMaterialProperty.isConstant || !Property.isConstant(updater.distanceDisplayConditionProperty)) {\n            this.updatersWithAttributes.set(id, updater);\n        } else {\n            var that = this;\n            this.subscriptions.set(id, updater.entity.definitionChanged.addEventListener(function(entity, propertyName, newValue, oldValue) {\n                if (propertyName === 'isShowing') {\n                    that.showsUpdated.set(updater.id, updater);\n                }\n            }));\n        }\n    };\n\n    Batch.prototype.remove = function(updater) {\n        var id = updater.id;\n        this.createPrimitive = this.geometry.remove(id) || this.createPrimitive;\n        if (this.updaters.remove(id)) {\n            this.updatersWithAttributes.remove(id);\n            var unsubscribe = this.subscriptions.get(id);\n            if (defined(unsubscribe)) {\n                unsubscribe();\n                this.subscriptions.remove(id);\n                this.showsUpdated.remove(id);\n            }\n            return true;\n        }\n        return false;\n    };\n\n    var scratchArray = new Array(4);\n\n    Batch.prototype.update = function(time) {\n        var isUpdated = true;\n        var removedCount = 0;\n        var primitive = this.primitive;\n        var primitives = this.primitives;\n        var i;\n\n        if (this.createPrimitive) {\n            var geometries = this.geometry.values;\n            var geometriesLength = geometries.length;\n            if (geometriesLength > 0) {\n                if (defined(primitive)) {\n                    if (!defined(this.oldPrimitive)) {\n                        this.oldPrimitive = primitive;\n                    } else {\n                        primitives.remove(primitive);\n                    }\n                }\n\n                primitive = new GroundPrimitive({\n                    show : false,\n                    asynchronous : true,\n                    geometryInstances : geometries.slice(),\n                    classificationType : this.classificationType\n                });\n                primitives.add(primitive, this.zIndex);\n                isUpdated = false;\n            } else {\n                if (defined(primitive)) {\n                    primitives.remove(primitive);\n                    primitive = undefined;\n                }\n                var oldPrimitive = this.oldPrimitive;\n                if (defined(oldPrimitive)) {\n                    primitives.remove(oldPrimitive);\n                    this.oldPrimitive = undefined;\n                }\n            }\n\n            this.attributes.removeAll();\n            this.primitive = primitive;\n            this.createPrimitive = false;\n            this.waitingOnCreate = true;\n        } else if (defined(primitive) && primitive.ready) {\n            primitive.show = true;\n            if (defined(this.oldPrimitive)) {\n                primitives.remove(this.oldPrimitive);\n                this.oldPrimitive = undefined;\n            }\n            var updatersWithAttributes = this.updatersWithAttributes.values;\n            var length = updatersWithAttributes.length;\n            var waitingOnCreate = this.waitingOnCreate;\n            for (i = 0; i < length; i++) {\n                var updater = updatersWithAttributes[i];\n                var instance = this.geometry.get(updater.id);\n\n                var attributes = this.attributes.get(instance.id.id);\n                if (!defined(attributes)) {\n                    attributes = primitive.getGeometryInstanceAttributes(instance.id);\n                    this.attributes.set(instance.id.id, attributes);\n                }\n\n                if (!updater.fillMaterialProperty.isConstant || waitingOnCreate) {\n                    var colorProperty = updater.fillMaterialProperty.color;\n                    var fillColor = Property.getValueOrDefault(colorProperty, time, Color.WHITE, colorScratch);\n\n                    if (!Color.equals(attributes._lastColor, fillColor)) {\n                        attributes._lastColor = Color.clone(fillColor, attributes._lastColor);\n                        var color = this.color;\n                        var newColor = fillColor.toBytes(scratchArray);\n                        if (color[0] !== newColor[0] || color[1] !== newColor[1] ||\n                            color[2] !== newColor[2] || color[3] !== newColor[3]) {\n                           this.itemsToRemove[removedCount++] = updater;\n                        }\n                    }\n                }\n\n                var show = updater.entity.isShowing && (updater.hasConstantFill || updater.isFilled(time));\n                var currentShow = attributes.show[0] === 1;\n                if (show !== currentShow) {\n                    attributes.show = ShowGeometryInstanceAttribute.toValue(show, attributes.show);\n                }\n\n                var distanceDisplayConditionProperty = updater.distanceDisplayConditionProperty;\n                if (!Property.isConstant(distanceDisplayConditionProperty)) {\n                    var distanceDisplayCondition = Property.getValueOrDefault(distanceDisplayConditionProperty, time, defaultDistanceDisplayCondition, distanceDisplayConditionScratch);\n                    if (!DistanceDisplayCondition.equals(distanceDisplayCondition, attributes._lastDistanceDisplayCondition)) {\n                        attributes._lastDistanceDisplayCondition = DistanceDisplayCondition.clone(distanceDisplayCondition, attributes._lastDistanceDisplayCondition);\n                        attributes.distanceDisplayCondition = DistanceDisplayConditionGeometryInstanceAttribute.toValue(distanceDisplayCondition, attributes.distanceDisplayCondition);\n                    }\n                }\n            }\n\n            this.updateShows(primitive);\n            this.waitingOnCreate = false;\n        } else if (defined(primitive) && !primitive.ready) {\n            isUpdated = false;\n        }\n        this.itemsToRemove.length = removedCount;\n        return isUpdated;\n    };\n\n    Batch.prototype.updateShows = function(primitive) {\n        var showsUpdated = this.showsUpdated.values;\n        var length = showsUpdated.length;\n        for (var i = 0; i < length; i++) {\n            var updater = showsUpdated[i];\n            var instance = this.geometry.get(updater.id);\n\n            var attributes = this.attributes.get(instance.id.id);\n            if (!defined(attributes)) {\n                attributes = primitive.getGeometryInstanceAttributes(instance.id);\n                this.attributes.set(instance.id.id, attributes);\n            }\n\n            var show = updater.entity.isShowing;\n            var currentShow = attributes.show[0] === 1;\n            if (show !== currentShow) {\n                attributes.show = ShowGeometryInstanceAttribute.toValue(show, attributes.show);\n                instance.attributes.show.value[0] = attributes.show[0];\n            }\n        }\n        this.showsUpdated.removeAll();\n    };\n\n    Batch.prototype.contains = function(updater) {\n        return this.updaters.contains(updater.id);\n    };\n\n    Batch.prototype.getBoundingSphere = function(updater, result) {\n        var primitive = this.primitive;\n        if (!primitive.ready) {\n            return BoundingSphereState.PENDING;\n        }\n\n        var bs = primitive.getBoundingSphere(updater.entity);\n        if (!defined(bs)) {\n            return BoundingSphereState.FAILED;\n        }\n\n        bs.clone(result);\n        return BoundingSphereState.DONE;\n    };\n\n    Batch.prototype.removeAllPrimitives = function() {\n        var primitives = this.primitives;\n\n        var primitive = this.primitive;\n        if (defined(primitive)) {\n            primitives.remove(primitive);\n            this.primitive = undefined;\n            this.geometry.removeAll();\n            this.updaters.removeAll();\n        }\n\n        var oldPrimitive = this.oldPrimitive;\n        if (defined(oldPrimitive)) {\n            primitives.remove(oldPrimitive);\n            this.oldPrimitive = undefined;\n        }\n    };\n\n    /**\n     * @private\n     */\n    function StaticGroundGeometryColorBatch(primitives, classificationType) {\n        this._batches = new AssociativeArray();\n        this._primitives = primitives;\n        this._classificationType = classificationType;\n    }\n\n    StaticGroundGeometryColorBatch.prototype.add = function(time, updater) {\n        var instance = updater.createFillGeometryInstance(time);\n        var batches = this._batches;\n        // color and zIndex are batch breakers, so we'll use that for the key\n        var zIndex = Property.getValueOrDefault(updater.zIndex, 0);\n        var batchKey = new Uint32Array(instance.attributes.color.value.buffer)[0] + ':' + zIndex;\n        var batch;\n        if (batches.contains(batchKey)) {\n            batch = batches.get(batchKey);\n        } else {\n            batch = new Batch(this._primitives, this._classificationType, instance.attributes.color.value, batchKey, zIndex);\n            batches.set(batchKey, batch);\n        }\n        batch.add(updater, instance);\n        return batch;\n    };\n\n    StaticGroundGeometryColorBatch.prototype.remove = function(updater) {\n        var batchesArray = this._batches.values;\n        var count = batchesArray.length;\n        for (var i = 0; i < count; ++i) {\n            if (batchesArray[i].remove(updater)) {\n                return;\n            }\n        }\n    };\n\n    StaticGroundGeometryColorBatch.prototype.update = function(time) {\n        var i;\n        var updater;\n\n        //Perform initial update\n        var isUpdated = true;\n        var batches = this._batches;\n        var batchesArray = batches.values;\n        var batchCount = batchesArray.length;\n        for (i = 0; i < batchCount; ++i) {\n            isUpdated = batchesArray[i].update(time) && isUpdated;\n        }\n\n        //If any items swapped between batches we need to move them\n        for (i = 0; i < batchCount; ++i) {\n            var oldBatch = batchesArray[i];\n            var itemsToRemove = oldBatch.itemsToRemove;\n            var itemsToMoveLength = itemsToRemove.length;\n            for (var j = 0; j < itemsToMoveLength; j++) {\n                updater = itemsToRemove[j];\n                oldBatch.remove(updater);\n                var newBatch = this.add(time, updater);\n                oldBatch.isDirty = true;\n                newBatch.isDirty = true;\n            }\n        }\n\n        //If we moved anything around, we need to re-build the primitive and remove empty batches\n        var batchesArrayCopy = batchesArray.slice();\n        var batchesCopyCount = batchesArrayCopy.length;\n        for (i = 0; i < batchesCopyCount; ++i) {\n            var batch = batchesArrayCopy[i];\n            if (batch.isDirty) {\n                isUpdated = batchesArrayCopy[i].update(time) && isUpdated;\n                batch.isDirty = false;\n            }\n            if (batch.geometry.length === 0) {\n                batches.remove(batch.key);\n            }\n        }\n\n        return isUpdated;\n    };\n\n    StaticGroundGeometryColorBatch.prototype.getBoundingSphere = function(updater, result) {\n        var batchesArray = this._batches.values;\n        var batchCount = batchesArray.length;\n        for (var i = 0; i < batchCount; ++i) {\n            var batch = batchesArray[i];\n            if (batch.contains(updater)) {\n                return batch.getBoundingSphere(updater, result);\n            }\n        }\n\n        return BoundingSphereState.FAILED;\n    };\n\n    StaticGroundGeometryColorBatch.prototype.removeAllPrimitives = function() {\n        var batchesArray = this._batches.values;\n        var batchCount = batchesArray.length;\n        for (var i = 0; i < batchCount; ++i) {\n            batchesArray[i].removeAllPrimitives();\n        }\n    };\nexport default StaticGroundGeometryColorBatch;\n","\nfunction quickselect(arr, k, left, right, compare) {\n    quickselectStep(arr, k, left || 0, right || (arr.length - 1), compare || defaultCompare);\n};\n\nfunction quickselectStep(arr, k, left, right, compare) {\n\n    while (right > left) {\n        if (right - left > 600) {\n            var n = right - left + 1;\n            var m = k - left + 1;\n            var z = Math.log(n);\n            var s = 0.5 * Math.exp(2 * z / 3);\n            var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);\n            var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));\n            var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));\n            quickselectStep(arr, k, newLeft, newRight, compare);\n        }\n\n        var t = arr[k];\n        var i = left;\n        var j = right;\n\n        swap(arr, left, k);\n        if (compare(arr[right], t) > 0) swap(arr, left, right);\n\n        while (i < j) {\n            swap(arr, i, j);\n            i++;\n            j--;\n            while (compare(arr[i], t) < 0) i++;\n            while (compare(arr[j], t) > 0) j--;\n        }\n\n        if (compare(arr[left], t) === 0) swap(arr, left, j);\n        else {\n            j++;\n            swap(arr, j, right);\n        }\n\n        if (j <= k) left = j + 1;\n        if (k <= j) right = j - 1;\n    }\n}\n\nfunction swap(arr, i, j) {\n    var tmp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = tmp;\n}\n\nfunction defaultCompare(a, b) {\n    return a < b ? -1 : a > b ? 1 : 0;\n}\n\nexport default quickselect;\n","import quickselect from './quickselect.js';\n\nfunction rbush(maxEntries, format) {\n    if (!(this instanceof rbush)) return new rbush(maxEntries, format);\n\n    // max entries in a node is 9 by default; min node fill is 40% for best performance\n    this._maxEntries = Math.max(4, maxEntries || 9);\n    this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));\n\n    if (format) {\n        this._initFormat(format);\n    }\n\n    this.clear();\n}\n\nrbush.prototype = {\n\n    all: function () {\n        return this._all(this.data, []);\n    },\n\n    search: function (bbox) {\n\n        var node = this.data,\n            result = [],\n            toBBox = this.toBBox;\n\n        if (!intersects(bbox, node)) return result;\n\n        var nodesToSearch = [],\n            i, len, child, childBBox;\n\n        while (node) {\n            for (i = 0, len = node.children.length; i < len; i++) {\n\n                child = node.children[i];\n                childBBox = node.leaf ? toBBox(child) : child;\n\n                if (intersects(bbox, childBBox)) {\n                    if (node.leaf) result.push(child);\n                    else if (contains(bbox, childBBox)) this._all(child, result);\n                    else nodesToSearch.push(child);\n                }\n            }\n            node = nodesToSearch.pop();\n        }\n\n        return result;\n    },\n\n    collides: function (bbox) {\n\n        var node = this.data,\n            toBBox = this.toBBox;\n\n        if (!intersects(bbox, node)) return false;\n\n        var nodesToSearch = [],\n            i, len, child, childBBox;\n\n        while (node) {\n            for (i = 0, len = node.children.length; i < len; i++) {\n\n                child = node.children[i];\n                childBBox = node.leaf ? toBBox(child) : child;\n\n                if (intersects(bbox, childBBox)) {\n                    if (node.leaf || contains(bbox, childBBox)) return true;\n                    nodesToSearch.push(child);\n                }\n            }\n            node = nodesToSearch.pop();\n        }\n\n        return false;\n    },\n\n    load: function (data) {\n        if (!(data && data.length)) return this;\n\n        if (data.length < this._minEntries) {\n            for (var i = 0, len = data.length; i < len; i++) {\n                this.insert(data[i]);\n            }\n            return this;\n        }\n\n        // recursively build the tree with the given data from scratch using OMT algorithm\n        var node = this._build(data.slice(), 0, data.length - 1, 0);\n\n        if (!this.data.children.length) {\n            // save as is if tree is empty\n            this.data = node;\n\n        } else if (this.data.height === node.height) {\n            // split root if trees have the same height\n            this._splitRoot(this.data, node);\n\n        } else {\n            if (this.data.height < node.height) {\n                // swap trees if inserted one is bigger\n                var tmpNode = this.data;\n                this.data = node;\n                node = tmpNode;\n            }\n\n            // insert the small tree into the large tree at appropriate level\n            this._insert(node, this.data.height - node.height - 1, true);\n        }\n\n        return this;\n    },\n\n    insert: function (item) {\n        if (item) this._insert(item, this.data.height - 1);\n        return this;\n    },\n\n    clear: function () {\n        this.data = createNode([]);\n        return this;\n    },\n\n    remove: function (item, equalsFn) {\n        if (!item) return this;\n\n        var node = this.data,\n            bbox = this.toBBox(item),\n            path = [],\n            indexes = [],\n            i, parent, index, goingUp;\n\n        // depth-first iterative tree traversal\n        while (node || path.length) {\n\n            if (!node) { // go up\n                node = path.pop();\n                parent = path[path.length - 1];\n                i = indexes.pop();\n                goingUp = true;\n            }\n\n            if (node.leaf) { // check current node\n                index = findItem(item, node.children, equalsFn);\n\n                if (index !== -1) {\n                    // item found, remove the item and condense tree upwards\n                    node.children.splice(index, 1);\n                    path.push(node);\n                    this._condense(path);\n                    return this;\n                }\n            }\n\n            if (!goingUp && !node.leaf && contains(node, bbox)) { // go down\n                path.push(node);\n                indexes.push(i);\n                i = 0;\n                parent = node;\n                node = node.children[0];\n\n            } else if (parent) { // go right\n                i++;\n                node = parent.children[i];\n                goingUp = false;\n\n            } else node = null; // nothing found\n        }\n\n        return this;\n    },\n\n    toBBox: function (item) { return item; },\n\n    compareMinX: compareNodeMinX,\n    compareMinY: compareNodeMinY,\n\n    toJSON: function () { return this.data; },\n\n    fromJSON: function (data) {\n        this.data = data;\n        return this;\n    },\n\n    _all: function (node, result) {\n        var nodesToSearch = [];\n        while (node) {\n            if (node.leaf) result.push.apply(result, node.children);\n            else nodesToSearch.push.apply(nodesToSearch, node.children);\n\n            node = nodesToSearch.pop();\n        }\n        return result;\n    },\n\n    _build: function (items, left, right, height) {\n\n        var N = right - left + 1,\n            M = this._maxEntries,\n            node;\n\n        if (N <= M) {\n            // reached leaf level; return leaf\n            node = createNode(items.slice(left, right + 1));\n            calcBBox(node, this.toBBox);\n            return node;\n        }\n\n        if (!height) {\n            // target height of the bulk-loaded tree\n            height = Math.ceil(Math.log(N) / Math.log(M));\n\n            // target number of root entries to maximize storage utilization\n            M = Math.ceil(N / Math.pow(M, height - 1));\n        }\n\n        node = createNode([]);\n        node.leaf = false;\n        node.height = height;\n\n        // split the items into M mostly square tiles\n\n        var N2 = Math.ceil(N / M),\n            N1 = N2 * Math.ceil(Math.sqrt(M)),\n            i, j, right2, right3;\n\n        multiSelect(items, left, right, N1, this.compareMinX);\n\n        for (i = left; i <= right; i += N1) {\n\n            right2 = Math.min(i + N1 - 1, right);\n\n            multiSelect(items, i, right2, N2, this.compareMinY);\n\n            for (j = i; j <= right2; j += N2) {\n\n                right3 = Math.min(j + N2 - 1, right2);\n\n                // pack each entry recursively\n                node.children.push(this._build(items, j, right3, height - 1));\n            }\n        }\n\n        calcBBox(node, this.toBBox);\n\n        return node;\n    },\n\n    _chooseSubtree: function (bbox, node, level, path) {\n\n        var i, len, child, targetNode, area, enlargement, minArea, minEnlargement;\n\n        while (true) {\n            path.push(node);\n\n            if (node.leaf || path.length - 1 === level) break;\n\n            minArea = minEnlargement = Infinity;\n\n            for (i = 0, len = node.children.length; i < len; i++) {\n                child = node.children[i];\n                area = bboxArea(child);\n                enlargement = enlargedArea(bbox, child) - area;\n\n                // choose entry with the least area enlargement\n                if (enlargement < minEnlargement) {\n                    minEnlargement = enlargement;\n                    minArea = area < minArea ? area : minArea;\n                    targetNode = child;\n\n                } else if (enlargement === minEnlargement) {\n                    // otherwise choose one with the smallest area\n                    if (area < minArea) {\n                        minArea = area;\n                        targetNode = child;\n                    }\n                }\n            }\n\n            node = targetNode || node.children[0];\n        }\n\n        return node;\n    },\n\n    _insert: function (item, level, isNode) {\n\n        var toBBox = this.toBBox,\n            bbox = isNode ? item : toBBox(item),\n            insertPath = [];\n\n        // find the best node for accommodating the item, saving all nodes along the path too\n        var node = this._chooseSubtree(bbox, this.data, level, insertPath);\n\n        // put the item into the node\n        node.children.push(item);\n        extend(node, bbox);\n\n        // split on node overflow; propagate upwards if necessary\n        while (level >= 0) {\n            if (insertPath[level].children.length > this._maxEntries) {\n                this._split(insertPath, level);\n                level--;\n            } else break;\n        }\n\n        // adjust bboxes along the insertion path\n        this._adjustParentBBoxes(bbox, insertPath, level);\n    },\n\n    // split overflowed node into two\n    _split: function (insertPath, level) {\n\n        var node = insertPath[level],\n            M = node.children.length,\n            m = this._minEntries;\n\n        this._chooseSplitAxis(node, m, M);\n\n        var splitIndex = this._chooseSplitIndex(node, m, M);\n\n        var newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));\n        newNode.height = node.height;\n        newNode.leaf = node.leaf;\n\n        calcBBox(node, this.toBBox);\n        calcBBox(newNode, this.toBBox);\n\n        if (level) insertPath[level - 1].children.push(newNode);\n        else this._splitRoot(node, newNode);\n    },\n\n    _splitRoot: function (node, newNode) {\n        // split root node\n        this.data = createNode([node, newNode]);\n        this.data.height = node.height + 1;\n        this.data.leaf = false;\n        calcBBox(this.data, this.toBBox);\n    },\n\n    _chooseSplitIndex: function (node, m, M) {\n\n        var i, bbox1, bbox2, overlap, area, minOverlap, minArea, index;\n\n        minOverlap = minArea = Infinity;\n\n        for (i = m; i <= M - m; i++) {\n            bbox1 = distBBox(node, 0, i, this.toBBox);\n            bbox2 = distBBox(node, i, M, this.toBBox);\n\n            overlap = intersectionArea(bbox1, bbox2);\n            area = bboxArea(bbox1) + bboxArea(bbox2);\n\n            // choose distribution with minimum overlap\n            if (overlap < minOverlap) {\n                minOverlap = overlap;\n                index = i;\n\n                minArea = area < minArea ? area : minArea;\n\n            } else if (overlap === minOverlap) {\n                // otherwise choose distribution with minimum area\n                if (area < minArea) {\n                    minArea = area;\n                    index = i;\n                }\n            }\n        }\n\n        return index;\n    },\n\n    // sorts node children by the best axis for split\n    _chooseSplitAxis: function (node, m, M) {\n\n        var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX,\n            compareMinY = node.leaf ? this.compareMinY : compareNodeMinY,\n            xMargin = this._allDistMargin(node, m, M, compareMinX),\n            yMargin = this._allDistMargin(node, m, M, compareMinY);\n\n        // if total distributions margin value is minimal for x, sort by minX,\n        // otherwise it's already sorted by minY\n        if (xMargin < yMargin) node.children.sort(compareMinX);\n    },\n\n    // total margin of all possible split distributions where each node is at least m full\n    _allDistMargin: function (node, m, M, compare) {\n\n        node.children.sort(compare);\n\n        var toBBox = this.toBBox,\n            leftBBox = distBBox(node, 0, m, toBBox),\n            rightBBox = distBBox(node, M - m, M, toBBox),\n            margin = bboxMargin(leftBBox) + bboxMargin(rightBBox),\n            i, child;\n\n        for (i = m; i < M - m; i++) {\n            child = node.children[i];\n            extend(leftBBox, node.leaf ? toBBox(child) : child);\n            margin += bboxMargin(leftBBox);\n        }\n\n        for (i = M - m - 1; i >= m; i--) {\n            child = node.children[i];\n            extend(rightBBox, node.leaf ? toBBox(child) : child);\n            margin += bboxMargin(rightBBox);\n        }\n\n        return margin;\n    },\n\n    _adjustParentBBoxes: function (bbox, path, level) {\n        // adjust bboxes along the given tree path\n        for (var i = level; i >= 0; i--) {\n            extend(path[i], bbox);\n        }\n    },\n\n    _condense: function (path) {\n        // go through the path, removing empty nodes and updating bboxes\n        for (var i = path.length - 1, siblings; i >= 0; i--) {\n            if (path[i].children.length === 0) {\n                if (i > 0) {\n                    siblings = path[i - 1].children;\n                    siblings.splice(siblings.indexOf(path[i]), 1);\n\n                } else this.clear();\n\n            } else calcBBox(path[i], this.toBBox);\n        }\n    },\n\n    _initFormat: function (format) {\n        // data format (minX, minY, maxX, maxY accessors)\n\n        // uses eval-type function compilation instead of just accepting a toBBox function\n        // because the algorithms are very sensitive to sorting functions performance,\n        // so they should be dead simple and without inner calls\n\n        var compareArr = ['return a', ' - b', ';'];\n\n        this.compareMinX = new Function('a', 'b', compareArr.join(format[0]));\n        this.compareMinY = new Function('a', 'b', compareArr.join(format[1]));\n\n        this.toBBox = new Function('a',\n            'return {minX: a' + format[0] +\n            ', minY: a' + format[1] +\n            ', maxX: a' + format[2] +\n            ', maxY: a' + format[3] + '};');\n    }\n};\n\nfunction findItem(item, items, equalsFn) {\n    if (!equalsFn) return items.indexOf(item);\n\n    for (var i = 0; i < items.length; i++) {\n        if (equalsFn(item, items[i])) return i;\n    }\n    return -1;\n}\n\n// calculate node's bbox from bboxes of its children\nfunction calcBBox(node, toBBox) {\n    distBBox(node, 0, node.children.length, toBBox, node);\n}\n\n// min bounding rectangle of node children from k to p-1\nfunction distBBox(node, k, p, toBBox, destNode) {\n    if (!destNode) destNode = createNode(null);\n    destNode.minX = Infinity;\n    destNode.minY = Infinity;\n    destNode.maxX = -Infinity;\n    destNode.maxY = -Infinity;\n\n    for (var i = k, child; i < p; i++) {\n        child = node.children[i];\n        extend(destNode, node.leaf ? toBBox(child) : child);\n    }\n\n    return destNode;\n}\n\nfunction extend(a, b) {\n    a.minX = Math.min(a.minX, b.minX);\n    a.minY = Math.min(a.minY, b.minY);\n    a.maxX = Math.max(a.maxX, b.maxX);\n    a.maxY = Math.max(a.maxY, b.maxY);\n    return a;\n}\n\nfunction compareNodeMinX(a, b) { return a.minX - b.minX; }\nfunction compareNodeMinY(a, b) { return a.minY - b.minY; }\n\nfunction bboxArea(a)   { return (a.maxX - a.minX) * (a.maxY - a.minY); }\nfunction bboxMargin(a) { return (a.maxX - a.minX) + (a.maxY - a.minY); }\n\nfunction enlargedArea(a, b) {\n    return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) *\n           (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));\n}\n\nfunction intersectionArea(a, b) {\n    var minX = Math.max(a.minX, b.minX),\n        minY = Math.max(a.minY, b.minY),\n        maxX = Math.min(a.maxX, b.maxX),\n        maxY = Math.min(a.maxY, b.maxY);\n\n    return Math.max(0, maxX - minX) *\n           Math.max(0, maxY - minY);\n}\n\nfunction contains(a, b) {\n    return a.minX <= b.minX &&\n           a.minY <= b.minY &&\n           b.maxX <= a.maxX &&\n           b.maxY <= a.maxY;\n}\n\nfunction intersects(a, b) {\n    return b.minX <= a.maxX &&\n           b.minY <= a.maxY &&\n           b.maxX >= a.minX &&\n           b.maxY >= a.minY;\n}\n\nfunction createNode(children) {\n    return {\n        children: children,\n        height: 1,\n        leaf: true,\n        minX: Infinity,\n        minY: Infinity,\n        maxX: -Infinity,\n        maxY: -Infinity\n    };\n}\n\n// sort an array so that items come in groups of n unsorted items, with groups sorted between each other;\n// combines selection algorithm with binary divide & conquer approach\n\nfunction multiSelect(arr, left, right, n, compare) {\n    var stack = [left, right],\n        mid;\n\n    while (stack.length) {\n        right = stack.pop();\n        left = stack.pop();\n\n        if (right - left <= n) continue;\n\n        mid = left + Math.ceil((right - left) / n / 2) * n;\n        quickselect(arr, mid, left, right, compare);\n\n        stack.push(left, mid, mid, right);\n    }\n}\n\nexport default rbush;\n","import rbush from '../ThirdParty/rbush.js';\nimport Check from './Check.js';\n\n    /**\n     * Wrapper around rbush for use with Rectangle types.\n     * @private\n     */\n    function RectangleCollisionChecker() {\n        this._tree = rbush();\n    }\n\n    function RectangleWithId() {\n        this.minX = 0.0;\n        this.minY = 0.0;\n        this.maxX = 0.0;\n        this.maxY = 0.0;\n        this.id = '';\n    }\n\n    RectangleWithId.fromRectangleAndId = function(id, rectangle, result) {\n        result.minX = rectangle.west;\n        result.minY = rectangle.south;\n        result.maxX = rectangle.east;\n        result.maxY = rectangle.north;\n        result.id = id;\n        return result;\n    };\n\n    /**\n     * Insert a rectangle into the collision checker.\n     *\n     * @param {String} id Unique string ID for the rectangle being inserted.\n     * @param {Rectangle} rectangle A Rectangle\n     * @private\n     */\n    RectangleCollisionChecker.prototype.insert = function(id, rectangle) {\n        \n\n        var withId = RectangleWithId.fromRectangleAndId(id, rectangle, new RectangleWithId());\n        this._tree.insert(withId);\n    };\n\n    function idCompare(a, b) {\n        return a.id === b.id;\n    }\n\n    var removalScratch = new RectangleWithId();\n    /**\n     * Remove a rectangle from the collision checker.\n     *\n     * @param {String} id Unique string ID for the rectangle being removed.\n     * @param {Rectangle} rectangle A Rectangle\n     * @private\n     */\n    RectangleCollisionChecker.prototype.remove = function(id, rectangle) {\n        \n\n        var withId = RectangleWithId.fromRectangleAndId(id, rectangle, removalScratch);\n        this._tree.remove(withId, idCompare);\n    };\n\n    var collisionScratch = new RectangleWithId();\n    /**\n     * Checks if a given rectangle collides with any of the rectangles in the collection.\n     *\n     * @param {Rectangle} rectangle A Rectangle that should be checked against the rectangles in the collision checker.\n     * @returns {Boolean} Whether the rectangle collides with any of the rectangles in the collision checker.\n     */\n    RectangleCollisionChecker.prototype.collides = function(rectangle) {\n        \n\n        var withId = RectangleWithId.fromRectangleAndId('', rectangle, collisionScratch);\n        return this._tree.collides(withId);\n    };\nexport default RectangleCollisionChecker;\n","import AssociativeArray from '../Core/AssociativeArray.js';\nimport defined from '../Core/defined.js';\nimport DistanceDisplayCondition from '../Core/DistanceDisplayCondition.js';\nimport DistanceDisplayConditionGeometryInstanceAttribute from '../Core/DistanceDisplayConditionGeometryInstanceAttribute.js';\nimport RectangleCollisionChecker from '../Core/RectangleCollisionChecker.js';\nimport ShowGeometryInstanceAttribute from '../Core/ShowGeometryInstanceAttribute.js';\nimport GroundPrimitive from '../Scene/GroundPrimitive.js';\nimport ShadowVolumeAppearance from '../Scene/ShadowVolumeAppearance.js';\nimport BoundingSphereState from './BoundingSphereState.js';\nimport ColorMaterialProperty from './ColorMaterialProperty.js';\nimport MaterialProperty from './MaterialProperty.js';\nimport Property from './Property.js';\n\n    var distanceDisplayConditionScratch = new DistanceDisplayCondition();\n    var defaultDistanceDisplayCondition = new DistanceDisplayCondition();\n\n    // Encapsulates a Primitive and all the entities that it represents.\n    function Batch(primitives, classificationType, appearanceType, materialProperty, usingSphericalTextureCoordinates, zIndex) {\n        this.primitives = primitives; // scene level primitive collection\n        this.classificationType = classificationType;\n        this.appearanceType = appearanceType;\n        this.materialProperty = materialProperty;\n        this.updaters = new AssociativeArray();\n        this.createPrimitive = true;\n        this.primitive = undefined; // a GroundPrimitive encapsulating all the entities\n        this.oldPrimitive = undefined;\n        this.geometry = new AssociativeArray();\n        this.material = undefined;\n        this.updatersWithAttributes = new AssociativeArray();\n        this.attributes = new AssociativeArray();\n        this.invalidated = false;\n        this.removeMaterialSubscription = materialProperty.definitionChanged.addEventListener(Batch.prototype.onMaterialChanged, this);\n        this.subscriptions = new AssociativeArray();\n        this.showsUpdated = new AssociativeArray();\n        this.usingSphericalTextureCoordinates = usingSphericalTextureCoordinates;\n        this.zIndex = zIndex;\n        this.rectangleCollisionCheck = new RectangleCollisionChecker();\n    }\n\n    Batch.prototype.onMaterialChanged = function() {\n        this.invalidated = true;\n    };\n\n    Batch.prototype.overlapping = function(rectangle) {\n        return this.rectangleCollisionCheck.collides(rectangle);\n    };\n\n    // Check if the given updater's material is compatible with this batch\n    Batch.prototype.isMaterial = function(updater) {\n        var material = this.materialProperty;\n        var updaterMaterial = updater.fillMaterialProperty;\n\n        if (updaterMaterial === material ||\n            (updaterMaterial instanceof ColorMaterialProperty && material instanceof ColorMaterialProperty)) {\n            return true;\n        }\n        return defined(material) && material.equals(updaterMaterial);\n    };\n\n    Batch.prototype.add = function(time, updater, geometryInstance) {\n        var id = updater.id;\n        this.updaters.set(id, updater);\n        this.geometry.set(id, geometryInstance);\n        this.rectangleCollisionCheck.insert(id, geometryInstance.geometry.rectangle);\n        // Updaters with dynamic attributes must be tracked separately, may exit the batch\n        if (!updater.hasConstantFill || !updater.fillMaterialProperty.isConstant || !Property.isConstant(updater.distanceDisplayConditionProperty)) {\n            this.updatersWithAttributes.set(id, updater);\n        } else {\n            var that = this;\n            // Listen for show changes. These will be synchronized in updateShows.\n            this.subscriptions.set(id, updater.entity.definitionChanged.addEventListener(function(entity, propertyName, newValue, oldValue) {\n                if (propertyName === 'isShowing') {\n                    that.showsUpdated.set(updater.id, updater);\n                }\n            }));\n        }\n        this.createPrimitive = true;\n    };\n\n    Batch.prototype.remove = function(updater) {\n        var id = updater.id;\n        var geometryInstance = this.geometry.get(id);\n        this.createPrimitive = this.geometry.remove(id) || this.createPrimitive;\n        if (this.updaters.remove(id)) {\n            this.rectangleCollisionCheck.remove(id, geometryInstance.geometry.rectangle);\n            this.updatersWithAttributes.remove(id);\n            var unsubscribe = this.subscriptions.get(id);\n            if (defined(unsubscribe)) {\n                unsubscribe();\n                this.subscriptions.remove(id);\n            }\n            return true;\n        }\n        return false;\n    };\n\n    Batch.prototype.update = function(time) {\n        var isUpdated = true;\n        var primitive = this.primitive;\n        var primitives = this.primitives;\n        var geometries = this.geometry.values;\n        var i;\n\n        if (this.createPrimitive) {\n            var geometriesLength = geometries.length;\n            if (geometriesLength > 0) {\n                if (defined(primitive)) {\n                    // Keep a handle to the old primitive so it can be removed when the updated version is ready.\n                    if (!defined(this.oldPrimitive)) {\n                        this.oldPrimitive = primitive;\n                    } else {\n                        // For if the new primitive changes again before it is ready.\n                        primitives.remove(primitive);\n                    }\n                }\n\n                this.material = MaterialProperty.getValue(time, this.materialProperty, this.material);\n\n                primitive = new GroundPrimitive({\n                    show : false,\n                    asynchronous : true,\n                    geometryInstances : geometries.slice(),\n                    appearance : new this.appearanceType({\n                        material : this.material\n                        // translucent and closed properties overridden\n                    }),\n                    classificationType : this.classificationType\n                });\n\n                primitives.add(primitive, this.zIndex);\n                isUpdated = false;\n            } else {\n                if (defined(primitive)) {\n                    primitives.remove(primitive);\n                    primitive = undefined;\n                }\n                var oldPrimitive = this.oldPrimitive;\n                if (defined(oldPrimitive)) {\n                    primitives.remove(oldPrimitive);\n                    this.oldPrimitive = undefined;\n                }\n            }\n\n            this.attributes.removeAll();\n            this.primitive = primitive;\n            this.createPrimitive = false;\n        } else if (defined(primitive) && primitive.ready) {\n            primitive.show = true;\n            if (defined(this.oldPrimitive)) {\n                primitives.remove(this.oldPrimitive);\n                this.oldPrimitive = undefined;\n            }\n\n            this.material = MaterialProperty.getValue(time, this.materialProperty, this.material);\n            this.primitive.appearance.material = this.material;\n\n            var updatersWithAttributes = this.updatersWithAttributes.values;\n            var length = updatersWithAttributes.length;\n            for (i = 0; i < length; i++) {\n                var updater = updatersWithAttributes[i];\n                var entity = updater.entity;\n                var instance = this.geometry.get(updater.id);\n\n                var attributes = this.attributes.get(instance.id.id);\n                if (!defined(attributes)) {\n                    attributes = primitive.getGeometryInstanceAttributes(instance.id);\n                    this.attributes.set(instance.id.id, attributes);\n                }\n\n                var show = entity.isShowing && (updater.hasConstantFill || updater.isFilled(time));\n                var currentShow = attributes.show[0] === 1;\n                if (show !== currentShow) {\n                    attributes.show = ShowGeometryInstanceAttribute.toValue(show, attributes.show);\n                }\n\n                var distanceDisplayConditionProperty = updater.distanceDisplayConditionProperty;\n                if (!Property.isConstant(distanceDisplayConditionProperty)) {\n                    var distanceDisplayCondition = Property.getValueOrDefault(distanceDisplayConditionProperty, time, defaultDistanceDisplayCondition, distanceDisplayConditionScratch);\n                    if (!DistanceDisplayCondition.equals(distanceDisplayCondition, attributes._lastDistanceDisplayCondition)) {\n                        attributes._lastDistanceDisplayCondition = DistanceDisplayCondition.clone(distanceDisplayCondition, attributes._lastDistanceDisplayCondition);\n                        attributes.distanceDisplayCondition = DistanceDisplayConditionGeometryInstanceAttribute.toValue(distanceDisplayCondition, attributes.distanceDisplayCondition);\n                    }\n                }\n            }\n\n            this.updateShows(primitive);\n        } else if (defined(primitive) && !primitive.ready) {\n            isUpdated = false;\n        }\n        return isUpdated;\n    };\n\n    Batch.prototype.updateShows = function(primitive) {\n        var showsUpdated = this.showsUpdated.values;\n        var length = showsUpdated.length;\n        for (var i = 0; i < length; i++) {\n            var updater = showsUpdated[i];\n            var entity = updater.entity;\n            var instance = this.geometry.get(updater.id);\n\n            var attributes = this.attributes.get(instance.id.id);\n            if (!defined(attributes)) {\n                attributes = primitive.getGeometryInstanceAttributes(instance.id);\n                this.attributes.set(instance.id.id, attributes);\n            }\n\n            var show = entity.isShowing;\n            var currentShow = attributes.show[0] === 1;\n            if (show !== currentShow) {\n                attributes.show = ShowGeometryInstanceAttribute.toValue(show, attributes.show);\n                instance.attributes.show.value[0] = attributes.show[0];\n            }\n        }\n        this.showsUpdated.removeAll();\n    };\n\n    Batch.prototype.contains = function(updater) {\n        return this.updaters.contains(updater.id);\n    };\n\n    Batch.prototype.getBoundingSphere = function(updater, result) {\n        var primitive = this.primitive;\n        if (!primitive.ready) {\n            return BoundingSphereState.PENDING;\n        }\n        var attributes = primitive.getGeometryInstanceAttributes(updater.entity);\n        if (!defined(attributes) || !defined(attributes.boundingSphere) ||\n            (defined(attributes.show) && attributes.show[0] === 0)) {\n            return BoundingSphereState.FAILED;\n        }\n        attributes.boundingSphere.clone(result);\n        return BoundingSphereState.DONE;\n    };\n\n    Batch.prototype.destroy = function() {\n        var primitive = this.primitive;\n        var primitives = this.primitives;\n        if (defined(primitive)) {\n            primitives.remove(primitive);\n        }\n        var oldPrimitive = this.oldPrimitive;\n        if (defined(oldPrimitive)) {\n            primitives.remove(oldPrimitive);\n        }\n        this.removeMaterialSubscription();\n    };\n\n    /**\n     * @private\n     */\n    function StaticGroundGeometryPerMaterialBatch(primitives, classificationType, appearanceType) {\n        this._items = [];\n        this._primitives = primitives;\n        this._classificationType = classificationType;\n        this._appearanceType = appearanceType;\n    }\n\n    StaticGroundGeometryPerMaterialBatch.prototype.add = function(time, updater) {\n        var items = this._items;\n        var length = items.length;\n        var geometryInstance = updater.createFillGeometryInstance(time);\n        var usingSphericalTextureCoordinates = ShadowVolumeAppearance.shouldUseSphericalCoordinates(geometryInstance.geometry.rectangle);\n        var zIndex = Property.getValueOrDefault(updater.zIndex, 0);\n        // Check if the Entity represented by the updater can be placed in an existing batch. Requirements:\n        // * compatible material (same material or same color)\n        // * same type of texture coordinates (spherical vs. planar)\n        // * conservatively non-overlapping with any entities in the existing batch\n        for (var i = 0; i < length; ++i) {\n            var item = items[i];\n            if (item.isMaterial(updater) &&\n                item.usingSphericalTextureCoordinates === usingSphericalTextureCoordinates &&\n                item.zIndex === zIndex &&\n                !item.overlapping(geometryInstance.geometry.rectangle)) {\n                item.add(time, updater, geometryInstance);\n                return;\n            }\n        }\n        // If a compatible batch wasn't found, create a new batch.\n        var batch = new Batch(this._primitives, this._classificationType, this._appearanceType, updater.fillMaterialProperty, usingSphericalTextureCoordinates, zIndex);\n        batch.add(time, updater, geometryInstance);\n        items.push(batch);\n    };\n\n    StaticGroundGeometryPerMaterialBatch.prototype.remove = function(updater) {\n        var items = this._items;\n        var length = items.length;\n        for (var i = length - 1; i >= 0; i--) {\n            var item = items[i];\n            if (item.remove(updater)) {\n                if (item.updaters.length === 0) {\n                    items.splice(i, 1);\n                    item.destroy();\n                }\n                break;\n            }\n        }\n    };\n\n    StaticGroundGeometryPerMaterialBatch.prototype.update = function(time) {\n        var i;\n        var items = this._items;\n        var length = items.length;\n\n        for (i = length - 1; i >= 0; i--) {\n            var item = items[i];\n            if (item.invalidated) {\n                items.splice(i, 1);\n                var updaters = item.updaters.values;\n                var updatersLength = updaters.length;\n                for (var h = 0; h < updatersLength; h++) {\n                    this.add(time, updaters[h]);\n                }\n                item.destroy();\n            }\n        }\n\n        var isUpdated = true;\n        for (i = 0; i < items.length; i++) {\n            isUpdated = items[i].update(time) && isUpdated;\n        }\n        return isUpdated;\n    };\n\n    StaticGroundGeometryPerMaterialBatch.prototype.getBoundingSphere = function(updater, result) {\n        var items = this._items;\n        var length = items.length;\n        for (var i = 0; i < length; i++) {\n            var item = items[i];\n            if (item.contains(updater)){\n                return item.getBoundingSphere(updater, result);\n            }\n        }\n        return BoundingSphereState.FAILED;\n    };\n\n    StaticGroundGeometryPerMaterialBatch.prototype.removeAllPrimitives = function() {\n        var items = this._items;\n        var length = items.length;\n        for (var i = 0; i < length; i++) {\n            items[i].destroy();\n        }\n        this._items.length = 0;\n    };\nexport default StaticGroundGeometryPerMaterialBatch;\n","import AssociativeArray from '../Core/AssociativeArray.js';\nimport Cartesian3 from '../Core/Cartesian3.js';\nimport Color from '../Core/Color.js';\nimport ColorGeometryInstanceAttribute from '../Core/ColorGeometryInstanceAttribute.js';\nimport defined from '../Core/defined.js';\nimport DistanceDisplayCondition from '../Core/DistanceDisplayCondition.js';\nimport DistanceDisplayConditionGeometryInstanceAttribute from '../Core/DistanceDisplayConditionGeometryInstanceAttribute.js';\nimport OffsetGeometryInstanceAttribute from '../Core/OffsetGeometryInstanceAttribute.js';\nimport ShowGeometryInstanceAttribute from '../Core/ShowGeometryInstanceAttribute.js';\nimport PerInstanceColorAppearance from '../Scene/PerInstanceColorAppearance.js';\nimport Primitive from '../Scene/Primitive.js';\nimport BoundingSphereState from './BoundingSphereState.js';\nimport Property from './Property.js';\n\n    var colorScratch = new Color();\n    var distanceDisplayConditionScratch = new DistanceDisplayCondition();\n    var defaultDistanceDisplayCondition = new DistanceDisplayCondition();\n    var defaultOffset = Cartesian3.ZERO;\n    var offsetScratch = new Cartesian3();\n\n    function Batch(primitives, translucent, width, shadows) {\n        this.translucent = translucent;\n        this.width = width;\n        this.shadows = shadows;\n        this.primitives = primitives;\n        this.createPrimitive = false;\n        this.waitingOnCreate = false;\n        this.primitive = undefined;\n        this.oldPrimitive = undefined;\n        this.geometry = new AssociativeArray();\n        this.updaters = new AssociativeArray();\n        this.updatersWithAttributes = new AssociativeArray();\n        this.attributes = new AssociativeArray();\n        this.itemsToRemove = [];\n        this.subscriptions = new AssociativeArray();\n        this.showsUpdated = new AssociativeArray();\n    }\n    Batch.prototype.add = function(updater, instance) {\n        var id = updater.id;\n        this.createPrimitive = true;\n        this.geometry.set(id, instance);\n        this.updaters.set(id, updater);\n        if (!updater.hasConstantOutline || !updater.outlineColorProperty.isConstant || !Property.isConstant(updater.distanceDisplayConditionProperty) || !Property.isConstant(updater.terrainOffsetProperty)) {\n            this.updatersWithAttributes.set(id, updater);\n        } else {\n            var that = this;\n            this.subscriptions.set(id, updater.entity.definitionChanged.addEventListener(function(entity, propertyName, newValue, oldValue) {\n                if (propertyName === 'isShowing') {\n                    that.showsUpdated.set(updater.id, updater);\n                }\n            }));\n        }\n    };\n\n    Batch.prototype.remove = function(updater) {\n        var id = updater.id;\n        this.createPrimitive = this.geometry.remove(id) || this.createPrimitive;\n        if (this.updaters.remove(id)) {\n            this.updatersWithAttributes.remove(id);\n            var unsubscribe = this.subscriptions.get(id);\n            if (defined(unsubscribe)) {\n                unsubscribe();\n                this.subscriptions.remove(id);\n                this.showsUpdated.remove(id);\n            }\n            return true;\n        }\n        return false;\n    };\n\n    Batch.prototype.update = function(time) {\n        var isUpdated = true;\n        var removedCount = 0;\n        var primitive = this.primitive;\n        var primitives = this.primitives;\n        var i;\n\n        if (this.createPrimitive) {\n            var geometries = this.geometry.values;\n            var geometriesLength = geometries.length;\n            if (geometriesLength > 0) {\n                if (defined(primitive)) {\n                    if (!defined(this.oldPrimitive)) {\n                        this.oldPrimitive = primitive;\n                    } else {\n                        primitives.remove(primitive);\n                    }\n                }\n\n                primitive = new Primitive({\n                    show : false,\n                    asynchronous : true,\n                    geometryInstances : geometries.slice(),\n                    appearance : new PerInstanceColorAppearance({\n                        flat : true,\n                        translucent : this.translucent,\n                        renderState : {\n                            lineWidth : this.width\n                        }\n                    }),\n                    shadows : this.shadows\n                });\n\n                primitives.add(primitive);\n                isUpdated = false;\n            } else {\n                if (defined(primitive)) {\n                    primitives.remove(primitive);\n                    primitive = undefined;\n                }\n                var oldPrimitive = this.oldPrimitive;\n                if (defined(oldPrimitive)) {\n                    primitives.remove(oldPrimitive);\n                    this.oldPrimitive = undefined;\n                }\n            }\n\n            this.attributes.removeAll();\n            this.primitive = primitive;\n            this.createPrimitive = false;\n            this.waitingOnCreate = true;\n        } else if (defined(primitive) && primitive.ready) {\n            primitive.show = true;\n            if (defined(this.oldPrimitive)) {\n                primitives.remove(this.oldPrimitive);\n                this.oldPrimitive = undefined;\n            }\n\n            var updatersWithAttributes = this.updatersWithAttributes.values;\n            var length = updatersWithAttributes.length;\n            var waitingOnCreate = this.waitingOnCreate;\n            for (i = 0; i < length; i++) {\n                var updater = updatersWithAttributes[i];\n                var instance = this.geometry.get(updater.id);\n\n                var attributes = this.attributes.get(instance.id.id);\n                if (!defined(attributes)) {\n                    attributes = primitive.getGeometryInstanceAttributes(instance.id);\n                    this.attributes.set(instance.id.id, attributes);\n                }\n\n                if (!updater.outlineColorProperty.isConstant || waitingOnCreate) {\n                    var outlineColorProperty = updater.outlineColorProperty;\n                    var outlineColor = Property.getValueOrDefault(outlineColorProperty, time, Color.WHITE, colorScratch);\n                    if (!Color.equals(attributes._lastColor, outlineColor)) {\n                        attributes._lastColor = Color.clone(outlineColor, attributes._lastColor);\n                        attributes.color = ColorGeometryInstanceAttribute.toValue(outlineColor, attributes.color);\n                        if ((this.translucent && attributes.color[3] === 255) || (!this.translucent && attributes.color[3] !== 255)) {\n                            this.itemsToRemove[removedCount++] = updater;\n                        }\n                    }\n                }\n\n                var show = updater.entity.isShowing && (updater.hasConstantOutline || updater.isOutlineVisible(time));\n                var currentShow = attributes.show[0] === 1;\n                if (show !== currentShow) {\n                    attributes.show = ShowGeometryInstanceAttribute.toValue(show, attributes.show);\n                }\n\n                var distanceDisplayConditionProperty = updater.distanceDisplayConditionProperty;\n                if (!Property.isConstant(distanceDisplayConditionProperty)) {\n                    var distanceDisplayCondition = Property.getValueOrDefault(distanceDisplayConditionProperty, time, defaultDistanceDisplayCondition, distanceDisplayConditionScratch);\n                    if (!DistanceDisplayCondition.equals(distanceDisplayCondition, attributes._lastDistanceDisplayCondition)) {\n                        attributes._lastDistanceDisplayCondition = DistanceDisplayCondition.clone(distanceDisplayCondition, attributes._lastDistanceDisplayCondition);\n                        attributes.distanceDisplayCondition = DistanceDisplayConditionGeometryInstanceAttribute.toValue(distanceDisplayCondition, attributes.distanceDisplayCondition);\n                    }\n                }\n\n                var offsetProperty = updater.terrainOffsetProperty;\n                if (!Property.isConstant(offsetProperty)) {\n                    var offset = Property.getValueOrDefault(offsetProperty, time, defaultOffset, offsetScratch);\n                    if (!Cartesian3.equals(offset, attributes._lastOffset)) {\n                        attributes._lastOffset = Cartesian3.clone(offset, attributes._lastOffset);\n                        attributes.offset = OffsetGeometryInstanceAttribute.toValue(offset, attributes.offset);\n                    }\n                }\n            }\n\n            this.updateShows(primitive);\n            this.waitingOnCreate = false;\n        } else if (defined(primitive) && !primitive.ready) {\n            isUpdated = false;\n        }\n\n        this.itemsToRemove.length = removedCount;\n        return isUpdated;\n    };\n\n    Batch.prototype.updateShows = function(primitive) {\n        var showsUpdated = this.showsUpdated.values;\n        var length = showsUpdated.length;\n        for (var i = 0; i < length; i++) {\n            var updater = showsUpdated[i];\n            var instance = this.geometry.get(updater.id);\n\n            var attributes = this.attributes.get(instance.id.id);\n            if (!defined(attributes)) {\n                attributes = primitive.getGeometryInstanceAttributes(instance.id);\n                this.attributes.set(instance.id.id, attributes);\n            }\n\n            var show = updater.entity.isShowing;\n            var currentShow = attributes.show[0] === 1;\n            if (show !== currentShow) {\n                attributes.show = ShowGeometryInstanceAttribute.toValue(show, attributes.show);\n                instance.attributes.show.value[0] = attributes.show[0];\n            }\n        }\n        this.showsUpdated.removeAll();\n    };\n\n    Batch.prototype.contains = function(updater) {\n        return this.updaters.contains(updater.id);\n    };\n\n    Batch.prototype.getBoundingSphere = function(updater, result) {\n        var primitive = this.primitive;\n        if (!primitive.ready) {\n            return BoundingSphereState.PENDING;\n        }\n        var attributes = primitive.getGeometryInstanceAttributes(updater.entity);\n        if (!defined(attributes) || !defined(attributes.boundingSphere) ||//\n            (defined(attributes.show) && attributes.show[0] === 0)) {\n            return BoundingSphereState.FAILED;\n        }\n        attributes.boundingSphere.clone(result);\n        return BoundingSphereState.DONE;\n    };\n\n    Batch.prototype.removeAllPrimitives = function() {\n        var primitives = this.primitives;\n\n        var primitive = this.primitive;\n        if (defined(primitive)) {\n            primitives.remove(primitive);\n            this.primitive = undefined;\n            this.geometry.removeAll();\n            this.updaters.removeAll();\n        }\n\n        var oldPrimitive = this.oldPrimitive;\n        if (defined(oldPrimitive)) {\n            primitives.remove(oldPrimitive);\n            this.oldPrimitive = undefined;\n        }\n    };\n\n    /**\n     * @private\n     */\n    function StaticOutlineGeometryBatch(primitives, scene, shadows) {\n        this._primitives = primitives;\n        this._scene = scene;\n        this._shadows = shadows;\n        this._solidBatches = new AssociativeArray();\n        this._translucentBatches = new AssociativeArray();\n    }\n    StaticOutlineGeometryBatch.prototype.add = function(time, updater) {\n        var instance = updater.createOutlineGeometryInstance(time);\n        var width = this._scene.clampLineWidth(updater.outlineWidth);\n        var batches;\n        var batch;\n        if (instance.attributes.color.value[3] === 255) {\n            batches = this._solidBatches;\n            batch = batches.get(width);\n            if (!defined(batch)) {\n                batch = new Batch(this._primitives, false, width, this._shadows);\n                batches.set(width, batch);\n            }\n            batch.add(updater, instance);\n        } else {\n            batches = this._translucentBatches;\n            batch = batches.get(width);\n            if (!defined(batch)) {\n                batch = new Batch(this._primitives, true, width, this._shadows);\n                batches.set(width, batch);\n            }\n            batch.add(updater, instance);\n        }\n    };\n\n    StaticOutlineGeometryBatch.prototype.remove = function(updater) {\n        var i;\n\n        var solidBatches = this._solidBatches.values;\n        var solidBatchesLength = solidBatches.length;\n        for (i = 0; i < solidBatchesLength; i++) {\n            if (solidBatches[i].remove(updater)) {\n                return;\n            }\n        }\n\n        var translucentBatches = this._translucentBatches.values;\n        var translucentBatchesLength = translucentBatches.length;\n        for (i = 0; i < translucentBatchesLength; i++) {\n            if (translucentBatches[i].remove(updater)) {\n                return;\n            }\n        }\n    };\n\n    StaticOutlineGeometryBatch.prototype.update = function(time) {\n        var i;\n        var x;\n        var updater;\n        var batch;\n        var solidBatches = this._solidBatches.values;\n        var solidBatchesLength = solidBatches.length;\n        var translucentBatches = this._translucentBatches.values;\n        var translucentBatchesLength = translucentBatches.length;\n        var itemsToRemove;\n        var isUpdated = true;\n        var needUpdate = false;\n\n        do {\n            needUpdate = false;\n            for (x = 0; x < solidBatchesLength; x++) {\n                batch = solidBatches[x];\n                //Perform initial update\n                isUpdated = batch.update(time);\n\n                //If any items swapped between solid/translucent, we need to\n                //move them between batches\n                itemsToRemove = batch.itemsToRemove;\n                var solidsToMoveLength = itemsToRemove.length;\n                if (solidsToMoveLength > 0) {\n                    needUpdate = true;\n                    for (i = 0; i < solidsToMoveLength; i++) {\n                        updater = itemsToRemove[i];\n                        batch.remove(updater);\n                        this.add(time, updater);\n                    }\n                }\n            }\n            for (x = 0; x < translucentBatchesLength; x++) {\n                batch = translucentBatches[x];\n                //Perform initial update\n                isUpdated = batch.update(time);\n\n                //If any items swapped between solid/translucent, we need to\n                //move them between batches\n                itemsToRemove = batch.itemsToRemove;\n                var translucentToMoveLength = itemsToRemove.length;\n                if (translucentToMoveLength > 0) {\n                    needUpdate = true;\n                    for (i = 0; i < translucentToMoveLength; i++) {\n                        updater = itemsToRemove[i];\n                        batch.remove(updater);\n                        this.add(time, updater);\n                    }\n                }\n            }\n        } while (needUpdate);\n\n        return isUpdated;\n    };\n\n    StaticOutlineGeometryBatch.prototype.getBoundingSphere = function(updater, result) {\n        var i;\n\n        var solidBatches = this._solidBatches.values;\n        var solidBatchesLength = solidBatches.length;\n        for (i = 0; i < solidBatchesLength; i++) {\n            var solidBatch = solidBatches[i];\n            if (solidBatch.contains(updater)){\n                return solidBatch.getBoundingSphere(updater, result);\n            }\n        }\n\n        var translucentBatches = this._translucentBatches.values;\n        var translucentBatchesLength = translucentBatches.length;\n        for (i = 0; i < translucentBatchesLength; i++) {\n            var translucentBatch = translucentBatches[i];\n            if (translucentBatch.contains(updater)){\n                return translucentBatch.getBoundingSphere(updater, result);\n            }\n        }\n\n        return BoundingSphereState.FAILED;\n    };\n\n    StaticOutlineGeometryBatch.prototype.removeAllPrimitives = function() {\n        var i;\n\n        var solidBatches = this._solidBatches.values;\n        var solidBatchesLength = solidBatches.length;\n        for (i = 0; i < solidBatchesLength; i++) {\n            solidBatches[i].removeAllPrimitives();\n        }\n\n        var translucentBatches = this._translucentBatches.values;\n        var translucentBatchesLength = translucentBatches.length;\n        for (i = 0; i < translucentBatchesLength; i++) {\n            translucentBatches[i].removeAllPrimitives();\n        }\n    };\nexport default StaticOutlineGeometryBatch;\n","import Cartographic from './Cartographic.js';\nimport defined from './defined.js';\nimport EllipsoidTangentPlane from './EllipsoidTangentPlane.js';\nimport CesiumMath from './Math.js';\nimport PolygonPipeline from './PolygonPipeline.js';\nimport PolylinePipeline from './PolylinePipeline.js';\nimport WindingOrder from './WindingOrder.js';\n\n    /**\n     * private\n     */\n    var WallGeometryLibrary = {};\n\n    function latLonEquals(c0, c1) {\n        return ((CesiumMath.equalsEpsilon(c0.latitude, c1.latitude, CesiumMath.EPSILON14)) && (CesiumMath.equalsEpsilon(c0.longitude, c1.longitude, CesiumMath.EPSILON14)));\n    }\n\n    var scratchCartographic1 = new Cartographic();\n    var scratchCartographic2 = new Cartographic();\n    function removeDuplicates(ellipsoid, positions, topHeights, bottomHeights) {\n        var length = positions.length;\n        if (length < 2) {\n            return;\n        }\n\n        var hasBottomHeights = defined(bottomHeights);\n        var hasTopHeights = defined(topHeights);\n        var hasAllZeroHeights = true;\n\n        var cleanedPositions = new Array(length);\n        var cleanedTopHeights = new Array(length);\n        var cleanedBottomHeights = new Array(length);\n\n        var v0 = positions[0];\n        cleanedPositions[0] = v0;\n\n        var c0 = ellipsoid.cartesianToCartographic(v0, scratchCartographic1);\n        if (hasTopHeights) {\n            c0.height = topHeights[0];\n        }\n\n        hasAllZeroHeights = hasAllZeroHeights && c0.height <= 0;\n\n        cleanedTopHeights[0] = c0.height;\n\n        if (hasBottomHeights) {\n            cleanedBottomHeights[0] = bottomHeights[0];\n        } else {\n            cleanedBottomHeights[0] = 0.0;\n        }\n\n        var index = 1;\n        for (var i = 1; i < length; ++i) {\n            var v1 = positions[i];\n            var c1 = ellipsoid.cartesianToCartographic(v1, scratchCartographic2);\n            if (hasTopHeights) {\n                c1.height = topHeights[i];\n            }\n            hasAllZeroHeights = hasAllZeroHeights && c1.height <= 0;\n\n            if (!latLonEquals(c0, c1)) {\n                cleanedPositions[index] = v1; // Shallow copy!\n                cleanedTopHeights[index] = c1.height;\n\n                if (hasBottomHeights) {\n                    cleanedBottomHeights[index] = bottomHeights[i];\n                } else {\n                    cleanedBottomHeights[index] = 0.0;\n                }\n\n                Cartographic.clone(c1, c0);\n                ++index;\n            } else if (c0.height < c1.height) {\n                cleanedTopHeights[index - 1] = c1.height;\n            }\n        }\n\n        if (hasAllZeroHeights || index < 2) {\n            return;\n        }\n\n        cleanedPositions.length = index;\n        cleanedTopHeights.length = index;\n        cleanedBottomHeights.length = index;\n\n        return {\n            positions: cleanedPositions,\n            topHeights: cleanedTopHeights,\n            bottomHeights: cleanedBottomHeights\n        };\n    }\n\n    var positionsArrayScratch = new Array(2);\n    var heightsArrayScratch = new Array(2);\n    var generateArcOptionsScratch = {\n        positions : undefined,\n        height : undefined,\n        granularity : undefined,\n        ellipsoid : undefined\n    };\n\n    /**\n     * @private\n     */\n    WallGeometryLibrary.computePositions = function(ellipsoid, wallPositions, maximumHeights, minimumHeights, granularity, duplicateCorners) {\n        var o = removeDuplicates(ellipsoid, wallPositions, maximumHeights, minimumHeights);\n\n        if (!defined(o)) {\n            return;\n        }\n\n        wallPositions = o.positions;\n        maximumHeights = o.topHeights;\n        minimumHeights = o.bottomHeights;\n\n        if (wallPositions.length >= 3) {\n            // Order positions counter-clockwise\n            var tangentPlane = EllipsoidTangentPlane.fromPoints(wallPositions, ellipsoid);\n            var positions2D = tangentPlane.projectPointsOntoPlane(wallPositions);\n\n            if (PolygonPipeline.computeWindingOrder2D(positions2D) === WindingOrder.CLOCKWISE) {\n                wallPositions.reverse();\n                maximumHeights.reverse();\n                minimumHeights.reverse();\n            }\n        }\n\n        var length = wallPositions.length;\n        var numCorners = length - 2;\n        var topPositions;\n        var bottomPositions;\n\n        var minDistance = CesiumMath.chordLength(granularity, ellipsoid.maximumRadius);\n\n        var generateArcOptions = generateArcOptionsScratch;\n        generateArcOptions.minDistance = minDistance;\n        generateArcOptions.ellipsoid = ellipsoid;\n\n        if (duplicateCorners) {\n            var count = 0;\n            var i;\n\n            for (i = 0; i < length - 1; i++) {\n                count += PolylinePipeline.numberOfPoints(wallPositions[i], wallPositions[i+1], minDistance) + 1;\n            }\n\n            topPositions = new Float64Array(count * 3);\n            bottomPositions = new Float64Array(count * 3);\n\n            var generateArcPositions = positionsArrayScratch;\n            var generateArcHeights = heightsArrayScratch;\n            generateArcOptions.positions = generateArcPositions;\n            generateArcOptions.height = generateArcHeights;\n\n            var offset = 0;\n            for (i = 0; i < length - 1; i++) {\n                generateArcPositions[0] = wallPositions[i];\n                generateArcPositions[1] = wallPositions[i + 1];\n\n                generateArcHeights[0] = maximumHeights[i];\n                generateArcHeights[1] = maximumHeights[i + 1];\n\n                var pos = PolylinePipeline.generateArc(generateArcOptions);\n                topPositions.set(pos, offset);\n\n                generateArcHeights[0] = minimumHeights[i];\n                generateArcHeights[1] = minimumHeights[i + 1];\n\n                bottomPositions.set(PolylinePipeline.generateArc(generateArcOptions), offset);\n\n                offset += pos.length;\n            }\n        } else {\n            generateArcOptions.positions = wallPositions;\n            generateArcOptions.height = maximumHeights;\n            topPositions = new Float64Array(PolylinePipeline.generateArc(generateArcOptions));\n\n            generateArcOptions.height = minimumHeights;\n            bottomPositions = new Float64Array(PolylinePipeline.generateArc(generateArcOptions));\n        }\n\n        return {\n            bottomPositions: bottomPositions,\n            topPositions: topPositions,\n            numCorners: numCorners\n        };\n    };\nexport default WallGeometryLibrary;\n","import BoundingSphere from './BoundingSphere.js';\nimport Cartesian3 from './Cartesian3.js';\nimport ComponentDatatype from './ComponentDatatype.js';\nimport defaultValue from './defaultValue.js';\nimport defined from './defined.js';\nimport DeveloperError from './DeveloperError.js';\nimport Ellipsoid from './Ellipsoid.js';\nimport Geometry from './Geometry.js';\nimport GeometryAttribute from './GeometryAttribute.js';\nimport GeometryAttributes from './GeometryAttributes.js';\nimport IndexDatatype from './IndexDatatype.js';\nimport CesiumMath from './Math.js';\nimport PrimitiveType from './PrimitiveType.js';\nimport VertexFormat from './VertexFormat.js';\nimport WallGeometryLibrary from './WallGeometryLibrary.js';\n\n    var scratchCartesian3Position1 = new Cartesian3();\n    var scratchCartesian3Position2 = new Cartesian3();\n    var scratchCartesian3Position3 = new Cartesian3();\n    var scratchCartesian3Position4 = new Cartesian3();\n    var scratchCartesian3Position5 = new Cartesian3();\n    var scratchBitangent = new Cartesian3();\n    var scratchTangent = new Cartesian3();\n    var scratchNormal = new Cartesian3();\n\n    /**\n     * A description of a wall, which is similar to a KML line string. A wall is defined by a series of points,\n     * which extrude down to the ground. Optionally, they can extrude downwards to a specified height.\n     *\n     * @alias WallGeometry\n     * @constructor\n     *\n     * @param {Object} options Object with the following properties:\n     * @param {Cartesian3[]} options.positions An array of Cartesian objects, which are the points of the wall.\n     * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n     * @param {Number[]} [options.maximumHeights] An array parallel to <code>positions</code> that give the maximum height of the\n     *        wall at <code>positions</code>. If undefined, the height of each position in used.\n     * @param {Number[]} [options.minimumHeights] An array parallel to <code>positions</code> that give the minimum height of the\n     *        wall at <code>positions</code>. If undefined, the height at each position is 0.0.\n     * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid for coordinate manipulation\n     * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\n     *\n     * @exception {DeveloperError} positions length must be greater than or equal to 2.\n     * @exception {DeveloperError} positions and maximumHeights must have the same length.\n     * @exception {DeveloperError} positions and minimumHeights must have the same length.\n     *\n     * @see WallGeometry#createGeometry\n     * @see WallGeometry#fromConstantHeight\n     *\n     * @demo {@link https://sandcastle.cesium.com/index.html?src=Wall.html|Cesium Sandcastle Wall Demo}\n     *\n     * @example\n     * // create a wall that spans from ground level to 10000 meters\n     * var wall = new Cesium.WallGeometry({\n     *   positions : Cesium.Cartesian3.fromDegreesArrayHeights([\n     *     19.0, 47.0, 10000.0,\n     *     19.0, 48.0, 10000.0,\n     *     20.0, 48.0, 10000.0,\n     *     20.0, 47.0, 10000.0,\n     *     19.0, 47.0, 10000.0\n     *   ])\n     * });\n     * var geometry = Cesium.WallGeometry.createGeometry(wall);\n     */\n    function WallGeometry(options) {\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n        var wallPositions = options.positions;\n        var maximumHeights = options.maximumHeights;\n        var minimumHeights = options.minimumHeights;\n\n        \n\n        var vertexFormat = defaultValue(options.vertexFormat, VertexFormat.DEFAULT);\n        var granularity = defaultValue(options.granularity, CesiumMath.RADIANS_PER_DEGREE);\n        var ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\n\n        this._positions = wallPositions;\n        this._minimumHeights = minimumHeights;\n        this._maximumHeights = maximumHeights;\n        this._vertexFormat = VertexFormat.clone(vertexFormat);\n        this._granularity = granularity;\n        this._ellipsoid = Ellipsoid.clone(ellipsoid);\n        this._workerName = 'createWallGeometry';\n\n        var numComponents = 1 + wallPositions.length * Cartesian3.packedLength + 2;\n        if (defined(minimumHeights)) {\n            numComponents += minimumHeights.length;\n        }\n        if (defined(maximumHeights)) {\n            numComponents += maximumHeights.length;\n        }\n\n        /**\n         * The number of elements used to pack the object into an array.\n         * @type {Number}\n         */\n        this.packedLength = numComponents + Ellipsoid.packedLength + VertexFormat.packedLength + 1;\n    }\n\n    /**\n     * Stores the provided instance into the provided array.\n     *\n     * @param {WallGeometry} value The value to pack.\n     * @param {Number[]} array The array to pack into.\n     * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n     *\n     * @returns {Number[]} The array that was packed into\n     */\n    WallGeometry.pack = function(value, array, startingIndex) {\n        \n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        var i;\n\n        var positions = value._positions;\n        var length = positions.length;\n        array[startingIndex++] = length;\n\n        for (i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {\n            Cartesian3.pack(positions[i], array, startingIndex);\n        }\n\n        var minimumHeights = value._minimumHeights;\n        length = defined(minimumHeights) ? minimumHeights.length : 0;\n        array[startingIndex++] = length;\n\n        if (defined(minimumHeights)) {\n            for (i = 0; i < length; ++i) {\n                array[startingIndex++] = minimumHeights[i];\n            }\n        }\n\n        var maximumHeights = value._maximumHeights;\n        length = defined(maximumHeights) ? maximumHeights.length : 0;\n        array[startingIndex++] = length;\n\n        if (defined(maximumHeights)) {\n            for (i = 0; i < length; ++i) {\n                array[startingIndex++] = maximumHeights[i];\n            }\n        }\n\n        Ellipsoid.pack(value._ellipsoid, array, startingIndex);\n        startingIndex += Ellipsoid.packedLength;\n\n        VertexFormat.pack(value._vertexFormat, array, startingIndex);\n        startingIndex += VertexFormat.packedLength;\n\n        array[startingIndex] = value._granularity;\n\n        return array;\n    };\n\n    var scratchEllipsoid = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);\n    var scratchVertexFormat = new VertexFormat();\n    var scratchOptions = {\n        positions : undefined,\n        minimumHeights : undefined,\n        maximumHeights : undefined,\n        ellipsoid : scratchEllipsoid,\n        vertexFormat : scratchVertexFormat,\n        granularity : undefined\n    };\n\n    /**\n     * Retrieves an instance from a packed array.\n     *\n     * @param {Number[]} array The packed array.\n     * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n     * @param {WallGeometry} [result] The object into which to store the result.\n     * @returns {WallGeometry} The modified result parameter or a new WallGeometry instance if one was not provided.\n     */\n    WallGeometry.unpack = function(array, startingIndex, result) {\n        \n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        var i;\n\n        var length = array[startingIndex++];\n        var positions = new Array(length);\n\n        for (i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {\n            positions[i] = Cartesian3.unpack(array, startingIndex);\n        }\n\n        length = array[startingIndex++];\n        var minimumHeights;\n\n        if (length > 0) {\n            minimumHeights = new Array(length);\n            for (i = 0; i < length; ++i) {\n                minimumHeights[i] = array[startingIndex++];\n            }\n        }\n\n        length = array[startingIndex++];\n        var maximumHeights;\n\n        if (length > 0) {\n            maximumHeights = new Array(length);\n            for (i = 0; i < length; ++i) {\n                maximumHeights[i] = array[startingIndex++];\n            }\n        }\n\n        var ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);\n        startingIndex += Ellipsoid.packedLength;\n\n        var vertexFormat = VertexFormat.unpack(array, startingIndex, scratchVertexFormat);\n        startingIndex += VertexFormat.packedLength;\n\n        var granularity = array[startingIndex];\n\n        if (!defined(result)) {\n            scratchOptions.positions = positions;\n            scratchOptions.minimumHeights = minimumHeights;\n            scratchOptions.maximumHeights = maximumHeights;\n            scratchOptions.granularity = granularity;\n            return new WallGeometry(scratchOptions);\n        }\n\n        result._positions = positions;\n        result._minimumHeights = minimumHeights;\n        result._maximumHeights = maximumHeights;\n        result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);\n        result._vertexFormat = VertexFormat.clone(vertexFormat, result._vertexFormat);\n        result._granularity = granularity;\n\n        return result;\n    };\n\n    /**\n     * A description of a wall, which is similar to a KML line string. A wall is defined by a series of points,\n     * which extrude down to the ground. Optionally, they can extrude downwards to a specified height.\n     *\n     * @param {Object} options Object with the following properties:\n     * @param {Cartesian3[]} options.positions An array of Cartesian objects, which are the points of the wall.\n     * @param {Number} [options.maximumHeight] A constant that defines the maximum height of the\n     *        wall at <code>positions</code>. If undefined, the height of each position in used.\n     * @param {Number} [options.minimumHeight] A constant that defines the minimum height of the\n     *        wall at <code>positions</code>. If undefined, the height at each position is 0.0.\n     * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid for coordinate manipulation\n     * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\n     * @returns {WallGeometry}\n     *\n     *\n     * @example\n     * // create a wall that spans from 10000 meters to 20000 meters\n     * var wall = Cesium.WallGeometry.fromConstantHeights({\n     *   positions : Cesium.Cartesian3.fromDegreesArray([\n     *     19.0, 47.0,\n     *     19.0, 48.0,\n     *     20.0, 48.0,\n     *     20.0, 47.0,\n     *     19.0, 47.0,\n     *   ]),\n     *   minimumHeight : 20000.0,\n     *   maximumHeight : 10000.0\n     * });\n     * var geometry = Cesium.WallGeometry.createGeometry(wall);\n     *\n     * @see WallGeometry#createGeometry\n     */\n    WallGeometry.fromConstantHeights = function(options) {\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n        var positions = options.positions;\n\n        \n\n        var minHeights;\n        var maxHeights;\n\n        var min = options.minimumHeight;\n        var max = options.maximumHeight;\n\n        var doMin = defined(min);\n        var doMax = defined(max);\n        if (doMin || doMax) {\n            var length = positions.length;\n            minHeights = (doMin) ? new Array(length) : undefined;\n            maxHeights = (doMax) ? new Array(length) : undefined;\n\n            for (var i = 0; i < length; ++i) {\n                if (doMin) {\n                    minHeights[i] = min;\n                }\n\n                if (doMax) {\n                    maxHeights[i] = max;\n                }\n            }\n        }\n\n        var newOptions = {\n            positions : positions,\n            maximumHeights : maxHeights,\n            minimumHeights : minHeights,\n            ellipsoid : options.ellipsoid,\n            vertexFormat : options.vertexFormat\n        };\n        return new WallGeometry(newOptions);\n    };\n\n    /**\n     * Computes the geometric representation of a wall, including its vertices, indices, and a bounding sphere.\n     *\n     * @param {WallGeometry} wallGeometry A description of the wall.\n     * @returns {Geometry|undefined} The computed vertices and indices.\n     */\n    WallGeometry.createGeometry = function(wallGeometry) {\n        var wallPositions = wallGeometry._positions;\n        var minimumHeights = wallGeometry._minimumHeights;\n        var maximumHeights = wallGeometry._maximumHeights;\n        var vertexFormat = wallGeometry._vertexFormat;\n        var granularity = wallGeometry._granularity;\n        var ellipsoid = wallGeometry._ellipsoid;\n\n        var pos = WallGeometryLibrary.computePositions(ellipsoid, wallPositions, maximumHeights, minimumHeights, granularity, true);\n        if (!defined(pos)) {\n            return;\n        }\n\n        var bottomPositions = pos.bottomPositions;\n        var topPositions = pos.topPositions;\n        var numCorners = pos.numCorners;\n\n        var length = topPositions.length;\n        var size = length * 2;\n\n        var positions = vertexFormat.position ? new Float64Array(size) : undefined;\n        var normals = vertexFormat.normal ? new Float32Array(size) : undefined;\n        var tangents = vertexFormat.tangent ? new Float32Array(size) : undefined;\n        var bitangents = vertexFormat.bitangent ? new Float32Array(size) : undefined;\n        var textureCoordinates = vertexFormat.st ? new Float32Array(size / 3 * 2) : undefined;\n\n        var positionIndex = 0;\n        var normalIndex = 0;\n        var bitangentIndex = 0;\n        var tangentIndex = 0;\n        var stIndex = 0;\n\n        // add lower and upper points one after the other, lower\n        // points being even and upper points being odd\n        var normal = scratchNormal;\n        var tangent = scratchTangent;\n        var bitangent = scratchBitangent;\n        var recomputeNormal = true;\n        length /= 3;\n        var i;\n        var s = 0;\n        var ds = 1/(length - wallPositions.length + 1);\n        for (i = 0; i < length; ++i) {\n            var i3 = i * 3;\n            var topPosition = Cartesian3.fromArray(topPositions, i3, scratchCartesian3Position1);\n            var bottomPosition = Cartesian3.fromArray(bottomPositions, i3, scratchCartesian3Position2);\n            if (vertexFormat.position) {\n                // insert the lower point\n                positions[positionIndex++] = bottomPosition.x;\n                positions[positionIndex++] = bottomPosition.y;\n                positions[positionIndex++] = bottomPosition.z;\n\n                // insert the upper point\n                positions[positionIndex++] = topPosition.x;\n                positions[positionIndex++] = topPosition.y;\n                positions[positionIndex++] = topPosition.z;\n            }\n\n            if (vertexFormat.st) {\n                textureCoordinates[stIndex++] = s;\n                textureCoordinates[stIndex++] = 0.0;\n\n                textureCoordinates[stIndex++] = s;\n                textureCoordinates[stIndex++] = 1.0;\n            }\n\n            if (vertexFormat.normal || vertexFormat.tangent || vertexFormat.bitangent) {\n                var nextPosition;\n                var nextTop = Cartesian3.clone(Cartesian3.ZERO, scratchCartesian3Position5);\n                var groundPosition = ellipsoid.scaleToGeodeticSurface(Cartesian3.fromArray(topPositions, i3, scratchCartesian3Position2), scratchCartesian3Position2);\n                if (i + 1 < length) {\n                    nextPosition = ellipsoid.scaleToGeodeticSurface(Cartesian3.fromArray(topPositions, i3 + 3, scratchCartesian3Position3), scratchCartesian3Position3);\n                    nextTop = Cartesian3.fromArray(topPositions, i3 + 3, scratchCartesian3Position5);\n                }\n\n                if (recomputeNormal) {\n                    var scalednextPosition = Cartesian3.subtract(nextTop, topPosition, scratchCartesian3Position4);\n                    var scaledGroundPosition = Cartesian3.subtract(groundPosition, topPosition, scratchCartesian3Position1);\n                    normal = Cartesian3.normalize(Cartesian3.cross(scaledGroundPosition, scalednextPosition, normal), normal);\n                    recomputeNormal = false;\n                }\n\n                if (Cartesian3.equalsEpsilon(nextPosition, groundPosition, CesiumMath.EPSILON10)) {\n                    recomputeNormal = true;\n                } else {\n                    s += ds;\n                    if (vertexFormat.tangent) {\n                        tangent = Cartesian3.normalize(Cartesian3.subtract(nextPosition, groundPosition, tangent), tangent);\n                    }\n                    if (vertexFormat.bitangent) {\n                        bitangent = Cartesian3.normalize(Cartesian3.cross(normal, tangent, bitangent), bitangent);\n                    }\n                }\n\n                if (vertexFormat.normal) {\n                    normals[normalIndex++] = normal.x;\n                    normals[normalIndex++] = normal.y;\n                    normals[normalIndex++] = normal.z;\n\n                    normals[normalIndex++] = normal.x;\n                    normals[normalIndex++] = normal.y;\n                    normals[normalIndex++] = normal.z;\n                }\n\n                if (vertexFormat.tangent) {\n                    tangents[tangentIndex++] = tangent.x;\n                    tangents[tangentIndex++] = tangent.y;\n                    tangents[tangentIndex++] = tangent.z;\n\n                    tangents[tangentIndex++] = tangent.x;\n                    tangents[tangentIndex++] = tangent.y;\n                    tangents[tangentIndex++] = tangent.z;\n                }\n\n                if (vertexFormat.bitangent) {\n                    bitangents[bitangentIndex++] = bitangent.x;\n                    bitangents[bitangentIndex++] = bitangent.y;\n                    bitangents[bitangentIndex++] = bitangent.z;\n\n                    bitangents[bitangentIndex++] = bitangent.x;\n                    bitangents[bitangentIndex++] = bitangent.y;\n                    bitangents[bitangentIndex++] = bitangent.z;\n                }\n            }\n        }\n\n        var attributes = new GeometryAttributes();\n\n        if (vertexFormat.position) {\n            attributes.position = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.DOUBLE,\n                componentsPerAttribute : 3,\n                values : positions\n            });\n        }\n\n        if (vertexFormat.normal) {\n            attributes.normal = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.FLOAT,\n                componentsPerAttribute : 3,\n                values : normals\n            });\n        }\n\n        if (vertexFormat.tangent) {\n            attributes.tangent = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.FLOAT,\n                componentsPerAttribute : 3,\n                values : tangents\n            });\n        }\n\n        if (vertexFormat.bitangent) {\n            attributes.bitangent = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.FLOAT,\n                componentsPerAttribute : 3,\n                values : bitangents\n            });\n        }\n\n        if (vertexFormat.st) {\n            attributes.st = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.FLOAT,\n                componentsPerAttribute : 2,\n                values : textureCoordinates\n            });\n        }\n\n        // prepare the side walls, two triangles for each wall\n        //\n        //    A (i+1)  B (i+3) E\n        //    +--------+-------+\n        //    |      / |      /|    triangles:  A C B\n        //    |     /  |     / |                B C D\n        //    |    /   |    /  |\n        //    |   /    |   /   |\n        //    |  /     |  /    |\n        //    | /      | /     |\n        //    +--------+-------+\n        //    C (i)    D (i+2) F\n        //\n\n        var numVertices = size / 3;\n        size -= 6 * (numCorners + 1);\n        var indices = IndexDatatype.createTypedArray(numVertices, size);\n\n        var edgeIndex = 0;\n        for (i = 0; i < numVertices - 2; i += 2) {\n            var LL = i;\n            var LR = i + 2;\n            var pl = Cartesian3.fromArray(positions, LL * 3, scratchCartesian3Position1);\n            var pr = Cartesian3.fromArray(positions, LR * 3, scratchCartesian3Position2);\n            if (Cartesian3.equalsEpsilon(pl, pr, CesiumMath.EPSILON10)) {\n                continue;\n            }\n            var UL = i + 1;\n            var UR = i + 3;\n\n            indices[edgeIndex++] = UL;\n            indices[edgeIndex++] = LL;\n            indices[edgeIndex++] = UR;\n            indices[edgeIndex++] = UR;\n            indices[edgeIndex++] = LL;\n            indices[edgeIndex++] = LR;\n        }\n\n        return new Geometry({\n            attributes : attributes,\n            indices : indices,\n            primitiveType : PrimitiveType.TRIANGLES,\n            boundingSphere : new BoundingSphere.fromVertices(positions)\n        });\n    };\nexport default WallGeometry;\n","import BoundingSphere from './BoundingSphere.js';\nimport Cartesian3 from './Cartesian3.js';\nimport ComponentDatatype from './ComponentDatatype.js';\nimport defaultValue from './defaultValue.js';\nimport defined from './defined.js';\nimport DeveloperError from './DeveloperError.js';\nimport Ellipsoid from './Ellipsoid.js';\nimport Geometry from './Geometry.js';\nimport GeometryAttribute from './GeometryAttribute.js';\nimport GeometryAttributes from './GeometryAttributes.js';\nimport IndexDatatype from './IndexDatatype.js';\nimport CesiumMath from './Math.js';\nimport PrimitiveType from './PrimitiveType.js';\nimport WallGeometryLibrary from './WallGeometryLibrary.js';\n\n    var scratchCartesian3Position1 = new Cartesian3();\n    var scratchCartesian3Position2 = new Cartesian3();\n\n    /**\n     * A description of a wall outline. A wall is defined by a series of points,\n     * which extrude down to the ground. Optionally, they can extrude downwards to a specified height.\n     *\n     * @alias WallOutlineGeometry\n     * @constructor\n     *\n     * @param {Object} options Object with the following properties:\n     * @param {Cartesian3[]} options.positions An array of Cartesian objects, which are the points of the wall.\n     * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n     * @param {Number[]} [options.maximumHeights] An array parallel to <code>positions</code> that give the maximum height of the\n     *        wall at <code>positions</code>. If undefined, the height of each position in used.\n     * @param {Number[]} [options.minimumHeights] An array parallel to <code>positions</code> that give the minimum height of the\n     *        wall at <code>positions</code>. If undefined, the height at each position is 0.0.\n     * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid for coordinate manipulation\n     *\n     * @exception {DeveloperError} positions length must be greater than or equal to 2.\n     * @exception {DeveloperError} positions and maximumHeights must have the same length.\n     * @exception {DeveloperError} positions and minimumHeights must have the same length.\n     *\n     * @see WallGeometry#createGeometry\n     * @see WallGeometry#fromConstantHeight\n     *\n     * @example\n     * // create a wall outline that spans from ground level to 10000 meters\n     * var wall = new Cesium.WallOutlineGeometry({\n     *   positions : Cesium.Cartesian3.fromDegreesArrayHeights([\n     *     19.0, 47.0, 10000.0,\n     *     19.0, 48.0, 10000.0,\n     *     20.0, 48.0, 10000.0,\n     *     20.0, 47.0, 10000.0,\n     *     19.0, 47.0, 10000.0\n     *   ])\n     * });\n     * var geometry = Cesium.WallOutlineGeometry.createGeometry(wall);\n     */\n    function WallOutlineGeometry(options) {\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n        var wallPositions = options.positions;\n        var maximumHeights = options.maximumHeights;\n        var minimumHeights = options.minimumHeights;\n\n        \n\n        var granularity = defaultValue(options.granularity, CesiumMath.RADIANS_PER_DEGREE);\n        var ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\n\n        this._positions = wallPositions;\n        this._minimumHeights = minimumHeights;\n        this._maximumHeights = maximumHeights;\n        this._granularity = granularity;\n        this._ellipsoid = Ellipsoid.clone(ellipsoid);\n        this._workerName = 'createWallOutlineGeometry';\n\n        var numComponents = 1 + wallPositions.length * Cartesian3.packedLength + 2;\n        if (defined(minimumHeights)) {\n            numComponents += minimumHeights.length;\n        }\n        if (defined(maximumHeights)) {\n            numComponents += maximumHeights.length;\n        }\n\n        /**\n         * The number of elements used to pack the object into an array.\n         * @type {Number}\n         */\n        this.packedLength = numComponents + Ellipsoid.packedLength + 1;\n    }\n\n    /**\n     * Stores the provided instance into the provided array.\n     *\n     * @param {WallOutlineGeometry} value The value to pack.\n     * @param {Number[]} array The array to pack into.\n     * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n     *\n     * @returns {Number[]} The array that was packed into\n     */\n    WallOutlineGeometry.pack = function(value, array, startingIndex) {\n        \n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        var i;\n\n        var positions = value._positions;\n        var length = positions.length;\n        array[startingIndex++] = length;\n\n        for (i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {\n            Cartesian3.pack(positions[i], array, startingIndex);\n        }\n\n        var minimumHeights = value._minimumHeights;\n        length = defined(minimumHeights) ? minimumHeights.length : 0;\n        array[startingIndex++] = length;\n\n        if (defined(minimumHeights)) {\n            for (i = 0; i < length; ++i) {\n                array[startingIndex++] = minimumHeights[i];\n            }\n        }\n\n        var maximumHeights = value._maximumHeights;\n        length = defined(maximumHeights) ? maximumHeights.length : 0;\n        array[startingIndex++] = length;\n\n        if (defined(maximumHeights)) {\n            for (i = 0; i < length; ++i) {\n                array[startingIndex++] = maximumHeights[i];\n            }\n        }\n\n        Ellipsoid.pack(value._ellipsoid, array, startingIndex);\n        startingIndex += Ellipsoid.packedLength;\n\n        array[startingIndex]   = value._granularity;\n\n        return array;\n    };\n\n    var scratchEllipsoid = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);\n    var scratchOptions = {\n        positions : undefined,\n        minimumHeights : undefined,\n        maximumHeights : undefined,\n        ellipsoid : scratchEllipsoid,\n        granularity : undefined\n    };\n\n    /**\n     * Retrieves an instance from a packed array.\n     *\n     * @param {Number[]} array The packed array.\n     * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n     * @param {WallOutlineGeometry} [result] The object into which to store the result.\n     * @returns {WallOutlineGeometry} The modified result parameter or a new WallOutlineGeometry instance if one was not provided.\n     */\n    WallOutlineGeometry.unpack = function(array, startingIndex, result) {\n        \n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        var i;\n\n        var length = array[startingIndex++];\n        var positions = new Array(length);\n\n        for (i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {\n            positions[i] = Cartesian3.unpack(array, startingIndex);\n        }\n\n        length = array[startingIndex++];\n        var minimumHeights;\n\n        if (length > 0) {\n            minimumHeights = new Array(length);\n            for (i = 0; i < length; ++i) {\n                minimumHeights[i] = array[startingIndex++];\n            }\n        }\n\n        length = array[startingIndex++];\n        var maximumHeights;\n\n        if (length > 0) {\n            maximumHeights = new Array(length);\n            for (i = 0; i < length; ++i) {\n                maximumHeights[i] = array[startingIndex++];\n            }\n        }\n\n        var ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);\n        startingIndex += Ellipsoid.packedLength;\n\n        var granularity = array[startingIndex];\n\n        if (!defined(result)) {\n            scratchOptions.positions = positions;\n            scratchOptions.minimumHeights = minimumHeights;\n            scratchOptions.maximumHeights = maximumHeights;\n            scratchOptions.granularity = granularity;\n            return new WallOutlineGeometry(scratchOptions);\n        }\n\n        result._positions = positions;\n        result._minimumHeights = minimumHeights;\n        result._maximumHeights = maximumHeights;\n        result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);\n        result._granularity = granularity;\n\n        return result;\n    };\n\n    /**\n     * A description of a walloutline. A wall is defined by a series of points,\n     * which extrude down to the ground. Optionally, they can extrude downwards to a specified height.\n     *\n     * @param {Object} options Object with the following properties:\n     * @param {Cartesian3[]} options.positions An array of Cartesian objects, which are the points of the wall.\n     * @param {Number} [options.maximumHeight] A constant that defines the maximum height of the\n     *        wall at <code>positions</code>. If undefined, the height of each position in used.\n     * @param {Number} [options.minimumHeight] A constant that defines the minimum height of the\n     *        wall at <code>positions</code>. If undefined, the height at each position is 0.0.\n     * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid for coordinate manipulation\n     * @returns {WallOutlineGeometry}\n     *\n     *\n     * @example\n     * // create a wall that spans from 10000 meters to 20000 meters\n     * var wall = Cesium.WallOutlineGeometry.fromConstantHeights({\n     *   positions : Cesium.Cartesian3.fromDegreesArray([\n     *     19.0, 47.0,\n     *     19.0, 48.0,\n     *     20.0, 48.0,\n     *     20.0, 47.0,\n     *     19.0, 47.0,\n     *   ]),\n     *   minimumHeight : 20000.0,\n     *   maximumHeight : 10000.0\n     * });\n     * var geometry = Cesium.WallOutlineGeometry.createGeometry(wall);\n     *\n     * @see WallOutlineGeometry#createGeometry\n     */\n    WallOutlineGeometry.fromConstantHeights = function(options) {\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n        var positions = options.positions;\n\n        \n\n        var minHeights;\n        var maxHeights;\n\n        var min = options.minimumHeight;\n        var max = options.maximumHeight;\n\n        var doMin = defined(min);\n        var doMax = defined(max);\n        if (doMin || doMax) {\n            var length = positions.length;\n            minHeights = (doMin) ? new Array(length) : undefined;\n            maxHeights = (doMax) ? new Array(length) : undefined;\n\n            for (var i = 0; i < length; ++i) {\n                if (doMin) {\n                    minHeights[i] = min;\n                }\n\n                if (doMax) {\n                    maxHeights[i] = max;\n                }\n            }\n        }\n\n        var newOptions = {\n            positions : positions,\n            maximumHeights : maxHeights,\n            minimumHeights : minHeights,\n            ellipsoid : options.ellipsoid\n        };\n        return new WallOutlineGeometry(newOptions);\n    };\n\n    /**\n     * Computes the geometric representation of a wall outline, including its vertices, indices, and a bounding sphere.\n     *\n     * @param {WallOutlineGeometry} wallGeometry A description of the wall outline.\n     * @returns {Geometry|undefined} The computed vertices and indices.\n     */\n    WallOutlineGeometry.createGeometry = function(wallGeometry) {\n        var wallPositions = wallGeometry._positions;\n        var minimumHeights = wallGeometry._minimumHeights;\n        var maximumHeights = wallGeometry._maximumHeights;\n        var granularity = wallGeometry._granularity;\n        var ellipsoid = wallGeometry._ellipsoid;\n\n        var pos = WallGeometryLibrary.computePositions(ellipsoid, wallPositions, maximumHeights, minimumHeights, granularity, false);\n        if (!defined(pos)) {\n            return;\n        }\n\n        var bottomPositions = pos.bottomPositions;\n        var topPositions = pos.topPositions;\n\n        var length = topPositions.length;\n        var size = length * 2;\n\n        var positions = new Float64Array(size);\n        var positionIndex = 0;\n\n        // add lower and upper points one after the other, lower\n        // points being even and upper points being odd\n        length /= 3;\n        var i;\n        for (i = 0; i < length; ++i) {\n            var i3 = i * 3;\n            var topPosition = Cartesian3.fromArray(topPositions, i3, scratchCartesian3Position1);\n            var bottomPosition = Cartesian3.fromArray(bottomPositions, i3, scratchCartesian3Position2);\n\n            // insert the lower point\n            positions[positionIndex++] = bottomPosition.x;\n            positions[positionIndex++] = bottomPosition.y;\n            positions[positionIndex++] = bottomPosition.z;\n\n            // insert the upper point\n            positions[positionIndex++] = topPosition.x;\n            positions[positionIndex++] = topPosition.y;\n            positions[positionIndex++] = topPosition.z;\n        }\n\n        var attributes = new GeometryAttributes({\n            position : new GeometryAttribute({\n                componentDatatype : ComponentDatatype.DOUBLE,\n                componentsPerAttribute : 3,\n                values : positions\n            })\n        });\n\n        var numVertices = size / 3;\n        size = 2 * numVertices - 4 + numVertices;\n        var indices = IndexDatatype.createTypedArray(numVertices, size);\n\n        var edgeIndex = 0;\n        for (i = 0; i < numVertices - 2; i += 2) {\n            var LL = i;\n            var LR = i + 2;\n            var pl = Cartesian3.fromArray(positions, LL * 3, scratchCartesian3Position1);\n            var pr = Cartesian3.fromArray(positions, LR * 3, scratchCartesian3Position2);\n            if (Cartesian3.equalsEpsilon(pl, pr, CesiumMath.EPSILON10)) {\n                continue;\n            }\n            var UL = i + 1;\n            var UR = i + 3;\n\n            indices[edgeIndex++] = UL;\n            indices[edgeIndex++] = LL;\n            indices[edgeIndex++] = UL;\n            indices[edgeIndex++] = UR;\n            indices[edgeIndex++] = LL;\n            indices[edgeIndex++] = LR;\n        }\n\n        indices[edgeIndex++] = numVertices - 2;\n        indices[edgeIndex++] = numVertices - 1;\n\n        return new Geometry({\n            attributes : attributes,\n            indices : indices,\n            primitiveType : PrimitiveType.LINES,\n            boundingSphere : new BoundingSphere.fromVertices(positions)\n        });\n    };\nexport default WallOutlineGeometry;\n","import Check from '../Core/Check.js';\nimport Color from '../Core/Color.js';\nimport ColorGeometryInstanceAttribute from '../Core/ColorGeometryInstanceAttribute.js';\nimport defined from '../Core/defined.js';\nimport DeveloperError from '../Core/DeveloperError.js';\nimport DistanceDisplayConditionGeometryInstanceAttribute from '../Core/DistanceDisplayConditionGeometryInstanceAttribute.js';\nimport GeometryInstance from '../Core/GeometryInstance.js';\nimport Iso8601 from '../Core/Iso8601.js';\nimport ShowGeometryInstanceAttribute from '../Core/ShowGeometryInstanceAttribute.js';\nimport WallGeometry from '../Core/WallGeometry.js';\nimport WallOutlineGeometry from '../Core/WallOutlineGeometry.js';\nimport MaterialAppearance from '../Scene/MaterialAppearance.js';\nimport PerInstanceColorAppearance from '../Scene/PerInstanceColorAppearance.js';\nimport ColorMaterialProperty from './ColorMaterialProperty.js';\nimport DynamicGeometryUpdater from './DynamicGeometryUpdater.js';\nimport GeometryUpdater from './GeometryUpdater.js';\nimport Property from './Property.js';\n\n    var scratchColor = new Color();\n\n    function WallGeometryOptions(entity) {\n        this.id = entity;\n        this.vertexFormat = undefined;\n        this.positions = undefined;\n        this.minimumHeights = undefined;\n        this.maximumHeights = undefined;\n        this.granularity = undefined;\n    }\n\n    /**\n     * A {@link GeometryUpdater} for walls.\n     * Clients do not normally create this class directly, but instead rely on {@link DataSourceDisplay}.\n     * @alias WallGeometryUpdater\n     * @constructor\n     *\n     * @param {Entity} entity The entity containing the geometry to be visualized.\n     * @param {Scene} scene The scene where visualization is taking place.\n     */\n    function WallGeometryUpdater(entity, scene) {\n        GeometryUpdater.call(this, {\n            entity : entity,\n            scene : scene,\n            geometryOptions : new WallGeometryOptions(entity),\n            geometryPropertyName : 'wall',\n            observedPropertyNames : ['availability', 'wall']\n        });\n\n        this._onEntityPropertyChanged(entity, 'wall', entity.wall, undefined);\n    }\n\n    if (defined(Object.create)) {\n        WallGeometryUpdater.prototype = Object.create(GeometryUpdater.prototype);\n        WallGeometryUpdater.prototype.constructor = WallGeometryUpdater;\n    }\n\n    /**\n     * Creates the geometry instance which represents the fill of the geometry.\n     *\n     * @param {JulianDate} time The time to use when retrieving initial attribute values.\n     * @returns {GeometryInstance} The geometry instance representing the filled portion of the geometry.\n     *\n     * @exception {DeveloperError} This instance does not represent a filled geometry.\n     */\n    WallGeometryUpdater.prototype.createFillGeometryInstance = function(time) {\n        \n\n        var entity = this._entity;\n        var isAvailable = entity.isAvailable(time);\n\n        var attributes;\n\n        var color;\n        var show = new ShowGeometryInstanceAttribute(isAvailable && entity.isShowing && this._showProperty.getValue(time) && this._fillProperty.getValue(time));\n        var distanceDisplayCondition = this._distanceDisplayConditionProperty.getValue(time);\n        var distanceDisplayConditionAttribute = DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(distanceDisplayCondition);\n        if (this._materialProperty instanceof ColorMaterialProperty) {\n            var currentColor;\n            if (defined(this._materialProperty.color) && (this._materialProperty.color.isConstant || isAvailable)) {\n                currentColor = this._materialProperty.color.getValue(time, scratchColor);\n            }\n            if (!defined(currentColor)) {\n                currentColor = Color.WHITE;\n            }\n            color = ColorGeometryInstanceAttribute.fromColor(currentColor);\n            attributes = {\n                show : show,\n                distanceDisplayCondition : distanceDisplayConditionAttribute,\n                color : color\n            };\n        } else {\n            attributes = {\n                show : show,\n                distanceDisplayCondition : distanceDisplayConditionAttribute\n            };\n        }\n\n        return new GeometryInstance({\n            id : entity,\n            geometry : new WallGeometry(this._options),\n            attributes : attributes\n        });\n    };\n\n    /**\n     * Creates the geometry instance which represents the outline of the geometry.\n     *\n     * @param {JulianDate} time The time to use when retrieving initial attribute values.\n     * @returns {GeometryInstance} The geometry instance representing the outline portion of the geometry.\n     *\n     * @exception {DeveloperError} This instance does not represent an outlined geometry.\n     */\n    WallGeometryUpdater.prototype.createOutlineGeometryInstance = function(time) {\n        \n\n        var entity = this._entity;\n        var isAvailable = entity.isAvailable(time);\n        var outlineColor = Property.getValueOrDefault(this._outlineColorProperty, time, Color.BLACK, scratchColor);\n        var distanceDisplayCondition = this._distanceDisplayConditionProperty.getValue(time);\n\n        return new GeometryInstance({\n            id : entity,\n            geometry : new WallOutlineGeometry(this._options),\n            attributes : {\n                show : new ShowGeometryInstanceAttribute(isAvailable && entity.isShowing && this._showProperty.getValue(time) && this._showOutlineProperty.getValue(time)),\n                color : ColorGeometryInstanceAttribute.fromColor(outlineColor),\n                distanceDisplayCondition : DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(distanceDisplayCondition)\n            }\n        });\n    };\n\n    WallGeometryUpdater.prototype._isHidden = function(entity, wall) {\n        return !defined(wall.positions) || GeometryUpdater.prototype._isHidden.call(this, entity, wall);\n    };\n\n    WallGeometryUpdater.prototype._getIsClosed = function(options) {\n        return false;\n    };\n\n    WallGeometryUpdater.prototype._isDynamic = function(entity, wall) {\n        return !wall.positions.isConstant || //\n               !Property.isConstant(wall.minimumHeights) || //\n               !Property.isConstant(wall.maximumHeights) || //\n               !Property.isConstant(wall.outlineWidth) || //\n               !Property.isConstant(wall.granularity);\n    };\n\n    WallGeometryUpdater.prototype._setStaticOptions = function(entity, wall) {\n        var minimumHeights = wall.minimumHeights;\n        var maximumHeights = wall.maximumHeights;\n        var granularity = wall.granularity;\n        var isColorMaterial = this._materialProperty instanceof ColorMaterialProperty;\n\n        var options = this._options;\n        options.vertexFormat = isColorMaterial ? PerInstanceColorAppearance.VERTEX_FORMAT : MaterialAppearance.MaterialSupport.TEXTURED.vertexFormat;\n        options.positions = wall.positions.getValue(Iso8601.MINIMUM_VALUE, options.positions);\n        options.minimumHeights = defined(minimumHeights) ? minimumHeights.getValue(Iso8601.MINIMUM_VALUE, options.minimumHeights) : undefined;\n        options.maximumHeights = defined(maximumHeights) ? maximumHeights.getValue(Iso8601.MINIMUM_VALUE, options.maximumHeights) : undefined;\n        options.granularity = defined(granularity) ? granularity.getValue(Iso8601.MINIMUM_VALUE) : undefined;\n    };\n\n    WallGeometryUpdater.DynamicGeometryUpdater = DynamicWallGeometryUpdater;\n\n    /**\n     * @private\n     */\n    function DynamicWallGeometryUpdater(geometryUpdater, primitives, groundPrimitives) {\n        DynamicGeometryUpdater.call(this, geometryUpdater, primitives, groundPrimitives);\n    }\n\n    if (defined(Object.create)) {\n        DynamicWallGeometryUpdater.prototype = Object.create(DynamicGeometryUpdater.prototype);\n        DynamicWallGeometryUpdater.prototype.constructor = DynamicWallGeometryUpdater;\n    }\n\n    DynamicWallGeometryUpdater.prototype._isHidden = function(entity, wall, time) {\n        return  !defined(this._options.positions) || DynamicGeometryUpdater.prototype._isHidden.call(this, entity, wall, time);\n    };\n\n    DynamicWallGeometryUpdater.prototype._setOptions = function(entity, wall, time) {\n        var options = this._options;\n        options.positions = Property.getValueOrUndefined(wall.positions, time, options.positions);\n        options.minimumHeights = Property.getValueOrUndefined(wall.minimumHeights, time, options.minimumHeights);\n        options.maximumHeights = Property.getValueOrUndefined(wall.maximumHeights, time, options.maximumHeights);\n        options.granularity = Property.getValueOrUndefined(wall.granularity, time);\n    };\nexport default WallGeometryUpdater;\n","import AssociativeArray from '../Core/AssociativeArray.js';\nimport BoundingSphere from '../Core/BoundingSphere.js';\nimport Check from '../Core/Check.js';\nimport defaultValue from '../Core/defaultValue.js';\nimport defined from '../Core/defined.js';\nimport destroyObject from '../Core/destroyObject.js';\nimport Event from '../Core/Event.js';\nimport EventHelper from '../Core/EventHelper.js';\nimport ClassificationType from '../Scene/ClassificationType.js';\nimport MaterialAppearance from '../Scene/MaterialAppearance.js';\nimport PerInstanceColorAppearance from '../Scene/PerInstanceColorAppearance.js';\nimport ShadowMode from '../Scene/ShadowMode.js';\nimport BoundingSphereState from './BoundingSphereState.js';\nimport BoxGeometryUpdater from './BoxGeometryUpdater.js';\nimport ColorMaterialProperty from './ColorMaterialProperty.js';\nimport CorridorGeometryUpdater from './CorridorGeometryUpdater.js';\nimport CylinderGeometryUpdater from './CylinderGeometryUpdater.js';\nimport DynamicGeometryBatch from './DynamicGeometryBatch.js';\nimport EllipseGeometryUpdater from './EllipseGeometryUpdater.js';\nimport EllipsoidGeometryUpdater from './EllipsoidGeometryUpdater.js';\nimport Entity from './Entity.js';\nimport PlaneGeometryUpdater from './PlaneGeometryUpdater.js';\nimport PolygonGeometryUpdater from './PolygonGeometryUpdater.js';\nimport PolylineVolumeGeometryUpdater from './PolylineVolumeGeometryUpdater.js';\nimport RectangleGeometryUpdater from './RectangleGeometryUpdater.js';\nimport StaticGeometryColorBatch from './StaticGeometryColorBatch.js';\nimport StaticGeometryPerMaterialBatch from './StaticGeometryPerMaterialBatch.js';\nimport StaticGroundGeometryColorBatch from './StaticGroundGeometryColorBatch.js';\nimport StaticGroundGeometryPerMaterialBatch from './StaticGroundGeometryPerMaterialBatch.js';\nimport StaticOutlineGeometryBatch from './StaticOutlineGeometryBatch.js';\nimport WallGeometryUpdater from './WallGeometryUpdater.js';\n\n    var emptyArray = [];\n\n    var geometryUpdaters = [BoxGeometryUpdater, CylinderGeometryUpdater, CorridorGeometryUpdater, EllipseGeometryUpdater, EllipsoidGeometryUpdater, PlaneGeometryUpdater,\n                            PolygonGeometryUpdater, PolylineVolumeGeometryUpdater, RectangleGeometryUpdater, WallGeometryUpdater];\n\n    function GeometryUpdaterSet(entity, scene) {\n        this.entity = entity;\n        this.scene = scene;\n        var updaters = new Array(geometryUpdaters.length);\n        var geometryChanged = new Event();\n        function raiseEvent(geometry) {\n            geometryChanged.raiseEvent(geometry);\n        }\n        var eventHelper = new EventHelper();\n        for (var i = 0; i < updaters.length; i++) {\n            var updater = new geometryUpdaters[i](entity, scene);\n            eventHelper.add(updater.geometryChanged, raiseEvent);\n            updaters[i] = updater;\n        }\n        this.updaters = updaters;\n        this.geometryChanged = geometryChanged;\n        this.eventHelper = eventHelper;\n\n        this._removeEntitySubscription = entity.definitionChanged.addEventListener(GeometryUpdaterSet.prototype._onEntityPropertyChanged, this);\n    }\n\n    GeometryUpdaterSet.prototype._onEntityPropertyChanged = function(entity, propertyName, newValue, oldValue) {\n        var updaters = this.updaters;\n        for (var i = 0; i < updaters.length; i++) {\n            updaters[i]._onEntityPropertyChanged(entity, propertyName, newValue, oldValue);\n        }\n    };\n\n    GeometryUpdaterSet.prototype.forEach = function (callback) {\n        var updaters = this.updaters;\n        for (var i = 0; i < updaters.length; i++) {\n            callback(updaters[i]);\n        }\n    };\n\n    GeometryUpdaterSet.prototype.destroy = function() {\n        this.eventHelper.removeAll();\n        var updaters = this.updaters;\n        for (var i = 0; i < updaters.length; i++) {\n            updaters[i].destroy();\n        }\n        this._removeEntitySubscription();\n        destroyObject(this);\n    };\n\n    /**\n     * A general purpose visualizer for geometry represented by {@link Primitive} instances.\n     * @alias GeometryVisualizer\n     * @constructor\n     *\n     * @param {Scene} scene The scene the primitives will be rendered in.\n     * @param {EntityCollection} entityCollection The entityCollection to visualize.\n     * @param {PrimitiveCollection} [primitives=scene.primitives] A collection to add primitives related to the entities\n     * @param {PrimitiveCollection} [groundPrimitives=scene.groundPrimitives] A collection to add ground primitives related to the entities\n     */\n    function GeometryVisualizer(scene, entityCollection, primitives, groundPrimitives) {\n        \n\n        primitives = defaultValue(primitives, scene.primitives);\n        groundPrimitives = defaultValue(groundPrimitives, scene.groundPrimitives);\n\n        this._scene = scene;\n        this._primitives = primitives;\n        this._groundPrimitives = groundPrimitives;\n        this._entityCollection = undefined;\n        this._addedObjects = new AssociativeArray();\n        this._removedObjects = new AssociativeArray();\n        this._changedObjects = new AssociativeArray();\n\n        var numberOfShadowModes = ShadowMode.NUMBER_OF_SHADOW_MODES;\n        this._outlineBatches = new Array(numberOfShadowModes*2);\n        this._closedColorBatches = new Array(numberOfShadowModes*2);\n        this._closedMaterialBatches = new Array(numberOfShadowModes*2);\n        this._openColorBatches = new Array(numberOfShadowModes*2);\n        this._openMaterialBatches = new Array(numberOfShadowModes*2);\n\n        var supportsMaterialsforEntitiesOnTerrain = Entity.supportsMaterialsforEntitiesOnTerrain(scene);\n        this._supportsMaterialsforEntitiesOnTerrain = supportsMaterialsforEntitiesOnTerrain;\n\n        var i;\n        for (i = 0; i < numberOfShadowModes; ++i) {\n            this._outlineBatches[i] = new StaticOutlineGeometryBatch(primitives, scene, i, false);\n            this._outlineBatches[numberOfShadowModes + i] = new StaticOutlineGeometryBatch(primitives, scene, i, true);\n\n            this._closedColorBatches[i] = new StaticGeometryColorBatch(primitives, PerInstanceColorAppearance, undefined, true, i, true);\n            this._closedColorBatches[numberOfShadowModes + i] = new StaticGeometryColorBatch(primitives, PerInstanceColorAppearance, undefined, true, i, false);\n\n            this._closedMaterialBatches[i] = new StaticGeometryPerMaterialBatch(primitives, MaterialAppearance, undefined, true, i, true);\n            this._closedMaterialBatches[numberOfShadowModes + i] = new StaticGeometryPerMaterialBatch(primitives, MaterialAppearance, undefined, true, i, false);\n\n            this._openColorBatches[i] = new StaticGeometryColorBatch(primitives, PerInstanceColorAppearance, undefined, false, i, true);\n            this._openColorBatches[numberOfShadowModes + i] = new StaticGeometryColorBatch(primitives, PerInstanceColorAppearance, undefined, false, i, false);\n\n            this._openMaterialBatches[i] = new StaticGeometryPerMaterialBatch(primitives, MaterialAppearance, undefined, false, i, true);\n            this._openMaterialBatches[numberOfShadowModes + i] = new StaticGeometryPerMaterialBatch(primitives, MaterialAppearance, undefined, false, i, false);\n        }\n\n        var numberOfClassificationTypes = ClassificationType.NUMBER_OF_CLASSIFICATION_TYPES;\n        var groundColorBatches = new Array(numberOfClassificationTypes);\n        var groundMaterialBatches = [];\n        if (supportsMaterialsforEntitiesOnTerrain) {\n            for (i = 0; i < numberOfClassificationTypes; ++i) {\n                groundMaterialBatches.push(new StaticGroundGeometryPerMaterialBatch(groundPrimitives, i, MaterialAppearance));\n                groundColorBatches[i] = new StaticGroundGeometryPerMaterialBatch(groundPrimitives, i, PerInstanceColorAppearance);\n            }\n        } else {\n            for (i = 0; i < numberOfClassificationTypes; ++i) {\n                groundColorBatches[i] = new StaticGroundGeometryColorBatch(groundPrimitives, i);\n            }\n        }\n\n        this._groundColorBatches = groundColorBatches;\n        this._groundMaterialBatches = groundMaterialBatches;\n\n        this._dynamicBatch = new DynamicGeometryBatch(primitives, groundPrimitives);\n\n        this._batches = this._outlineBatches.concat(this._closedColorBatches, this._closedMaterialBatches, this._openColorBatches, this._openMaterialBatches, this._groundColorBatches, this._groundMaterialBatches, this._dynamicBatch);\n\n        this._subscriptions = new AssociativeArray();\n        this._updaterSets = new AssociativeArray();\n\n        this._entityCollection = entityCollection;\n        entityCollection.collectionChanged.addEventListener(GeometryVisualizer.prototype._onCollectionChanged, this);\n        this._onCollectionChanged(entityCollection, entityCollection.values, emptyArray);\n    }\n\n    /**\n     * Updates all of the primitives created by this visualizer to match their\n     * Entity counterpart at the given time.\n     *\n     * @param {JulianDate} time The time to update to.\n     * @returns {Boolean} True if the visualizer successfully updated to the provided time,\n     * false if the visualizer is waiting for asynchronous primitives to be created.\n     */\n    GeometryVisualizer.prototype.update = function(time) {\n        \n\n        var addedObjects = this._addedObjects;\n        var added = addedObjects.values;\n        var removedObjects = this._removedObjects;\n        var removed = removedObjects.values;\n        var changedObjects = this._changedObjects;\n        var changed = changedObjects.values;\n\n        var i;\n        var entity;\n        var id;\n        var updaterSet;\n        var that = this;\n\n        for (i = changed.length - 1; i > -1; i--) {\n            entity = changed[i];\n            id = entity.id;\n            updaterSet = this._updaterSets.get(id);\n\n            //If in a single update, an entity gets removed and a new instance\n            //re-added with the same id, the updater no longer tracks the\n            //correct entity, we need to both remove the old one and\n            //add the new one, which is done by pushing the entity\n            //onto the removed/added lists.\n            if (updaterSet.entity === entity) {\n                updaterSet.forEach(function(updater) {\n                    that._removeUpdater(updater);\n                    that._insertUpdaterIntoBatch(time, updater);\n                });\n            } else {\n                removed.push(entity);\n                added.push(entity);\n            }\n        }\n\n        for (i = removed.length - 1; i > -1; i--) {\n            entity = removed[i];\n            id = entity.id;\n            updaterSet = this._updaterSets.get(id);\n            updaterSet.forEach(this._removeUpdater.bind(this));\n            updaterSet.destroy();\n            this._updaterSets.remove(id);\n            this._subscriptions.get(id)();\n            this._subscriptions.remove(id);\n        }\n\n        for (i = added.length - 1; i > -1; i--) {\n            entity = added[i];\n            id = entity.id;\n            updaterSet = new GeometryUpdaterSet(entity, this._scene);\n            this._updaterSets.set(id, updaterSet);\n            updaterSet.forEach(function(updater) {\n                that._insertUpdaterIntoBatch(time, updater);\n            });\n            this._subscriptions.set(id, updaterSet.geometryChanged.addEventListener(GeometryVisualizer._onGeometryChanged, this));\n        }\n\n        addedObjects.removeAll();\n        removedObjects.removeAll();\n        changedObjects.removeAll();\n\n        var isUpdated = true;\n        var batches = this._batches;\n        var length = batches.length;\n        for (i = 0; i < length; i++) {\n            isUpdated = batches[i].update(time) && isUpdated;\n        }\n\n        return isUpdated;\n    };\n\n    var getBoundingSphereArrayScratch = [];\n    var getBoundingSphereBoundingSphereScratch = new BoundingSphere();\n\n    /**\n     * Computes a bounding sphere which encloses the visualization produced for the specified entity.\n     * The bounding sphere is in the fixed frame of the scene's globe.\n     *\n     * @param {Entity} entity The entity whose bounding sphere to compute.\n     * @param {BoundingSphere} result The bounding sphere onto which to store the result.\n     * @returns {BoundingSphereState} BoundingSphereState.DONE if the result contains the bounding sphere,\n     *                       BoundingSphereState.PENDING if the result is still being computed, or\n     *                       BoundingSphereState.FAILED if the entity has no visualization in the current scene.\n     * @private\n     */\n    GeometryVisualizer.prototype.getBoundingSphere = function(entity, result) {\n        \n\n        var boundingSpheres = getBoundingSphereArrayScratch;\n        var tmp = getBoundingSphereBoundingSphereScratch;\n\n        var count = 0;\n        var state = BoundingSphereState.DONE;\n        var batches = this._batches;\n        var batchesLength = batches.length;\n\n        var id = entity.id;\n        var updaters = this._updaterSets.get(id).updaters;\n\n        for (var j = 0; j < updaters.length; j++) {\n            var updater = updaters[j];\n            for (var i = 0; i < batchesLength; i++) {\n                state = batches[i].getBoundingSphere(updater, tmp);\n                if (state === BoundingSphereState.PENDING) {\n                    return BoundingSphereState.PENDING;\n                } else if (state === BoundingSphereState.DONE) {\n                    boundingSpheres[count] = BoundingSphere.clone(tmp, boundingSpheres[count]);\n                    count++;\n                }\n            }\n        }\n\n        if (count === 0) {\n            return BoundingSphereState.FAILED;\n        }\n\n        boundingSpheres.length = count;\n        BoundingSphere.fromBoundingSpheres(boundingSpheres, result);\n        return BoundingSphereState.DONE;\n    };\n\n    /**\n     * Returns true if this object was destroyed; otherwise, false.\n     *\n     * @returns {Boolean} True if this object was destroyed; otherwise, false.\n     */\n    GeometryVisualizer.prototype.isDestroyed = function() {\n        return false;\n    };\n\n    /**\n     * Removes and destroys all primitives created by this instance.\n     */\n    GeometryVisualizer.prototype.destroy = function() {\n        this._entityCollection.collectionChanged.removeEventListener(GeometryVisualizer.prototype._onCollectionChanged, this);\n        this._addedObjects.removeAll();\n        this._removedObjects.removeAll();\n\n        var i;\n        var batches = this._batches;\n        var length = batches.length;\n        for (i = 0; i < length; i++) {\n            batches[i].removeAllPrimitives();\n        }\n\n        var subscriptions = this._subscriptions.values;\n        length = subscriptions.length;\n        for (i = 0; i < length; i++) {\n            subscriptions[i]();\n        }\n        this._subscriptions.removeAll();\n\n        var updaterSets = this._updaterSets.values;\n        length = updaterSets.length;\n        for (i = 0; i < length; i++) {\n            updaterSets[i].destroy();\n        }\n        this._updaterSets.removeAll();\n        return destroyObject(this);\n    };\n\n    /**\n     * @private\n     */\n    GeometryVisualizer.prototype._removeUpdater = function(updater) {\n        //We don't keep track of which batch an updater is in, so just remove it from all of them.\n        var batches = this._batches;\n        var length = batches.length;\n        for (var i = 0; i < length; i++) {\n            batches[i].remove(updater);\n        }\n    };\n\n    /**\n     * @private\n     */\n    GeometryVisualizer.prototype._insertUpdaterIntoBatch = function(time, updater) {\n        if (updater.isDynamic) {\n            this._dynamicBatch.add(time, updater);\n            return;\n        }\n\n        var shadows;\n        if (updater.outlineEnabled || updater.fillEnabled) {\n            shadows = updater.shadowsProperty.getValue(time);\n        }\n\n        var numberOfShadowModes = ShadowMode.NUMBER_OF_SHADOW_MODES;\n        if (updater.outlineEnabled) {\n            if (defined(updater.terrainOffsetProperty)) {\n                this._outlineBatches[numberOfShadowModes + shadows].add(time, updater);\n            } else {\n                this._outlineBatches[shadows].add(time, updater);\n            }\n        }\n\n        if (updater.fillEnabled) {\n            if (updater.onTerrain) {\n                var classificationType = updater.classificationTypeProperty.getValue(time);\n                if (updater.fillMaterialProperty instanceof ColorMaterialProperty) {\n                    this._groundColorBatches[classificationType].add(time, updater);\n                } else {\n                    // If unsupported, updater will not be on terrain.\n                    this._groundMaterialBatches[classificationType].add(time, updater);\n                }\n            } else if (updater.isClosed) {\n                if (updater.fillMaterialProperty instanceof ColorMaterialProperty) {\n                    if (defined(updater.terrainOffsetProperty)) {\n                        this._closedColorBatches[numberOfShadowModes + shadows].add(time, updater);\n                    } else {\n                        this._closedColorBatches[shadows].add(time, updater);\n                    }\n                } else if (defined(updater.terrainOffsetProperty)) {\n                    this._closedMaterialBatches[numberOfShadowModes + shadows].add(time, updater);\n                } else {\n                    this._closedMaterialBatches[shadows].add(time, updater);\n                }\n            } else if (updater.fillMaterialProperty instanceof ColorMaterialProperty) {\n                if (defined(updater.terrainOffsetProperty)) {\n                    this._openColorBatches[numberOfShadowModes + shadows].add(time, updater);\n                } else {\n                    this._openColorBatches[shadows].add(time, updater);\n                }\n            } else if (defined(updater.terrainOffsetProperty)) {\n                this._openMaterialBatches[numberOfShadowModes + shadows].add(time, updater);\n            } else {\n                this._openMaterialBatches[shadows].add(time, updater);\n            }\n        }\n    };\n\n    /**\n     * @private\n     */\n    GeometryVisualizer._onGeometryChanged = function(updater) {\n        var removedObjects = this._removedObjects;\n        var changedObjects = this._changedObjects;\n\n        var entity = updater.entity;\n        var id = entity.id;\n\n        if (!defined(removedObjects.get(id)) && !defined(changedObjects.get(id))) {\n            changedObjects.set(id, entity);\n        }\n    };\n\n    /**\n     * @private\n     */\n    GeometryVisualizer.prototype._onCollectionChanged = function(entityCollection, added, removed) {\n        var addedObjects = this._addedObjects;\n        var removedObjects = this._removedObjects;\n        var changedObjects = this._changedObjects;\n\n        var i;\n        var id;\n        var entity;\n        for (i = removed.length - 1; i > -1; i--) {\n            entity = removed[i];\n            id = entity.id;\n            if (!addedObjects.remove(id)) {\n                removedObjects.set(id, entity);\n                changedObjects.remove(id);\n            }\n        }\n\n        for (i = added.length - 1; i > -1; i--) {\n            entity = added[i];\n            id = entity.id;\n            if (removedObjects.remove(id)) {\n                changedObjects.set(id, entity);\n            } else {\n                addedObjects.set(id, entity);\n            }\n        }\n    };\nexport default GeometryVisualizer;\n","import AssociativeArray from '../Core/AssociativeArray.js';\nimport Cartesian2 from '../Core/Cartesian2.js';\nimport Cartesian3 from '../Core/Cartesian3.js';\nimport Color from '../Core/Color.js';\nimport defaultValue from '../Core/defaultValue.js';\nimport defined from '../Core/defined.js';\nimport destroyObject from '../Core/destroyObject.js';\nimport DeveloperError from '../Core/DeveloperError.js';\nimport DistanceDisplayCondition from '../Core/DistanceDisplayCondition.js';\nimport NearFarScalar from '../Core/NearFarScalar.js';\nimport HeightReference from '../Scene/HeightReference.js';\nimport HorizontalOrigin from '../Scene/HorizontalOrigin.js';\nimport LabelStyle from '../Scene/LabelStyle.js';\nimport VerticalOrigin from '../Scene/VerticalOrigin.js';\nimport BoundingSphereState from './BoundingSphereState.js';\nimport Property from './Property.js';\n\n    var defaultScale = 1.0;\n    var defaultFont = '30px sans-serif';\n    var defaultStyle = LabelStyle.FILL;\n    var defaultFillColor = Color.WHITE;\n    var defaultOutlineColor = Color.BLACK;\n    var defaultOutlineWidth = 1.0;\n    var defaultShowBackground = false;\n    var defaultBackgroundColor = new Color(0.165, 0.165, 0.165, 0.8);\n    var defaultBackgroundPadding = new Cartesian2(7, 5);\n    var defaultPixelOffset = Cartesian2.ZERO;\n    var defaultEyeOffset = Cartesian3.ZERO;\n    var defaultHeightReference = HeightReference.NONE;\n    var defaultHorizontalOrigin = HorizontalOrigin.CENTER;\n    var defaultVerticalOrigin = VerticalOrigin.CENTER;\n\n    var positionScratch = new Cartesian3();\n    var fillColorScratch = new Color();\n    var outlineColorScratch = new Color();\n    var backgroundColorScratch = new Color();\n    var backgroundPaddingScratch = new Cartesian2();\n    var eyeOffsetScratch = new Cartesian3();\n    var pixelOffsetScratch = new Cartesian2();\n    var translucencyByDistanceScratch = new NearFarScalar();\n    var pixelOffsetScaleByDistanceScratch = new NearFarScalar();\n    var scaleByDistanceScratch = new NearFarScalar();\n    var distanceDisplayConditionScratch = new DistanceDisplayCondition();\n\n    function EntityData(entity) {\n        this.entity = entity;\n        this.label = undefined;\n        this.index = undefined;\n    }\n\n    /**\n     * A {@link Visualizer} which maps the {@link LabelGraphics} instance\n     * in {@link Entity#label} to a {@link Label}.\n     * @alias LabelVisualizer\n     * @constructor\n     *\n     * @param {EntityCluster} entityCluster The entity cluster to manage the collection of billboards and optionally cluster with other entities.\n     * @param {EntityCollection} entityCollection The entityCollection to visualize.\n     */\n    function LabelVisualizer(entityCluster, entityCollection) {\n        \n\n        entityCollection.collectionChanged.addEventListener(LabelVisualizer.prototype._onCollectionChanged, this);\n\n        this._cluster = entityCluster;\n        this._entityCollection = entityCollection;\n        this._items = new AssociativeArray();\n\n        this._onCollectionChanged(entityCollection, entityCollection.values, [], []);\n    }\n\n    /**\n     * Updates the primitives created by this visualizer to match their\n     * Entity counterpart at the given time.\n     *\n     * @param {JulianDate} time The time to update to.\n     * @returns {Boolean} This function always returns true.\n     */\n    LabelVisualizer.prototype.update = function(time) {\n        \n\n        var items = this._items.values;\n        var cluster = this._cluster;\n\n        for (var i = 0, len = items.length; i < len; i++) {\n            var item = items[i];\n            var entity = item.entity;\n            var labelGraphics = entity._label;\n            var text;\n            var label = item.label;\n            var show = entity.isShowing && entity.isAvailable(time) && Property.getValueOrDefault(labelGraphics._show, time, true);\n            var position;\n            if (show) {\n                position = Property.getValueOrUndefined(entity._position, time, positionScratch);\n                text = Property.getValueOrUndefined(labelGraphics._text, time);\n                show = defined(position) && defined(text);\n            }\n\n            if (!show) {\n                //don't bother creating or updating anything else\n                returnPrimitive(item, entity, cluster);\n                continue;\n            }\n\n            if (!Property.isConstant(entity._position)) {\n                cluster._clusterDirty = true;\n            }\n\n            var updateClamping = false;\n            var heightReference = Property.getValueOrDefault(labelGraphics._heightReference, time, defaultHeightReference);\n\n            if (!defined(label)) {\n                label = cluster.getLabel(entity);\n                label.id = entity;\n                item.label = label;\n\n                // If this new label happens to have a position and height reference that match our new values,\n                // label._updateClamping will not be called automatically. That's a problem because the clamped\n                // height may be based on different terrain than is now loaded. So we'll manually call\n                // _updateClamping below.\n                updateClamping = Cartesian3.equals(label.position, position) && label.heightReference === heightReference;\n            }\n\n            label.show = true;\n            label.position = position;\n            label.text = text;\n            label.scale = Property.getValueOrDefault(labelGraphics._scale, time, defaultScale);\n            label.font = Property.getValueOrDefault(labelGraphics._font, time, defaultFont);\n            label.style = Property.getValueOrDefault(labelGraphics._style, time, defaultStyle);\n            label.fillColor = Property.getValueOrDefault(labelGraphics._fillColor, time, defaultFillColor, fillColorScratch);\n            label.outlineColor = Property.getValueOrDefault(labelGraphics._outlineColor, time, defaultOutlineColor, outlineColorScratch);\n            label.outlineWidth = Property.getValueOrDefault(labelGraphics._outlineWidth, time, defaultOutlineWidth);\n            label.showBackground = Property.getValueOrDefault(labelGraphics._showBackground, time, defaultShowBackground);\n            label.backgroundColor = Property.getValueOrDefault(labelGraphics._backgroundColor, time, defaultBackgroundColor, backgroundColorScratch);\n            label.backgroundPadding = Property.getValueOrDefault(labelGraphics._backgroundPadding, time, defaultBackgroundPadding, backgroundPaddingScratch);\n            label.pixelOffset = Property.getValueOrDefault(labelGraphics._pixelOffset, time, defaultPixelOffset, pixelOffsetScratch);\n            label.eyeOffset = Property.getValueOrDefault(labelGraphics._eyeOffset, time, defaultEyeOffset, eyeOffsetScratch);\n            label.heightReference = heightReference;\n            label.horizontalOrigin = Property.getValueOrDefault(labelGraphics._horizontalOrigin, time, defaultHorizontalOrigin);\n            label.verticalOrigin = Property.getValueOrDefault(labelGraphics._verticalOrigin, time, defaultVerticalOrigin);\n            label.translucencyByDistance = Property.getValueOrUndefined(labelGraphics._translucencyByDistance, time, translucencyByDistanceScratch);\n            label.pixelOffsetScaleByDistance = Property.getValueOrUndefined(labelGraphics._pixelOffsetScaleByDistance, time, pixelOffsetScaleByDistanceScratch);\n            label.scaleByDistance = Property.getValueOrUndefined(labelGraphics._scaleByDistance, time, scaleByDistanceScratch);\n            label.distanceDisplayCondition = Property.getValueOrUndefined(labelGraphics._distanceDisplayCondition, time, distanceDisplayConditionScratch);\n            label.disableDepthTestDistance = Property.getValueOrUndefined(labelGraphics._disableDepthTestDistance, time);\n\n            if (updateClamping) {\n                label._updateClamping();\n            }\n        }\n        return true;\n    };\n\n    /**\n     * Computes a bounding sphere which encloses the visualization produced for the specified entity.\n     * The bounding sphere is in the fixed frame of the scene's globe.\n     *\n     * @param {Entity} entity The entity whose bounding sphere to compute.\n     * @param {BoundingSphere} result The bounding sphere onto which to store the result.\n     * @returns {BoundingSphereState} BoundingSphereState.DONE if the result contains the bounding sphere,\n     *                       BoundingSphereState.PENDING if the result is still being computed, or\n     *                       BoundingSphereState.FAILED if the entity has no visualization in the current scene.\n     * @private\n     */\n    LabelVisualizer.prototype.getBoundingSphere = function(entity, result) {\n        \n\n        var item = this._items.get(entity.id);\n        if (!defined(item) || !defined(item.label)) {\n            return BoundingSphereState.FAILED;\n        }\n\n        var label = item.label;\n        result.center = Cartesian3.clone(defaultValue(label._clampedPosition, label.position), result.center);\n        result.radius = 0;\n        return BoundingSphereState.DONE;\n    };\n\n    /**\n     * Returns true if this object was destroyed; otherwise, false.\n     *\n     * @returns {Boolean} True if this object was destroyed; otherwise, false.\n     */\n    LabelVisualizer.prototype.isDestroyed = function() {\n        return false;\n    };\n\n    /**\n     * Removes and destroys all primitives created by this instance.\n     */\n    LabelVisualizer.prototype.destroy = function() {\n        this._entityCollection.collectionChanged.removeEventListener(LabelVisualizer.prototype._onCollectionChanged, this);\n        var entities = this._entityCollection.values;\n        for (var i = 0; i < entities.length; i++) {\n            this._cluster.removeLabel(entities[i]);\n        }\n        return destroyObject(this);\n    };\n\n    LabelVisualizer.prototype._onCollectionChanged = function(entityCollection, added, removed, changed) {\n        var i;\n        var entity;\n        var items = this._items;\n        var cluster = this._cluster;\n\n        for (i = added.length - 1; i > -1; i--) {\n            entity = added[i];\n            if (defined(entity._label) && defined(entity._position)) {\n                items.set(entity.id, new EntityData(entity));\n            }\n        }\n\n        for (i = changed.length - 1; i > -1; i--) {\n            entity = changed[i];\n            if (defined(entity._label) && defined(entity._position)) {\n                if (!items.contains(entity.id)) {\n                    items.set(entity.id, new EntityData(entity));\n                }\n            } else {\n                returnPrimitive(items.get(entity.id), entity, cluster);\n                items.remove(entity.id);\n            }\n        }\n\n        for (i = removed.length - 1; i > -1; i--) {\n            entity = removed[i];\n            returnPrimitive(items.get(entity.id), entity, cluster);\n            items.remove(entity.id);\n        }\n    };\n\n    function returnPrimitive(item, entity, cluster) {\n        if (defined(item)) {\n            item.label = undefined;\n            cluster.removeLabel(entity);\n        }\n    }\nexport default LabelVisualizer;\n","import Check from '../Core/Check.js';\nimport freezeObject from '../Core/freezeObject.js';\nimport CesiumMath from '../Core/Math.js';\nimport Matrix3 from '../Core/Matrix3.js';\nimport Matrix4 from '../Core/Matrix4.js';\n\n    /**\n     * An enum describing the x, y, and z axes and helper conversion functions.\n     *\n     * @exports Axis\n     * @private\n     */\n    var Axis = {\n        /**\n         * Denotes the x-axis.\n         *\n         * @type {Number}\n         * @constant\n         */\n        X : 0,\n\n        /**\n         * Denotes the y-axis.\n         *\n         * @type {Number}\n         * @constant\n         */\n        Y : 1,\n\n        /**\n         * Denotes the z-axis.\n         *\n         * @type {Number}\n         * @constant\n         */\n        Z : 2,\n\n        /**\n         * Matrix used to convert from y-up to z-up\n         *\n         * @type {Matrix4}\n         * @constant\n         */\n        Y_UP_TO_Z_UP : Matrix4.fromRotationTranslation(Matrix3.fromRotationX(CesiumMath.PI_OVER_TWO)),\n\n        /**\n         * Matrix used to convert from z-up to y-up\n         *\n         * @type {Matrix4}\n         * @constant\n         */\n        Z_UP_TO_Y_UP : Matrix4.fromRotationTranslation(Matrix3.fromRotationX(-CesiumMath.PI_OVER_TWO)),\n\n        /**\n         * Matrix used to convert from x-up to z-up\n         *\n         * @type {Matrix4}\n         * @constant\n         */\n        X_UP_TO_Z_UP : Matrix4.fromRotationTranslation(Matrix3.fromRotationY(-CesiumMath.PI_OVER_TWO)),\n\n        /**\n         * Matrix used to convert from z-up to x-up\n         *\n         * @type {Matrix4}\n         * @constant\n         */\n        Z_UP_TO_X_UP : Matrix4.fromRotationTranslation(Matrix3.fromRotationY(CesiumMath.PI_OVER_TWO)),\n\n        /**\n         * Matrix used to convert from x-up to y-up\n         *\n         * @type {Matrix4}\n         * @constant\n         */\n        X_UP_TO_Y_UP : Matrix4.fromRotationTranslation(Matrix3.fromRotationZ(CesiumMath.PI_OVER_TWO)),\n\n        /**\n         * Matrix used to convert from y-up to x-up\n         *\n         * @type {Matrix4}\n         * @constant\n         */\n        Y_UP_TO_X_UP : Matrix4.fromRotationTranslation(Matrix3.fromRotationZ(-CesiumMath.PI_OVER_TWO)),\n\n        /**\n         * Gets the axis by name\n         *\n         * @param {String} name The name of the axis.\n         * @returns {Number} The axis enum.\n         */\n        fromName : function(name) {\n            \n\n            return Axis[name];\n        }\n    };\nexport default freezeObject(Axis);\n","import defaultValue from './defaultValue.js';\nimport getStringFromTypedArray from './getStringFromTypedArray.js';\n\n    /**\n     * @private\n     */\n    function getMagic(uint8Array, byteOffset) {\n        byteOffset = defaultValue(byteOffset, 0);\n        return getStringFromTypedArray(uint8Array, byteOffset, Math.min(4, uint8Array.length));\n    }\nexport default getMagic;\n","import when from '../ThirdParty/when.js';\nimport Check from './Check.js';\nimport defaultValue from './defaultValue.js';\nimport defined from './defined.js';\nimport Resource from './Resource.js';\n\n    /**\n     * @private\n     */\n    function loadImageFromTypedArray(options) {\n        var uint8Array = options.uint8Array;\n        var format = options.format;\n        var request = options.request;\n        var flipY = defaultValue(options.flipY, false);\n        \n\n        var blob = new Blob([uint8Array], {\n            type : format\n        });\n\n        var blobUrl;\n        return Resource.supportsImageBitmapOptions()\n            .then(function(result) {\n                if (result) {\n                    return when(Resource.createImageBitmapFromBlob(blob, {\n                        flipY: flipY,\n                        premultiplyAlpha: false\n                    }));\n                }\n\n                blobUrl = window.URL.createObjectURL(blob);\n                var resource = new Resource({\n                    url: blobUrl,\n                    request: request\n                });\n\n                return resource.fetchImage({\n                    flipY : flipY\n                });\n            })\n            .then(function(result) {\n                if (defined(blobUrl)) {\n                    window.URL.revokeObjectURL(blobUrl);\n                }\n                return result;\n            })\n            .otherwise(function(error) {\n                if (defined(blobUrl)) {\n                    window.URL.revokeObjectURL(blobUrl);\n                }\n                return when.reject(error);\n            });\n    }\nexport default loadImageFromTypedArray;\n","import defaultValue from '../../Core/defaultValue.js'\n\n    /**\n     * Adds an element to an array and returns the element's index.\n     *\n     * @param {Array} array The array to add to.\n     * @param {Object} element The element to add.\n     * @param {Boolean} [checkDuplicates=false] When <code>true</code>, if a duplicate element is found its index is returned and <code>element</code> is not added to the array.\n     *\n     * @private\n     */\n    function addToArray(array, element, checkDuplicates) {\n        checkDuplicates = defaultValue(checkDuplicates, false);\n        if (checkDuplicates) {\n            var index = array.indexOf(element);\n            if (index > -1) {\n                return index;\n            }\n        }\n\n        array.push(element);\n        return array.length - 1;\n    }\n\n    export default addToArray;\n","import defined from '../../Core/defined.js'\n\n    /**\n     * Checks whether the glTF has the given extension.\n     *\n     * @param {Object} gltf A javascript object containing a glTF asset.\n     * @param {String} extension The name of the extension.\n     * @returns {Boolean} Whether the glTF has the given extension.\n     *\n     * @private\n     */\n    function hasExtension(gltf, extension) {\n        return defined(gltf.extensionsUsed) && (gltf.extensionsUsed.indexOf(extension) >= 0);\n    }\n\n    export default hasExtension;\n","import hasExtension from './hasExtension.js'\nimport defined from '../../Core/defined.js'\nimport isArray from '../../Core/isArray.js'\n\n    /**\n     * Contains traversal functions for processing elements of the glTF hierarchy.\n     * @constructor\n     *\n     * @private\n     */\n    function ForEach() {\n    }\n\n    /**\n     * Fallback for glTF 1.0\n     * @private\n     */\n    ForEach.objectLegacy = function(objects, handler) {\n        if (defined(objects)) {\n            for (var objectId in objects) {\n                if (Object.prototype.hasOwnProperty.call(objects, objectId)) {\n                    var object = objects[objectId];\n                    var value = handler(object, objectId);\n\n                    if (defined(value)) {\n                        return value;\n                    }\n                }\n            }\n        }\n    };\n\n    /**\n     * @private\n     */\n    ForEach.object = function(arrayOfObjects, handler) {\n        if (defined(arrayOfObjects)) {\n            var length = arrayOfObjects.length;\n            for (var i = 0; i < length; i++) {\n                var object = arrayOfObjects[i];\n                var value = handler(object, i);\n\n                if (defined(value)) {\n                    return value;\n                }\n            }\n        }\n    };\n\n    /**\n     * Supports glTF 1.0 and 2.0\n     * @private\n     */\n    ForEach.topLevel = function(gltf, name, handler) {\n        var gltfProperty = gltf[name];\n        if (defined(gltfProperty) && !isArray(gltfProperty)) {\n            return ForEach.objectLegacy(gltfProperty, handler);\n        }\n\n        return ForEach.object(gltfProperty, handler);\n    };\n\n    ForEach.accessor = function(gltf, handler) {\n        return ForEach.topLevel(gltf, 'accessors', handler);\n    };\n\n    ForEach.accessorWithSemantic = function(gltf, semantic, handler) {\n        var visited = {};\n        return ForEach.mesh(gltf, function(mesh) {\n            return ForEach.meshPrimitive(mesh, function(primitive) {\n                var valueForEach = ForEach.meshPrimitiveAttribute(primitive, function(accessorId, attributeSemantic) {\n                    if (attributeSemantic.indexOf(semantic) === 0 && !defined(visited[accessorId])) {\n                        visited[accessorId] = true;\n                        var value = handler(accessorId);\n\n                        if (defined(value)) {\n                            return value;\n                        }\n                    }\n                });\n\n                if (defined(valueForEach)) {\n                    return valueForEach;\n                }\n\n                return ForEach.meshPrimitiveTarget(primitive, function(target) {\n                    return ForEach.meshPrimitiveTargetAttribute(target, function(accessorId, attributeSemantic) {\n                        if (attributeSemantic.indexOf(semantic) === 0 && !defined(visited[accessorId])) {\n                            visited[accessorId] = true;\n                            var value = handler(accessorId);\n\n                            if (defined(value)) {\n                                return value;\n                            }\n                        }\n                    });\n                });\n            });\n        });\n    };\n\n    ForEach.accessorContainingVertexAttributeData = function(gltf, handler) {\n        var visited = {};\n        return ForEach.mesh(gltf, function(mesh) {\n            return ForEach.meshPrimitive(mesh, function(primitive) {\n                var valueForEach = ForEach.meshPrimitiveAttribute(primitive, function(accessorId) {\n                    if (!defined(visited[accessorId])) {\n                        visited[accessorId] = true;\n                        var value = handler(accessorId);\n\n                        if (defined(value)) {\n                            return value;\n                        }\n                    }\n                });\n\n                if (defined(valueForEach)) {\n                    return valueForEach;\n                }\n\n                return ForEach.meshPrimitiveTarget(primitive, function(target) {\n                    return ForEach.meshPrimitiveTargetAttribute(target, function(accessorId) {\n                        if (!defined(visited[accessorId])) {\n                            visited[accessorId] = true;\n                            var value = handler(accessorId);\n\n                            if (defined(value)) {\n                                return value;\n                            }\n                        }\n                    });\n                });\n            });\n        });\n    };\n\n    ForEach.accessorContainingIndexData = function(gltf, handler) {\n        var visited = {};\n        return ForEach.mesh(gltf, function(mesh) {\n            return ForEach.meshPrimitive(mesh, function(primitive) {\n                var indices = primitive.indices;\n                if (defined(indices) && !defined(visited[indices])) {\n                    visited[indices] = true;\n                    var value = handler(indices);\n\n                    if (defined(value)) {\n                        return value;\n                    }\n                }\n            });\n        });\n    };\n\n    ForEach.animation = function(gltf, handler) {\n        return ForEach.topLevel(gltf, 'animations', handler);\n    };\n\n    ForEach.animationChannel = function(animation, handler) {\n        var channels = animation.channels;\n        return ForEach.object(channels, handler);\n    };\n\n    ForEach.animationSampler = function(animation, handler) {\n        var samplers = animation.samplers;\n        return ForEach.object(samplers, handler);\n    };\n\n    ForEach.buffer = function(gltf, handler) {\n        return ForEach.topLevel(gltf, 'buffers', handler);\n    };\n\n    ForEach.bufferView = function(gltf, handler) {\n        return ForEach.topLevel(gltf, 'bufferViews', handler);\n    };\n\n    ForEach.camera = function(gltf, handler) {\n        return ForEach.topLevel(gltf, 'cameras', handler);\n    };\n\n    ForEach.image = function(gltf, handler) {\n        return ForEach.topLevel(gltf, 'images', handler);\n    };\n\n    ForEach.compressedImage = function(image, handler) {\n        if (defined(image.extras)) {\n            var compressedImages = image.extras.compressedImage3DTiles;\n            for (var type in compressedImages) {\n                if (Object.prototype.hasOwnProperty.call(compressedImages, type)) {\n                    var compressedImage = compressedImages[type];\n                    var value = handler(compressedImage, type);\n\n                    if (defined(value)) {\n                        return value;\n                    }\n                }\n            }\n        }\n    };\n\n    ForEach.material = function(gltf, handler) {\n        return ForEach.topLevel(gltf, 'materials', handler);\n    };\n\n    ForEach.materialValue = function(material, handler) {\n        var values = material.values;\n        if (defined(material.extensions) && defined(material.extensions.KHR_techniques_webgl)) {\n            values = material.extensions.KHR_techniques_webgl.values;\n        }\n\n        for (var name in values) {\n            if (Object.prototype.hasOwnProperty.call(values, name)) {\n                var value = handler(values[name], name);\n\n                if (defined(value)) {\n                    return value;\n                }\n            }\n        }\n    };\n\n    ForEach.mesh = function(gltf, handler) {\n        return ForEach.topLevel(gltf, 'meshes', handler);\n    };\n\n    ForEach.meshPrimitive = function(mesh, handler) {\n        var primitives = mesh.primitives;\n        if (defined(primitives)) {\n            var primitivesLength = primitives.length;\n            for (var i = 0; i < primitivesLength; i++) {\n                var primitive = primitives[i];\n                var value = handler(primitive, i);\n\n                if (defined(value)) {\n                    return value;\n                }\n            }\n        }\n    };\n\n    ForEach.meshPrimitiveAttribute = function(primitive, handler) {\n        var attributes = primitive.attributes;\n        for (var semantic in attributes) {\n            if (Object.prototype.hasOwnProperty.call(attributes, semantic)) {\n                var value = handler(attributes[semantic], semantic);\n\n                if (defined(value)) {\n                    return value;\n                }\n            }\n        }\n    };\n\n    ForEach.meshPrimitiveTarget = function(primitive, handler) {\n        var targets = primitive.targets;\n        if (defined(targets)) {\n            var length = targets.length;\n            for (var i = 0; i < length; ++i) {\n                var value = handler(targets[i], i);\n\n                if (defined(value)) {\n                    return value;\n                }\n            }\n        }\n    };\n\n    ForEach.meshPrimitiveTargetAttribute = function(target, handler) {\n        for (var semantic in target) {\n            if (Object.prototype.hasOwnProperty.call(target, semantic)) {\n                var accessorId = target[semantic];\n                var value = handler(accessorId, semantic);\n\n                if (defined(value)) {\n                    return value;\n                }\n            }\n        }\n    };\n\n    ForEach.node = function(gltf, handler) {\n        return ForEach.topLevel(gltf, 'nodes', handler);\n    };\n\n    ForEach.nodeInTree = function(gltf, nodeIds, handler) {\n        var nodes = gltf.nodes;\n        if (defined(nodes)) {\n            var length = nodeIds.length;\n            for (var i = 0; i < length; i++) {\n                var nodeId = nodeIds[i];\n                var node = nodes[nodeId];\n                if (defined(node)) {\n                    var value = handler(node, nodeId);\n\n                    if (defined(value)) {\n                        return value;\n                    }\n\n                    var children = node.children;\n                    if (defined(children)) {\n                        value = ForEach.nodeInTree(gltf, children, handler);\n\n                        if (defined(value)) {\n                            return value;\n                        }\n                    }\n                }\n            }\n        }\n    };\n\n    ForEach.nodeInScene = function(gltf, scene, handler) {\n        var sceneNodeIds = scene.nodes;\n        if (defined(sceneNodeIds)) {\n            return ForEach.nodeInTree(gltf, sceneNodeIds, handler);\n        }\n    };\n\n    ForEach.program = function(gltf, handler) {\n        if (hasExtension(gltf, 'KHR_techniques_webgl')) {\n            return ForEach.object(gltf.extensions.KHR_techniques_webgl.programs, handler);\n        }\n\n        return ForEach.topLevel(gltf, 'programs', handler);\n    };\n\n    ForEach.sampler = function(gltf, handler) {\n        return ForEach.topLevel(gltf, 'samplers', handler);\n    };\n\n    ForEach.scene = function(gltf, handler) {\n        return ForEach.topLevel(gltf, 'scenes', handler);\n    };\n\n    ForEach.shader = function(gltf, handler) {\n        if (hasExtension(gltf, 'KHR_techniques_webgl')) {\n            return ForEach.object(gltf.extensions.KHR_techniques_webgl.shaders, handler);\n        }\n\n        return ForEach.topLevel(gltf, 'shaders', handler);\n    };\n\n    ForEach.skin = function(gltf, handler) {\n        return ForEach.topLevel(gltf, 'skins', handler);\n    };\n\n    ForEach.skinJoint = function(skin, handler) {\n        var joints = skin.joints;\n        if (defined(joints)) {\n            var jointsLength = joints.length;\n            for (var i = 0; i < jointsLength; i++) {\n                var joint = joints[i];\n                var value = handler(joint);\n\n                if (defined(value)) {\n                    return value;\n                }\n            }\n        }\n    };\n\n    ForEach.techniqueAttribute = function(technique, handler) {\n        var attributes = technique.attributes;\n        for (var attributeName in attributes) {\n            if (Object.prototype.hasOwnProperty.call(attributes, attributeName)) {\n                var value = handler(attributes[attributeName], attributeName);\n\n                if (defined(value)) {\n                    return value;\n                }\n            }\n        }\n    };\n\n    ForEach.techniqueUniform = function(technique, handler) {\n        var uniforms = technique.uniforms;\n        for (var uniformName in uniforms) {\n            if (Object.prototype.hasOwnProperty.call(uniforms, uniformName)) {\n                var value = handler(uniforms[uniformName], uniformName);\n\n                if (defined(value)) {\n                    return value;\n                }\n            }\n        }\n    };\n\n    ForEach.techniqueParameter = function(technique, handler) {\n        var parameters = technique.parameters;\n        for (var parameterName in parameters) {\n            if (Object.prototype.hasOwnProperty.call(parameters, parameterName)) {\n                var value = handler(parameters[parameterName], parameterName);\n\n                if (defined(value)) {\n                    return value;\n                }\n            }\n        }\n    };\n\n    ForEach.technique = function(gltf, handler) {\n        if (hasExtension(gltf, 'KHR_techniques_webgl')) {\n            return ForEach.object(gltf.extensions.KHR_techniques_webgl.techniques, handler);\n        }\n\n        return ForEach.topLevel(gltf, 'techniques', handler);\n    };\n\n    ForEach.texture = function(gltf, handler) {\n        return ForEach.topLevel(gltf, 'textures', handler);\n    };\n\n    export default ForEach;\n","\n\n    /**\n     * Utility function for retrieving the number of components in a given type.\n     *\n     * @param {String} type glTF type\n     * @returns {Number} The number of components in that type.\n     *\n     * @private\n     */\n    function numberOfComponentsForType(type) {\n        switch (type) {\n            case 'SCALAR':\n                return 1;\n            case 'VEC2':\n                return 2;\n            case 'VEC3':\n                return 3;\n            case 'VEC4':\n            case 'MAT2':\n                return 4;\n            case 'MAT3':\n                return 9;\n            case 'MAT4':\n                return 16;\n        }\n    }\n\n    export default numberOfComponentsForType;\n","import numberOfComponentsForType from './numberOfComponentsForType.js'\nimport ComponentDatatype from '../../Core/ComponentDatatype.js'\nimport defined from '../../Core/defined.js'\n\n    /**\n     * Returns the byte stride of the provided accessor.\n     * If the byteStride is 0, it is calculated based on type and componentType\n     *\n     * @param {Object} gltf A javascript object containing a glTF asset.\n     * @param {Object} accessor The accessor.\n     * @returns {Number} The byte stride of the accessor.\n     *\n     * @private\n     */\n    function getAccessorByteStride(gltf, accessor) {\n        var bufferViewId = accessor.bufferView;\n        if (defined(bufferViewId)) {\n            var bufferView = gltf.bufferViews[bufferViewId];\n            if (defined(bufferView.byteStride) && bufferView.byteStride > 0) {\n                return bufferView.byteStride;\n            }\n        }\n        return ComponentDatatype.getSizeInBytes(accessor.componentType) * numberOfComponentsForType(accessor.type);\n    }\n\n    export default getAccessorByteStride;\n","import addToArray from './addToArray.js'\nimport ForEach from './ForEach.js'\nimport getAccessorByteStride from './getAccessorByteStride.js'\nimport defaultValue from '../../Core/defaultValue.js'\nimport defined from '../../Core/defined.js'\nimport WebGLConstants from '../../Core/WebGLConstants.js'\n\n    /**\n     * Adds default glTF values if they don't exist.\n     *\n     * @param {Object} gltf A javascript object containing a glTF asset.\n     * @returns {Object} The modified glTF.\n     *\n     * @private\n     */\n    function addDefaults(gltf) {\n        ForEach.accessor(gltf, function(accessor) {\n            if (defined(accessor.bufferView)) {\n                accessor.byteOffset = defaultValue(accessor.byteOffset, 0);\n            }\n        });\n\n        ForEach.bufferView(gltf, function(bufferView) {\n            if (defined(bufferView.buffer)) {\n                bufferView.byteOffset = defaultValue(bufferView.byteOffset, 0);\n            }\n        });\n\n        ForEach.mesh(gltf, function(mesh) {\n            ForEach.meshPrimitive(mesh, function(primitive) {\n                primitive.mode = defaultValue(primitive.mode, WebGLConstants.TRIANGLES);\n                if (!defined(primitive.material)) {\n                    if (!defined(gltf.materials)) {\n                        gltf.materials = [];\n                    }\n                    var defaultMaterial = {\n                        name: 'default'\n                    };\n                    primitive.material = addToArray(gltf.materials, defaultMaterial);\n                }\n            });\n        });\n\n        ForEach.accessorContainingVertexAttributeData(gltf, function(accessorId) {\n            var accessor = gltf.accessors[accessorId];\n            var bufferViewId = accessor.bufferView;\n            accessor.normalized = defaultValue(accessor.normalized, false);\n            if (defined(bufferViewId)) {\n                var bufferView = gltf.bufferViews[bufferViewId];\n                bufferView.byteStride = getAccessorByteStride(gltf, accessor);\n                bufferView.target = WebGLConstants.ARRAY_BUFFER;\n            }\n        });\n\n        ForEach.accessorContainingIndexData(gltf, function(accessorId) {\n            var accessor = gltf.accessors[accessorId];\n            var bufferViewId = accessor.bufferView;\n            if (defined(bufferViewId)) {\n                var bufferView = gltf.bufferViews[bufferViewId];\n                bufferView.target = WebGLConstants.ELEMENT_ARRAY_BUFFER;\n            }\n        });\n\n        ForEach.material(gltf, function(material) {\n            var extensions = defaultValue(material.extensions, defaultValue.EMPTY_OBJECT);\n            var materialsCommon = extensions.KHR_materials_common;\n            if (defined(materialsCommon)) {\n                var technique = materialsCommon.technique;\n                var values = defined(materialsCommon.values) ? materialsCommon.values : {};\n                materialsCommon.values = values;\n\n                values.ambient = defined(values.ambient) ? values.ambient : [0.0, 0.0, 0.0, 1.0];\n                values.emission = defined(values.emission) ? values.emission : [0.0, 0.0, 0.0, 1.0];\n\n                values.transparency = defaultValue(values.transparency, 1.0);\n                values.transparent = defaultValue(values.transparent, false);\n                values.doubleSided = defaultValue(values.doubleSided, false);\n\n                if (technique !== 'CONSTANT') {\n                    values.diffuse = defined(values.diffuse) ? values.diffuse : [0.0, 0.0, 0.0, 1.0];\n                    if (technique !== 'LAMBERT') {\n                        values.specular = defined(values.specular) ? values.specular : [0.0, 0.0, 0.0, 1.0];\n                        values.shininess = defaultValue(values.shininess, 0.0);\n                    }\n                }\n                return;\n            }\n\n            material.emissiveFactor = defaultValue(material.emissiveFactor, [0.0, 0.0, 0.0]);\n            material.alphaMode = defaultValue(material.alphaMode, 'OPAQUE');\n            material.doubleSided = defaultValue(material.doubleSided, false);\n\n            if (material.alphaMode === 'MASK') {\n                material.alphaCutoff = defaultValue(material.alphaCutoff, 0.5);\n            }\n\n            var techniquesExtension = extensions.KHR_techniques_webgl;\n            if (defined(techniquesExtension)) {\n                ForEach.materialValue(material, function (materialValue) {\n                    // Check if material value is a TextureInfo object\n                    if (defined(materialValue.index)) {\n                        addTextureDefaults(materialValue);\n                    }\n                });\n            }\n\n            addTextureDefaults(material.emissiveTexture);\n            addTextureDefaults(material.normalTexture);\n            addTextureDefaults(material.occlusionTexture);\n\n            var pbrMetallicRoughness = material.pbrMetallicRoughness;\n            if (defined(pbrMetallicRoughness)) {\n                pbrMetallicRoughness.baseColorFactor = defaultValue(pbrMetallicRoughness.baseColorFactor, [1.0, 1.0, 1.0, 1.0]);\n                pbrMetallicRoughness.metallicFactor = defaultValue(pbrMetallicRoughness.metallicFactor, 1.0);\n                pbrMetallicRoughness.roughnessFactor = defaultValue(pbrMetallicRoughness.roughnessFactor, 1.0);\n                addTextureDefaults(pbrMetallicRoughness.baseColorTexture);\n                addTextureDefaults(pbrMetallicRoughness.metallicRoughnessTexture);\n            }\n\n            var pbrSpecularGlossiness = extensions.pbrSpecularGlossiness;\n            if (defined(pbrSpecularGlossiness)) {\n                pbrSpecularGlossiness.diffuseFactor = defaultValue(pbrSpecularGlossiness.diffuseFactor, [1.0, 1.0, 1.0, 1.0]);\n                pbrSpecularGlossiness.specularFactor = defaultValue(pbrSpecularGlossiness.specularFactor, [1.0, 1.0, 1.0]);\n                pbrSpecularGlossiness.glossinessFactor = defaultValue(pbrSpecularGlossiness.glossinessFactor, 1.0);\n                addTextureDefaults(pbrSpecularGlossiness.specularGlossinessTexture);\n            }\n        });\n\n        ForEach.animation(gltf, function(animation) {\n            ForEach.animationSampler(animation, function(sampler) {\n                sampler.interpolation = defaultValue(sampler.interpolation, 'LINEAR');\n            });\n        });\n\n        var animatedNodes = getAnimatedNodes(gltf);\n        ForEach.node(gltf, function(node, id) {\n            var animated = defined(animatedNodes[id]);\n            if (animated || defined(node.translation) || defined(node.rotation) || defined(node.scale)) {\n                node.translation = defaultValue(node.translation, [0.0, 0.0, 0.0]);\n                node.rotation = defaultValue(node.rotation, [0.0, 0.0, 0.0, 1.0]);\n                node.scale = defaultValue(node.scale, [1.0, 1.0, 1.0]);\n            } else {\n                node.matrix = defaultValue(node.matrix, [1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0]);\n            }\n        });\n\n        ForEach.sampler(gltf, function(sampler) {\n            sampler.wrapS = defaultValue(sampler.wrapS, WebGLConstants.REPEAT);\n            sampler.wrapT = defaultValue(sampler.wrapT, WebGLConstants.REPEAT);\n        });\n\n        if (defined(gltf.scenes) && !defined(gltf.scene)) {\n            gltf.scene = 0;\n        }\n\n        return gltf;\n    }\n\n    function getAnimatedNodes(gltf) {\n        var nodes = {};\n        ForEach.animation(gltf, function(animation) {\n            ForEach.animationChannel(animation, function(channel) {\n                var target = channel.target;\n                var nodeId = target.node;\n                var path = target.path;\n                // Ignore animations that target 'weights'\n                if (path === 'translation' || path === 'rotation' || path === 'scale') {\n                    nodes[nodeId] = true;\n                }\n            });\n        });\n        return nodes;\n    }\n\n    function addTextureDefaults(texture) {\n        if (defined(texture)) {\n            texture.texCoord = defaultValue(texture.texCoord, 0);\n        }\n    }\n\n    export default addDefaults;\n","import ForEach from './ForEach.js'\nimport defined from '../../Core/defined.js'\n\n    /**\n     * Adds extras._pipeline to each object that can have extras in the glTF asset.\n     * This stage runs before updateVersion and handles both glTF 1.0 and glTF 2.0 assets.\n     *\n     * @param {Object} gltf A javascript object containing a glTF asset.\n     * @returns {Object} The glTF asset with the added pipeline extras.\n     *\n     * @private\n     */\n    function addPipelineExtras(gltf) {\n        ForEach.shader(gltf, function(shader) {\n            addExtras(shader);\n        });\n        ForEach.buffer(gltf, function(buffer) {\n            addExtras(buffer);\n        });\n        ForEach.image(gltf, function (image) {\n            addExtras(image);\n            ForEach.compressedImage(image, function(compressedImage) {\n                addExtras(compressedImage);\n            });\n        });\n\n        addExtras(gltf);\n\n        return gltf;\n    }\n\n    function addExtras(object) {\n        object.extras = defined(object.extras) ? object.extras : {};\n        object.extras._pipeline = defined(object.extras._pipeline) ? object.extras._pipeline : {};\n    }\n\n    export default addPipelineExtras;\n","import defined from '../../Core/defined.js'\n\n    /**\n     * Removes an extension from gltf.extensionsRequired if it is present.\n     *\n     * @param {Object} gltf A javascript object containing a glTF asset.\n     * @param {String} extension The extension to remove.\n     *\n     * @private\n     */\n    function removeExtensionsRequired(gltf, extension) {\n        var extensionsRequired = gltf.extensionsRequired;\n        if (defined(extensionsRequired)) {\n            var index = extensionsRequired.indexOf(extension);\n            if (index >= 0) {\n                extensionsRequired.splice(index, 1);\n            }\n            if (extensionsRequired.length === 0) {\n                delete gltf.extensionsRequired;\n            }\n        }\n    }\n\n    export default removeExtensionsRequired;\n","import removeExtensionsRequired from './removeExtensionsRequired.js'\nimport defined from '../../Core/defined.js'\n\n    /**\n     * Removes an extension from gltf.extensionsUsed and gltf.extensionsRequired if it is present.\n     *\n     * @param {Object} gltf A javascript object containing a glTF asset.\n     * @param {String} extension The extension to remove.\n     *\n     * @private\n     */\n    function removeExtensionsUsed(gltf, extension) {\n        var extensionsUsed = gltf.extensionsUsed;\n        if (defined(extensionsUsed)) {\n            var index = extensionsUsed.indexOf(extension);\n            if (index >= 0) {\n                extensionsUsed.splice(index, 1);\n            }\n            removeExtensionsRequired(gltf, extension);\n            if (extensionsUsed.length === 0) {\n                delete gltf.extensionsUsed;\n            }\n        }\n    }\n\n    export default removeExtensionsUsed;\n","import addPipelineExtras from './addPipelineExtras.js'\nimport removeExtensionsUsed from './removeExtensionsUsed.js'\nimport defaultValue from '../../Core/defaultValue.js'\nimport defined from '../../Core/defined.js'\nimport getMagic from '../../Core/getMagic.js'\nimport getStringFromTypedArray from '../../Core/getStringFromTypedArray.js'\nimport RuntimeError from '../../Core/RuntimeError.js'\n\n    var sizeOfUint32 = 4;\n\n    /**\n     * Convert a binary glTF to glTF.\n     *\n     * The returned glTF has pipeline extras included. The embedded binary data is stored in gltf.buffers[0].extras._pipeline.source.\n     *\n     * @param {Buffer} glb The glb data to parse.\n     * @returns {Object} A javascript object containing a glTF asset with pipeline extras included.\n     *\n     * @private\n     */\n    function parseGlb(glb) {\n        // Check that the magic string is present\n        var magic = getMagic(glb);\n        if (magic !== 'glTF') {\n            throw new RuntimeError('File is not valid binary glTF');\n        }\n\n        var header = readHeader(glb, 0, 5);\n        var version = header[1];\n        if (version !== 1 && version !== 2) {\n            throw new RuntimeError('Binary glTF version is not 1 or 2');\n        }\n\n        if (version === 1) {\n            return parseGlbVersion1(glb, header);\n        }\n\n        return parseGlbVersion2(glb, header);\n    }\n\n    function readHeader(glb, byteOffset, count) {\n        var dataView = new DataView(glb.buffer);\n        var header = new Array(count);\n        for (var i = 0; i < count; ++i) {\n            header[i] = dataView.getUint32(glb.byteOffset + byteOffset + i * sizeOfUint32, true);\n        }\n        return header;\n    }\n\n    function parseGlbVersion1(glb, header) {\n        var length = header[2];\n        var contentLength = header[3];\n        var contentFormat = header[4];\n\n        // Check that the content format is 0, indicating that it is JSON\n        if (contentFormat !== 0) {\n            throw new RuntimeError('Binary glTF scene format is not JSON');\n        }\n\n        var jsonStart = 20;\n        var binaryStart = jsonStart + contentLength;\n\n        var contentString = getStringFromTypedArray(glb, jsonStart, contentLength);\n        var gltf = JSON.parse(contentString);\n        addPipelineExtras(gltf);\n\n        var binaryBuffer = glb.subarray(binaryStart, length);\n\n        var buffers = gltf.buffers;\n        if (defined(buffers) && Object.keys(buffers).length > 0) {\n            // In some older models, the binary glTF buffer is named KHR_binary_glTF\n            var binaryGltfBuffer = defaultValue(buffers.binary_glTF, buffers.KHR_binary_glTF);\n            if (defined(binaryGltfBuffer)) {\n                binaryGltfBuffer.extras._pipeline.source = binaryBuffer;\n            }\n        }\n        // Remove the KHR_binary_glTF extension\n        removeExtensionsUsed(gltf, 'KHR_binary_glTF');\n        return gltf;\n    }\n\n    function parseGlbVersion2(glb, header) {\n        var length = header[2];\n        var byteOffset = 12;\n        var gltf;\n        var binaryBuffer;\n        while (byteOffset < length) {\n            var chunkHeader = readHeader(glb, byteOffset, 2);\n            var chunkLength = chunkHeader[0];\n            var chunkType = chunkHeader[1];\n            byteOffset += 8;\n            var chunkBuffer = glb.subarray(byteOffset, byteOffset + chunkLength);\n            byteOffset += chunkLength;\n            // Load JSON chunk\n            if (chunkType === 0x4E4F534A) {\n                var jsonString = getStringFromTypedArray(chunkBuffer);\n                gltf = JSON.parse(jsonString);\n                addPipelineExtras(gltf);\n            }\n            // Load Binary chunk\n            else if (chunkType === 0x004E4942) {\n                binaryBuffer = chunkBuffer;\n            }\n        }\n        if (defined(gltf) && defined(binaryBuffer)) {\n            var buffers = gltf.buffers;\n            if (defined(buffers) && buffers.length > 0) {\n                var buffer = buffers[0];\n                buffer.extras._pipeline.source = binaryBuffer;\n            }\n        }\n        return gltf;\n    }\n\n    export default parseGlb;\n","import addToArray from './addToArray.js'\nimport defined from '../../Core/defined.js'\n\n    /**\n     * Adds an extension to gltf.extensionsUsed if it does not already exist.\n     * Initializes extensionsUsed if it is not defined.\n     *\n     * @param {Object} gltf A javascript object containing a glTF asset.\n     * @param {String} extension The extension to add.\n     *\n     * @private\n     */\n    function addExtensionsUsed(gltf, extension) {\n        var extensionsUsed = gltf.extensionsUsed;\n        if (!defined(extensionsUsed)) {\n            extensionsUsed = [];\n            gltf.extensionsUsed = extensionsUsed;\n        }\n        addToArray(extensionsUsed, extension, true);\n    }\n\n    export default addExtensionsUsed;\n","import ComponentDatatype from '../../Core/ComponentDatatype.js'\n\n    /**\n     * Returns a function to read and convert data from a DataView into an array.\n     *\n     * @param {Number} componentType Type to convert the data to.\n     * @returns {ComponentReader} Function that reads and converts data.\n     *\n     * @private\n     */\n    function getComponentReader(componentType) {\n        switch (componentType) {\n            case ComponentDatatype.BYTE:\n                return function (dataView, byteOffset, numberOfComponents, componentTypeByteLength, result) {\n                    for (var i = 0; i < numberOfComponents; ++i) {\n                        result[i] = dataView.getInt8(byteOffset + i * componentTypeByteLength);\n                    }\n                };\n            case ComponentDatatype.UNSIGNED_BYTE:\n                return function (dataView, byteOffset, numberOfComponents, componentTypeByteLength, result) {\n                    for (var i = 0; i < numberOfComponents; ++i) {\n                        result[i] = dataView.getUint8(byteOffset + i * componentTypeByteLength);\n                    }\n                };\n            case ComponentDatatype.SHORT:\n                return function (dataView, byteOffset, numberOfComponents, componentTypeByteLength, result) {\n                    for (var i = 0; i < numberOfComponents; ++i) {\n                        result[i] = dataView.getInt16(byteOffset + i * componentTypeByteLength, true);\n                    }\n                };\n            case ComponentDatatype.UNSIGNED_SHORT:\n                return function (dataView, byteOffset, numberOfComponents, componentTypeByteLength, result) {\n                    for (var i = 0; i < numberOfComponents; ++i) {\n                        result[i] = dataView.getUint16(byteOffset + i * componentTypeByteLength, true);\n                    }\n                };\n            case ComponentDatatype.INT:\n                return function (dataView, byteOffset, numberOfComponents, componentTypeByteLength, result) {\n                    for (var i = 0; i < numberOfComponents; ++i) {\n                        result[i] = dataView.getInt32(byteOffset + i * componentTypeByteLength, true);\n                    }\n                };\n            case ComponentDatatype.UNSIGNED_INT:\n                return function (dataView, byteOffset, numberOfComponents, componentTypeByteLength, result) {\n                    for (var i = 0; i < numberOfComponents; ++i) {\n                        result[i] = dataView.getUint32(byteOffset + i * componentTypeByteLength, true);\n                    }\n                };\n            case ComponentDatatype.FLOAT:\n                return function (dataView, byteOffset, numberOfComponents, componentTypeByteLength, result) {\n                    for (var i = 0; i < numberOfComponents; ++i) {\n                        result[i] = dataView.getFloat32(byteOffset + i * componentTypeByteLength, true);\n                    }\n                };\n            case ComponentDatatype.DOUBLE:\n                return function (dataView, byteOffset, numberOfComponents, componentTypeByteLength, result) {\n                    for (var i = 0; i < numberOfComponents; ++i) {\n                        result[i] = dataView.getFloat64(byteOffset + i * componentTypeByteLength, true);\n                    }\n                };\n        }\n    }\n\n    /**\n     * A callback function that logs messages.\n     * @callback ComponentReader\n     *\n     * @param {DataView} dataView The data view to read from.\n     * @param {Number} byteOffset The byte offset applied when reading from the data view.\n     * @param {Number} numberOfComponents The number of components to read.\n     * @param {Number} componentTypeByteLength The byte length of each component.\n     * @param {Number} result An array storing the components that are read.\n     */\n\n    export default getComponentReader;\n","import getAccessorByteStride from './getAccessorByteStride.js'\nimport getComponentReader from './getComponentReader.js'\nimport numberOfComponentsForType from './numberOfComponentsForType.js'\nimport arrayFill from '../../Core/arrayFill.js'\nimport ComponentDatatype from '../../Core/ComponentDatatype.js'\nimport defined from '../../Core/defined.js'\n\n    /**\n     * Finds the min and max values of the accessor.\n     *\n     * @param {Object} gltf A javascript object containing a glTF asset.\n     * @param {Object} accessor The accessor object from the glTF asset to read.\n     * @returns {{min: Array, max: Array}} min holding the array of minimum values and max holding the array of maximum values.\n     *\n     * @private\n     */\n    function findAccessorMinMax(gltf, accessor) {\n        var bufferViews = gltf.bufferViews;\n        var buffers = gltf.buffers;\n        var bufferViewId = accessor.bufferView;\n        var numberOfComponents = numberOfComponentsForType(accessor.type);\n\n        // According to the spec, when bufferView is not defined, accessor must be initialized with zeros\n        if (!defined(accessor.bufferView)) {\n            return {\n                min: arrayFill(new Array(numberOfComponents), 0.0),\n                max: arrayFill(new Array(numberOfComponents), 0.0)\n            };\n        }\n\n        var min = arrayFill(new Array(numberOfComponents), Number.POSITIVE_INFINITY);\n        var max = arrayFill(new Array(numberOfComponents), Number.NEGATIVE_INFINITY);\n\n        var bufferView = bufferViews[bufferViewId];\n        var bufferId = bufferView.buffer;\n        var buffer = buffers[bufferId];\n        var source = buffer.extras._pipeline.source;\n\n        var count = accessor.count;\n        var byteStride = getAccessorByteStride(gltf, accessor);\n        var byteOffset = accessor.byteOffset + bufferView.byteOffset + source.byteOffset;\n        var componentType = accessor.componentType;\n        var componentTypeByteLength = ComponentDatatype.getSizeInBytes(componentType);\n        var dataView = new DataView(source.buffer);\n        var components = new Array(numberOfComponents);\n        var componentReader = getComponentReader(componentType);\n\n        for (var i = 0; i < count; i++) {\n            componentReader(dataView, byteOffset, numberOfComponents, componentTypeByteLength, components);\n            for (var j = 0; j < numberOfComponents; j++) {\n                var value = components[j];\n                min[j] = Math.min(min[j], value);\n                max[j] = Math.max(max[j], value);\n            }\n            byteOffset += byteStride;\n        }\n\n        return {\n            min: min,\n            max: max\n        };\n    }\n\n    export default findAccessorMinMax;\n","import addExtensionsUsed from './addExtensionsUsed.js'\nimport ForEach from './ForEach.js'\nimport defaultValue from '../../Core/defaultValue.js'\nimport defined from '../../Core/defined.js'\nimport WebGLConstants from '../../Core/WebGLConstants.js'\n\n    var defaultBlendEquation = [\n        WebGLConstants.FUNC_ADD,\n        WebGLConstants.FUNC_ADD\n    ];\n\n    var defaultBlendFactors = [\n        WebGLConstants.ONE,\n        WebGLConstants.ZERO,\n        WebGLConstants.ONE,\n        WebGLConstants.ZERO\n    ];\n\n    function isStateEnabled(renderStates, state) {\n        var enabled = renderStates.enable;\n        if (!defined(enabled)) {\n            return false;\n        }\n\n        return (enabled.indexOf(state) > -1);\n    }\n\n    var supportedBlendFactors = [\n        WebGLConstants.ZERO,\n        WebGLConstants.ONE,\n        WebGLConstants.SRC_COLOR,\n        WebGLConstants.ONE_MINUS_SRC_COLOR,\n        WebGLConstants.SRC_ALPHA,\n        WebGLConstants.ONE_MINUS_SRC_ALPHA,\n        WebGLConstants.DST_ALPHA,\n        WebGLConstants.ONE_MINUS_DST_ALPHA,\n        WebGLConstants.DST_COLOR,\n        WebGLConstants.ONE_MINUS_DST_COLOR\n    ];\n\n    // If any of the blend factors are not supported, return the default\n    function getSupportedBlendFactors(value, defaultValue) {\n        if (!defined(value)) {\n            return defaultValue;\n        }\n\n        for (var i = 0; i < 4; i++) {\n            if (supportedBlendFactors.indexOf(value[i]) === -1) {\n                return defaultValue;\n            }\n        }\n\n        return value;\n    }\n\n    /**\n     * Move glTF 1.0 technique render states to glTF 2.0 materials properties and KHR_blend extension.\n     *\n     * @param {Object} gltf A javascript object containing a glTF asset.\n     * @returns {Object} The updated glTF asset.\n     *\n     * @private\n     */\n    function moveTechniqueRenderStates(gltf) {\n        var blendingForTechnique = {};\n        var materialPropertiesForTechnique = {};\n        var techniquesLegacy = gltf.techniques;\n        if (!defined(techniquesLegacy)) {\n            return gltf;\n        }\n\n        ForEach.technique(gltf, function (techniqueLegacy, techniqueIndex) {\n            var renderStates = techniqueLegacy.states;\n            if (defined(renderStates)) {\n                var materialProperties = materialPropertiesForTechnique[techniqueIndex] = {};\n\n                // If BLEND is enabled, the material should have alpha mode BLEND\n                if (isStateEnabled(renderStates, WebGLConstants.BLEND)) {\n                    materialProperties.alphaMode = 'BLEND';\n\n                    var blendFunctions = renderStates.functions;\n                    if (defined(blendFunctions) && (defined(blendFunctions.blendEquationSeparate)\n                            || defined(blendFunctions.blendFuncSeparate))) {\n                        blendingForTechnique[techniqueIndex] = {\n                            blendEquation: defaultValue(blendFunctions.blendEquationSeparate, defaultBlendEquation),\n                            blendFactors: getSupportedBlendFactors(blendFunctions.blendFuncSeparate, defaultBlendFactors)\n                        };\n                    }\n                }\n\n                // If CULL_FACE is not enabled, the material should be doubleSided\n                if (!isStateEnabled(renderStates, WebGLConstants.CULL_FACE)) {\n                    materialProperties.doubleSided = true;\n                }\n\n                delete techniqueLegacy.states;\n            }\n        });\n\n        if (Object.keys(blendingForTechnique).length > 0) {\n            if (!defined(gltf.extensions)) {\n                gltf.extensions = {};\n            }\n\n            addExtensionsUsed(gltf, 'KHR_blend');\n        }\n\n        ForEach.material(gltf, function (material) {\n            if (defined(material.technique)) {\n                var materialProperties = materialPropertiesForTechnique[material.technique];\n                ForEach.objectLegacy(materialProperties, function (value, property) {\n                    material[property] = value;\n                });\n\n                var blending = blendingForTechnique[material.technique];\n                if (defined(blending)) {\n                    if (!defined(material.extensions)) {\n                        material.extensions = {};\n                    }\n\n                    material.extensions.KHR_blend = blending;\n                }\n            }\n        });\n\n        return gltf;\n    }\n\n    export default moveTechniqueRenderStates;\n","import addExtensionsUsed from './addExtensionsUsed.js'\nimport addToArray from './addToArray.js'\nimport defined from '../../Core/defined.js'\n\n    /**\n     * Adds an extension to gltf.extensionsRequired if it does not already exist.\n     * Initializes extensionsRequired if it is not defined.\n     *\n     * @param {Object} gltf A javascript object containing a glTF asset.\n     * @param {String} extension The extension to add.\n     *\n     * @private\n     */\n    function addExtensionsRequired(gltf, extension) {\n        var extensionsRequired = gltf.extensionsRequired;\n        if (!defined(extensionsRequired)) {\n            extensionsRequired = [];\n            gltf.extensionsRequired = extensionsRequired;\n        }\n        addToArray(extensionsRequired, extension, true);\n        addExtensionsUsed(gltf, extension);\n    }\n\n    export default addExtensionsRequired;\n","import addExtensionsUsed from './addExtensionsUsed.js'\nimport addExtensionsRequired from './addExtensionsRequired.js'\nimport addToArray from './addToArray.js'\nimport ForEach from './ForEach.js'\nimport defined from '../../Core/defined.js'\n\n    /**\n     * Move glTF 1.0 material techniques to glTF 2.0 KHR_techniques_webgl extension.\n     *\n     * @param {Object} gltf A javascript object containing a glTF asset.\n     * @returns {Object} The updated glTF asset.\n     *\n     * @private\n     */\n    function moveTechniquesToExtension(gltf) {\n        var techniquesLegacy = gltf.techniques;\n        var mappedUniforms = {};\n        var updatedTechniqueIndices = {};\n        if (defined(techniquesLegacy)) {\n            var extension = {\n                programs: [],\n                shaders: [],\n                techniques: []\n            };\n\n            // Some 1.1 models have a glExtensionsUsed property that can be transferred to program.glExtensions\n            var glExtensions = gltf.glExtensionsUsed;\n            delete gltf.glExtensionsUsed;\n\n            ForEach.technique(gltf, function (techniqueLegacy, techniqueIndex) {\n                var technique = {\n                    name: techniqueLegacy.name,\n                    program: undefined,\n                    attributes: {},\n                    uniforms: {}\n                };\n\n                var parameterLegacy;\n                ForEach.techniqueAttribute(techniqueLegacy, function (parameterName, attributeName) {\n                    parameterLegacy = techniqueLegacy.parameters[parameterName];\n                    technique.attributes[attributeName] = {\n                        semantic: parameterLegacy.semantic\n                    };\n                });\n\n                ForEach.techniqueUniform(techniqueLegacy, function (parameterName, uniformName) {\n                    parameterLegacy = techniqueLegacy.parameters[parameterName];\n                    technique.uniforms[uniformName] = {\n                        count: parameterLegacy.count,\n                        node: parameterLegacy.node,\n                        type: parameterLegacy.type,\n                        semantic: parameterLegacy.semantic,\n                        value: parameterLegacy.value\n                    };\n\n                    // Store the name of the uniform to update material values.\n                    mappedUniforms[parameterName] = uniformName;\n                });\n\n                var programLegacy = gltf.programs[techniqueLegacy.program];\n                var program = {\n                    name: programLegacy.name,\n                    fragmentShader: undefined,\n                    vertexShader: undefined,\n                    glExtensions: glExtensions\n                };\n\n                var fs = gltf.shaders[programLegacy.fragmentShader];\n                program.fragmentShader = addToArray(extension.shaders, fs, true);\n\n                var vs = gltf.shaders[programLegacy.vertexShader];\n                program.vertexShader = addToArray(extension.shaders, vs, true);\n\n                technique.program = addToArray(extension.programs, program);\n\n                // Store the index of the new technique to reference instead.\n                updatedTechniqueIndices[techniqueIndex] = addToArray(extension.techniques, technique);\n            });\n\n            if (extension.techniques.length > 0) {\n                if (!defined(gltf.extensions)) {\n                    gltf.extensions = {};\n                }\n\n                gltf.extensions.KHR_techniques_webgl = extension;\n                addExtensionsUsed(gltf, 'KHR_techniques_webgl');\n                addExtensionsRequired(gltf, 'KHR_techniques_webgl');\n            }\n        }\n\n        ForEach.material(gltf, function (material) {\n            if (defined(material.technique)) {\n                var materialExtension = {\n                    technique: updatedTechniqueIndices[material.technique]\n                };\n\n                ForEach.objectLegacy(material.values, function (value, parameterName) {\n                    if (!defined(materialExtension.values)) {\n                        materialExtension.values = {};\n                    }\n\n                    var uniformName = mappedUniforms[parameterName];\n                    materialExtension.values[uniformName] = value;\n                });\n\n                if (!defined(material.extensions)) {\n                    material.extensions = {};\n                }\n\n                material.extensions.KHR_techniques_webgl = materialExtension;\n            }\n\n            delete material.technique;\n            delete material.values;\n        });\n\n        delete gltf.techniques;\n        delete gltf.programs;\n        delete gltf.shaders;\n\n        return gltf;\n    }\n\n    export default moveTechniquesToExtension;\n","import ForEach from './ForEach.js'\nimport hasExtension from './hasExtension.js'\nimport defaultValue from '../../Core/defaultValue.js'\nimport defined from '../../Core/defined.js'\n\n    var allElementTypes = ['mesh', 'node', 'material', 'accessor', 'bufferView', 'buffer'];\n\n    /**\n     * Removes unused elements from gltf.\n     *\n     * @param {Object} gltf A javascript object containing a glTF asset.\n     * @param {String[]} [elementTypes=['mesh', 'node', 'material', 'accessor', 'bufferView', 'buffer']] Element types to be removed. Needs to be a subset of ['mesh', 'node', 'material', 'accessor', 'bufferView', 'buffer'], other items will be ignored.\n     *\n     * @private\n     */\n    function removeUnusedElements(gltf, elementTypes) {\n        elementTypes = defaultValue(elementTypes, allElementTypes);\n        allElementTypes.forEach(function(type) {\n            if (elementTypes.indexOf(type) > -1) {\n                removeUnusedElementsByType(gltf, type);\n            }\n        });\n        return gltf;\n    }\n\n    var TypeToGltfElementName = {\n        accessor: 'accessors',\n        buffer: 'buffers',\n        bufferView: 'bufferViews',\n        node: 'nodes',\n        material: 'materials',\n        mesh: 'meshes'\n    };\n\n    function removeUnusedElementsByType(gltf, type) {\n        var name = TypeToGltfElementName[type];\n        var arrayOfObjects = gltf[name];\n\n        if (defined(arrayOfObjects)) {\n            var removed = 0;\n            var usedIds = getListOfElementsIdsInUse[type](gltf);\n            var length = arrayOfObjects.length;\n\n            for (var i = 0; i < length; ++i) {\n                if (!usedIds[i]) {\n                    Remove[type](gltf, i - removed);\n                    removed++;\n                }\n            }\n        }\n    }\n\n    /**\n     * Contains functions for removing elements from a glTF hierarchy.\n     * Since top-level glTF elements are arrays, when something is removed, referring\n     * indices need to be updated.\n     * @constructor\n     *\n     * @private\n     */\n    function Remove() {}\n\n    Remove.accessor = function(gltf, accessorId) {\n        var accessors = gltf.accessors;\n\n        accessors.splice(accessorId, 1);\n\n        ForEach.mesh(gltf, function(mesh) {\n            ForEach.meshPrimitive(mesh, function(primitive) {\n                // Update accessor ids for the primitives.\n                ForEach.meshPrimitiveAttribute(primitive, function(attributeAccessorId, semantic) {\n                    if (attributeAccessorId > accessorId) {\n                        primitive.attributes[semantic]--;\n                    }\n                });\n\n                // Update accessor ids for the targets.\n                ForEach.meshPrimitiveTarget(primitive, function(target) {\n                    ForEach.meshPrimitiveTargetAttribute(target, function(attributeAccessorId, semantic) {\n                        if (attributeAccessorId > accessorId) {\n                            target[semantic]--;\n                        }\n                    });\n                });\n                var indices = primitive.indices;\n                if (defined(indices) && indices > accessorId) {\n                    primitive.indices--;\n                }\n            });\n        });\n\n        ForEach.skin(gltf, function(skin) {\n            if (defined(skin.inverseBindMatrices) && skin.inverseBindMatrices > accessorId) {\n                skin.inverseBindMatrices--;\n            }\n        });\n\n        ForEach.animation(gltf, function(animation) {\n            ForEach.animationSampler(animation, function(sampler) {\n                if (defined(sampler.input) && sampler.input > accessorId) {\n                    sampler.input--;\n                }\n                if (defined(sampler.output) && sampler.output > accessorId) {\n                    sampler.output--;\n                }\n            });\n        });\n    };\n\n    Remove.buffer = function(gltf, bufferId) {\n        var buffers = gltf.buffers;\n\n        buffers.splice(bufferId, 1);\n\n        ForEach.bufferView(gltf, function(bufferView) {\n            if (defined(bufferView.buffer) && bufferView.buffer > bufferId) {\n                bufferView.buffer--;\n            }\n        });\n    };\n\n    Remove.bufferView = function(gltf, bufferViewId) {\n        var bufferViews = gltf.bufferViews;\n\n        bufferViews.splice(bufferViewId, 1);\n\n        ForEach.accessor(gltf, function(accessor) {\n            if (defined(accessor.bufferView) && accessor.bufferView > bufferViewId) {\n                accessor.bufferView--;\n            }\n        });\n\n        ForEach.shader(gltf, function(shader) {\n            if (defined(shader.bufferView) && shader.bufferView > bufferViewId) {\n                shader.bufferView--;\n            }\n        });\n\n        ForEach.image(gltf, function(image) {\n            if (defined(image.bufferView) && image.bufferView > bufferViewId) {\n                image.bufferView--;\n            }\n            ForEach.compressedImage(image, function(compressedImage) {\n                var compressedImageBufferView = compressedImage.bufferView;\n                if (defined(compressedImageBufferView) && compressedImageBufferView > bufferViewId) {\n                    compressedImage.bufferView--;\n                }\n            });\n        });\n\n        if (hasExtension(gltf, 'KHR_draco_mesh_compression')) {\n            ForEach.mesh(gltf, function(mesh) {\n                ForEach.meshPrimitive(mesh, function(primitive) {\n                    if (defined(primitive.extensions) &&\n                        defined(primitive.extensions.KHR_draco_mesh_compression)) {\n                        if (primitive.extensions.KHR_draco_mesh_compression.bufferView > bufferViewId) {\n                            primitive.extensions.KHR_draco_mesh_compression.bufferView--;\n                        }\n                    }\n                });\n            });\n        }\n    };\n\n    Remove.mesh = function(gltf, meshId) {\n        var meshes = gltf.meshes;\n        meshes.splice(meshId, 1);\n\n        ForEach.node(gltf, function(node) {\n            if (defined(node.mesh)) {\n                if (node.mesh > meshId) {\n                    node.mesh--;\n                } else if (node.mesh === meshId) {\n                    // Remove reference to deleted mesh\n                    delete node.mesh;\n                }\n            }\n        });\n    };\n\n    Remove.node = function(gltf, nodeId) {\n        var nodes = gltf.nodes;\n        nodes.splice(nodeId, 1);\n\n        // Shift all node references\n        ForEach.skin(gltf, function(skin) {\n            if (defined(skin.skeleton) && skin.skeleton > nodeId) {\n                skin.skeleton--;\n            }\n\n            skin.joints = skin.joints.map(function(x) {\n                return x > nodeId ? x - 1 : x;\n            });\n        });\n        ForEach.animation(gltf, function(animation) {\n            ForEach.animationChannel(animation, function(channel) {\n                if (defined(channel.target) && defined(channel.target.node) && (channel.target.node > nodeId)) {\n                    channel.target.node--;\n                }\n            });\n        });\n        ForEach.technique(gltf, function(technique) {\n            ForEach.techniqueUniform(technique, function(uniform) {\n                if (defined(uniform.node) && uniform.node > nodeId) {\n                    uniform.node--;\n                }\n            });\n        });\n        ForEach.node(gltf, function(node) {\n            if (!defined(node.children)) {\n                return;\n            }\n\n            node.children = node.children\n                .filter(function(x) {\n                    return x !== nodeId; // Remove\n                })\n                .map(function(x) {\n                    return x > nodeId ? x - 1 : x; // Shift indices\n                });\n        });\n        ForEach.scene(gltf, function(scene) {\n            scene.nodes = scene.nodes\n                .filter(function(x) {\n                    return x !== nodeId; // Remove\n                })\n                .map(function(x) {\n                    return x > nodeId ? x - 1 : x; // Shift indices\n                });\n        });\n    };\n\n    Remove.material = function(gltf, materialId) {\n        var materials = gltf.materials;\n        materials.splice(materialId, 1);\n\n        // Shift other material ids\n        ForEach.mesh(gltf, function(mesh) {\n            ForEach.meshPrimitive(mesh, function(primitive) {\n                if (defined(primitive.material) && primitive.material > materialId) {\n                    primitive.material--;\n                }\n            });\n        });\n    };\n\n    /**\n     * Contains functions for getting a list of element ids in use by the glTF asset.\n     * @constructor\n     *\n     * @private\n     */\n    function getListOfElementsIdsInUse() {}\n\n    getListOfElementsIdsInUse.accessor = function(gltf) {\n        // Calculate accessor's that are currently in use.\n        var usedAccessorIds = {};\n\n        ForEach.mesh(gltf, function(mesh) {\n            ForEach.meshPrimitive(mesh, function(primitive) {\n                ForEach.meshPrimitiveAttribute(primitive, function(accessorId) {\n                    usedAccessorIds[accessorId] = true;\n                });\n                ForEach.meshPrimitiveTarget(primitive, function(target) {\n                    ForEach.meshPrimitiveTargetAttribute(target, function(accessorId) {\n                        usedAccessorIds[accessorId] = true;\n                    });\n                });\n                var indices = primitive.indices;\n                if (defined(indices)) {\n                    usedAccessorIds[indices] = true;\n                }\n            });\n        });\n\n        ForEach.skin(gltf, function(skin) {\n            if (defined(skin.inverseBindMatrices)) {\n                usedAccessorIds[skin.inverseBindMatrices] = true;\n            }\n        });\n\n        ForEach.animation(gltf, function(animation) {\n            ForEach.animationSampler(animation, function(sampler) {\n                if (defined(sampler.input)) {\n                    usedAccessorIds[sampler.input] = true;\n                }\n                if (defined(sampler.output)) {\n                    usedAccessorIds[sampler.output] = true;\n                }\n            });\n        });\n\n        return usedAccessorIds;\n    };\n\n    getListOfElementsIdsInUse.buffer = function(gltf) {\n        // Calculate buffer's that are currently in use.\n        var usedBufferIds = {};\n\n        ForEach.bufferView(gltf, function(bufferView) {\n            if (defined(bufferView.buffer)) {\n                usedBufferIds[bufferView.buffer] = true;\n            }\n        });\n\n        return usedBufferIds;\n    };\n\n    getListOfElementsIdsInUse.bufferView = function(gltf) {\n        // Calculate bufferView's that are currently in use.\n        var usedBufferViewIds = {};\n\n        ForEach.accessor(gltf, function(accessor) {\n            if (defined(accessor.bufferView)) {\n                usedBufferViewIds[accessor.bufferView] = true;\n            }\n        });\n\n        ForEach.shader(gltf, function(shader) {\n            if (defined(shader.bufferView)) {\n                usedBufferViewIds[shader.bufferView] = true;\n            }\n        });\n\n        ForEach.image(gltf, function(image) {\n            if (defined(image.bufferView)) {\n                usedBufferViewIds[image.bufferView] = true;\n            }\n            ForEach.compressedImage(image, function(compressedImage) {\n                if (defined(compressedImage.bufferView)) {\n                    usedBufferViewIds[compressedImage.bufferView] = true;\n                }\n            });\n        });\n\n        if (hasExtension(gltf, 'KHR_draco_mesh_compression')) {\n            ForEach.mesh(gltf, function(mesh) {\n                ForEach.meshPrimitive(mesh, function(primitive) {\n                    if (defined(primitive.extensions) &&\n                        defined(primitive.extensions.KHR_draco_mesh_compression)) {\n                        usedBufferViewIds[primitive.extensions.KHR_draco_mesh_compression.bufferView] = true;\n                    }\n                });\n            });\n        }\n\n        return usedBufferViewIds;\n    };\n\n    getListOfElementsIdsInUse.mesh = function(gltf) {\n        var usedMeshIds = {};\n        ForEach.node(gltf, function(node) {\n            if (defined(node.mesh && defined(gltf.meshes))) {\n                var mesh = gltf.meshes[node.mesh];\n                if (defined(mesh) && defined(mesh.primitives) && (mesh.primitives.length > 0)) {\n                    usedMeshIds[node.mesh] = true;\n                }\n            }\n        });\n\n        return usedMeshIds;\n    };\n\n    // Check if node is empty. It is considered empty if neither referencing\n    // mesh, camera, extensions and has no children\n    function nodeIsEmpty(gltf, node) {\n        if (defined(node.mesh) || defined(node.camera) || defined(node.skin)\n            || defined(node.weights) || defined(node.extras)\n            || (defined(node.extensions) && node.extensions.length !== 0)) {\n            return false;\n        }\n\n        // Empty if no children or children are all empty nodes\n        return !defined(node.children)\n            || node.children.filter(function(n) {\n                return !nodeIsEmpty(gltf, gltf.nodes[n]);\n            }).length === 0;\n    }\n\n    getListOfElementsIdsInUse.node = function(gltf) {\n        var usedNodeIds = {};\n        ForEach.node(gltf, function(node, nodeId) {\n            if (!nodeIsEmpty(gltf, node)) {\n                usedNodeIds[nodeId] = true;\n            }\n        });\n        ForEach.skin(gltf, function(skin) {\n            if (defined(skin.skeleton)) {\n                usedNodeIds[skin.skeleton] = true;\n            }\n\n            ForEach.skinJoint(skin, function(joint) {\n                usedNodeIds[joint] = true;\n            });\n        });\n        ForEach.animation(gltf, function(animation) {\n            ForEach.animationChannel(animation, function(channel) {\n                if (defined(channel.target) && defined(channel.target.node)) {\n                    usedNodeIds[channel.target.node] = true;\n                }\n            });\n        });\n        ForEach.technique(gltf, function(technique) {\n            ForEach.techniqueUniform(technique, function(uniform) {\n                if (defined(uniform.node)) {\n                    usedNodeIds[uniform.node] = true;\n                }\n            });\n        });\n\n        return usedNodeIds;\n    };\n\n    getListOfElementsIdsInUse.material = function(gltf) {\n        var usedMaterialIds = {};\n\n        ForEach.mesh(gltf, function(mesh) {\n            ForEach.meshPrimitive(mesh, function(primitive) {\n                if (defined(primitive.material)) {\n                    usedMaterialIds[primitive.material] = true;\n                }\n            });\n        });\n\n        return usedMaterialIds;\n    };\n\n    export default removeUnusedElements;\n","import addToArray from './addToArray.js'\n\n    /**\n     * Adds buffer to gltf.\n     *\n     * @param {Object} gltf A javascript object containing a glTF asset.\n     * @param {Buffer} buffer A Buffer object which will be added to gltf.buffers.\n     * @returns {Number} The bufferView id of the newly added bufferView.\n     *\n     * @private\n     */\n    function addBuffer(gltf, buffer) {\n        var newBuffer = {\n            byteLength: buffer.length,\n            extras: {\n                _pipeline: {\n                    source: buffer\n                }\n            }\n        };\n        var bufferId = addToArray(gltf.buffers, newBuffer);\n        var bufferView = {\n            buffer: bufferId,\n            byteOffset: 0,\n            byteLength: buffer.length\n        };\n        return addToArray(gltf.bufferViews, bufferView);\n    }\n\n    export default addBuffer;\n","import getAccessorByteStride from './getAccessorByteStride.js'\nimport getComponentReader from './getComponentReader.js'\nimport numberOfComponentsForType from './numberOfComponentsForType.js'\nimport arrayFill from '../../Core/arrayFill.js'\nimport ComponentDatatype from '../../Core/ComponentDatatype.js'\nimport defined from '../../Core/defined.js'\n\n    /**\n     * Returns the accessor data in a contiguous array.\n     *\n     * @param {Object} gltf A javascript object containing a glTF asset.\n     * @param {Object} accessor The accessor.\n     * @returns {Array} The accessor values in a contiguous array.\n     *\n     * @private\n     */\n    function readAccessorPacked(gltf, accessor) {\n        var byteStride = getAccessorByteStride(gltf, accessor);\n        var componentTypeByteLength = ComponentDatatype.getSizeInBytes(accessor.componentType);\n        var numberOfComponents = numberOfComponentsForType(accessor.type);\n        var count = accessor.count;\n        var values = new Array(numberOfComponents * count);\n\n        if (!defined(accessor.bufferView)) {\n            arrayFill(values, 0);\n            return values;\n        }\n\n        var bufferView = gltf.bufferViews[accessor.bufferView];\n        var source = gltf.buffers[bufferView.buffer].extras._pipeline.source;\n        var byteOffset = accessor.byteOffset + bufferView.byteOffset + source.byteOffset;\n\n        var dataView = new DataView(source.buffer);\n        var components = new Array(numberOfComponents);\n        var componentReader = getComponentReader(accessor.componentType);\n\n        for (var i = 0; i < count; ++i) {\n            componentReader(dataView, byteOffset, numberOfComponents, componentTypeByteLength, components);\n            for (var j = 0; j < numberOfComponents; ++j) {\n                values[i * numberOfComponents + j] = components[j];\n            }\n            byteOffset += byteStride;\n        }\n        return values;\n    }\n\n    export default readAccessorPacked;\n","import addBuffer from './addBuffer.js'\nimport ForEach from './ForEach.js'\nimport readAccessorPacked from './readAccessorPacked.js'\nimport ComponentDatatype from '../../Core/ComponentDatatype.js'\nimport WebGLConstants from '../../Core/WebGLConstants.js'\n\n    /**\n     * Update accessors referenced by JOINTS_0 and WEIGHTS_0 attributes to use correct component types.\n     *\n     * @param {Object} gltf A javascript object containing a glTF asset.\n     * @returns {Object} The glTF asset with compressed meshes.\n     *\n     * @private\n     */\n    function updateAccessorComponentTypes(gltf) {\n        var componentType;\n        ForEach.accessorWithSemantic(gltf, 'JOINTS_0', function(accessorId) {\n            var accessor = gltf.accessors[accessorId];\n            componentType = accessor.componentType;\n            if (componentType === WebGLConstants.BYTE) {\n                convertType(gltf, accessor, ComponentDatatype.UNSIGNED_BYTE);\n            } else if (componentType !== WebGLConstants.UNSIGNED_BYTE\n                    && componentType !== WebGLConstants.UNSIGNED_SHORT) {\n                convertType(gltf, accessor, ComponentDatatype.UNSIGNED_SHORT);\n            }\n        });\n        ForEach.accessorWithSemantic(gltf, 'WEIGHTS_0', function(accessorId) {\n            var accessor = gltf.accessors[accessorId];\n            componentType = accessor.componentType;\n            if (componentType === WebGLConstants.BYTE) {\n                convertType(gltf, accessor, ComponentDatatype.UNSIGNED_BYTE);\n            } else if (componentType === WebGLConstants.SHORT) {\n                convertType(gltf, accessor, ComponentDatatype.UNSIGNED_SHORT);\n            }\n        });\n\n        return gltf;\n    }\n\n    function convertType(gltf, accessor, updatedComponentType) {\n        var typedArray = ComponentDatatype.createTypedArray(updatedComponentType, readAccessorPacked(gltf, accessor));\n        var newBuffer = new Uint8Array(typedArray.buffer);\n        accessor.bufferView = addBuffer(gltf, newBuffer);\n        accessor.componentType = updatedComponentType;\n        accessor.byteOffset = 0;\n    }\n\n    export default updateAccessorComponentTypes;\n","import addExtensionsUsed from './addExtensionsUsed.js'\nimport addToArray from './addToArray.js'\nimport findAccessorMinMax from './findAccessorMinMax.js'\nimport ForEach from './ForEach.js'\nimport getAccessorByteStride from './getAccessorByteStride.js'\nimport numberOfComponentsForType from './numberOfComponentsForType.js'\nimport moveTechniqueRenderStates from './moveTechniqueRenderStates.js'\nimport moveTechniquesToExtension from './moveTechniquesToExtension.js'\nimport removeUnusedElements from './removeUnusedElements.js'\nimport updateAccessorComponentTypes from './updateAccessorComponentTypes.js'\nimport Cartesian3 from '../../Core/Cartesian3.js'\nimport Cartesian4 from '../../Core/Cartesian4.js'\nimport clone from '../../Core/clone.js'\nimport ComponentDatatype from '../../Core/ComponentDatatype.js'\nimport defaultValue from '../../Core/defaultValue.js'\nimport defined from '../../Core/defined.js'\nimport isArray from '../../Core/isArray.js'\nimport Matrix4 from '../../Core/Matrix4.js'\nimport Quaternion from '../../Core/Quaternion.js'\nimport WebGLConstants from '../../Core/WebGLConstants.js'\n\n    var updateFunctions = {\n        '0.8': glTF08to10,\n        '1.0': glTF10to20,\n        '2.0': undefined\n    };\n\n    /**\n     * Update the glTF version to the latest version (2.0), or targetVersion if specified.\n     * Applies changes made to the glTF spec between revisions so that the core library\n     * only has to handle the latest version.\n     *\n     * @param {Object} gltf A javascript object containing a glTF asset.\n     * @param {Object} [options] Options for updating the glTF.\n     * @param {String} [options.targetVersion] The glTF will be upgraded until it hits the specified version.\n     * @returns {Object} The updated glTF asset.\n     *\n     * @private\n     */\n    function updateVersion(gltf, options) {\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n        var targetVersion = options.targetVersion;\n        var version = gltf.version;\n\n        gltf.asset = defaultValue(gltf.asset, {\n            version: '1.0'\n        });\n\n        gltf.asset.version = defaultValue(gltf.asset.version, '1.0');\n        version = defaultValue(version, gltf.asset.version).toString();\n\n        // Invalid version\n        if (!Object.prototype.hasOwnProperty.call(updateFunctions, version)) {\n            // Try truncating trailing version numbers, could be a number as well if it is 0.8\n            if (defined(version)) {\n                version = version.substring(0, 3);\n            }\n            // Default to 1.0 if it cannot be determined\n            if (!Object.prototype.hasOwnProperty.call(updateFunctions, version)) {\n                version = '1.0';\n            }\n        }\n\n        var updateFunction = updateFunctions[version];\n\n        while (defined(updateFunction)) {\n            if (version === targetVersion) {\n                break;\n            }\n            updateFunction(gltf, options);\n            version = gltf.asset.version;\n            updateFunction = updateFunctions[version];\n        }\n        return gltf;\n    }\n\n    function updateInstanceTechniques(gltf) {\n        var materials = gltf.materials;\n        for (var materialId in materials) {\n            if (Object.prototype.hasOwnProperty.call(materials, materialId)) {\n                var material = materials[materialId];\n                var instanceTechnique = material.instanceTechnique;\n                if (defined(instanceTechnique)) {\n                    material.technique = instanceTechnique.technique;\n                    material.values = instanceTechnique.values;\n                    delete material.instanceTechnique;\n                }\n            }\n        }\n    }\n\n    function setPrimitiveModes(gltf) {\n        var meshes = gltf.meshes;\n        for (var meshId in meshes) {\n            if (Object.prototype.hasOwnProperty.call(meshes, meshId)) {\n                var mesh = meshes[meshId];\n                var primitives = mesh.primitives;\n                if (defined(primitives)) {\n                    var primitivesLength = primitives.length;\n                    for (var i = 0; i < primitivesLength; ++i) {\n                        var primitive = primitives[i];\n                        var defaultMode = defaultValue(primitive.primitive, WebGLConstants.TRIANGLES);\n                        primitive.mode = defaultValue(primitive.mode, defaultMode);\n                        delete primitive.primitive;\n                    }\n                }\n            }\n        }\n    }\n\n    function updateNodes(gltf) {\n        var nodes = gltf.nodes;\n        var axis = new Cartesian3();\n        var quat = new Quaternion();\n        for (var nodeId in nodes) {\n            if (Object.prototype.hasOwnProperty.call(nodes, nodeId)) {\n                var node = nodes[nodeId];\n                if (defined(node.rotation)) {\n                    var rotation = node.rotation;\n                    Cartesian3.fromArray(rotation, 0, axis);\n                    Quaternion.fromAxisAngle(axis, rotation[3], quat);\n                    node.rotation = [quat.x, quat.y, quat.z, quat.w];\n                }\n                var instanceSkin = node.instanceSkin;\n                if (defined(instanceSkin)) {\n                    node.skeletons = instanceSkin.skeletons;\n                    node.skin = instanceSkin.skin;\n                    node.meshes = instanceSkin.meshes;\n                    delete node.instanceSkin;\n                }\n            }\n        }\n    }\n\n    function updateAnimations(gltf) {\n        var animations = gltf.animations;\n        var accessors = gltf.accessors;\n        var bufferViews = gltf.bufferViews;\n        var buffers = gltf.buffers;\n        var updatedAccessors = {};\n        var axis = new Cartesian3();\n        var quat = new Quaternion();\n        for (var animationId in animations) {\n            if (Object.prototype.hasOwnProperty.call(animations, animationId)) {\n                var animation = animations[animationId];\n                var channels = animation.channels;\n                var parameters = animation.parameters;\n                var samplers = animation.samplers;\n                if (defined(channels)) {\n                    var channelsLength = channels.length;\n                    for (var i = 0; i < channelsLength; ++i) {\n                        var channel = channels[i];\n                        if (channel.target.path === 'rotation') {\n                            var accessorId = parameters[samplers[channel.sampler].output];\n                            if (defined(updatedAccessors[accessorId])) {\n                                continue;\n                            }\n                            updatedAccessors[accessorId] = true;\n                            var accessor = accessors[accessorId];\n                            var bufferView = bufferViews[accessor.bufferView];\n                            var buffer = buffers[bufferView.buffer];\n                            var source = buffer.extras._pipeline.source;\n                            var byteOffset = source.byteOffset + bufferView.byteOffset + accessor.byteOffset;\n                            var componentType = accessor.componentType;\n                            var count = accessor.count;\n                            var componentsLength = numberOfComponentsForType(accessor.type);\n                            var length = accessor.count * componentsLength;\n                            var typedArray = ComponentDatatype.createArrayBufferView(componentType, source.buffer, byteOffset, length);\n\n                            for (var j = 0; j < count; j++) {\n                                var offset = j * componentsLength;\n                                Cartesian3.unpack(typedArray, offset, axis);\n                                var angle = typedArray[offset + 3];\n                                Quaternion.fromAxisAngle(axis, angle, quat);\n                                Quaternion.pack(quat, typedArray, offset);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    function removeTechniquePasses(gltf) {\n        var techniques = gltf.techniques;\n        for (var techniqueId in techniques) {\n            if (Object.prototype.hasOwnProperty.call(techniques, techniqueId)) {\n                var technique = techniques[techniqueId];\n                var passes = technique.passes;\n                if (defined(passes)) {\n                    var passName = defaultValue(technique.pass, 'defaultPass');\n                    if (Object.prototype.hasOwnProperty.call(passes, passName)) {\n                        var pass = passes[passName];\n                        var instanceProgram = pass.instanceProgram;\n                        technique.attributes = defaultValue(technique.attributes, instanceProgram.attributes);\n                        technique.program = defaultValue(technique.program, instanceProgram.program);\n                        technique.uniforms = defaultValue(technique.uniforms, instanceProgram.uniforms);\n                        technique.states = defaultValue(technique.states, pass.states);\n                    }\n                    delete technique.passes;\n                    delete technique.pass;\n                }\n            }\n        }\n    }\n\n    function glTF08to10(gltf) {\n        if (!defined(gltf.asset)) {\n            gltf.asset = {};\n        }\n        var asset = gltf.asset;\n        asset.version = '1.0';\n        // Profile should be an object, not a string\n        if (typeof asset.profile === 'string') {\n            var split = asset.profile.split(' ');\n            asset.profile = {\n                api: split[0],\n                version: split[1]\n            };\n        } else {\n            asset.profile = {};\n        }\n\n        // Version property should be in asset, not on the root element\n        if (defined(gltf.version)) {\n            delete gltf.version;\n        }\n        // material.instanceTechnique properties should be directly on the material\n        updateInstanceTechniques(gltf);\n        // primitive.primitive should be primitive.mode\n        setPrimitiveModes(gltf);\n        // Node rotation should be quaternion, not axis-angle\n        // node.instanceSkin is deprecated\n        updateNodes(gltf);\n        // Animations that target rotations should be quaternion, not axis-angle\n        updateAnimations(gltf);\n        // technique.pass and techniques.passes are deprecated\n        removeTechniquePasses(gltf);\n        // gltf.allExtensions -> extensionsUsed\n        if (defined(gltf.allExtensions)) {\n            gltf.extensionsUsed = gltf.allExtensions;\n            delete gltf.allExtensions;\n        }\n        // gltf.lights -> khrMaterialsCommon.lights\n        if (defined(gltf.lights)) {\n            var extensions = defaultValue(gltf.extensions, {});\n            gltf.extensions = extensions;\n            var materialsCommon = defaultValue(extensions.KHR_materials_common, {});\n            extensions.KHR_materials_common = materialsCommon;\n            materialsCommon.lights = gltf.lights;\n            delete gltf.lights;\n            addExtensionsUsed(gltf, 'KHR_materials_common');\n        }\n    }\n\n    function removeAnimationSamplersIndirection(gltf) {\n        var animations = gltf.animations;\n        for (var animationId in animations) {\n            if (Object.prototype.hasOwnProperty.call(animations, animationId)) {\n                var animation = animations[animationId];\n                var parameters = animation.parameters;\n                if (defined(parameters)) {\n                    var samplers = animation.samplers;\n                    for (var samplerId in samplers) {\n                        if (Object.prototype.hasOwnProperty.call(samplers, samplerId)) {\n                            var sampler = samplers[samplerId];\n                            sampler.input = parameters[sampler.input];\n                            sampler.output = parameters[sampler.output];\n                        }\n                    }\n                    delete animation.parameters;\n                }\n            }\n        }\n    }\n\n    function objectToArray(object, mapping) {\n        var array = [];\n        for (var id in object) {\n            if (Object.prototype.hasOwnProperty.call(object, id)) {\n                var value = object[id];\n                mapping[id] = array.length;\n                array.push(value);\n                if (!defined(value.name)) {\n                    value.name = id;\n                }\n            }\n        }\n        return array;\n    }\n\n    function objectsToArrays(gltf) {\n        var i;\n        var globalMapping = {\n            accessors: {},\n            animations: {},\n            buffers: {},\n            bufferViews: {},\n            cameras: {},\n            images: {},\n            materials: {},\n            meshes: {},\n            nodes: {},\n            programs: {},\n            samplers: {},\n            scenes: {},\n            shaders: {},\n            skins: {},\n            textures: {},\n            techniques: {}\n        };\n\n        // Map joint names to id names\n        var jointName;\n        var jointNameToId = {};\n        var nodes = gltf.nodes;\n        for (var id in nodes) {\n            if (Object.prototype.hasOwnProperty.call(nodes, id)) {\n                jointName = nodes[id].jointName;\n                if (defined(jointName)) {\n                    jointNameToId[jointName] = id;\n                }\n            }\n        }\n\n        // Convert top level objects to arrays\n        for (var topLevelId in gltf) {\n            if (Object.prototype.hasOwnProperty.call(gltf, topLevelId) && defined(globalMapping[topLevelId])) {\n                var objectMapping = {};\n                var object = gltf[topLevelId];\n                gltf[topLevelId] = objectToArray(object, objectMapping);\n                globalMapping[topLevelId] = objectMapping;\n            }\n        }\n\n        // Remap joint names to array indexes\n        for (jointName in jointNameToId) {\n            if (Object.prototype.hasOwnProperty.call(jointNameToId, jointName)) {\n                jointNameToId[jointName] = globalMapping.nodes[jointNameToId[jointName]];\n            }\n        }\n\n        // Fix references\n        if (defined(gltf.scene)) {\n            gltf.scene = globalMapping.scenes[gltf.scene];\n        }\n        ForEach.bufferView(gltf, function(bufferView) {\n            if (defined(bufferView.buffer)) {\n                bufferView.buffer = globalMapping.buffers[bufferView.buffer];\n            }\n        });\n        ForEach.accessor(gltf, function(accessor) {\n            if (defined(accessor.bufferView)) {\n                accessor.bufferView = globalMapping.bufferViews[accessor.bufferView];\n            }\n        });\n        ForEach.shader(gltf, function(shader) {\n            var extensions = shader.extensions;\n            if (defined(extensions)) {\n                var binaryGltf = extensions.KHR_binary_glTF;\n                if (defined(binaryGltf)) {\n                    shader.bufferView = globalMapping.bufferViews[binaryGltf.bufferView];\n                    delete extensions.KHR_binary_glTF;\n                }\n                if (Object.keys(extensions).length === 0) {\n                    delete shader.extensions;\n                }\n            }\n        });\n        ForEach.program(gltf, function(program) {\n            if (defined(program.vertexShader)) {\n                program.vertexShader = globalMapping.shaders[program.vertexShader];\n            }\n            if (defined(program.fragmentShader)) {\n                program.fragmentShader = globalMapping.shaders[program.fragmentShader];\n            }\n        });\n        ForEach.technique(gltf, function(technique) {\n            if (defined(technique.program)) {\n                technique.program = globalMapping.programs[technique.program];\n            }\n            ForEach.techniqueParameter(technique, function(parameter) {\n                if (defined(parameter.node)) {\n                    parameter.node = globalMapping.nodes[parameter.node];\n                }\n                var value = parameter.value;\n                if (typeof value === 'string') {\n                    parameter.value = {\n                        index: globalMapping.textures[value]\n                    };\n                }\n            });\n        });\n        ForEach.mesh(gltf, function(mesh) {\n            ForEach.meshPrimitive(mesh, function(primitive) {\n                if (defined(primitive.indices)) {\n                    primitive.indices = globalMapping.accessors[primitive.indices];\n                }\n                ForEach.meshPrimitiveAttribute(primitive, function(accessorId, semantic) {\n                    primitive.attributes[semantic] = globalMapping.accessors[accessorId];\n                });\n                if (defined(primitive.material)) {\n                    primitive.material = globalMapping.materials[primitive.material];\n                }\n            });\n        });\n        ForEach.node(gltf, function(node) {\n            var children = node.children;\n            if (defined(children)) {\n                var childrenLength = children.length;\n                for (i = 0; i < childrenLength; ++i) {\n                    children[i] = globalMapping.nodes[children[i]];\n                }\n            }\n            if (defined(node.meshes)) {\n                // Split out meshes on nodes\n                var meshes = node.meshes;\n                var meshesLength = meshes.length;\n                if (meshesLength > 0) {\n                    node.mesh = globalMapping.meshes[meshes[0]];\n                    for (i = 1; i < meshesLength; ++i) {\n                        var meshNode = {\n                            mesh: globalMapping.meshes[meshes[i]]\n                        };\n                        var meshNodeId = addToArray(gltf.nodes, meshNode);\n                        if (!defined(children)) {\n                            children = [];\n                            node.children = children;\n                        }\n                        children.push(meshNodeId);\n                    }\n                }\n                delete node.meshes;\n            }\n            if (defined(node.camera)) {\n                node.camera = globalMapping.cameras[node.camera];\n            }\n            if (defined(node.skin)) {\n                node.skin = globalMapping.skins[node.skin];\n            }\n            if (defined(node.skeletons)) {\n                // Assign skeletons to skins\n                var skeletons = node.skeletons;\n                var skeletonsLength = skeletons.length;\n                if ((skeletonsLength > 0) && defined(node.skin)) {\n                    var skin = gltf.skins[node.skin];\n                    skin.skeleton = globalMapping.nodes[skeletons[0]];\n                }\n                delete node.skeletons;\n            }\n            if (defined(node.jointName)) {\n                delete node.jointName;\n            }\n        });\n        ForEach.skin(gltf, function(skin) {\n            if (defined(skin.inverseBindMatrices)) {\n                skin.inverseBindMatrices = globalMapping.accessors[skin.inverseBindMatrices];\n            }\n            var jointNames = skin.jointNames;\n            if (defined(jointNames)) {\n                var joints = [];\n                var jointNamesLength = jointNames.length;\n                for (i = 0; i < jointNamesLength; ++i) {\n                    joints[i] = jointNameToId[jointNames[i]];\n                }\n                skin.joints = joints;\n                delete skin.jointNames;\n            }\n        });\n        ForEach.scene(gltf, function(scene) {\n            var sceneNodes = scene.nodes;\n            if (defined(sceneNodes)) {\n                var sceneNodesLength = sceneNodes.length;\n                for (i = 0; i < sceneNodesLength; ++i) {\n                    sceneNodes[i] = globalMapping.nodes[sceneNodes[i]];\n                }\n            }\n        });\n        ForEach.animation(gltf, function(animation) {\n            var samplerMapping = {};\n            animation.samplers = objectToArray(animation.samplers, samplerMapping);\n            ForEach.animationSampler(animation, function(sampler) {\n                sampler.input = globalMapping.accessors[sampler.input];\n                sampler.output = globalMapping.accessors[sampler.output];\n            });\n            ForEach.animationChannel(animation, function(channel) {\n                channel.sampler = samplerMapping[channel.sampler];\n                var target = channel.target;\n                if (defined(target)) {\n                    target.node = globalMapping.nodes[target.id];\n                    delete target.id;\n                }\n            });\n        });\n        ForEach.material(gltf, function(material) {\n            if (defined(material.technique)) {\n                material.technique = globalMapping.techniques[material.technique];\n            }\n            ForEach.materialValue(material, function(value, name) {\n                if (typeof value === 'string') {\n                    material.values[name] = {\n                        index: globalMapping.textures[value]\n                    };\n                }\n            });\n            var extensions = material.extensions;\n            if (defined(extensions)) {\n                var materialsCommon = extensions.KHR_materials_common;\n                if (defined(materialsCommon)) {\n                    ForEach.materialValue(materialsCommon, function(value, name) {\n                        if (typeof value === 'string') {\n                            materialsCommon.values[name] = {\n                                index: globalMapping.textures[value]\n                            };\n                        }\n                    });\n                }\n            }\n        });\n        ForEach.image(gltf, function(image) {\n            var extensions = image.extensions;\n            if (defined(extensions)) {\n                var binaryGltf = extensions.KHR_binary_glTF;\n                if (defined(binaryGltf)) {\n                    image.bufferView = globalMapping.bufferViews[binaryGltf.bufferView];\n                    image.mimeType = binaryGltf.mimeType;\n                    delete extensions.KHR_binary_glTF;\n                }\n                if (Object.keys(extensions).length === 0) {\n                    delete image.extensions;\n                }\n            }\n            ForEach.compressedImage(image, function(compressedImage) {\n                var compressedExtensions = compressedImage.extensions;\n                if (defined(compressedExtensions)) {\n                    var compressedBinaryGltf = compressedExtensions.KHR_binary_glTF;\n                    if (defined(compressedBinaryGltf)) {\n                        compressedImage.bufferView = globalMapping.bufferViews[compressedBinaryGltf.bufferView];\n                        compressedImage.mimeType = compressedBinaryGltf.mimeType;\n                        delete compressedExtensions.KHR_binary_glTF;\n                    }\n                    if (Object.keys(extensions).length === 0) {\n                        delete compressedImage.extensions;\n                    }\n                }\n            });\n        });\n        ForEach.texture(gltf, function(texture) {\n            if (defined(texture.sampler)) {\n                texture.sampler = globalMapping.samplers[texture.sampler];\n            }\n            if (defined(texture.source)) {\n                texture.source = globalMapping.images[texture.source];\n            }\n        });\n    }\n\n    function removeAnimationSamplerNames(gltf) {\n        ForEach.animation(gltf, function(animation) {\n            ForEach.animationSampler(animation, function(sampler) {\n                delete sampler.name;\n            });\n        });\n    }\n\n    function removeEmptyArrays(gltf) {\n        for (var topLevelId in gltf) {\n            if (Object.prototype.hasOwnProperty.call(gltf, topLevelId)) {\n                var array = gltf[topLevelId];\n                if (isArray(array) && array.length === 0) {\n                    delete gltf[topLevelId];\n                }\n            }\n        }\n        ForEach.node(gltf, function(node) {\n            if (defined(node.children) && node.children.length === 0) {\n                delete node.children;\n            }\n        });\n    }\n\n    function stripAsset(gltf) {\n        var asset = gltf.asset;\n        delete asset.profile;\n        delete asset.premultipliedAlpha;\n    }\n\n    var knownExtensions = {\n        CESIUM_RTC: true,\n        KHR_materials_common: true,\n        WEB3D_quantized_attributes: true\n    };\n    function requireKnownExtensions(gltf) {\n        var extensionsUsed = gltf.extensionsUsed;\n        gltf.extensionsRequired = defaultValue(gltf.extensionsRequired, []);\n        if (defined(extensionsUsed)) {\n            var extensionsUsedLength = extensionsUsed.length;\n            for (var i = 0; i < extensionsUsedLength; ++i) {\n                var extension = extensionsUsed[i];\n                if (defined(knownExtensions[extension])) {\n                    gltf.extensionsRequired.push(extension);\n                }\n            }\n        }\n    }\n\n    function removeBufferType(gltf) {\n        ForEach.buffer(gltf, function(buffer) {\n            delete buffer.type;\n        });\n    }\n\n    function removeTextureProperties(gltf) {\n        ForEach.texture(gltf, function(texture) {\n            delete texture.format;\n            delete texture.internalFormat;\n            delete texture.target;\n            delete texture.type;\n        });\n    }\n\n    function requireAttributeSetIndex(gltf) {\n        ForEach.mesh(gltf, function(mesh) {\n            ForEach.meshPrimitive(mesh, function(primitive) {\n                ForEach.meshPrimitiveAttribute(primitive, function(accessorId, semantic) {\n                    if (semantic === 'TEXCOORD') {\n                        primitive.attributes.TEXCOORD_0 = accessorId;\n                    } else if (semantic === 'COLOR') {\n                        primitive.attributes.COLOR_0 = accessorId;\n                    }\n                });\n                delete primitive.attributes.TEXCOORD;\n                delete primitive.attributes.COLOR;\n            });\n        });\n        ForEach.technique(gltf, function(technique) {\n            ForEach.techniqueParameter(technique, function(parameter) {\n                var semantic = parameter.semantic;\n                if (defined(semantic)) {\n                    if (semantic === 'TEXCOORD') {\n                        parameter.semantic = 'TEXCOORD_0';\n                    } else if (semantic === 'COLOR') {\n                        parameter.semantic = 'COLOR_0';\n                    }\n                }\n            });\n        });\n    }\n\n    var knownSemantics = {\n        POSITION: true,\n        NORMAL: true,\n        TANGENT: true\n    };\n    var indexedSemantics = {\n        COLOR: 'COLOR',\n        JOINT : 'JOINTS',\n        JOINTS: 'JOINTS',\n        TEXCOORD: 'TEXCOORD',\n        WEIGHT: 'WEIGHTS',\n        WEIGHTS: 'WEIGHTS'\n    };\n    function underscoreApplicationSpecificSemantics(gltf) {\n        var mappedSemantics = {};\n        ForEach.mesh(gltf, function(mesh) {\n            ForEach.meshPrimitive(mesh, function(primitive) {\n                /*eslint-disable no-unused-vars*/\n                ForEach.meshPrimitiveAttribute(primitive, function(accessorId, semantic) {\n                    if (semantic.charAt(0) !== '_') {\n                        var setIndex = semantic.search(/_[0-9]+/g);\n                        var strippedSemantic = semantic;\n                        var suffix = '_0';\n                        if (setIndex >= 0) {\n                            strippedSemantic = semantic.substring(0, setIndex);\n                            suffix = semantic.substring(setIndex);\n                        }\n                        var newSemantic;\n                        var indexedSemantic = indexedSemantics[strippedSemantic];\n                        if (defined(indexedSemantic)) {\n                            newSemantic = indexedSemantic + suffix;\n                            mappedSemantics[semantic] = newSemantic;\n                        } else if (!defined(knownSemantics[strippedSemantic])) {\n                            newSemantic = '_' + semantic;\n                            mappedSemantics[semantic] = newSemantic;\n                        }\n                    }\n                });\n                for (var semantic in mappedSemantics) {\n                    if (Object.prototype.hasOwnProperty.call(mappedSemantics, semantic)) {\n                        var mappedSemantic = mappedSemantics[semantic];\n                        var accessorId = primitive.attributes[semantic];\n                        if (defined(accessorId)) {\n                            delete primitive.attributes[semantic];\n                            primitive.attributes[mappedSemantic] = accessorId;\n                        }\n                    }\n                }\n            });\n        });\n        ForEach.technique(gltf, function(technique) {\n            ForEach.techniqueParameter(technique, function(parameter) {\n                var mappedSemantic = mappedSemantics[parameter.semantic];\n                if (defined(mappedSemantic)) {\n                    parameter.semantic = mappedSemantic;\n                }\n            });\n        });\n    }\n\n    function clampCameraParameters(gltf) {\n        ForEach.camera(gltf, function(camera) {\n            var perspective = camera.perspective;\n            if (defined(perspective)) {\n                var aspectRatio = perspective.aspectRatio;\n                if (defined(aspectRatio) && aspectRatio === 0.0) {\n                    delete perspective.aspectRatio;\n                }\n                var yfov = perspective.yfov;\n                if (defined(yfov) && yfov === 0.0) {\n                    perspective.yfov = 1.0;\n                }\n            }\n        });\n    }\n\n    function computeAccessorByteStride(gltf, accessor) {\n        return (defined(accessor.byteStride) && accessor.byteStride !== 0) ? accessor.byteStride : getAccessorByteStride(gltf, accessor);\n    }\n\n    function requireByteLength(gltf) {\n        ForEach.buffer(gltf, function(buffer) {\n            if (!defined(buffer.byteLength)) {\n                buffer.byteLength = buffer.extras._pipeline.source.length;\n            }\n        });\n        ForEach.accessor(gltf, function(accessor) {\n            var bufferViewId = accessor.bufferView;\n            if (defined(bufferViewId)) {\n                var bufferView = gltf.bufferViews[bufferViewId];\n                var accessorByteStride = computeAccessorByteStride(gltf, accessor);\n                var accessorByteEnd = accessor.byteOffset + accessor.count * accessorByteStride;\n                bufferView.byteLength = Math.max(defaultValue(bufferView.byteLength, 0), accessorByteEnd);\n            }\n        });\n    }\n\n    function moveByteStrideToBufferView(gltf) {\n        var i;\n        var j;\n        var bufferView;\n        var bufferViews = gltf.bufferViews;\n\n        var bufferViewHasVertexAttributes = {};\n        ForEach.accessorContainingVertexAttributeData(gltf, function(accessorId) {\n            var accessor = gltf.accessors[accessorId];\n            if (defined(accessor.bufferView)) {\n                bufferViewHasVertexAttributes[accessor.bufferView] = true;\n            }\n        });\n\n        // Map buffer views to a list of accessors\n        var bufferViewMap = {};\n        ForEach.accessor(gltf, function(accessor) {\n            if (defined(accessor.bufferView)) {\n                bufferViewMap[accessor.bufferView] = defaultValue(bufferViewMap[accessor.bufferView], []);\n                bufferViewMap[accessor.bufferView].push(accessor);\n            }\n        });\n\n        // Split accessors with different byte strides\n        for (var bufferViewId in bufferViewMap) {\n            if (Object.prototype.hasOwnProperty.call(bufferViewMap, bufferViewId)) {\n                bufferView = bufferViews[bufferViewId];\n                var accessors = bufferViewMap[bufferViewId];\n                accessors.sort(function(a, b) {\n                    return a.byteOffset - b.byteOffset;\n                });\n                var currentByteOffset = 0;\n                var currentIndex = 0;\n                var accessorsLength = accessors.length;\n                for (i = 0; i < accessorsLength; ++i) {\n                    var accessor = accessors[i];\n                    var accessorByteStride = computeAccessorByteStride(gltf, accessor);\n                    var accessorByteOffset = accessor.byteOffset;\n                    var accessorByteLength = accessor.count * accessorByteStride;\n                    delete accessor.byteStride;\n\n                    var hasNextAccessor = (i < accessorsLength - 1);\n                    var nextAccessorByteStride = hasNextAccessor ? computeAccessorByteStride(gltf, accessors[i + 1]) : undefined;\n                    if (accessorByteStride !== nextAccessorByteStride) {\n                        var newBufferView = clone(bufferView, true);\n                        if (bufferViewHasVertexAttributes[bufferViewId]) {\n                            newBufferView.byteStride = accessorByteStride;\n                        }\n                        newBufferView.byteOffset += currentByteOffset;\n                        newBufferView.byteLength = accessorByteOffset + accessorByteLength - currentByteOffset;\n                        var newBufferViewId = addToArray(bufferViews, newBufferView);\n                        for (j = currentIndex; j <= i; ++j) {\n                            accessor = accessors[j];\n                            accessor.bufferView = newBufferViewId;\n                            accessor.byteOffset = accessor.byteOffset - currentByteOffset;\n                        }\n                        // Set current byte offset to next accessor's byte offset\n                        currentByteOffset = hasNextAccessor ? accessors[i + 1].byteOffset : undefined;\n                        currentIndex = i + 1;\n                    }\n                }\n            }\n        }\n\n        // Remove unused buffer views\n        removeUnusedElements(gltf, ['accessor', 'bufferView', 'buffer']);\n    }\n\n    function requirePositionAccessorMinMax(gltf) {\n        ForEach.accessorWithSemantic(gltf, 'POSITION', function(accessorId) {\n            var accessor = gltf.accessors[accessorId];\n            if (!defined(accessor.min) || !defined(accessor.max)) {\n                var minMax = findAccessorMinMax(gltf, accessor);\n                accessor.min = minMax.min;\n                accessor.max = minMax.max;\n            }\n        });\n    }\n\n    function isNodeEmpty(node) {\n        return (!defined(node.children) || node.children.length === 0) &&\n            (!defined(node.meshes) || node.meshes.length === 0) &&\n            !defined(node.camera) && !defined(node.skin) && !defined(node.skeletons) && !defined(node.jointName) &&\n            (!defined(node.translation) || Cartesian3.fromArray(node.translation).equals(Cartesian3.ZERO)) &&\n            (!defined(node.scale) || Cartesian3.fromArray(node.scale).equals(new Cartesian3(1.0, 1.0, 1.0))) &&\n            (!defined(node.rotation) || Cartesian4.fromArray(node.rotation).equals(new Cartesian4(0.0, 0.0, 0.0, 1.0))) &&\n            (!defined(node.matrix) || Matrix4.fromColumnMajorArray(node.matrix).equals(Matrix4.IDENTITY)) &&\n            !defined(node.extensions) && !defined(node.extras);\n    }\n\n    function deleteNode(gltf, nodeId) {\n        // Remove from list of nodes in scene\n        ForEach.scene(gltf, function(scene) {\n            var sceneNodes = scene.nodes;\n            if (defined(sceneNodes)) {\n                var sceneNodesLength = sceneNodes.length;\n                for (var i = sceneNodesLength; i >= 0; --i) {\n                    if (sceneNodes[i] === nodeId) {\n                        sceneNodes.splice(i, 1);\n                        return;\n                    }\n                }\n            }\n        });\n\n        // Remove parent node's reference to this node, and delete the parent if also empty\n        ForEach.node(gltf, function(parentNode, parentNodeId) {\n            if (defined(parentNode.children)) {\n                var index = parentNode.children.indexOf(nodeId);\n                if (index > -1) {\n                    parentNode.children.splice(index, 1);\n\n                    if (isNodeEmpty(parentNode)) {\n                        deleteNode(gltf, parentNodeId);\n                    }\n                }\n            }\n        });\n\n        delete gltf.nodes[nodeId];\n    }\n\n    function removeEmptyNodes(gltf) {\n        ForEach.node(gltf, function(node, nodeId) {\n            if (isNodeEmpty(node)) {\n                deleteNode(gltf, nodeId);\n            }\n        });\n\n        return gltf;\n    }\n\n    function requireAnimationAccessorMinMax(gltf) {\n        ForEach.animation(gltf, function(animation) {\n            ForEach.animationSampler(animation, function(sampler) {\n                var accessor = gltf.accessors[sampler.input];\n                if (!defined(accessor.min) || !defined(accessor.max)) {\n                    var minMax = findAccessorMinMax(gltf, accessor);\n                    accessor.min = minMax.min;\n                    accessor.max = minMax.max;\n                }\n            });\n        });\n    }\n\n    function glTF10to20(gltf) {\n        gltf.asset = defaultValue(gltf.asset, {});\n        gltf.asset.version = '2.0';\n        // material.instanceTechnique properties should be directly on the material. instanceTechnique is a gltf 0.8 property but is seen in some 1.0 models.\n        updateInstanceTechniques(gltf);\n        // animation.samplers now refers directly to accessors and animation.parameters should be removed\n        removeAnimationSamplersIndirection(gltf);\n        // Remove empty nodes and re-assign referencing indices\n        removeEmptyNodes(gltf);\n        // Top-level objects are now arrays referenced by index instead of id\n        objectsToArrays(gltf);\n        // Animation.sampler objects cannot have names\n        removeAnimationSamplerNames(gltf);\n        // asset.profile no longer exists\n        stripAsset(gltf);\n        // Move known extensions from extensionsUsed to extensionsRequired\n        requireKnownExtensions(gltf);\n        // bufferView.byteLength and buffer.byteLength are required\n        requireByteLength(gltf);\n        // byteStride moved from accessor to bufferView\n        moveByteStrideToBufferView(gltf);\n        // accessor.min and accessor.max must be defined for accessors containing POSITION attributes\n        requirePositionAccessorMinMax(gltf);\n        // An animation sampler's input accessor must have min and max properties defined\n        requireAnimationAccessorMinMax(gltf);\n        // buffer.type is unnecessary and should be removed\n        removeBufferType(gltf);\n        // Remove format, internalFormat, target, and type\n        removeTextureProperties(gltf);\n        // TEXCOORD and COLOR attributes must be written with a set index (TEXCOORD_#)\n        requireAttributeSetIndex(gltf);\n        // Add underscores to application-specific parameters\n        underscoreApplicationSpecificSemantics(gltf);\n        // Accessors referenced by JOINTS_0 and WEIGHTS_0 attributes must have correct component types\n        updateAccessorComponentTypes(gltf);\n        // Clamp camera parameters\n        clampCameraParameters(gltf);\n        // Move legacy technique render states to material properties and add KHR_blend extension blending functions\n        moveTechniqueRenderStates(gltf);\n        // Add material techniques to KHR_techniques_webgl extension, removing shaders, programs, and techniques\n        moveTechniquesToExtension(gltf);\n        // Remove empty arrays\n        removeEmptyArrays(gltf);\n    }\n\n    export default updateVersion;\n","import arraySlice from '../Core/arraySlice.js';\nimport ComponentDatatype from '../Core/ComponentDatatype.js';\nimport defined from '../Core/defined.js';\nimport FeatureDetection from '../Core/FeatureDetection.js';\nimport TaskProcessor from '../Core/TaskProcessor.js';\nimport ForEach from '../ThirdParty/GltfPipeline/ForEach.js';\nimport when from '../ThirdParty/when.js';\n\n    /**\n     * @private\n     */\n    function DracoLoader() {}\n\n    // Maximum concurrency to use when decoding draco models\n    DracoLoader._maxDecodingConcurrency = Math.max(FeatureDetection.hardwareConcurrency - 1, 1);\n\n    // Exposed for testing purposes\n    DracoLoader._decoderTaskProcessor = undefined;\n    DracoLoader._taskProcessorReady = false;\n    DracoLoader._getDecoderTaskProcessor = function () {\n        if (!defined(DracoLoader._decoderTaskProcessor)) {\n            var processor = new TaskProcessor('decodeDraco', DracoLoader._maxDecodingConcurrency);\n            processor.initWebAssemblyModule({\n                modulePath : 'ThirdParty/Workers/draco_wasm_wrapper.js',\n                wasmBinaryFile : 'ThirdParty/draco_decoder.wasm',\n                fallbackModulePath : 'ThirdParty/Workers/draco_decoder.js'\n            }).then(function () {\n                DracoLoader._taskProcessorReady = true;\n            });\n            DracoLoader._decoderTaskProcessor = processor;\n        }\n\n        return DracoLoader._decoderTaskProcessor;\n    };\n\n    /**\n     * Returns true if the model uses or requires KHR_draco_mesh_compression.\n     *\n     * @private\n     */\n    DracoLoader.hasExtension = function(model) {\n        return (defined(model.extensionsRequired.KHR_draco_mesh_compression)\n            || defined(model.extensionsUsed.KHR_draco_mesh_compression));\n    };\n\n    function addBufferToLoadResources(loadResources, typedArray) {\n        // Create a new id to differentiate from original glTF bufferViews\n        var bufferViewId = 'runtime.' + Object.keys(loadResources.createdBufferViews).length;\n\n        var loadResourceBuffers = loadResources.buffers;\n        var id = Object.keys(loadResourceBuffers).length;\n        loadResourceBuffers[id] = typedArray;\n        loadResources.createdBufferViews[bufferViewId] = {\n            buffer : id,\n            byteOffset : 0,\n            byteLength : typedArray.byteLength\n        };\n\n        return bufferViewId;\n    }\n\n    function addNewVertexBuffer(typedArray, model, context) {\n        var loadResources = model._loadResources;\n        var id = addBufferToLoadResources(loadResources, typedArray);\n        loadResources.vertexBuffersToCreate.enqueue(id);\n        return id;\n    }\n\n    function addNewIndexBuffer(indexArray, model, context) {\n        var typedArray = indexArray.typedArray;\n        var loadResources = model._loadResources;\n        var id = addBufferToLoadResources(loadResources, typedArray);\n        loadResources.indexBuffersToCreate.enqueue({\n            id : id,\n            componentType : ComponentDatatype.fromTypedArray(typedArray)\n        });\n\n        return {\n            bufferViewId : id,\n            numberOfIndices : indexArray.numberOfIndices\n        };\n    }\n\n    function scheduleDecodingTask(decoderTaskProcessor, model, loadResources, context) {\n        if (!DracoLoader._taskProcessorReady) {\n            // The task processor is not ready to schedule tasks\n            return;\n        }\n\n        var taskData = loadResources.primitivesToDecode.peek();\n        if (!defined(taskData)) {\n            // All primitives are processing\n            return;\n        }\n\n        var promise = decoderTaskProcessor.scheduleTask(taskData, [taskData.array.buffer]);\n        if (!defined(promise)) {\n            // Cannot schedule another task this frame\n            return;\n        }\n\n        loadResources.activeDecodingTasks++;\n        loadResources.primitivesToDecode.dequeue();\n        return promise.then(function (result) {\n            loadResources.activeDecodingTasks--;\n\n            var decodedIndexBuffer = addNewIndexBuffer(result.indexArray, model, context);\n\n            var attributes = {};\n            var decodedAttributeData = result.attributeData;\n            for (var attributeName in decodedAttributeData) {\n                if (decodedAttributeData.hasOwnProperty(attributeName)) {\n                    var attribute = decodedAttributeData[attributeName];\n                    var vertexArray = attribute.array;\n                    var vertexBufferView = addNewVertexBuffer(vertexArray, model, context);\n\n                    var data = attribute.data;\n                    data.bufferView = vertexBufferView;\n\n                    attributes[attributeName] = data;\n                }\n            }\n\n            model._decodedData[taskData.mesh + '.primitive.' + taskData.primitive] = {\n                bufferView : decodedIndexBuffer.bufferViewId,\n                numberOfIndices : decodedIndexBuffer.numberOfIndices,\n                attributes : attributes\n            };\n        });\n    }\n\n    DracoLoader._decodedModelResourceCache = undefined;\n\n    /**\n     * Parses draco extension on model primitives and\n     * adds the decoding data to the model's load resources.\n     *\n     * @private\n     */\n    DracoLoader.parse = function(model, context) {\n        if (!DracoLoader.hasExtension(model)) {\n            return;\n        }\n\n        var loadResources = model._loadResources;\n        var cacheKey = model.cacheKey;\n        if (defined(cacheKey)) {\n            if (!defined(DracoLoader._decodedModelResourceCache)) {\n                if (!defined(context.cache.modelDecodingCache)) {\n                    context.cache.modelDecodingCache = {};\n                }\n\n                DracoLoader._decodedModelResourceCache = context.cache.modelDecodingCache;\n            }\n\n            // Decoded data for model will be loaded from cache\n            var cachedData = DracoLoader._decodedModelResourceCache[cacheKey];\n            if (defined(cachedData)) {\n                cachedData.count++;\n                loadResources.pendingDecodingCache = true;\n                return;\n            }\n        }\n\n        var dequantizeInShader = model._dequantizeInShader;\n        var gltf = model.gltf;\n        ForEach.mesh(gltf, function(mesh, meshId) {\n            ForEach.meshPrimitive(mesh, function(primitive, primitiveId) {\n                if (!defined(primitive.extensions)) {\n                    return;\n                }\n\n                var compressionData = primitive.extensions.KHR_draco_mesh_compression;\n                if (!defined(compressionData)) {\n                    return;\n                }\n\n                var bufferView = gltf.bufferViews[compressionData.bufferView];\n                var typedArray = arraySlice(gltf.buffers[bufferView.buffer].extras._pipeline.source, bufferView.byteOffset, bufferView.byteOffset + bufferView.byteLength);\n                loadResources.primitivesToDecode.enqueue({\n                    mesh : meshId,\n                    primitive : primitiveId,\n                    array : typedArray,\n                    bufferView : bufferView,\n                    compressedAttributes : compressionData.attributes,\n                    dequantizeInShader : dequantizeInShader\n                });\n            });\n        });\n    };\n\n    /**\n     * Schedules decoding tasks available this frame.\n     * @private\n     */\n    DracoLoader.decodeModel = function(model, context) {\n        if (!DracoLoader.hasExtension(model)) {\n            return when.resolve();\n        }\n\n        var loadResources = model._loadResources;\n        var cacheKey = model.cacheKey;\n        if (defined(cacheKey) && defined(DracoLoader._decodedModelResourceCache)) {\n            var cachedData = DracoLoader._decodedModelResourceCache[cacheKey];\n            // Load decoded data for model when cache is ready\n            if (defined(cachedData) && loadResources.pendingDecodingCache) {\n                return when(cachedData.ready, function () {\n                    model._decodedData = cachedData.data;\n                    loadResources.pendingDecodingCache = false;\n                });\n            }\n\n            // Decoded data for model should be cached when ready\n            DracoLoader._decodedModelResourceCache[cacheKey] = {\n                ready : false,\n                count : 1,\n                data : undefined\n            };\n        }\n\n        if (loadResources.primitivesToDecode.length === 0) {\n            // No more tasks to schedule\n            return when.resolve();\n        }\n\n        var decoderTaskProcessor = DracoLoader._getDecoderTaskProcessor();\n        var decodingPromises = [];\n\n        var promise = scheduleDecodingTask(decoderTaskProcessor, model, loadResources, context);\n        while (defined(promise)) {\n            decodingPromises.push(promise);\n            promise = scheduleDecodingTask(decoderTaskProcessor, model, loadResources, context);\n        }\n\n        return when.all(decodingPromises);\n    };\n\n    /**\n     * Decodes a compressed point cloud. Returns undefined if the task cannot be scheduled.\n     * @private\n     */\n    DracoLoader.decodePointCloud = function(parameters) {\n        var decoderTaskProcessor = DracoLoader._getDecoderTaskProcessor();\n        if (!DracoLoader._taskProcessorReady) {\n            // The task processor is not ready to schedule tasks\n            return;\n        }\n        return decoderTaskProcessor.scheduleTask(parameters, [parameters.buffer.buffer]);\n    };\n\n    /**\n     * Caches a models decoded data so it doesn't need to decode more than once.\n     * @private\n     */\n    DracoLoader.cacheDataForModel = function(model) {\n        var cacheKey = model.cacheKey;\n        if (defined(cacheKey) && defined(DracoLoader._decodedModelResourceCache)) {\n            var cachedData = DracoLoader._decodedModelResourceCache[cacheKey];\n            if (defined(cachedData)) {\n                cachedData.ready = true;\n                cachedData.data = model._decodedData;\n            }\n        }\n    };\n\n    /**\n     * Destroys the cached data that this model references if it is no longer in use.\n     * @private\n     */\n    DracoLoader.destroyCachedDataForModel = function(model) {\n        var cacheKey = model.cacheKey;\n        if (defined(cacheKey) && defined(DracoLoader._decodedModelResourceCache)) {\n            var cachedData = DracoLoader._decodedModelResourceCache[cacheKey];\n            if (defined(cachedData) && --cachedData.count === 0) {\n                delete DracoLoader._decodedModelResourceCache[cacheKey];\n            }\n        }\n    };\nexport default DracoLoader;\n","import Check from '../Core/Check.js';\n\n    /**\n     * Gets a GLSL snippet that clips a fragment using the `clip` function from {@link getClippingFunction} and styles it.\n     *\n     * @param {String} samplerUniformName Name of the uniform for the clipping planes texture sampler.\n     * @param {String} matrixUniformName Name of the uniform for the clipping planes matrix.\n     * @param {String} styleUniformName Name of the uniform for the clipping planes style, a vec4.\n     * @returns {String} A string containing GLSL that clips and styles the current fragment.\n     * @private\n     */\n    function getClipAndStyleCode(samplerUniformName, matrixUniformName, styleUniformName) {\n        \n\n        var shaderCode =\n        '    float clipDistance = clip(gl_FragCoord, ' + samplerUniformName + ', ' + matrixUniformName + '); \\n' +\n        '    vec4 clippingPlanesEdgeColor = vec4(1.0); \\n' +\n        '    clippingPlanesEdgeColor.rgb = ' + styleUniformName + '.rgb; \\n' +\n        '    float clippingPlanesEdgeWidth = ' + styleUniformName + '.a; \\n' +\n        '    if (clipDistance > 0.0 && clipDistance < clippingPlanesEdgeWidth) \\n' +\n        '    { \\n' +\n        '        gl_FragColor = clippingPlanesEdgeColor;\\n' +\n        '    } \\n';\n        return shaderCode;\n    }\nexport default getClipAndStyleCode;\n","import Check from './Check.js';\nimport defaultValue from './defaultValue.js';\nimport defined from './defined.js';\nimport DeveloperError from './DeveloperError.js';\nimport CesiumMath from './Math.js';\n\n    /**\n     * Creates a curve parameterized and evaluated by time. This type describes an interface\n     * and is not intended to be instantiated directly.\n     *\n     * @alias Spline\n     * @constructor\n     *\n     * @see CatmullRomSpline\n     * @see HermiteSpline\n     * @see LinearSpline\n     * @see QuaternionSpline\n     */\n    function Spline() {\n        /**\n         * An array of times for the control points.\n         * @type {Number[]}\n         * @default undefined\n         */\n        this.times = undefined;\n\n        /**\n         * An array of control points.\n         * @type {Cartesian3[]|Quaternion[]}\n         * @default undefined\n         */\n        this.points = undefined;\n\n        DeveloperError.throwInstantiationError();\n    }\n\n    /**\n     * Evaluates the curve at a given time.\n     * @function\n     *\n     * @param {Number} time The time at which to evaluate the curve.\n     * @param {Cartesian3|Quaternion|Number[]} [result] The object onto which to store the result.\n     * @returns {Cartesian3|Quaternion|Number[]} The modified result parameter or a new instance of the point on the curve at the given time.\n     *\n     * @exception {DeveloperError} time must be in the range <code>[t<sub>0</sub>, t<sub>n</sub>]</code>, where <code>t<sub>0</sub></code>\n     *                             is the first element in the array <code>times</code> and <code>t<sub>n</sub></code> is the last element\n     *                             in the array <code>times</code>.\n     */\n    Spline.prototype.evaluate = DeveloperError.throwInstantiationError;\n\n    /**\n     * Finds an index <code>i</code> in <code>times</code> such that the parameter\n     * <code>time</code> is in the interval <code>[times[i], times[i + 1]]</code>.\n     *\n     * @param {Number} time The time.\n     * @param {Number} startIndex The index from which to start the search.\n     * @returns {Number} The index for the element at the start of the interval.\n     *\n     * @exception {DeveloperError} time must be in the range <code>[t<sub>0</sub>, t<sub>n</sub>]</code>, where <code>t<sub>0</sub></code>\n     *                             is the first element in the array <code>times</code> and <code>t<sub>n</sub></code> is the last element\n     *                             in the array <code>times</code>.\n     */\n    Spline.prototype.findTimeInterval = function(time, startIndex) {\n        var times = this.times;\n        var length = times.length;\n\n        \n\n        // Take advantage of temporal coherence by checking current, next and previous intervals\n        // for containment of time.\n        startIndex = defaultValue(startIndex, 0);\n\n        if (time >= times[startIndex]) {\n            if (startIndex + 1 < length && time < times[startIndex + 1]) {\n                return startIndex;\n            } else if (startIndex + 2 < length && time < times[startIndex + 2]) {\n                return startIndex + 1;\n            }\n        } else if (startIndex - 1 >= 0 && time >= times[startIndex - 1]) {\n            return startIndex - 1;\n        }\n\n        // The above failed so do a linear search. For the use cases so far, the\n        // length of the list is less than 10. In the future, if there is a bottle neck,\n        // it might be here.\n\n        var i;\n        if (time > times[startIndex]) {\n            for (i = startIndex; i < length - 1; ++i) {\n                if (time >= times[i] && time < times[i + 1]) {\n                    break;\n                }\n            }\n        } else {\n            for (i = startIndex - 1; i >= 0; --i) {\n                if (time >= times[i] && time < times[i + 1]) {\n                    break;\n                }\n            }\n        }\n\n        if (i === length - 1) {\n            i = length - 2;\n        }\n\n        return i;\n    };\n\n    /**\n     * Wraps the given time to the period covered by the spline.\n     * @function\n     *\n     * @param {Number} time The time.\n     * @return {Number} The time, wrapped around the animation period.\n     */\n    Spline.prototype.wrapTime = function(time) {\n        \n\n        var times = this.times;\n        var timeEnd = times[times.length - 1];\n        var timeStart = times[0];\n        var timeStretch = timeEnd - timeStart;\n        var divs;\n        if (time < timeStart) {\n            divs = Math.floor((timeStart - time) / timeStretch) + 1;\n            time += divs * timeStretch;\n        }\n        if (time > timeEnd) {\n            divs = Math.floor((time - timeEnd) / timeStretch) + 1;\n            time -= divs * timeStretch;\n        }\n        return time;\n    };\n\n    /**\n     * Clamps the given time to the period covered by the spline.\n     * @function\n     *\n     * @param {Number} time The time.\n     * @return {Number} The time, clamped to the animation period.\n     */\n    Spline.prototype.clampTime = function(time) {\n        \n\n        var times = this.times;\n        return CesiumMath.clamp(time, times[0], times[times.length - 1]);\n    };\nexport default Spline;\n","import Cartesian3 from './Cartesian3.js';\nimport defaultValue from './defaultValue.js';\nimport defined from './defined.js';\nimport defineProperties from './defineProperties.js';\nimport DeveloperError from './DeveloperError.js';\nimport Spline from './Spline.js';\n\n    /**\n     * A spline that uses piecewise linear interpolation to create a curve.\n     *\n     * @alias LinearSpline\n     * @constructor\n     *\n     * @param {Object} options Object with the following properties:\n     * @param {Number[]} options.times An array of strictly increasing, unit-less, floating-point times at each point.\n     *                The values are in no way connected to the clock time. They are the parameterization for the curve.\n     * @param {Cartesian3[]} options.points The array of {@link Cartesian3} control points.\n     *\n     * @exception {DeveloperError} points.length must be greater than or equal to 2.\n     * @exception {DeveloperError} times.length must be equal to points.length.\n     *\n     *\n     * @example\n     * var times = [ 0.0, 1.5, 3.0, 4.5, 6.0 ];\n     * var spline = new Cesium.LinearSpline({\n     *     times : times,\n     *     points : [\n     *         new Cesium.Cartesian3(1235398.0, -4810983.0, 4146266.0),\n     *         new Cesium.Cartesian3(1372574.0, -5345182.0, 4606657.0),\n     *         new Cesium.Cartesian3(-757983.0, -5542796.0, 4514323.0),\n     *         new Cesium.Cartesian3(-2821260.0, -5248423.0, 4021290.0),\n     *         new Cesium.Cartesian3(-2539788.0, -4724797.0, 3620093.0)\n     *     ]\n     * });\n     *\n     * var p0 = spline.evaluate(times[0]);\n     *\n     * @see HermiteSpline\n     * @see CatmullRomSpline\n     * @see QuaternionSpline\n     * @see WeightSpline\n     */\n    function LinearSpline(options) {\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n        var points = options.points;\n        var times = options.times;\n\n        \n\n        this._times = times;\n        this._points = points;\n\n        this._lastTimeIndex = 0;\n    }\n\n    defineProperties(LinearSpline.prototype, {\n        /**\n         * An array of times for the control points.\n         *\n         * @memberof LinearSpline.prototype\n         *\n         * @type {Number[]}\n         * @readonly\n         */\n        times : {\n            get : function() {\n                return this._times;\n            }\n        },\n\n        /**\n         * An array of {@link Cartesian3} control points.\n         *\n         * @memberof LinearSpline.prototype\n         *\n         * @type {Cartesian3[]}\n         * @readonly\n         */\n        points : {\n            get : function() {\n                return this._points;\n            }\n        }\n    });\n\n    /**\n     * Finds an index <code>i</code> in <code>times</code> such that the parameter\n     * <code>time</code> is in the interval <code>[times[i], times[i + 1]]</code>.\n     * @function\n     *\n     * @param {Number} time The time.\n     * @returns {Number} The index for the element at the start of the interval.\n     *\n     * @exception {DeveloperError} time must be in the range <code>[t<sub>0</sub>, t<sub>n</sub>]</code>, where <code>t<sub>0</sub></code>\n     *                             is the first element in the array <code>times</code> and <code>t<sub>n</sub></code> is the last element\n     *                             in the array <code>times</code>.\n     */\n    LinearSpline.prototype.findTimeInterval = Spline.prototype.findTimeInterval;\n\n    /**\n     * Wraps the given time to the period covered by the spline.\n     * @function\n     *\n     * @param {Number} time The time.\n     * @return {Number} The time, wrapped around to the updated animation.\n     */\n    LinearSpline.prototype.wrapTime = Spline.prototype.wrapTime;\n\n    /**\n     * Clamps the given time to the period covered by the spline.\n     * @function\n     *\n     * @param {Number} time The time.\n     * @return {Number} The time, clamped to the animation period.\n     */\n    LinearSpline.prototype.clampTime = Spline.prototype.clampTime;\n\n    /**\n     * Evaluates the curve at a given time.\n     *\n     * @param {Number} time The time at which to evaluate the curve.\n     * @param {Cartesian3} [result] The object onto which to store the result.\n     * @returns {Cartesian3} The modified result parameter or a new instance of the point on the curve at the given time.\n     *\n     * @exception {DeveloperError} time must be in the range <code>[t<sub>0</sub>, t<sub>n</sub>]</code>, where <code>t<sub>0</sub></code>\n     *                             is the first element in the array <code>times</code> and <code>t<sub>n</sub></code> is the last element\n     *                             in the array <code>times</code>.\n     */\n    LinearSpline.prototype.evaluate = function(time, result) {\n        var points = this.points;\n        var times = this.times;\n\n        var i = this._lastTimeIndex = this.findTimeInterval(time, this._lastTimeIndex);\n        var u = (time - times[i]) / (times[i + 1] - times[i]);\n\n        if (!defined(result)) {\n            result = new Cartesian3();\n        }\n\n        return Cartesian3.lerp(points[i], points[i + 1], u, result);\n    };\nexport default LinearSpline;\n","import defaultValue from './defaultValue.js';\nimport defined from './defined.js';\nimport defineProperties from './defineProperties.js';\nimport DeveloperError from './DeveloperError.js';\nimport Quaternion from './Quaternion.js';\nimport Spline from './Spline.js';\n\n    function createEvaluateFunction(spline) {\n        var points = spline.points;\n        var times = spline.times;\n\n        // use slerp interpolation\n        return function(time, result) {\n            if (!defined(result)){\n                result = new Quaternion();\n            }\n            var i = spline._lastTimeIndex = spline.findTimeInterval(time, spline._lastTimeIndex);\n            var u = (time - times[i]) / (times[i + 1] - times[i]);\n\n            var q0 = points[i];\n            var q1 = points[i + 1];\n\n            return Quaternion.fastSlerp(q0, q1, u, result);\n        };\n    }\n\n    /**\n     * A spline that uses spherical linear (slerp) interpolation to create a quaternion curve.\n     * The generated curve is in the class C<sup>1</sup>.\n     *\n     * @alias QuaternionSpline\n     * @constructor\n     *\n     * @param {Object} options Object with the following properties:\n     * @param {Number[]} options.times An array of strictly increasing, unit-less, floating-point times at each point.\n     *                The values are in no way connected to the clock time. They are the parameterization for the curve.\n     * @param {Quaternion[]} options.points The array of {@link Quaternion} control points.\n     *\n     * @exception {DeveloperError} points.length must be greater than or equal to 2.\n     * @exception {DeveloperError} times.length must be equal to points.length.\n     *\n     * @see HermiteSpline\n     * @see CatmullRomSpline\n     * @see LinearSpline\n     * @see WeightSpline\n     */\n    function QuaternionSpline(options) {\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n        var points = options.points;\n        var times = options.times;\n\n        \n\n        this._times = times;\n        this._points = points;\n\n        this._evaluateFunction = createEvaluateFunction(this);\n        this._lastTimeIndex = 0;\n    }\n\n    defineProperties(QuaternionSpline.prototype, {\n        /**\n         * An array of times for the control points.\n         *\n         * @memberof QuaternionSpline.prototype\n         *\n         * @type {Number[]}\n         * @readonly\n         */\n        times : {\n            get : function() {\n                return this._times;\n            }\n        },\n\n        /**\n         * An array of {@link Quaternion} control points.\n         *\n         * @memberof QuaternionSpline.prototype\n         *\n         * @type {Quaternion[]}\n         * @readonly\n         */\n        points : {\n            get : function() {\n                return this._points;\n            }\n        }\n    });\n\n    /**\n     * Finds an index <code>i</code> in <code>times</code> such that the parameter\n     * <code>time</code> is in the interval <code>[times[i], times[i + 1]]</code>.\n     * @function\n     *\n     * @param {Number} time The time.\n     * @returns {Number} The index for the element at the start of the interval.\n     *\n     * @exception {DeveloperError} time must be in the range <code>[t<sub>0</sub>, t<sub>n</sub>]</code>, where <code>t<sub>0</sub></code>\n     *                             is the first element in the array <code>times</code> and <code>t<sub>n</sub></code> is the last element\n     *                             in the array <code>times</code>.\n     */\n    QuaternionSpline.prototype.findTimeInterval = Spline.prototype.findTimeInterval;\n\n    /**\n     * Wraps the given time to the period covered by the spline.\n     * @function\n     *\n     * @param {Number} time The time.\n     * @return {Number} The time, wrapped around to the updated animation.\n     */\n    QuaternionSpline.prototype.wrapTime = Spline.prototype.wrapTime;\n\n    /**\n     * Clamps the given time to the period covered by the spline.\n     * @function\n     *\n     * @param {Number} time The time.\n     * @return {Number} The time, clamped to the animation period.\n     */\n    QuaternionSpline.prototype.clampTime = Spline.prototype.clampTime;\n\n    /**\n     * Evaluates the curve at a given time.\n     *\n     * @param {Number} time The time at which to evaluate the curve.\n     * @param {Quaternion} [result] The object onto which to store the result.\n     * @returns {Quaternion} The modified result parameter or a new instance of the point on the curve at the given time.\n     *\n     * @exception {DeveloperError} time must be in the range <code>[t<sub>0</sub>, t<sub>n</sub>]</code>, where <code>t<sub>0</sub></code>\n     *                             is the first element in the array <code>times</code> and <code>t<sub>n</sub></code> is the last element\n     *                             in the array <code>times</code>.\n     */\n    QuaternionSpline.prototype.evaluate = function(time, result) {\n        return this._evaluateFunction(time, result);\n    };\nexport default QuaternionSpline;\n","import Check from './Check.js';\nimport defaultValue from './defaultValue.js';\nimport defined from './defined.js';\nimport defineProperties from './defineProperties.js';\nimport DeveloperError from './DeveloperError.js';\nimport Spline from './Spline.js';\n\n    /**\n     * A spline that linearly interpolates over an array of weight values used by morph targets.\n     *\n     * @alias WeightSpline\n     * @constructor\n     *\n     * @param {Object} options Object with the following properties:\n     * @param {Number[]} options.times An array of strictly increasing, unit-less, floating-point times at each point.\n     *                The values are in no way connected to the clock time. They are the parameterization for the curve.\n     * @param {Number[]} options.weights The array of floating-point control weights given. The weights are ordered such\n     *                that all weights for the targets are given in chronological order and order in which they appear in\n     *                the glTF from which the morph targets come. This means for 2 targets, weights = [w(0,0), w(0,1), w(1,0), w(1,1) ...]\n     *                where i and j in w(i,j) are the time indices and target indices, respectively.\n     *\n     * @exception {DeveloperError} weights.length must be greater than or equal to 2.\n     * @exception {DeveloperError} times.length must be a factor of weights.length.\n     *\n     *\n     * @example\n     * var times = [ 0.0, 1.5, 3.0, 4.5, 6.0 ];\n     * var weights = [0.0, 1.0, 0.25, 0.75, 0.5, 0.5, 0.75, 0.25, 1.0, 0.0]; //Two targets\n     * var spline = new Cesium.WeightSpline({\n     *     times : times,\n     *     weights : weights\n     * });\n     *\n     * var p0 = spline.evaluate(times[0]);\n     *\n     * @see LinearSpline\n     * @see HermiteSpline\n     * @see CatmullRomSpline\n     * @see QuaternionSpline\n     */\n    function WeightSpline(options) {\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n        var weights = options.weights;\n        var times = options.times;\n\n        \n\n        this._times = times;\n        this._weights = weights;\n        this._count = weights.length / times.length;\n\n        this._lastTimeIndex = 0;\n    }\n\n    defineProperties(WeightSpline.prototype, {\n        /**\n         * An array of times for the control weights.\n         *\n         * @memberof WeightSpline.prototype\n         *\n         * @type {Number[]}\n         * @readonly\n         */\n        times : {\n            get : function() {\n                return this._times;\n            }\n        },\n\n        /**\n         * An array of floating-point array control weights.\n         *\n         * @memberof WeightSpline.prototype\n         *\n         * @type {Number[]}\n         * @readonly\n         */\n        weights : {\n            get : function() {\n                return this._weights;\n            }\n        }\n    });\n\n    /**\n     * Finds an index <code>i</code> in <code>times</code> such that the parameter\n     * <code>time</code> is in the interval <code>[times[i], times[i + 1]]</code>.\n     * @function\n     *\n     * @param {Number} time The time.\n     * @returns {Number} The index for the element at the start of the interval.\n     *\n     * @exception {DeveloperError} time must be in the range <code>[t<sub>0</sub>, t<sub>n</sub>]</code>, where <code>t<sub>0</sub></code>\n     *                             is the first element in the array <code>times</code> and <code>t<sub>n</sub></code> is the last element\n     *                             in the array <code>times</code>.\n     */\n    WeightSpline.prototype.findTimeInterval = Spline.prototype.findTimeInterval;\n\n    /**\n     * Wraps the given time to the period covered by the spline.\n     * @function\n     *\n     * @param {Number} time The time.\n     * @return {Number} The time, wrapped around to the updated animation.\n     */\n    WeightSpline.prototype.wrapTime = Spline.prototype.wrapTime;\n\n    /**\n     * Clamps the given time to the period covered by the spline.\n     * @function\n     *\n     * @param {Number} time The time.\n     * @return {Number} The time, clamped to the animation period.\n     */\n    WeightSpline.prototype.clampTime = Spline.prototype.clampTime;\n\n    /**\n     * Evaluates the curve at a given time.\n     *\n     * @param {Number} time The time at which to evaluate the curve.\n     * @param {Number[]} [result] The object onto which to store the result.\n     * @returns {Number[]} The modified result parameter or a new instance of the point on the curve at the given time.\n     *\n     * @exception {DeveloperError} time must be in the range <code>[t<sub>0</sub>, t<sub>n</sub>]</code>, where <code>t<sub>0</sub></code>\n     *                             is the first element in the array <code>times</code> and <code>t<sub>n</sub></code> is the last element\n     *                             in the array <code>times</code>.\n     */\n    WeightSpline.prototype.evaluate = function(time, result) {\n        var weights = this.weights;\n        var times = this.times;\n\n        var i = this._lastTimeIndex = this.findTimeInterval(time, this._lastTimeIndex);\n        var u = (time - times[i]) / (times[i + 1] - times[i]);\n\n        if (!defined(result)) {\n            result = new Array(this._count);\n        }\n\n        for (var j = 0; j < this._count; j++) {\n            var index = (i * this._count) + j;\n            result[j] = weights[index] * (1.0 - u) + weights[index + this._count] * u;\n        }\n\n        return result;\n    };\nexport default WeightSpline;\n","import freezeObject from '../Core/freezeObject.js';\n\n    /**\n     * An enum describing the attribute type for glTF and 3D Tiles.\n     *\n     * @exports AttributeType\n     *\n     * @private\n     */\n    var AttributeType = {\n        /**\n         * The attribute is a single component.\n         *\n         * @type {String}\n         * @constant\n         */\n        SCALAR : 'SCALAR',\n\n        /**\n         * The attribute is a two-component vector.\n         *\n         * @type {String}\n         * @constant\n         */\n        VEC2 : 'VEC2',\n\n        /**\n         * The attribute is a three-component vector.\n         *\n         * @type {String}\n         * @constant\n         */\n        VEC3 : 'VEC3',\n\n        /**\n         * The attribute is a four-component vector.\n         *\n         * @type {String}\n         * @constant\n         */\n        VEC4 : 'VEC4',\n\n        /**\n         * The attribute is a 2x2 matrix.\n         *\n         * @type {String}\n         * @constant\n         */\n        MAT2 : 'MAT2',\n\n        /**\n         * The attribute is a 3x3 matrix.\n         *\n         * @type {String}\n         * @constant\n         */\n        MAT3 : 'MAT3',\n\n        /**\n         * The attribute is a 4x4 matrix.\n         *\n         * @type {String}\n         * @constant\n         */\n        MAT4 : 'MAT4'\n    };\nexport default freezeObject(AttributeType);\n","import Cartesian3 from '../Core/Cartesian3.js';\nimport ComponentDatatype from '../Core/ComponentDatatype.js';\nimport defaultValue from '../Core/defaultValue.js';\nimport defined from '../Core/defined.js';\nimport LinearSpline from '../Core/LinearSpline.js';\nimport Matrix4 from '../Core/Matrix4.js';\nimport Quaternion from '../Core/Quaternion.js';\nimport QuaternionSpline from '../Core/QuaternionSpline.js';\nimport WebGLConstants from '../Core/WebGLConstants.js';\nimport WeightSpline from '../Core/WeightSpline.js';\nimport getAccessorByteStride from '../ThirdParty/GltfPipeline/getAccessorByteStride.js';\nimport numberOfComponentsForType from '../ThirdParty/GltfPipeline/numberOfComponentsForType.js';\nimport AttributeType from './AttributeType.js';\n\n    /**\n     * @private\n     */\n    function ModelAnimationCache() {\n    }\n\n    var dataUriRegex = /^data\\:/i;\n\n    function getAccessorKey(model, accessor) {\n        var gltf = model.gltf;\n        var buffers = gltf.buffers;\n        var bufferViews = gltf.bufferViews;\n\n        var bufferView = bufferViews[accessor.bufferView];\n        var buffer = buffers[bufferView.buffer];\n\n        var byteOffset = bufferView.byteOffset + accessor.byteOffset;\n        var byteLength = accessor.count * numberOfComponentsForType(accessor.type);\n\n        var uriKey = dataUriRegex.test(buffer.uri) ? '' : buffer.uri;\n        return model.cacheKey + '//' + uriKey + '/' + byteOffset + '/' + byteLength;\n    }\n\n    var cachedAnimationParameters = {\n    };\n\n    ModelAnimationCache.getAnimationParameterValues = function(model, accessor) {\n        var key = getAccessorKey(model, accessor);\n        var values = cachedAnimationParameters[key];\n\n        if (!defined(values)) {\n            // Cache miss\n            var gltf = model.gltf;\n\n            var buffers = gltf.buffers;\n            var bufferViews = gltf.bufferViews;\n\n            var bufferView = bufferViews[accessor.bufferView];\n            var bufferId = bufferView.buffer;\n            var buffer = buffers[bufferId];\n            var source = buffer.extras._pipeline.source;\n\n            var componentType = accessor.componentType;\n            var type = accessor.type;\n            var numberOfComponents = numberOfComponentsForType(type);\n            var count = accessor.count;\n            var byteStride = getAccessorByteStride(gltf, accessor);\n\n            values = new Array(count);\n            var accessorByteOffset = defaultValue(accessor.byteOffset, 0);\n            var byteOffset = bufferView.byteOffset + accessorByteOffset;\n            for (var i = 0; i < count; i++) {\n                var typedArrayView = ComponentDatatype.createArrayBufferView(componentType, source.buffer, source.byteOffset + byteOffset, numberOfComponents);\n                if (type === 'SCALAR') {\n                    values[i] = typedArrayView[0];\n                } else if (type === 'VEC3') {\n                    values[i] = Cartesian3.fromArray(typedArrayView);\n                } else if (type === 'VEC4') {\n                    values[i] = Quaternion.unpack(typedArrayView);\n                }\n                byteOffset += byteStride;\n            }\n            // GLTF_SPEC: Support more parameter types when glTF supports targeting materials. https://github.com/KhronosGroup/glTF/issues/142\n\n            if (defined(model.cacheKey)) {\n                // Only cache when we can create a unique id\n                cachedAnimationParameters[key] = values;\n            }\n        }\n\n        return values;\n    };\n\n    var cachedAnimationSplines = {\n    };\n\n    function getAnimationSplineKey(model, animationName, samplerName) {\n        return model.cacheKey + '//' + animationName + '/' + samplerName;\n    }\n\n    function ConstantSpline(value) {\n        this._value = value;\n    }\n    ConstantSpline.prototype.evaluate = function(time, result) {\n        return this._value;\n    };\n    ConstantSpline.prototype.wrapTime = function(time) {\n        return 0.0;\n    };\n    ConstantSpline.prototype.clampTime = function(time) {\n        return 0.0;\n    };\n\n    ModelAnimationCache.getAnimationSpline = function(model, animationName, animation, samplerName, sampler, input, path, output) {\n        var key = getAnimationSplineKey(model, animationName, samplerName);\n        var spline = cachedAnimationSplines[key];\n\n        if (!defined(spline)) {\n            var times = input;\n            var controlPoints = output;\n\n            if ((times.length === 1) && (controlPoints.length === 1)) {\n                spline = new ConstantSpline(controlPoints[0]);\n            } else if (sampler.interpolation === 'LINEAR') {\n                if (path === 'translation' || path === 'scale') {\n                    spline = new LinearSpline({\n                        times : times,\n                        points : controlPoints\n                    });\n                } else if (path === 'rotation') {\n                    spline = new QuaternionSpline({\n                        times : times,\n                        points : controlPoints\n                    });\n                } else if (path === 'weights') {\n                    spline = new WeightSpline({\n                        times : times,\n                        weights : controlPoints\n                    });\n                }\n                // GLTF_SPEC: Support more parameter types when glTF supports targeting materials. https://github.com/KhronosGroup/glTF/issues/142\n            }\n\n            if (defined(model.cacheKey)) {\n                // Only cache when we can create a unique id\n                cachedAnimationSplines[key] = spline;\n            }\n        }\n\n        return spline;\n    };\n\n    var cachedSkinInverseBindMatrices = {\n    };\n\n    ModelAnimationCache.getSkinInverseBindMatrices = function(model, accessor) {\n        var key = getAccessorKey(model, accessor);\n        var matrices = cachedSkinInverseBindMatrices[key];\n\n        if (!defined(matrices)) {\n            // Cache miss\n            var gltf = model.gltf;\n            var buffers = gltf.buffers;\n            var bufferViews = gltf.bufferViews;\n\n            var bufferViewId = accessor.bufferView;\n            var bufferView = bufferViews[bufferViewId];\n            var bufferId = bufferView.buffer;\n            var buffer = buffers[bufferId];\n            var source = buffer.extras._pipeline.source;\n\n            var componentType = accessor.componentType;\n            var type = accessor.type;\n            var count = accessor.count;\n            var byteStride = getAccessorByteStride(gltf, accessor);\n            var byteOffset = bufferView.byteOffset + accessor.byteOffset;\n            var numberOfComponents = numberOfComponentsForType(type);\n\n            matrices = new Array(count);\n\n            if ((componentType === WebGLConstants.FLOAT) && (type === AttributeType.MAT4)) {\n                for (var i = 0; i < count; ++i) {\n                    var typedArrayView = ComponentDatatype.createArrayBufferView(componentType, source.buffer, source.byteOffset + byteOffset, numberOfComponents);\n                    matrices[i] = Matrix4.fromArray(typedArrayView);\n                    byteOffset += byteStride;\n                }\n            }\n\n            cachedSkinInverseBindMatrices[key] = matrices;\n        }\n\n        return matrices;\n    };\nexport default ModelAnimationCache;\n","import freezeObject from '../Core/freezeObject.js';\n\n    /**\n     * Determines if and how a glTF animation is looped.\n     *\n     * @exports ModelAnimationLoop\n     *\n     * @see ModelAnimationCollection#add\n     */\n    var ModelAnimationLoop = {\n        /**\n         * Play the animation once; do not loop it.\n         *\n         * @type {Number}\n         * @constant\n         */\n        NONE : 0,\n\n        /**\n         * Loop the animation playing it from the start immediately after it stops.\n         *\n         * @type {Number}\n         * @constant\n         */\n        REPEAT : 1,\n\n        /**\n         * Loop the animation.  First, playing it forward, then in reverse, then forward, and so on.\n         *\n         * @type {Number}\n         * @constant\n         */\n        MIRRORED_REPEAT : 2\n    };\nexport default freezeObject(ModelAnimationLoop);\n","import freezeObject from '../Core/freezeObject.js';\n\n    /**\n     * @private\n     */\nexport default freezeObject({\n        STOPPED : 0,\n        ANIMATING : 1\n    });\n","import defaultValue from '../Core/defaultValue.js';\nimport defineProperties from '../Core/defineProperties.js';\nimport Event from '../Core/Event.js';\nimport JulianDate from '../Core/JulianDate.js';\nimport ModelAnimationLoop from './ModelAnimationLoop.js';\nimport ModelAnimationState from './ModelAnimationState.js';\n\n    /**\n     * An active glTF animation.  A glTF asset can contain animations.  An active animation\n     * is an animation that is currently playing or scheduled to be played because it was\n     * added to a model's {@link ModelAnimationCollection}.  An active animation is an\n     * instance of an animation; for example, there can be multiple active animations\n     * for the same glTF animation, each with a different start time.\n     * <p>\n     * Create this by calling {@link ModelAnimationCollection#add}.\n     * </p>\n     *\n     * @alias ModelAnimation\n     * @internalConstructor\n     * @class\n     *\n     * @see ModelAnimationCollection#add\n     */\n    function ModelAnimation(options, model, runtimeAnimation) {\n        this._name = runtimeAnimation.name;\n        this._startTime = JulianDate.clone(options.startTime);\n        this._delay = defaultValue(options.delay, 0.0); // in seconds\n        this._stopTime = options.stopTime;\n\n        /**\n         * When <code>true</code>, the animation is removed after it stops playing.\n         * This is slightly more efficient that not removing it, but if, for example,\n         * time is reversed, the animation is not played again.\n         *\n         * @type {Boolean}\n         * @default false\n         */\n        this.removeOnStop = defaultValue(options.removeOnStop, false);\n        this._multiplier = defaultValue(options.multiplier, 1.0);\n        this._reverse = defaultValue(options.reverse, false);\n        this._loop = defaultValue(options.loop, ModelAnimationLoop.NONE);\n\n        /**\n         * The event fired when this animation is started.  This can be used, for\n         * example, to play a sound or start a particle system, when the animation starts.\n         * <p>\n         * This event is fired at the end of the frame after the scene is rendered.\n         * </p>\n         *\n         * @type {Event}\n         * @default new Event()\n         *\n         * @example\n         * animation.start.addEventListener(function(model, animation) {\n         *   console.log('Animation started: ' + animation.name);\n         * });\n         */\n        this.start = new Event();\n\n        /**\n         * The event fired when on each frame when this animation is updated.  The\n         * current time of the animation, relative to the glTF animation time span, is\n         * passed to the event, which allows, for example, starting new animations at a\n         * specific time relative to a playing animation.\n         * <p>\n         * This event is fired at the end of the frame after the scene is rendered.\n         * </p>\n         *\n         * @type {Event}\n         * @default new Event()\n         *\n         * @example\n         * animation.update.addEventListener(function(model, animation, time) {\n         *   console.log('Animation updated: ' + animation.name + '. glTF animation time: ' + time);\n         * });\n         */\n        this.update = new Event();\n\n        /**\n         * The event fired when this animation is stopped.  This can be used, for\n         * example, to play a sound or start a particle system, when the animation stops.\n         * <p>\n         * This event is fired at the end of the frame after the scene is rendered.\n         * </p>\n         *\n         * @type {Event}\n         * @default new Event()\n         *\n         * @example\n         * animation.stop.addEventListener(function(model, animation) {\n         *   console.log('Animation stopped: ' + animation.name);\n         * });\n         */\n        this.stop = new Event();\n\n        this._state = ModelAnimationState.STOPPED;\n        this._runtimeAnimation = runtimeAnimation;\n\n        // Set during animation update\n        this._computedStartTime = undefined;\n        this._duration = undefined;\n\n        // To avoid allocations in ModelAnimationCollection.update\n        var that = this;\n        this._raiseStartEvent = function() {\n            that.start.raiseEvent(model, that);\n        };\n        this._updateEventTime = 0.0;\n        this._raiseUpdateEvent = function() {\n            that.update.raiseEvent(model, that, that._updateEventTime);\n        };\n        this._raiseStopEvent = function() {\n            that.stop.raiseEvent(model, that);\n        };\n    }\n\n    defineProperties(ModelAnimation.prototype, {\n        /**\n         * The glTF animation name that identifies this animation.\n         *\n         * @memberof ModelAnimation.prototype\n         *\n         * @type {String}\n         * @readonly\n         */\n        name : {\n            get : function() {\n                return this._name;\n            }\n        },\n\n        /**\n         * The scene time to start playing this animation.  When this is <code>undefined</code>,\n         * the animation starts at the next frame.\n         *\n         * @memberof ModelAnimation.prototype\n         *\n         * @type {JulianDate}\n         * @readonly\n         *\n         * @default undefined\n         */\n        startTime : {\n            get : function() {\n                return this._startTime;\n            }\n        },\n\n        /**\n         * The delay, in seconds, from {@link ModelAnimation#startTime} to start playing.\n         *\n         * @memberof ModelAnimation.prototype\n         *\n         * @type {Number}\n         * @readonly\n         *\n         * @default undefined\n         */\n        delay : {\n            get : function() {\n                return this._delay;\n            }\n        },\n\n        /**\n         * The scene time to stop playing this animation.  When this is <code>undefined</code>,\n         * the animation is played for its full duration and perhaps repeated depending on\n         * {@link ModelAnimation#loop}.\n         *\n         * @memberof ModelAnimation.prototype\n         *\n         * @type {JulianDate}\n         * @readonly\n         *\n         * @default undefined\n         */\n        stopTime : {\n            get : function() {\n                return this._stopTime;\n            }\n        },\n        /**\n         * Values greater than <code>1.0</code> increase the speed that the animation is played relative\n         * to the scene clock speed; values less than <code>1.0</code> decrease the speed.  A value of\n         * <code>1.0</code> plays the animation at the speed in the glTF animation mapped to the scene\n         * clock speed.  For example, if the scene is played at 2x real-time, a two-second glTF animation\n         * will play in one second even if <code>multiplier</code> is <code>1.0</code>.\n         *\n         * @memberof ModelAnimation.prototype\n         *\n         * @type {Number}\n         * @readonly\n         *\n         * @default 1.0\n         */\n        multiplier : {\n            get : function() {\n                return this._multiplier;\n            }\n        },\n\n        /**\n         * When <code>true</code>, the animation is played in reverse.\n         *\n         * @memberof ModelAnimation.prototype\n         *\n         * @type {Boolean}\n         * @readonly\n         *\n         * @default false\n         */\n        reverse : {\n            get : function() {\n                return this._reverse;\n            }\n        },\n\n        /**\n         * Determines if and how the animation is looped.\n         *\n         * @memberof ModelAnimation.prototype\n         *\n         * @type {ModelAnimationLoop}\n         * @readonly\n         *\n         * @default {@link ModelAnimationLoop.NONE}\n         */\n        loop : {\n            get : function() {\n                return this._loop;\n            }\n        }\n    });\nexport default ModelAnimation;\n","import defaultValue from '../Core/defaultValue.js';\nimport defined from '../Core/defined.js';\nimport defineProperties from '../Core/defineProperties.js';\nimport DeveloperError from '../Core/DeveloperError.js';\nimport Event from '../Core/Event.js';\nimport JulianDate from '../Core/JulianDate.js';\nimport CesiumMath from '../Core/Math.js';\nimport ModelAnimation from './ModelAnimation.js';\nimport ModelAnimationLoop from './ModelAnimationLoop.js';\nimport ModelAnimationState from './ModelAnimationState.js';\n\n    /**\n     * A collection of active model animations.  Access this using {@link Model#activeAnimations}.\n     *\n     * @alias ModelAnimationCollection\n     * @internalConstructor\n     * @class\n     *\n     * @see Model#activeAnimations\n     */\n    function ModelAnimationCollection(model) {\n        /**\n         * The event fired when an animation is added to the collection.  This can be used, for\n         * example, to keep a UI in sync.\n         *\n         * @type {Event}\n         * @default new Event()\n         *\n         * @example\n         * model.activeAnimations.animationAdded.addEventListener(function(model, animation) {\n         *   console.log('Animation added: ' + animation.name);\n         * });\n         */\n        this.animationAdded = new Event();\n\n        /**\n         * The event fired when an animation is removed from the collection.  This can be used, for\n         * example, to keep a UI in sync.\n         *\n         * @type {Event}\n         * @default new Event()\n         *\n         * @example\n         * model.activeAnimations.animationRemoved.addEventListener(function(model, animation) {\n         *   console.log('Animation removed: ' + animation.name);\n         * });\n         */\n        this.animationRemoved = new Event();\n\n        this._model = model;\n        this._scheduledAnimations = [];\n        this._previousTime = undefined;\n    }\n\n    defineProperties(ModelAnimationCollection.prototype, {\n        /**\n         * The number of animations in the collection.\n         *\n         * @memberof ModelAnimationCollection.prototype\n         *\n         * @type {Number}\n         * @readonly\n         */\n        length : {\n            get : function() {\n                return this._scheduledAnimations.length;\n            }\n        }\n    });\n\n    function add(collection, index, options) {\n        var model = collection._model;\n        var animations = model._runtime.animations;\n        var animation = animations[index];\n        var scheduledAnimation = new ModelAnimation(options, model, animation);\n        collection._scheduledAnimations.push(scheduledAnimation);\n        collection.animationAdded.raiseEvent(model, scheduledAnimation);\n        return scheduledAnimation;\n    }\n\n    /**\n     * Creates and adds an animation with the specified initial properties to the collection.\n     * <p>\n     * This raises the {@link ModelAnimationCollection#animationAdded} event so, for example, a UI can stay in sync.\n     * </p>\n     *\n     * @param {Object} options Object with the following properties:\n     * @param {String} [options.name] The glTF animation name that identifies the animation. Must be defined if <code>options.index</code> is <code>undefined</code>.\n     * @param {Number} [options.index] The glTF animation index that identifies the animation. Must be defined if <code>options.name</code> is <code>undefined</code>.\n     * @param {JulianDate} [options.startTime] The scene time to start playing the animation.  When this is <code>undefined</code>, the animation starts at the next frame.\n     * @param {Number} [options.delay=0.0] The delay, in seconds, from <code>startTime</code> to start playing.\n     * @param {JulianDate} [options.stopTime] The scene time to stop playing the animation.  When this is <code>undefined</code>, the animation is played for its full duration.\n     * @param {Boolean} [options.removeOnStop=false] When <code>true</code>, the animation is removed after it stops playing.\n     * @param {Number} [options.multiplier=1.0] Values greater than <code>1.0</code> increase the speed that the animation is played relative to the scene clock speed; values less than <code>1.0</code> decrease the speed.\n     * @param {Boolean} [options.reverse=false] When <code>true</code>, the animation is played in reverse.\n     * @param {ModelAnimationLoop} [options.loop=ModelAnimationLoop.NONE] Determines if and how the animation is looped.\n     * @returns {ModelAnimation} The animation that was added to the collection.\n     *\n     * @exception {DeveloperError} Animations are not loaded.  Wait for the {@link Model#readyPromise} to resolve.\n     * @exception {DeveloperError} options.name must be a valid animation name.\n     * @exception {DeveloperError} options.index must be a valid animation index.\n     * @exception {DeveloperError} Either options.name or options.index must be defined.\n     * @exception {DeveloperError} options.multiplier must be greater than zero.\n     *\n     * @example\n     * // Example 1. Add an animation by name\n     * model.activeAnimations.add({\n     *   name : 'animation name'\n     * });\n     *\n     * // Example 2. Add an animation by index\n     * model.activeAnimations.add({\n     *   index : 0\n     * });\n     *\n     * @example\n     * // Example 3. Add an animation and provide all properties and events\n     * var startTime = Cesium.JulianDate.now();\n     *\n     * var animation = model.activeAnimations.add({\n     *   name : 'another animation name',\n     *   startTime : startTime,\n     *   delay : 0.0,                          // Play at startTime (default)\n     *   stopTime : Cesium.JulianDate.addSeconds(startTime, 4.0, new Cesium.JulianDate()),\n     *   removeOnStop : false,                 // Do not remove when animation stops (default)\n     *   multiplier : 2.0,                        // Play at double speed\n     *   reverse : true,                       // Play in reverse\n     *   loop : Cesium.ModelAnimationLoop.REPEAT      // Loop the animation\n     * });\n     *\n     * animation.start.addEventListener(function(model, animation) {\n     *   console.log('Animation started: ' + animation.name);\n     * });\n     * animation.update.addEventListener(function(model, animation, time) {\n     *   console.log('Animation updated: ' + animation.name + '. glTF animation time: ' + time);\n     * });\n     * animation.stop.addEventListener(function(model, animation) {\n     *   console.log('Animation stopped: ' + animation.name);\n     * });\n     */\n    ModelAnimationCollection.prototype.add = function(options) {\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n        var model = this._model;\n        var animations = model._runtime.animations;\n\n        \n\n        if (defined(options.index)) {\n            return add(this, options.index, options);\n        }\n\n        // Find the index of the animation with the given name\n        var index;\n        var length = animations.length;\n        for (var i = 0; i < length; ++i) {\n            if (animations[i].name === options.name) {\n                index = i;\n                break;\n            }\n        }\n\n        \n\n        return add(this, index, options);\n    };\n\n    /**\n     * Creates and adds an animation with the specified initial properties to the collection\n     * for each animation in the model.\n     * <p>\n     * This raises the {@link ModelAnimationCollection#animationAdded} event for each model so, for example, a UI can stay in sync.\n     * </p>\n     *\n     * @param {Object} [options] Object with the following properties:\n     * @param {JulianDate} [options.startTime] The scene time to start playing the animations.  When this is <code>undefined</code>, the animations starts at the next frame.\n     * @param {Number} [options.delay=0.0] The delay, in seconds, from <code>startTime</code> to start playing.\n     * @param {JulianDate} [options.stopTime] The scene time to stop playing the animations.  When this is <code>undefined</code>, the animations are played for its full duration.\n     * @param {Boolean} [options.removeOnStop=false] When <code>true</code>, the animations are removed after they stop playing.\n     * @param {Number} [options.multiplier=1.0] Values greater than <code>1.0</code> increase the speed that the animations play relative to the scene clock speed; values less than <code>1.0</code> decrease the speed.\n     * @param {Boolean} [options.reverse=false] When <code>true</code>, the animations are played in reverse.\n     * @param {ModelAnimationLoop} [options.loop=ModelAnimationLoop.NONE] Determines if and how the animations are looped.\n     * @returns {ModelAnimation[]} An array of {@link ModelAnimation} objects, one for each animation added to the collection.  If there are no glTF animations, the array is empty.\n     *\n     * @exception {DeveloperError} Animations are not loaded.  Wait for the {@link Model#readyPromise} to resolve.\n     * @exception {DeveloperError} options.multiplier must be greater than zero.\n     *\n     * @example\n     * model.activeAnimations.addAll({\n     *   multiplier : 0.5,                        // Play at half-speed\n     *   loop : Cesium.ModelAnimationLoop.REPEAT      // Loop the animations\n     * });\n     */\n    ModelAnimationCollection.prototype.addAll = function(options) {\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n        \n\n        var scheduledAnimations = [];\n        var model = this._model;\n        var animations = model._runtime.animations;\n        var length = animations.length;\n        for (var i = 0; i < length; ++i) {\n            scheduledAnimations.push(add(this, i, options));\n        }\n        return scheduledAnimations;\n    };\n\n    /**\n     * Removes an animation from the collection.\n     * <p>\n     * This raises the {@link ModelAnimationCollection#animationRemoved} event so, for example, a UI can stay in sync.\n     * </p>\n     * <p>\n     * An animation can also be implicitly removed from the collection by setting {@link ModelAnimation#removeOnStop} to\n     * <code>true</code>.  The {@link ModelAnimationCollection#animationRemoved} event is still fired when the animation is removed.\n     * </p>\n     *\n     * @param {ModelAnimation} animation The animation to remove.\n     * @returns {Boolean} <code>true</code> if the animation was removed; <code>false</code> if the animation was not found in the collection.\n     *\n     * @example\n     * var a = model.activeAnimations.add({\n     *   name : 'animation name'\n     * });\n     * model.activeAnimations.remove(a); // Returns true\n     */\n    ModelAnimationCollection.prototype.remove = function(animation) {\n        if (defined(animation)) {\n            var animations = this._scheduledAnimations;\n            var i = animations.indexOf(animation);\n            if (i !== -1) {\n                animations.splice(i, 1);\n                this.animationRemoved.raiseEvent(this._model, animation);\n                return true;\n            }\n        }\n\n        return false;\n    };\n\n    /**\n     * Removes all animations from the collection.\n     * <p>\n     * This raises the {@link ModelAnimationCollection#animationRemoved} event for each\n     * animation so, for example, a UI can stay in sync.\n     * </p>\n     */\n    ModelAnimationCollection.prototype.removeAll = function() {\n        var model = this._model;\n        var animations = this._scheduledAnimations;\n        var length = animations.length;\n\n        this._scheduledAnimations = [];\n\n        for (var i = 0; i < length; ++i) {\n            this.animationRemoved.raiseEvent(model, animations[i]);\n        }\n    };\n\n    /**\n     * Determines whether this collection contains a given animation.\n     *\n     * @param {ModelAnimation} animation The animation to check for.\n     * @returns {Boolean} <code>true</code> if this collection contains the animation, <code>false</code> otherwise.\n     */\n    ModelAnimationCollection.prototype.contains = function(animation) {\n        if (defined(animation)) {\n            return (this._scheduledAnimations.indexOf(animation) !== -1);\n        }\n\n        return false;\n    };\n\n    /**\n     * Returns the animation in the collection at the specified index.  Indices are zero-based\n     * and increase as animations are added.  Removing an animation shifts all animations after\n     * it to the left, changing their indices.  This function is commonly used to iterate over\n     * all the animations in the collection.\n     *\n     * @param {Number} index The zero-based index of the animation.\n     * @returns {ModelAnimation} The animation at the specified index.\n     *\n     * @example\n     * // Output the names of all the animations in the collection.\n     * var animations = model.activeAnimations;\n     * var length = animations.length;\n     * for (var i = 0; i < length; ++i) {\n     *   console.log(animations.get(i).name);\n     * }\n     */\n    ModelAnimationCollection.prototype.get = function(index) {\n        \n\n        return this._scheduledAnimations[index];\n    };\n\n    function animateChannels(runtimeAnimation, localAnimationTime) {\n        var channelEvaluators = runtimeAnimation.channelEvaluators;\n        var length = channelEvaluators.length;\n        for (var i = 0; i < length; ++i) {\n            channelEvaluators[i](localAnimationTime);\n        }\n    }\n\n    var animationsToRemove = [];\n\n    function createAnimationRemovedFunction(modelAnimationCollection, model, animation) {\n        return function() {\n            modelAnimationCollection.animationRemoved.raiseEvent(model, animation);\n        };\n    }\n\n    /**\n     * @private\n     */\n    ModelAnimationCollection.prototype.update = function(frameState) {\n        var scheduledAnimations = this._scheduledAnimations;\n        var length = scheduledAnimations.length;\n\n        if (length === 0) {\n            // No animations - quick return for performance\n            this._previousTime = undefined;\n            return false;\n        }\n\n        if (JulianDate.equals(frameState.time, this._previousTime)) {\n            // Animations are currently only time-dependent so do not animate when paused or picking\n            return false;\n        }\n        this._previousTime = JulianDate.clone(frameState.time, this._previousTime);\n\n        var animationOccured = false;\n        var sceneTime = frameState.time;\n        var model = this._model;\n\n        for (var i = 0; i < length; ++i) {\n            var scheduledAnimation = scheduledAnimations[i];\n            var runtimeAnimation = scheduledAnimation._runtimeAnimation;\n\n            if (!defined(scheduledAnimation._computedStartTime)) {\n                scheduledAnimation._computedStartTime = JulianDate.addSeconds(defaultValue(scheduledAnimation.startTime, sceneTime), scheduledAnimation.delay, new JulianDate());\n            }\n\n            if (!defined(scheduledAnimation._duration)) {\n                scheduledAnimation._duration = runtimeAnimation.stopTime * (1.0 / scheduledAnimation.multiplier);\n            }\n\n            var startTime = scheduledAnimation._computedStartTime;\n            var duration = scheduledAnimation._duration;\n            var stopTime = scheduledAnimation.stopTime;\n\n            // [0.0, 1.0] normalized local animation time\n            var delta = (duration !== 0.0) ? (JulianDate.secondsDifference(sceneTime, startTime) / duration) : 0.0;\n            var pastStartTime = (delta >= 0.0);\n\n            // Play animation if\n            // * we are after the start time or the animation is being repeated, and\n            // * before the end of the animation's duration or the animation is being repeated, and\n            // * we did not reach a user-provided stop time.\n\n            var repeat = ((scheduledAnimation.loop === ModelAnimationLoop.REPEAT) ||\n                          (scheduledAnimation.loop === ModelAnimationLoop.MIRRORED_REPEAT));\n\n            var play = (pastStartTime || (repeat && !defined(scheduledAnimation.startTime))) &&\n                       ((delta <= 1.0) || repeat) &&\n                       (!defined(stopTime) || JulianDate.lessThanOrEquals(sceneTime, stopTime));\n\n            if (play) {\n                // STOPPED -> ANIMATING state transition?\n                if (scheduledAnimation._state === ModelAnimationState.STOPPED) {\n                    scheduledAnimation._state = ModelAnimationState.ANIMATING;\n                    if (scheduledAnimation.start.numberOfListeners > 0) {\n                        frameState.afterRender.push(scheduledAnimation._raiseStartEvent);\n                    }\n                }\n\n                // Truncate to [0.0, 1.0] for repeating animations\n                if (scheduledAnimation.loop === ModelAnimationLoop.REPEAT) {\n                    delta = delta - Math.floor(delta);\n                } else if (scheduledAnimation.loop === ModelAnimationLoop.MIRRORED_REPEAT) {\n                    var floor = Math.floor(delta);\n                    var fract = delta - floor;\n                    // When even use (1.0 - fract) to mirror repeat\n                    delta = (floor % 2 === 1.0) ? (1.0 - fract) : fract;\n                }\n\n                if (scheduledAnimation.reverse) {\n                    delta = 1.0 - delta;\n                }\n\n                var localAnimationTime = delta * duration * scheduledAnimation.multiplier;\n                // Clamp in case floating-point roundoff goes outside the animation's first or last keyframe\n                localAnimationTime = CesiumMath.clamp(localAnimationTime, runtimeAnimation.startTime, runtimeAnimation.stopTime);\n\n                animateChannels(runtimeAnimation, localAnimationTime);\n\n                if (scheduledAnimation.update.numberOfListeners > 0) {\n                    scheduledAnimation._updateEventTime = localAnimationTime;\n                    frameState.afterRender.push(scheduledAnimation._raiseUpdateEvent);\n                }\n                animationOccured = true;\n            } else if (pastStartTime && (scheduledAnimation._state === ModelAnimationState.ANIMATING)) {\n                // ANIMATING -> STOPPED state transition?\n                scheduledAnimation._state = ModelAnimationState.STOPPED;\n                if (scheduledAnimation.stop.numberOfListeners > 0) {\n                    frameState.afterRender.push(scheduledAnimation._raiseStopEvent);\n                }\n\n                if (scheduledAnimation.removeOnStop) {\n                    animationsToRemove.push(scheduledAnimation);\n                }\n            }\n        }\n\n        // Remove animations that stopped\n        length = animationsToRemove.length;\n        for (var j = 0; j < length; ++j) {\n            var animationToRemove = animationsToRemove[j];\n            scheduledAnimations.splice(scheduledAnimations.indexOf(animationToRemove), 1);\n            frameState.afterRender.push(createAnimationRemovedFunction(this, model, animationToRemove));\n        }\n        animationsToRemove.length = 0;\n\n        return animationOccured;\n    };\nexport default ModelAnimationCollection;\n","import Queue from '../Core/Queue.js';\n\n    /**\n     * @private\n     */\n    function ModelLoadResources() {\n        this.initialized = false;\n        this.resourcesParsed = false;\n\n        this.vertexBuffersToCreate = new Queue();\n        this.indexBuffersToCreate = new Queue();\n        this.buffers = {};\n        this.pendingBufferLoads = 0;\n\n        this.programsToCreate = new Queue();\n        this.shaders = {};\n        this.pendingShaderLoads = 0;\n\n        this.texturesToCreate = new Queue();\n        this.pendingTextureLoads = 0;\n\n        this.texturesToCreateFromBufferView = new Queue();\n        this.pendingBufferViewToImage = 0;\n\n        this.createSamplers = true;\n        this.createSkins = true;\n        this.createRuntimeAnimations = true;\n        this.createVertexArrays = true;\n        this.createRenderStates = true;\n        this.createUniformMaps = true;\n        this.createRuntimeNodes = true;\n\n        this.createdBufferViews = {};\n        this.primitivesToDecode = new Queue();\n        this.activeDecodingTasks = 0;\n        this.pendingDecodingCache = false;\n\n        this.skinnedNodesIds = [];\n    }\n\n    /**\n     * This function differs from the normal subarray function\n     * because it takes offset and length, rather than begin and end.\n     */\n    function getSubarray(array, offset, length) {\n        return array.subarray(offset, offset + length);\n    }\n\n    ModelLoadResources.prototype.getBuffer = function(bufferView) {\n        return getSubarray(this.buffers[bufferView.buffer], bufferView.byteOffset, bufferView.byteLength);\n    };\n\n    ModelLoadResources.prototype.finishedPendingBufferLoads = function() {\n        return (this.pendingBufferLoads === 0);\n    };\n\n    ModelLoadResources.prototype.finishedBuffersCreation = function() {\n        return ((this.pendingBufferLoads === 0) &&\n                (this.vertexBuffersToCreate.length === 0) &&\n                (this.indexBuffersToCreate.length === 0));\n    };\n\n    ModelLoadResources.prototype.finishedProgramCreation = function() {\n        return ((this.pendingShaderLoads === 0) && (this.programsToCreate.length === 0));\n    };\n\n    ModelLoadResources.prototype.finishedTextureCreation = function() {\n        var finishedPendingLoads = (this.pendingTextureLoads === 0);\n        var finishedResourceCreation =\n            (this.texturesToCreate.length === 0) &&\n            (this.texturesToCreateFromBufferView.length === 0);\n\n        return finishedPendingLoads && finishedResourceCreation;\n    };\n\n    ModelLoadResources.prototype.finishedEverythingButTextureCreation = function() {\n        var finishedPendingLoads =\n            (this.pendingBufferLoads === 0) &&\n            (this.pendingShaderLoads === 0);\n        var finishedResourceCreation =\n            (this.vertexBuffersToCreate.length === 0) &&\n            (this.indexBuffersToCreate.length === 0) &&\n            (this.programsToCreate.length === 0) &&\n            (this.pendingBufferViewToImage === 0);\n\n        return this.finishedDecoding() && finishedPendingLoads && finishedResourceCreation;\n    };\n\n    ModelLoadResources.prototype.finishedDecoding = function() {\n        return this.primitivesToDecode.length === 0 && this.activeDecodingTasks === 0 && !this.pendingDecodingCache;\n    };\n\n    ModelLoadResources.prototype.finished = function() {\n        return this.finishedDecoding() && this.finishedTextureCreation() && this.finishedEverythingButTextureCreation();\n    };\nexport default ModelLoadResources;\n","import defined from '../Core/defined.js';\nimport defineProperties from '../Core/defineProperties.js';\nimport DeveloperError from '../Core/DeveloperError.js';\n\n    /**\n     * A model's material with modifiable parameters.  A glTF material\n     * contains parameters defined by the material's technique with values\n     * defined by the technique and potentially overridden by the material.\n     * This class allows changing these values at runtime.\n     * <p>\n     * Use {@link Model#getMaterial} to create an instance.\n     * </p>\n     *\n     * @alias ModelMaterial\n     * @internalConstructor\n     * @class\n     *\n     * @see Model#getMaterial\n     */\n    function ModelMaterial(model, material, id) {\n        this._name = material.name;\n        this._id = id;\n        this._uniformMap = model._uniformMaps[id];\n\n        this._technique = undefined;\n        this._program = undefined;\n        this._values = undefined;\n    }\n\n    defineProperties(ModelMaterial.prototype, {\n        /**\n         * The value of the <code>name</code> property of this material.\n         *\n         * @memberof ModelMaterial.prototype\n         *\n         * @type {String}\n         * @readonly\n         */\n        name : {\n            get : function() {\n                return this._name;\n            }\n        },\n\n        /**\n         * The index of the material.\n         *\n         * @memberof ModelMaterial.prototype\n         *\n         * @type {String}\n         * @readonly\n         */\n        id : {\n            get : function() {\n                return this._id;\n            }\n        }\n    });\n\n    /**\n     * Assigns a value to a material parameter.  The type for <code>value</code>\n     * depends on the glTF type of the parameter.  It will be a floating-point\n     * number, Cartesian, or matrix.\n     *\n     * @param {String} name The name of the parameter.\n     * @param {*} [value] The value to assign to the parameter.\n     *\n     * @exception {DeveloperError} name must match a parameter name in the material's technique that is targetable and not optimized out.\n     *\n     * @example\n     * material.setValue('diffuse', new Cesium.Cartesian4(1.0, 0.0, 0.0, 1.0));  // vec4\n     * material.setValue('shininess', 256.0); // scalar\n     */\n    ModelMaterial.prototype.setValue = function(name, value) {\n        \n\n        var uniformName = 'u_' + name;\n        var v = this._uniformMap.values[uniformName];\n\n        \n\n        v.value = v.clone(value, v.value);\n    };\n\n    /**\n     * Returns the value of the parameter with the given <code>name</code>.  The type of the\n     * returned object depends on the glTF type of the parameter.  It will be a floating-point\n     * number, Cartesian, or matrix.\n     *\n     * @param {String} name The name of the parameter.\n     * @returns {*} The value of the parameter or <code>undefined</code> if the parameter does not exist.\n     */\n    ModelMaterial.prototype.getValue = function(name) {\n        \n\n        var uniformName = 'u_' + name;\n        var v = this._uniformMap.values[uniformName];\n\n        if (!defined(v)) {\n            return undefined;\n        }\n\n        return v.value;\n    };\nexport default ModelMaterial;\n","import defineProperties from '../Core/defineProperties.js';\n\n    /**\n     * A model's mesh and its materials.\n     * <p>\n     * Use {@link Model#getMesh} to create an instance.\n     * </p>\n     *\n     * @alias ModelMesh\n     * @internalConstructor\n     * @class\n     *\n     * @see Model#getMesh\n     */\n    function ModelMesh(mesh, runtimeMaterialsById, id) {\n        var materials = [];\n        var primitives = mesh.primitives;\n        var length = primitives.length;\n        for (var i = 0; i < length; ++i) {\n            var p = primitives[i];\n            materials[i] = runtimeMaterialsById[p.material];\n        }\n\n        this._name = mesh.name;\n        this._materials = materials;\n        this._id = id;\n    }\n\n    defineProperties(ModelMesh.prototype, {\n        /**\n         * The value of the <code>name</code> property of this mesh.\n         *\n         * @memberof ModelMesh.prototype\n         *\n         * @type {String}\n         * @readonly\n         */\n        name : {\n            get : function() {\n                return this._name;\n            }\n        },\n\n        /**\n         * The index of the mesh.\n         *\n         * @memberof ModelMesh.prototype\n         *\n         * @type {String}\n         * @readonly\n         */\n        id : {\n            get : function() {\n                return this._id;\n            }\n        },\n\n        /**\n         * An array of {@link ModelMaterial} instances indexed by the mesh's\n         * primitive indices.\n         *\n         * @memberof ModelMesh.prototype\n         *\n         * @type {ModelMaterial[]}\n         * @readonly\n         */\n        materials : {\n            get : function() {\n                return this._materials;\n            }\n        }\n    });\nexport default ModelMesh;\n","import defineProperties from '../Core/defineProperties.js';\nimport Matrix4 from '../Core/Matrix4.js';\n\n    /**\n     * A model node with a transform for user-defined animations.  A glTF asset can\n     * contain animations that target a node's transform.  This class allows\n     * changing a node's transform externally so animation can be driven by another\n     * source, not just an animation in the glTF asset.\n     * <p>\n     * Use {@link Model#getNode} to create an instance.\n     * </p>\n     *\n     * @alias ModelNode\n     * @internalConstructor\n     * @class\n     *\n     * @example\n     * var node = model.getNode('LOD3sp');\n     * node.matrix = Cesium.Matrix4.fromScale(new Cesium.Cartesian3(5.0, 1.0, 1.0), node.matrix);\n     *\n     * @see Model#getNode\n     */\n    function ModelNode(model, node, runtimeNode, id, matrix) {\n        this._model = model;\n        this._runtimeNode = runtimeNode;\n        this._name = node.name;\n        this._id = id;\n\n        /**\n         * @private\n         */\n        this.useMatrix = false;\n\n        this._show = true;\n        this._matrix = Matrix4.clone(matrix);\n        this._originalMatrix = Matrix4.clone(matrix);\n    }\n\n    defineProperties(ModelNode.prototype, {\n        /**\n         * The value of the <code>name</code> property of this node.\n         *\n         * @memberof ModelNode.prototype\n         *\n         * @type {String}\n         * @readonly\n         */\n        name : {\n            get : function() {\n                return this._name;\n            }\n        },\n\n        /**\n         * The index of the node.\n         *\n         * @memberof ModelNode.prototype\n         *\n         * @type {String}\n         * @readonly\n         */\n        id : {\n            get : function() {\n                return this._id;\n            }\n        },\n\n        /**\n         * Determines if this node and its children will be shown.\n         *\n         * @memberof ModelNode.prototype\n         * @type {Boolean}\n         *\n         * @default true\n         */\n        show : {\n            get : function() {\n                return this._show;\n            },\n            set : function(value) {\n                if (this._show !== value) {\n                    this._show = value;\n                    this._model._perNodeShowDirty = true;\n                }\n            }\n        },\n\n        /**\n         * The node's 4x4 matrix transform from its local coordinates to\n         * its parent's.\n         * <p>\n         * For changes to take effect, this property must be assigned to;\n         * setting individual elements of the matrix will not work.\n         * </p>\n         *\n         * @memberof ModelNode.prototype\n         * @type {Matrix4}\n         */\n        matrix : {\n            get : function() {\n                return this._matrix;\n            },\n            set : function(value) {\n                this._matrix = Matrix4.clone(value, this._matrix);\n                this.useMatrix = true;\n\n                var model = this._model;\n                model._cesiumAnimationsDirty = true;\n                this._runtimeNode.dirtyNumber = model._maxDirtyNumber;\n            }\n        },\n\n        /**\n         * Gets the node's original 4x4 matrix transform from its local coordinates to\n         * its parent's, without any node transformations or articulations applied.\n         *\n         * @memberof ModelNode.prototype\n         * @type {Matrix4}\n         */\n        originalMatrix : {\n            get : function() {\n                return this._originalMatrix;\n            }\n        }\n    });\n\n    /**\n     * @private\n     */\n    ModelNode.prototype.setMatrix = function(matrix) {\n        // Update matrix but do not set the dirty flag since this is used internally\n        // to keep the matrix in-sync during a glTF animation.\n        Matrix4.clone(matrix, this._matrix);\n    };\nexport default ModelNode;\n","import BoundingSphere from '../Core/BoundingSphere.js';\nimport Cartesian2 from '../Core/Cartesian2.js';\nimport Cartesian3 from '../Core/Cartesian3.js';\nimport Cartesian4 from '../Core/Cartesian4.js';\nimport clone from '../Core/clone.js';\nimport defined from '../Core/defined.js';\nimport defineProperties from '../Core/defineProperties.js';\nimport Matrix2 from '../Core/Matrix2.js';\nimport Matrix3 from '../Core/Matrix3.js';\nimport Matrix4 from '../Core/Matrix4.js';\nimport Quaternion from '../Core/Quaternion.js';\nimport RuntimeError from '../Core/RuntimeError.js';\nimport WebGLConstants from '../Core/WebGLConstants.js';\nimport ShaderSource from '../Renderer/ShaderSource.js';\nimport addToArray from '../ThirdParty/GltfPipeline/addToArray.js';\nimport ForEach from '../ThirdParty/GltfPipeline/ForEach.js';\nimport hasExtension from '../ThirdParty/GltfPipeline/hasExtension.js';\nimport AttributeType from './AttributeType.js';\nimport Axis from './Axis.js';\n\n    /**\n     * @private\n     */\n    var ModelUtility = {};\n\n    /**\n     * Updates the model's forward axis if the model is not a 2.0 model.\n     *\n     * @param {Object} model The model to update.\n     */\n    ModelUtility.updateForwardAxis = function(model) {\n        var cachedSourceVersion = model.gltf.extras.sourceVersion;\n\n        if ((defined(cachedSourceVersion) && cachedSourceVersion !== '2.0')\n                || ModelUtility.getAssetVersion(model.gltf) !== '2.0') {\n            model._gltfForwardAxis = Axis.X;\n        }\n    };\n\n    /**\n     *  Gets the string representing the glTF asset version.\n     *\n     *  @param {Object} gltf A javascript object containing a glTF asset.\n     *  @returns {String} The glTF asset version string.\n     */\n    ModelUtility.getAssetVersion = function(gltf) {\n        // In glTF 1.0 it was valid to omit the version number.\n        if (!defined(gltf.asset) || !defined(gltf.asset.version)) {\n            return '1.0';\n        }\n\n        return gltf.asset.version;\n    };\n\n    /**\n     * Splits primitive materials with values incompatible for generating techniques.\n     *\n     * @param {Object} gltf A javascript object containing a glTF asset.\n     * @returns {Object} The glTF asset with modified materials.\n     */\n    ModelUtility.splitIncompatibleMaterials = function(gltf) {\n        var accessors = gltf.accessors;\n        var materials = gltf.materials;\n        var primitiveInfoByMaterial = {};\n        ForEach.mesh(gltf, function(mesh) {\n            ForEach.meshPrimitive(mesh, function(primitive) {\n                var materialIndex = primitive.material;\n                var material = materials[materialIndex];\n\n                var jointAccessorId = primitive.attributes.JOINTS_0;\n                var componentType;\n                var type;\n                if (defined(jointAccessorId)) {\n                    var jointAccessor = accessors[jointAccessorId];\n                    componentType = jointAccessor.componentType;\n                    type = jointAccessor.type;\n                }\n                var isSkinned = defined(jointAccessorId);\n                var hasVertexColors = defined(primitive.attributes.COLOR_0);\n                var hasMorphTargets = defined(primitive.targets);\n                var hasNormals = defined(primitive.attributes.NORMAL);\n                var hasTangents = defined(primitive.attributes.TANGENT);\n                var hasTexCoords = defined(primitive.attributes.TEXCOORD_0);\n\n                var primitiveInfo = primitiveInfoByMaterial[materialIndex];\n                if (!defined(primitiveInfo)) {\n                    primitiveInfoByMaterial[materialIndex] = {\n                        skinning: {\n                            skinned: isSkinned,\n                            componentType: componentType,\n                            type: type\n                        },\n                        hasVertexColors: hasVertexColors,\n                        hasMorphTargets: hasMorphTargets,\n                        hasNormals: hasNormals,\n                        hasTangents: hasTangents,\n                        hasTexCoords: hasTexCoords\n                    };\n                } else if ((primitiveInfo.skinning.skinned !== isSkinned) ||\n                    (primitiveInfo.skinning.type !== type) ||\n                    (primitiveInfo.hasVertexColors !== hasVertexColors) ||\n                    (primitiveInfo.hasMorphTargets !== hasMorphTargets) ||\n                    (primitiveInfo.hasNormals !== hasNormals) ||\n                    (primitiveInfo.hasTangents !== hasTangents) ||\n                    (primitiveInfo.hasTexCoords !== hasTexCoords)) {\n                    // This primitive uses the same material as another one that either:\n                    // * Isn't skinned\n                    // * Uses a different type to store joints and weights\n                    // * Doesn't have vertex colors, morph targets, normals, tangents, or texCoords\n                    var clonedMaterial = clone(material, true);\n                    // Split this off as a separate material\n                    materialIndex = addToArray(materials, clonedMaterial);\n                    primitive.material = materialIndex;\n                    primitiveInfoByMaterial[materialIndex] = {\n                        skinning: {\n                            skinned: isSkinned,\n                            componentType: componentType,\n                            type: type\n                        },\n                        hasVertexColors: hasVertexColors,\n                        hasMorphTargets: hasMorphTargets,\n                        hasNormals: hasNormals,\n                        hasTangents: hasTangents,\n                        hasTexCoords: hasTexCoords\n                    };\n                }\n            });\n        });\n\n        return primitiveInfoByMaterial;\n    };\n\n    ModelUtility.getShaderVariable = function(type) {\n        if (type === 'SCALAR') {\n            return 'float';\n        }\n        return type.toLowerCase();\n    };\n\n    ModelUtility.ModelState = {\n        NEEDS_LOAD: 0,\n        LOADING: 1,\n        LOADED: 2, // Renderable, but textures can still be pending when incrementallyLoadTextures is true.\n        FAILED: 3\n    };\n\n    ModelUtility.getFailedLoadFunction = function(model, type, path) {\n        return function(error) {\n            model._state = ModelUtility.ModelState.FAILED;\n            var message = 'Failed to load ' + type + ': ' + path;\n            if (defined(error)) {\n                message += '\\n' + error.message;\n            }\n            model._readyPromise.reject(new RuntimeError(message));\n        };\n    };\n\n    ModelUtility.parseBuffers = function(model, bufferLoad) {\n        var loadResources = model._loadResources;\n        ForEach.buffer(model.gltf, function(buffer, bufferViewId) {\n            if (defined(buffer.extras._pipeline.source)) {\n                loadResources.buffers[bufferViewId] = buffer.extras._pipeline.source;\n            } else if (defined(bufferLoad)) {\n                var bufferResource = model._resource.getDerivedResource({\n                    url: buffer.uri\n                });\n                ++loadResources.pendingBufferLoads;\n                bufferResource.fetchArrayBuffer()\n                    .then(bufferLoad(model, bufferViewId))\n                    .otherwise(ModelUtility.getFailedLoadFunction(model, 'buffer', bufferResource.url));\n            }\n        });\n    };\n\n    var aMinScratch = new Cartesian3();\n    var aMaxScratch = new Cartesian3();\n\n    ModelUtility.computeBoundingSphere = function(model) {\n        var gltf = model.gltf;\n        var gltfNodes = gltf.nodes;\n        var gltfMeshes = gltf.meshes;\n        var rootNodes = gltf.scenes[gltf.scene].nodes;\n        var rootNodesLength = rootNodes.length;\n\n        var nodeStack = [];\n\n        var min = new Cartesian3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\n        var max = new Cartesian3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);\n\n        for (var i = 0; i < rootNodesLength; ++i) {\n            var n = gltfNodes[rootNodes[i]];\n            n._transformToRoot = ModelUtility.getTransform(n);\n            nodeStack.push(n);\n\n            while (nodeStack.length > 0) {\n                n = nodeStack.pop();\n                var transformToRoot = n._transformToRoot;\n\n                var meshId = n.mesh;\n                if (defined(meshId)) {\n                    var mesh = gltfMeshes[meshId];\n                    var primitives = mesh.primitives;\n                    var primitivesLength = primitives.length;\n                    for (var m = 0; m < primitivesLength; ++m) {\n                        var positionAccessor = primitives[m].attributes.POSITION;\n                        if (defined(positionAccessor)) {\n                            var minMax = ModelUtility.getAccessorMinMax(gltf, positionAccessor);\n                            var aMin = Cartesian3.fromArray(minMax.min, 0, aMinScratch);\n                            var aMax = Cartesian3.fromArray(minMax.max, 0, aMaxScratch);\n                            if (defined(min) && defined(max)) {\n                                Matrix4.multiplyByPoint(transformToRoot, aMin, aMin);\n                                Matrix4.multiplyByPoint(transformToRoot, aMax, aMax);\n                                Cartesian3.minimumByComponent(min, aMin, min);\n                                Cartesian3.maximumByComponent(max, aMax, max);\n                            }\n                        }\n                    }\n                }\n\n                var children = n.children;\n                if (defined(children)) {\n                    var childrenLength = children.length;\n                    for (var k = 0; k < childrenLength; ++k) {\n                        var child = gltfNodes[children[k]];\n                        child._transformToRoot = ModelUtility.getTransform(child);\n                        Matrix4.multiplyTransformation(transformToRoot, child._transformToRoot, child._transformToRoot);\n                        nodeStack.push(child);\n                    }\n                }\n                delete n._transformToRoot;\n            }\n        }\n\n        var boundingSphere = BoundingSphere.fromCornerPoints(min, max);\n        if (model._forwardAxis === Axis.Z) {\n            // glTF 2.0 has a Z-forward convention that must be adapted here to X-forward.\n            BoundingSphere.transformWithoutScale(boundingSphere, Axis.Z_UP_TO_X_UP, boundingSphere);\n        }\n        if (model._upAxis === Axis.Y) {\n            BoundingSphere.transformWithoutScale(boundingSphere, Axis.Y_UP_TO_Z_UP, boundingSphere);\n        } else if (model._upAxis === Axis.X) {\n            BoundingSphere.transformWithoutScale(boundingSphere, Axis.X_UP_TO_Z_UP, boundingSphere);\n        }\n        return boundingSphere;\n    };\n\n    function techniqueAttributeForSemantic(technique, semantic) {\n        return ForEach.techniqueAttribute(technique, function(attribute, attributeName) {\n            if (attribute.semantic === semantic) {\n                return attributeName;\n            }\n        });\n    }\n\n    function ensureSemanticExistenceForPrimitive(gltf, primitive) {\n        var accessors = gltf.accessors;\n        var materials = gltf.materials;\n        var techniquesWebgl = gltf.extensions.KHR_techniques_webgl;\n\n        var techniques = techniquesWebgl.techniques;\n        var programs = techniquesWebgl.programs;\n        var shaders = techniquesWebgl.shaders;\n        var targets = primitive.targets;\n\n        var attributes = primitive.attributes;\n        for (var target in targets) {\n            if (targets.hasOwnProperty(target)) {\n                var targetAttributes = targets[target];\n                for (var attribute in targetAttributes) {\n                    if (attribute !== 'extras') {\n                        attributes[attribute + '_' + target] = targetAttributes[attribute];\n                    }\n                }\n            }\n        }\n\n        var material = materials[primitive.material];\n        var technique = techniques[material.extensions.KHR_techniques_webgl.technique];\n        var program = programs[technique.program];\n        var vertexShader = shaders[program.vertexShader];\n\n        for (var semantic in attributes) {\n            if (attributes.hasOwnProperty(semantic)) {\n                if (!defined(techniqueAttributeForSemantic(technique, semantic))) {\n                    var accessorId = attributes[semantic];\n                    var accessor = accessors[accessorId];\n                    var lowerCase = semantic.toLowerCase();\n                    if (lowerCase.charAt(0) === '_') {\n                        lowerCase = lowerCase.slice(1);\n                    }\n                    var attributeName = 'a_' + lowerCase;\n                    technique.attributes[attributeName] = {\n                        semantic: semantic,\n                        type: accessor.componentType\n                    };\n                    var pipelineExtras = vertexShader.extras._pipeline;\n                    var shaderText = pipelineExtras.source;\n                    shaderText = 'attribute ' + ModelUtility.getShaderVariable(accessor.type) + ' ' + attributeName + ';\\n' + shaderText;\n                    pipelineExtras.source = shaderText;\n                }\n            }\n        }\n    }\n\n    /**\n     * Ensures all attributes present on the primitive are present in the technique and\n     * vertex shader.\n     *\n     * @param {Object} gltf A javascript object containing a glTF asset.\n     * @returns {Object} The glTF asset, including any additional attributes.\n     */\n    ModelUtility.ensureSemanticExistence = function (gltf) {\n        ForEach.mesh(gltf, function(mesh) {\n            ForEach.meshPrimitive(mesh, function(primitive) {\n                ensureSemanticExistenceForPrimitive(gltf, primitive);\n            });\n        });\n\n        return gltf;\n    };\n\n    /**\n     * Creates attribute location for all attributes required by a technique.\n     *\n     * @param {Object} technique A glTF KHR_techniques_webgl technique object.\n     * @param {Object} precreatedAttributes A dictionary object of pre-created attributes for which to also create locations.\n     * @returns {Object} A dictionary object containing attribute names and their locations.\n     */\n    ModelUtility.createAttributeLocations = function(technique, precreatedAttributes) {\n        var attributeLocations = {};\n        var hasIndex0 = false;\n        var i = 1;\n\n        ForEach.techniqueAttribute(technique, function (attribute, attributeName) {\n            // Set the position attribute to the 0th index. In some WebGL implementations the shader\n            // will not work correctly if the 0th attribute is not active. For example, some glTF models\n            // list the normal attribute first but derived shaders like the cast-shadows shader do not use\n            // the normal attribute.\n            if (/pos/i.test(attributeName) && !hasIndex0) {\n                attributeLocations[attributeName] = 0;\n                hasIndex0 = true;\n            } else {\n                attributeLocations[attributeName] = i++;\n            }\n        });\n\n        if (defined(precreatedAttributes)) {\n            for (var attributeName in precreatedAttributes) {\n                if (precreatedAttributes.hasOwnProperty(attributeName)) {\n                    attributeLocations[attributeName] = i++;\n                }\n            }\n        }\n\n        return attributeLocations;\n    };\n\n    ModelUtility.getAccessorMinMax = function(gltf, accessorId) {\n        var accessor = gltf.accessors[accessorId];\n        var extensions = accessor.extensions;\n        var accessorMin = accessor.min;\n        var accessorMax = accessor.max;\n        // If this accessor is quantized, we should use the decoded min and max\n        if (defined(extensions)) {\n            var quantizedAttributes = extensions.WEB3D_quantized_attributes;\n            if (defined(quantizedAttributes)) {\n                accessorMin = quantizedAttributes.decodedMin;\n                accessorMax = quantizedAttributes.decodedMax;\n            }\n        }\n        return {\n            min : accessorMin,\n            max : accessorMax\n        };\n    };\n\n    function getTechniqueAttributeOrUniformFunction(gltf, technique, semantic, ignoreNodes) {\n        if (hasExtension(gltf, 'KHR_techniques_webgl')) {\n            return function(attributeOrUniform, attributeOrUniformName) {\n                if (attributeOrUniform.semantic === semantic && (!ignoreNodes || !defined(attributeOrUniform.node))) {\n                    return attributeOrUniformName;\n                }\n            };\n        }\n\n        return function(parameterName, attributeOrUniformName) {\n            var attributeOrUniform = technique.parameters[parameterName];\n            if (attributeOrUniform.semantic === semantic && (!ignoreNodes || !defined(attributeOrUniform.node))) {\n                return attributeOrUniformName;\n            }\n        };\n    }\n\n    ModelUtility.getAttributeOrUniformBySemantic = function(gltf, semantic, programId, ignoreNodes) {\n        return ForEach.technique(gltf, function(technique) {\n            if (defined(programId) && (technique.program !== programId)) {\n                return;\n            }\n\n            var value = ForEach.techniqueAttribute(technique, getTechniqueAttributeOrUniformFunction(gltf, technique, semantic, ignoreNodes));\n\n            if (defined(value)) {\n                return value;\n            }\n\n            return ForEach.techniqueUniform(technique, getTechniqueAttributeOrUniformFunction(gltf, technique, semantic, ignoreNodes));\n        });\n    };\n\n    ModelUtility.getDiffuseAttributeOrUniform = function(gltf, programId) {\n        var diffuseUniformName = ModelUtility.getAttributeOrUniformBySemantic(gltf, 'COLOR_0', programId);\n        if (!defined(diffuseUniformName)) {\n            diffuseUniformName = ModelUtility.getAttributeOrUniformBySemantic(gltf, '_3DTILESDIFFUSE', programId);\n        }\n        return diffuseUniformName;\n    };\n\n    var nodeTranslationScratch = new Cartesian3();\n    var nodeQuaternionScratch = new Quaternion();\n    var nodeScaleScratch = new Cartesian3();\n\n    ModelUtility.getTransform = function(node, result) {\n        if (defined(node.matrix)) {\n            return Matrix4.fromColumnMajorArray(node.matrix, result);\n        }\n\n        return Matrix4.fromTranslationQuaternionRotationScale(\n            Cartesian3.fromArray(node.translation, 0, nodeTranslationScratch),\n            Quaternion.unpack(node.rotation, 0, nodeQuaternionScratch),\n            Cartesian3.fromArray(node.scale, 0, nodeScaleScratch),\n            result);\n    };\n\n    ModelUtility.getUsedExtensions = function(gltf) {\n        var extensionsUsed = gltf.extensionsUsed;\n        var cachedExtensionsUsed = {};\n\n        if (defined(extensionsUsed)) {\n            var extensionsUsedLength = extensionsUsed.length;\n            for (var i = 0; i < extensionsUsedLength; i++) {\n                var extension = extensionsUsed[i];\n                cachedExtensionsUsed[extension] = true;\n            }\n        }\n        return cachedExtensionsUsed;\n    };\n\n    ModelUtility.getRequiredExtensions = function(gltf) {\n        var extensionsRequired = gltf.extensionsRequired;\n        var cachedExtensionsRequired = {};\n\n        if (defined(extensionsRequired)) {\n            var extensionsRequiredLength = extensionsRequired.length;\n            for (var i = 0; i < extensionsRequiredLength; i++) {\n                var extension = extensionsRequired[i];\n                cachedExtensionsRequired[extension] = true;\n            }\n        }\n\n        return cachedExtensionsRequired;\n    };\n\n    ModelUtility.supportedExtensions = {\n        'AGI_articulations' : true,\n        'CESIUM_RTC' : true,\n        'EXT_texture_webp' : true,\n        'KHR_blend' : true,\n        'KHR_binary_glTF' : true,\n        'KHR_draco_mesh_compression' : true,\n        'KHR_materials_common' : true,\n        'KHR_techniques_webgl' : true,\n        'KHR_materials_unlit' : true,\n        'KHR_materials_pbrSpecularGlossiness' : true,\n        'KHR_texture_transform' : true,\n        'WEB3D_quantized_attributes' : true\n    };\n\n    ModelUtility.checkSupportedExtensions = function(extensionsRequired, browserSupportsWebp) {\n        for (var extension in extensionsRequired) {\n            if (extensionsRequired.hasOwnProperty(extension)) {\n                if (!ModelUtility.supportedExtensions[extension]) {\n                    throw new RuntimeError('Unsupported glTF Extension: ' + extension);\n                }\n\n                if (extension === 'EXT_texture_webp' && browserSupportsWebp === false) {\n                    throw new RuntimeError('Loaded model requires WebP but browser does not support it.');\n                }\n            }\n        }\n    };\n\n    ModelUtility.checkSupportedGlExtensions = function(extensionsUsed, context) {\n        if (defined(extensionsUsed)) {\n            var glExtensionsUsedLength = extensionsUsed.length;\n            for (var i = 0; i < glExtensionsUsedLength; i++) {\n                var extension = extensionsUsed[i];\n                if (extension !== 'OES_element_index_uint') {\n                    throw new RuntimeError('Unsupported WebGL Extension: ' + extension);\n                } else if (!context.elementIndexUint) {\n                    throw new RuntimeError('OES_element_index_uint WebGL extension is not enabled.');\n                }\n            }\n        }\n    };\n\n    function replaceAllButFirstInString(string, find, replace) {\n        // Limit search to strings that are not a subset of other tokens.\n        find += '(?!\\\\w)';\n        find = new RegExp(find, 'g');\n\n        var index = string.search(find);\n        return string.replace(find, function(match, offset) {\n            return index === offset ? match : replace;\n        });\n    }\n\n    function getQuantizedAttributes(gltf, accessorId) {\n        var accessor = gltf.accessors[accessorId];\n        var extensions = accessor.extensions;\n        if (defined(extensions)) {\n            return extensions.WEB3D_quantized_attributes;\n        }\n        return undefined;\n    }\n\n    function getAttributeVariableName(gltf, primitive, attributeSemantic) {\n        var materialId = primitive.material;\n        var material = gltf.materials[materialId];\n\n        if (!hasExtension(gltf, 'KHR_techniques_webgl')\n                || !defined(material.extensions)\n                || !defined(material.extensions.KHR_techniques_webgl)) {\n            return;\n        }\n\n        var techniqueId = material.extensions.KHR_techniques_webgl.technique;\n        var techniquesWebgl = gltf.extensions.KHR_techniques_webgl;\n        var technique = techniquesWebgl.techniques[techniqueId];\n        return ForEach.techniqueAttribute(technique, function(attribute, attributeName) {\n            var semantic = attribute.semantic;\n            if (semantic === attributeSemantic) {\n                return attributeName;\n            }\n        });\n    }\n\n    ModelUtility.modifyShaderForDracoQuantizedAttributes = function(gltf, primitive, shader, decodedAttributes) {\n        var quantizedUniforms = {};\n        for (var attributeSemantic in decodedAttributes) {\n            if (decodedAttributes.hasOwnProperty(attributeSemantic)) {\n                var attribute = decodedAttributes[attributeSemantic];\n                var quantization = attribute.quantization;\n                if (!defined(quantization)) {\n                    continue;\n                }\n\n                var attributeVarName = getAttributeVariableName(gltf, primitive, attributeSemantic);\n\n                if (attributeSemantic.charAt(0) === '_') {\n                    attributeSemantic = attributeSemantic.substring(1);\n                }\n                var decodeUniformVarName = 'gltf_u_dec_' + attributeSemantic.toLowerCase();\n\n                if (!defined(quantizedUniforms[decodeUniformVarName])) {\n                    var newMain = 'gltf_decoded_' + attributeSemantic;\n                    var decodedAttributeVarName = attributeVarName.replace('a_', 'gltf_a_dec_');\n                    var size = attribute.componentsPerAttribute;\n\n                    // replace usages of the original attribute with the decoded version, but not the declaration\n                    shader = replaceAllButFirstInString(shader, attributeVarName, decodedAttributeVarName);\n\n                    // declare decoded attribute\n                    var variableType;\n                    if (quantization.octEncoded) {\n                        variableType = 'vec3';\n                    } else if (size > 1) {\n                        variableType = 'vec' + size;\n                    } else {\n                        variableType = 'float';\n                    }\n                    shader = variableType + ' ' + decodedAttributeVarName + ';\\n' + shader;\n\n                    // The gltf 2.0 COLOR_0 vertex attribute can be VEC4 or VEC3\n                    var vec3Color = size === 3 && attributeSemantic === 'COLOR_0';\n                    if (vec3Color) {\n                        shader = replaceAllButFirstInString(shader, decodedAttributeVarName, 'vec4(' + decodedAttributeVarName + ', 1.0)');\n                    }\n\n                    // splice decode function into the shader\n                    var decode = '';\n                    if (quantization.octEncoded) {\n                        var decodeUniformVarNameRangeConstant = decodeUniformVarName + '_rangeConstant';\n                        shader = 'uniform float ' + decodeUniformVarNameRangeConstant + ';\\n' + shader;\n                        decode = '\\n' +\n                                'void main() {\\n' +\n                                // Draco oct-encoding decodes to zxy order\n                                '    ' + decodedAttributeVarName + ' = czm_octDecode(' + attributeVarName + '.xy, ' + decodeUniformVarNameRangeConstant + ').zxy;\\n' +\n                                '    ' + newMain + '();\\n' +\n                                '}\\n';\n                    } else {\n                        var decodeUniformVarNameNormConstant = decodeUniformVarName + '_normConstant';\n                        var decodeUniformVarNameMin = decodeUniformVarName + '_min';\n                        shader = 'uniform float ' + decodeUniformVarNameNormConstant + ';\\n' +\n                                'uniform ' + variableType + ' ' + decodeUniformVarNameMin + ';\\n' + shader;\n                        var attributeVarAccess = vec3Color ? '.xyz' : '';\n                        decode = '\\n' +\n                                'void main() {\\n' +\n                                '    ' + decodedAttributeVarName + ' = ' + decodeUniformVarNameMin + ' + ' + attributeVarName + attributeVarAccess + ' * ' + decodeUniformVarNameNormConstant + ';\\n' +\n                                '    ' + newMain + '();\\n' +\n                                '}\\n';\n                    }\n\n                    shader = ShaderSource.replaceMain(shader, newMain);\n                    shader += decode;\n                }\n            }\n        }\n        return {\n            shader : shader\n        };\n    };\n\n    ModelUtility.modifyShaderForQuantizedAttributes = function(gltf, primitive, shader) {\n        var quantizedUniforms = {};\n        var attributes = primitive.attributes;\n        for (var attributeSemantic in attributes) {\n            if (attributes.hasOwnProperty(attributeSemantic)) {\n                var attributeVarName = getAttributeVariableName(gltf, primitive, attributeSemantic);\n                var accessorId = primitive.attributes[attributeSemantic];\n\n                if (attributeSemantic.charAt(0) === '_') {\n                    attributeSemantic = attributeSemantic.substring(1);\n                }\n                var decodeUniformVarName = 'gltf_u_dec_' + attributeSemantic.toLowerCase();\n\n                var decodeUniformVarNameScale = decodeUniformVarName + '_scale';\n                var decodeUniformVarNameTranslate = decodeUniformVarName + '_translate';\n                if (!defined(quantizedUniforms[decodeUniformVarName]) && !defined(quantizedUniforms[decodeUniformVarNameScale])) {\n                    var quantizedAttributes = getQuantizedAttributes(gltf, accessorId);\n                    if (defined(quantizedAttributes)) {\n                        var decodeMatrix = quantizedAttributes.decodeMatrix;\n                        var newMain = 'gltf_decoded_' + attributeSemantic;\n                        var decodedAttributeVarName = attributeVarName.replace('a_', 'gltf_a_dec_');\n                        var size = Math.floor(Math.sqrt(decodeMatrix.length));\n\n                        // replace usages of the original attribute with the decoded version, but not the declaration\n                        shader = replaceAllButFirstInString(shader, attributeVarName, decodedAttributeVarName);\n                        // declare decoded attribute\n                        var variableType;\n                        if (size > 2) {\n                            variableType = 'vec' + (size - 1);\n                        } else {\n                            variableType = 'float';\n                        }\n                        shader = variableType + ' ' + decodedAttributeVarName + ';\\n' + shader;\n                        // splice decode function into the shader - attributes are pre-multiplied with the decode matrix\n                        // uniform in the shader (32-bit floating point)\n                        var decode = '';\n                        if (size === 5) {\n                            // separate scale and translate since glsl doesn't have mat5\n                            shader = 'uniform mat4 ' + decodeUniformVarNameScale + ';\\n' + shader;\n                            shader = 'uniform vec4 ' + decodeUniformVarNameTranslate + ';\\n' + shader;\n                            decode = '\\n' +\n                                     'void main() {\\n' +\n                                     '    ' + decodedAttributeVarName + ' = ' + decodeUniformVarNameScale + ' * ' + attributeVarName + ' + ' + decodeUniformVarNameTranslate + ';\\n' +\n                                     '    ' + newMain + '();\\n' +\n                                     '}\\n';\n\n                            quantizedUniforms[decodeUniformVarNameScale] = {mat : 4};\n                            quantizedUniforms[decodeUniformVarNameTranslate] = {vec : 4};\n                        }\n                        else {\n                            shader = 'uniform mat' + size + ' ' + decodeUniformVarName + ';\\n' + shader;\n                            decode = '\\n' +\n                                     'void main() {\\n' +\n                                     '    ' + decodedAttributeVarName + ' = ' + variableType + '(' + decodeUniformVarName + ' * vec' + size + '(' + attributeVarName + ',1.0));\\n' +\n                                     '    ' + newMain + '();\\n' +\n                                     '}\\n';\n\n                            quantizedUniforms[decodeUniformVarName] = {mat : size};\n                        }\n                        shader = ShaderSource.replaceMain(shader, newMain);\n                        shader += decode;\n                    }\n                }\n            }\n        }\n        return {\n            shader : shader,\n            uniforms : quantizedUniforms\n        };\n    };\n\n    ModelUtility.toClipCoordinatesGLSL = function(gltf, shader) {\n        var positionName = ModelUtility.getAttributeOrUniformBySemantic(gltf, 'POSITION');\n        var decodedPositionName = positionName.replace('a_', 'gltf_a_dec_');\n        if (shader.indexOf(decodedPositionName) !== -1) {\n            positionName = decodedPositionName;\n        }\n\n        var modelViewProjectionName = ModelUtility.getAttributeOrUniformBySemantic(gltf, 'MODELVIEWPROJECTION', undefined, true);\n        if (!defined(modelViewProjectionName) || shader.indexOf(modelViewProjectionName) === -1) {\n            var projectionName = ModelUtility.getAttributeOrUniformBySemantic(gltf, 'PROJECTION', undefined, true);\n            var modelViewName = ModelUtility.getAttributeOrUniformBySemantic(gltf, 'MODELVIEW', undefined, true);\n            if (shader.indexOf('czm_instanced_modelView ') !== -1) {\n                modelViewName = 'czm_instanced_modelView';\n            } else if (!defined(modelViewName)) {\n                modelViewName = ModelUtility.getAttributeOrUniformBySemantic(gltf, 'CESIUM_RTC_MODELVIEW', undefined, true);\n            }\n            modelViewProjectionName = projectionName + ' * ' + modelViewName;\n        }\n\n        return modelViewProjectionName + ' * vec4(' + positionName + '.xyz, 1.0)';\n    };\n\n    ModelUtility.modifyFragmentShaderForLogDepth = function(shader) {\n        shader = ShaderSource.replaceMain(shader, 'czm_depth_main');\n        shader +=\n            '\\n' +\n            'void main() \\n' +\n            '{ \\n' +\n            '    czm_depth_main(); \\n' +\n            '    czm_writeLogDepth(); \\n' +\n            '} \\n';\n\n        return shader;\n    };\n\n    ModelUtility.modifyVertexShaderForLogDepth = function(shader, toClipCoordinatesGLSL) {\n        shader = ShaderSource.replaceMain(shader, 'czm_depth_main');\n        shader +=\n            '\\n' +\n            'void main() \\n' +\n            '{ \\n' +\n            '    czm_depth_main(); \\n' +\n            '    czm_vertexLogDepth(' + toClipCoordinatesGLSL + '); \\n' +\n            '} \\n';\n\n        return shader;\n    };\n\n    function getScalarUniformFunction(value) {\n        var that = {\n            value : value,\n            clone : function(source, result) {\n                return source;\n            },\n            func : function() {\n                return that.value;\n            }\n        };\n        return that;\n    }\n\n    function getVec2UniformFunction(value) {\n        var that = {\n            value : Cartesian2.fromArray(value),\n            clone : Cartesian2.clone,\n            func : function() {\n                return that.value;\n            }\n        };\n        return that;\n    }\n\n    function getVec3UniformFunction(value) {\n        var that = {\n            value : Cartesian3.fromArray(value),\n            clone : Cartesian3.clone,\n            func : function() {\n                return that.value;\n            }\n        };\n        return that;\n    }\n\n    function getVec4UniformFunction(value) {\n        var that = {\n            value : Cartesian4.fromArray(value),\n            clone : Cartesian4.clone,\n            func : function() {\n                return that.value;\n            }\n        };\n        return that;\n    }\n\n    function getMat2UniformFunction(value) {\n        var that = {\n            value : Matrix2.fromColumnMajorArray(value),\n            clone : Matrix2.clone,\n            func : function() {\n                return that.value;\n            }\n        };\n        return that;\n    }\n\n    function getMat3UniformFunction(value) {\n        var that = {\n            value : Matrix3.fromColumnMajorArray(value),\n            clone : Matrix3.clone,\n            func : function() {\n                return that.value;\n            }\n        };\n        return that;\n    }\n\n    function getMat4UniformFunction(value) {\n        var that = {\n            value : Matrix4.fromColumnMajorArray(value),\n            clone : Matrix4.clone,\n            func : function() {\n                return that.value;\n            }\n        };\n        return that;\n    }\n\n    ///////////////////////////////////////////////////////////////////////////\n\n    function DelayLoadedTextureUniform(value, textures, defaultTexture) {\n        this._value = undefined;\n        this._textureId = value.index;\n        this._textures = textures;\n        this._defaultTexture = defaultTexture;\n    }\n\n    defineProperties(DelayLoadedTextureUniform.prototype, {\n        value : {\n            get : function() {\n                // Use the default texture (1x1 white) until the model's texture is loaded\n                if (!defined(this._value)) {\n                    var texture = this._textures[this._textureId];\n                    if (defined(texture)) {\n                        this._value = texture;\n                    } else {\n                        return this._defaultTexture;\n                    }\n                }\n\n                return this._value;\n            },\n            set : function(value) {\n                this._value = value;\n            }\n        }\n    });\n\n    DelayLoadedTextureUniform.prototype.clone = function(source) {\n        return source;\n    };\n\n    DelayLoadedTextureUniform.prototype.func = undefined;\n\n    ///////////////////////////////////////////////////////////////////////////\n\n    function getTextureUniformFunction(value, textures, defaultTexture) {\n        var uniform = new DelayLoadedTextureUniform(value, textures, defaultTexture);\n        // Define function here to access closure since 'this' can't be\n        // used when the Renderer sets uniforms.\n        uniform.func = function() {\n            return uniform.value;\n        };\n        return uniform;\n    }\n\n    var gltfUniformFunctions = {};\n    gltfUniformFunctions[WebGLConstants.FLOAT] = getScalarUniformFunction;\n    gltfUniformFunctions[WebGLConstants.FLOAT_VEC2] = getVec2UniformFunction;\n    gltfUniformFunctions[WebGLConstants.FLOAT_VEC3] = getVec3UniformFunction;\n    gltfUniformFunctions[WebGLConstants.FLOAT_VEC4] = getVec4UniformFunction;\n    gltfUniformFunctions[WebGLConstants.INT] = getScalarUniformFunction;\n    gltfUniformFunctions[WebGLConstants.INT_VEC2] = getVec2UniformFunction;\n    gltfUniformFunctions[WebGLConstants.INT_VEC3] = getVec3UniformFunction;\n    gltfUniformFunctions[WebGLConstants.INT_VEC4] = getVec4UniformFunction;\n    gltfUniformFunctions[WebGLConstants.BOOL] = getScalarUniformFunction;\n    gltfUniformFunctions[WebGLConstants.BOOL_VEC2] = getVec2UniformFunction;\n    gltfUniformFunctions[WebGLConstants.BOOL_VEC3] = getVec3UniformFunction;\n    gltfUniformFunctions[WebGLConstants.BOOL_VEC4] = getVec4UniformFunction;\n    gltfUniformFunctions[WebGLConstants.FLOAT_MAT2] = getMat2UniformFunction;\n    gltfUniformFunctions[WebGLConstants.FLOAT_MAT3] = getMat3UniformFunction;\n    gltfUniformFunctions[WebGLConstants.FLOAT_MAT4] = getMat4UniformFunction;\n    gltfUniformFunctions[WebGLConstants.SAMPLER_2D] = getTextureUniformFunction;\n    // GLTF_SPEC: Support SAMPLER_CUBE. https://github.com/KhronosGroup/glTF/issues/40\n\n    ModelUtility.createUniformFunction = function(type, value, textures, defaultTexture) {\n        return gltfUniformFunctions[type](value, textures, defaultTexture);\n    };\n\n    function scaleFromMatrix5Array(matrix) {\n        return [matrix[0], matrix[1], matrix[2], matrix[3],\n                matrix[5], matrix[6], matrix[7], matrix[8],\n                matrix[10], matrix[11], matrix[12], matrix[13],\n                matrix[15], matrix[16], matrix[17], matrix[18]];\n    }\n\n    function translateFromMatrix5Array(matrix) {\n        return [matrix[20], matrix[21], matrix[22], matrix[23]];\n    }\n\n    ModelUtility.createUniformsForDracoQuantizedAttributes = function(decodedAttributes) {\n        var uniformMap = {};\n        for (var attribute in decodedAttributes) {\n            if (decodedAttributes.hasOwnProperty(attribute)) {\n                var decodedData = decodedAttributes[attribute];\n                var quantization = decodedData.quantization;\n\n                if (!defined(quantization)) {\n                    continue;\n                }\n\n                if (attribute.charAt(0) === '_'){\n                    attribute = attribute.substring(1);\n                }\n\n                var uniformVarName = 'gltf_u_dec_' + attribute.toLowerCase();\n\n                if (quantization.octEncoded) {\n                    var uniformVarNameRangeConstant = uniformVarName + '_rangeConstant';\n                    var rangeConstant = (1 << quantization.quantizationBits) - 1.0;\n                    uniformMap[uniformVarNameRangeConstant] = getScalarUniformFunction(rangeConstant).func;\n                    continue;\n                }\n\n                var uniformVarNameNormConstant = uniformVarName + '_normConstant';\n                var normConstant = quantization.range / (1 << quantization.quantizationBits);\n                uniformMap[uniformVarNameNormConstant] = getScalarUniformFunction(normConstant).func;\n\n                var uniformVarNameMin = uniformVarName + '_min';\n                switch (decodedData.componentsPerAttribute) {\n                    case 1:\n                        uniformMap[uniformVarNameMin] = getScalarUniformFunction(quantization.minValues).func;\n                        break;\n                    case 2:\n                        uniformMap[uniformVarNameMin] = getVec2UniformFunction(quantization.minValues).func;\n                        break;\n                    case 3:\n                        uniformMap[uniformVarNameMin] = getVec3UniformFunction(quantization.minValues).func;\n                        break;\n                    case 4:\n                        uniformMap[uniformVarNameMin] = getVec4UniformFunction(quantization.minValues).func;\n                        break;\n                }\n            }\n        }\n\n        return uniformMap;\n    };\n\n    ModelUtility.createUniformsForQuantizedAttributes = function(gltf, primitive, quantizedUniforms) {\n        var accessors = gltf.accessors;\n        var setUniforms = {};\n        var uniformMap = {};\n\n        var attributes = primitive.attributes;\n        for (var attribute in attributes) {\n            if (attributes.hasOwnProperty(attribute)) {\n                var accessorId = attributes[attribute];\n                var a = accessors[accessorId];\n                var extensions = a.extensions;\n\n                if (attribute.charAt(0) === '_') {\n                    attribute = attribute.substring(1);\n                }\n\n                if (defined(extensions)) {\n                    var quantizedAttributes = extensions.WEB3D_quantized_attributes;\n                    if (defined(quantizedAttributes)) {\n                        var decodeMatrix = quantizedAttributes.decodeMatrix;\n                        var uniformVariable = 'gltf_u_dec_' + attribute.toLowerCase();\n\n                        switch (a.type) {\n                            case AttributeType.SCALAR:\n                                uniformMap[uniformVariable] = getMat2UniformFunction(decodeMatrix).func;\n                                setUniforms[uniformVariable] = true;\n                                break;\n                            case AttributeType.VEC2:\n                                uniformMap[uniformVariable] = getMat3UniformFunction(decodeMatrix).func;\n                                setUniforms[uniformVariable] = true;\n                                break;\n                            case AttributeType.VEC3:\n                                uniformMap[uniformVariable] = getMat4UniformFunction(decodeMatrix).func;\n                                setUniforms[uniformVariable] = true;\n                                break;\n                            case AttributeType.VEC4:\n                                // VEC4 attributes are split into scale and translate because there is no mat5 in GLSL\n                                var uniformVariableScale = uniformVariable + '_scale';\n                                var uniformVariableTranslate = uniformVariable + '_translate';\n                                uniformMap[uniformVariableScale] = getMat4UniformFunction(scaleFromMatrix5Array(decodeMatrix)).func;\n                                uniformMap[uniformVariableTranslate] = getVec4UniformFunction(translateFromMatrix5Array(decodeMatrix)).func;\n                                setUniforms[uniformVariableScale] = true;\n                                setUniforms[uniformVariableTranslate] = true;\n                                break;\n                        }\n                    }\n                }\n            }\n        }\n\n        // If there are any unset quantized uniforms in this program, they should be set to the identity\n        for (var quantizedUniform in quantizedUniforms) {\n            if (quantizedUniforms.hasOwnProperty(quantizedUniform)) {\n                if (!setUniforms[quantizedUniform]) {\n                    var properties = quantizedUniforms[quantizedUniform];\n                    if (defined(properties.mat)) {\n                        if (properties.mat === 2) {\n                            uniformMap[quantizedUniform] = getMat2UniformFunction(Matrix2.IDENTITY).func;\n                        } else if (properties.mat === 3) {\n                            uniformMap[quantizedUniform] = getMat3UniformFunction(Matrix3.IDENTITY).func;\n                        } else if (properties.mat === 4) {\n                            uniformMap[quantizedUniform] = getMat4UniformFunction(Matrix4.IDENTITY).func;\n                        }\n                    }\n                    if (defined(properties.vec)) {\n                        if (properties.vec === 4) {\n                            uniformMap[quantizedUniform] = getVec4UniformFunction([0, 0, 0, 0]).func;\n                        }\n                    }\n                }\n            }\n        }\n        return uniformMap;\n    };\n\n    // This doesn't support LOCAL, which we could add if it is ever used.\n    var scratchTranslationRtc = new Cartesian3();\n    var gltfSemanticUniforms = {\n        MODEL : function(uniformState, model) {\n            return function() {\n                return uniformState.model;\n            };\n        },\n        VIEW : function(uniformState, model) {\n            return function() {\n                return uniformState.view;\n            };\n        },\n        PROJECTION : function(uniformState, model) {\n            return function() {\n                return uniformState.projection;\n            };\n        },\n        MODELVIEW : function(uniformState, model) {\n            return function() {\n                return uniformState.modelView;\n            };\n        },\n        CESIUM_RTC_MODELVIEW : function(uniformState, model) {\n            // CESIUM_RTC extension\n            var mvRtc = new Matrix4();\n            return function() {\n                if (defined(model._rtcCenter)) {\n                    Matrix4.getTranslation(uniformState.model, scratchTranslationRtc);\n                    Cartesian3.add(scratchTranslationRtc, model._rtcCenter, scratchTranslationRtc);\n                    Matrix4.multiplyByPoint(uniformState.view, scratchTranslationRtc, scratchTranslationRtc);\n                    return Matrix4.setTranslation(uniformState.modelView, scratchTranslationRtc, mvRtc);\n                }\n                return uniformState.modelView;\n            };\n        },\n        MODELVIEWPROJECTION : function(uniformState, model) {\n            return function() {\n                return uniformState.modelViewProjection;\n            };\n        },\n        MODELINVERSE : function(uniformState, model) {\n            return function() {\n                return uniformState.inverseModel;\n            };\n        },\n        VIEWINVERSE : function(uniformState, model) {\n            return function() {\n                return uniformState.inverseView;\n            };\n        },\n        PROJECTIONINVERSE : function(uniformState, model) {\n            return function() {\n                return uniformState.inverseProjection;\n            };\n        },\n        MODELVIEWINVERSE : function(uniformState, model) {\n            return function() {\n                return uniformState.inverseModelView;\n            };\n        },\n        MODELVIEWPROJECTIONINVERSE : function(uniformState, model) {\n            return function() {\n                return uniformState.inverseModelViewProjection;\n            };\n        },\n        MODELINVERSETRANSPOSE : function(uniformState, model) {\n            return function() {\n                return uniformState.inverseTransposeModel;\n            };\n        },\n        MODELVIEWINVERSETRANSPOSE : function(uniformState, model) {\n            return function() {\n                return uniformState.normal;\n            };\n        },\n        VIEWPORT : function(uniformState, model) {\n            return function() {\n                return uniformState.viewportCartesian4;\n            };\n        }\n        // JOINTMATRIX created in createCommand()\n    };\n\n    ModelUtility.getGltfSemanticUniforms = function() {\n        return gltfSemanticUniforms;\n    };\nexport default ModelUtility;\n","import WebGLConstants from './WebGLConstants.js';\n\n    function webGLConstantToGlslType(webGLValue) {\n        switch (webGLValue) {\n            case WebGLConstants.FLOAT:\n                return 'float';\n            case WebGLConstants.FLOAT_VEC2:\n                return 'vec2';\n            case WebGLConstants.FLOAT_VEC3:\n                return 'vec3';\n            case WebGLConstants.FLOAT_VEC4:\n                return 'vec4';\n            case WebGLConstants.FLOAT_MAT2:\n                return 'mat2';\n            case WebGLConstants.FLOAT_MAT3:\n                return 'mat3';\n            case WebGLConstants.FLOAT_MAT4:\n                return 'mat4';\n            case WebGLConstants.SAMPLER_2D:\n                return 'sampler2D';\n            case WebGLConstants.BOOL:\n                return 'bool';\n        }\n    }\nexport default webGLConstantToGlslType;\n","import defaultValue from '../Core/defaultValue.js';\nimport defined from '../Core/defined.js';\nimport WebGLConstants from '../Core/WebGLConstants.js';\nimport webGLConstantToGlslType from '../Core/webGLConstantToGlslType.js';\nimport addToArray from '../ThirdParty/GltfPipeline/addToArray.js';\nimport ForEach from '../ThirdParty/GltfPipeline/ForEach.js';\nimport hasExtension from '../ThirdParty/GltfPipeline/hasExtension.js';\nimport numberOfComponentsForType from '../ThirdParty/GltfPipeline/numberOfComponentsForType.js';\nimport ModelUtility from './ModelUtility.js';\n\n    /**\n     * @private\n     */\n    function processModelMaterialsCommon(gltf, options) {\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n        if (!defined(gltf)) {\n            return;\n        }\n\n        if (!hasExtension(gltf, 'KHR_materials_common')) {\n            return;\n        }\n\n        if (!hasExtension(gltf, 'KHR_techniques_webgl')) {\n            if (!defined(gltf.extensions)) {\n                gltf.extensions = {};\n            }\n\n            gltf.extensions.KHR_techniques_webgl = {\n                programs : [],\n                shaders : [],\n                techniques : []\n            };\n            gltf.extensionsUsed.push('KHR_techniques_webgl');\n            gltf.extensionsRequired.push('KHR_techniques_webgl');\n        }\n\n        var techniquesWebgl = gltf.extensions.KHR_techniques_webgl;\n\n        lightDefaults(gltf);\n\n        var lightParameters = generateLightParameters(gltf);\n\n        var primitiveByMaterial = ModelUtility.splitIncompatibleMaterials(gltf);\n\n        var techniques = {};\n        var generatedTechniques = false;\n        ForEach.material(gltf, function(material, materialIndex) {\n            if (defined(material.extensions) && defined(material.extensions.KHR_materials_common)) {\n                var khrMaterialsCommon = material.extensions.KHR_materials_common;\n                var primitiveInfo = primitiveByMaterial[materialIndex];\n\n                var techniqueKey = getTechniqueKey(khrMaterialsCommon, primitiveInfo);\n                var technique = techniques[techniqueKey];\n\n                if (!defined(technique)) {\n                    technique = generateTechnique(gltf, techniquesWebgl, primitiveInfo, khrMaterialsCommon, lightParameters, options.addBatchIdToGeneratedShaders);\n                    techniques[techniqueKey] = technique;\n                    generatedTechniques = true;\n                }\n\n                var materialValues = {};\n                var values = khrMaterialsCommon.values;\n                var uniformName;\n                for (var valueName in values) {\n                    if (values.hasOwnProperty(valueName) && (valueName !== 'transparent') && (valueName !== 'doubleSided')) {\n                        uniformName = 'u_' + valueName.toLowerCase();\n                        materialValues[uniformName] = values[valueName];\n                    }\n                }\n\n                material.extensions.KHR_techniques_webgl = {\n                    technique: technique,\n                    values: materialValues\n                };\n\n                material.alphaMode = 'OPAQUE';\n                if (khrMaterialsCommon.transparent) {\n                    material.alphaMode = 'BLEND';\n                }\n\n                if (khrMaterialsCommon.doubleSided) {\n                    material.doubleSided = true;\n                }\n            }\n        });\n\n        if (!generatedTechniques) {\n            return gltf;\n        }\n\n        // If any primitives have semantics that aren't declared in the generated\n        // shaders, we want to preserve them.\n        ModelUtility.ensureSemanticExistence(gltf);\n\n        return gltf;\n    }\n\n    function generateLightParameters(gltf) {\n        var result = {};\n\n        var lights;\n        if (defined(gltf.extensions) && defined(gltf.extensions.KHR_materials_common)) {\n            lights = gltf.extensions.KHR_materials_common.lights;\n        }\n\n        if (defined(lights)) {\n            // Figure out which node references the light\n            var nodes = gltf.nodes;\n            for (var nodeName in nodes) {\n                if (nodes.hasOwnProperty(nodeName)) {\n                    var node = nodes[nodeName];\n                    if (defined(node.extensions) && defined(node.extensions.KHR_materials_common)) {\n                        var nodeLightId = node.extensions.KHR_materials_common.light;\n                        if (defined(nodeLightId) && defined(lights[nodeLightId])) {\n                            lights[nodeLightId].node = nodeName;\n                        }\n                        delete node.extensions.KHR_materials_common;\n                    }\n                }\n            }\n\n            // Add light parameters to result\n            var lightCount = 0;\n            for (var lightName in lights) {\n                if (lights.hasOwnProperty(lightName)) {\n                    var light = lights[lightName];\n                    var lightType = light.type;\n                    if ((lightType !== 'ambient') && !defined(light.node)) {\n                        delete lights[lightName];\n                        continue;\n                    }\n                    var lightBaseName = 'light' + lightCount.toString();\n                    light.baseName = lightBaseName;\n                    switch (lightType) {\n                        case 'ambient':\n                            var ambient = light.ambient;\n                            result[lightBaseName + 'Color'] = {\n                                type: WebGLConstants.FLOAT_VEC3,\n                                value: ambient.color\n                            };\n                            break;\n                        case 'directional':\n                            var directional = light.directional;\n                            result[lightBaseName + 'Color'] = {\n                                type: WebGLConstants.FLOAT_VEC3,\n                                value: directional.color\n                            };\n                            if (defined(light.node)) {\n                                result[lightBaseName + 'Transform'] = {\n                                    node: light.node,\n                                    semantic: 'MODELVIEW',\n                                    type: WebGLConstants.FLOAT_MAT4\n                                };\n                            }\n                            break;\n                        case 'point':\n                            var point = light.point;\n                            result[lightBaseName + 'Color'] = {\n                                type: WebGLConstants.FLOAT_VEC3,\n                                value: point.color\n                            };\n                            if (defined(light.node)) {\n                                result[lightBaseName + 'Transform'] = {\n                                    node: light.node,\n                                    semantic: 'MODELVIEW',\n                                    type: WebGLConstants.FLOAT_MAT4\n                                };\n                            }\n                            result[lightBaseName + 'Attenuation'] = {\n                                type: WebGLConstants.FLOAT_VEC3,\n                                value: [point.constantAttenuation, point.linearAttenuation, point.quadraticAttenuation]\n                            };\n                            break;\n                        case 'spot':\n                            var spot = light.spot;\n                            result[lightBaseName + 'Color'] = {\n                                type: WebGLConstants.FLOAT_VEC3,\n                                value: spot.color\n                            };\n                            if (defined(light.node)) {\n                                result[lightBaseName + 'Transform'] = {\n                                    node: light.node,\n                                    semantic: 'MODELVIEW',\n                                    type: WebGLConstants.FLOAT_MAT4\n                                };\n                                result[lightBaseName + 'InverseTransform'] = {\n                                    node: light.node,\n                                    semantic: 'MODELVIEWINVERSE',\n                                    type: WebGLConstants.FLOAT_MAT4,\n                                    useInFragment: true\n                                };\n                            }\n                            result[lightBaseName + 'Attenuation'] = {\n                                type: WebGLConstants.FLOAT_VEC3,\n                                value: [spot.constantAttenuation, spot.linearAttenuation, spot.quadraticAttenuation]\n                            };\n\n                            result[lightBaseName + 'FallOff'] = {\n                                type: WebGLConstants.FLOAT_VEC2,\n                                value: [spot.fallOffAngle, spot.fallOffExponent]\n                            };\n                            break;\n                    }\n                    ++lightCount;\n                }\n            }\n        }\n\n        return result;\n    }\n\n    function generateTechnique(gltf, techniquesWebgl, primitiveInfo, khrMaterialsCommon, lightParameters, addBatchIdToGeneratedShaders) {\n        if (!defined(khrMaterialsCommon)) {\n            khrMaterialsCommon = {};\n        }\n\n        addBatchIdToGeneratedShaders = defaultValue(addBatchIdToGeneratedShaders, false);\n\n        var techniques = techniquesWebgl.techniques;\n        var shaders = techniquesWebgl.shaders;\n        var programs = techniquesWebgl.programs;\n        var lightingModel = khrMaterialsCommon.technique.toUpperCase();\n        var lights;\n        if (defined(gltf.extensions) && defined(gltf.extensions.KHR_materials_common)) {\n            lights = gltf.extensions.KHR_materials_common.lights;\n        }\n\n        var parameterValues = khrMaterialsCommon.values;\n        var jointCount = defaultValue(khrMaterialsCommon.jointCount, 0);\n\n        var skinningInfo;\n        var hasSkinning = false;\n        var hasVertexColors = false;\n\n        if (defined(primitiveInfo)) {\n            skinningInfo = primitiveInfo.skinning;\n            hasSkinning = skinningInfo.skinned;\n            hasVertexColors = primitiveInfo.hasVertexColors;\n        }\n\n        var vertexShader = 'precision highp float;\\n';\n        var fragmentShader = 'precision highp float;\\n';\n\n        var hasNormals = (lightingModel !== 'CONSTANT');\n\n        // Add techniques\n        var techniqueUniforms = {\n            u_modelViewMatrix: {\n                semantic: hasExtension(gltf, 'CESIUM_RTC') ? 'CESIUM_RTC_MODELVIEW' : 'MODELVIEW',\n                type: WebGLConstants.FLOAT_MAT4\n            },\n            u_projectionMatrix: {\n                semantic: 'PROJECTION',\n                type: WebGLConstants.FLOAT_MAT4\n            }\n        };\n\n        if (hasNormals) {\n            techniqueUniforms.u_normalMatrix = {\n                semantic: 'MODELVIEWINVERSETRANSPOSE',\n                type: WebGLConstants.FLOAT_MAT3\n            };\n        }\n\n        if (hasSkinning) {\n            techniqueUniforms.u_jointMatrix = {\n                count: jointCount,\n                semantic: 'JOINTMATRIX',\n                type: WebGLConstants.FLOAT_MAT4\n            };\n        }\n\n        // Add material values\n        var uniformName;\n        var hasTexCoords = false;\n        for (var name in parameterValues) {\n            //generate shader parameters for KHR_materials_common attributes\n            //(including a check, because some boolean flags should not be used as shader parameters)\n            if (parameterValues.hasOwnProperty(name) && (name !== 'transparent') && (name !== 'doubleSided')) {\n                var uniformType = getKHRMaterialsCommonValueType(name, parameterValues[name]);\n                uniformName = 'u_' + name.toLowerCase();\n                if (!hasTexCoords && (uniformType === WebGLConstants.SAMPLER_2D)) {\n                    hasTexCoords = true;\n                }\n\n                techniqueUniforms[uniformName] = {\n                    type : uniformType\n                };\n            }\n        }\n\n        // Give the diffuse uniform a semantic to support color replacement in 3D Tiles\n        if (defined(techniqueUniforms.u_diffuse)) {\n            techniqueUniforms.u_diffuse.semantic = '_3DTILESDIFFUSE';\n        }\n\n        // Copy light parameters into technique parameters\n        if (defined(lightParameters)) {\n            for (var lightParamName in lightParameters) {\n                if (lightParameters.hasOwnProperty(lightParamName)) {\n                    uniformName = 'u_' + lightParamName;\n                    techniqueUniforms[uniformName] = lightParameters[lightParamName];\n                }\n            }\n        }\n\n        // Add uniforms to shaders\n        for (uniformName in techniqueUniforms) {\n            if (techniqueUniforms.hasOwnProperty(uniformName)) {\n                var uniform = techniqueUniforms[uniformName];\n                var arraySize = defined(uniform.count) ? '[' + uniform.count + ']' : '';\n                if (((uniform.type !== WebGLConstants.FLOAT_MAT3) && (uniform.type !== WebGLConstants.FLOAT_MAT4)) ||\n                    uniform.useInFragment) {\n                    fragmentShader += 'uniform ' + webGLConstantToGlslType(uniform.type) + ' ' + uniformName + arraySize + ';\\n';\n                    delete uniform.useInFragment;\n                } else {\n                    vertexShader += 'uniform ' + webGLConstantToGlslType(uniform.type) + ' ' + uniformName + arraySize + ';\\n';\n                }\n            }\n        }\n\n        // Add attributes with semantics\n        var vertexShaderMain = '';\n        if (hasSkinning) {\n            var i, j;\n            var numberOfComponents = numberOfComponentsForType(skinningInfo.type);\n            var matrix = false;\n            if (skinningInfo.type.indexOf('MAT') === 0) {\n                matrix = true;\n                numberOfComponents = Math.sqrt(numberOfComponents);\n            }\n            if (!matrix) {\n                for (i = 0; i < numberOfComponents; i++) {\n                    if (i === 0) {\n                        vertexShaderMain += '  mat4 skinMat = ';\n                    } else {\n                        vertexShaderMain += '  skinMat += ';\n                    }\n                    vertexShaderMain += 'a_weight[' + i + '] * u_jointMatrix[int(a_joint[' + i + '])];\\n';\n                }\n            } else {\n                for (i = 0; i < numberOfComponents; i++) {\n                    for (j = 0; j < numberOfComponents; j++) {\n                        if (i === 0 && j === 0) {\n                            vertexShaderMain += '  mat4 skinMat = ';\n                        } else {\n                            vertexShaderMain += '  skinMat += ';\n                        }\n                        vertexShaderMain += 'a_weight[' + i + '][' + j + '] * u_jointMatrix[int(a_joint[' + i + '][' + j + '])];\\n';\n                    }\n                }\n            }\n        }\n\n        // Add position always\n        var techniqueAttributes = {\n            a_position: {\n                semantic : 'POSITION'\n            }\n        };\n        vertexShader += 'attribute vec3 a_position;\\n';\n        vertexShader += 'varying vec3 v_positionEC;\\n';\n        if (hasSkinning) {\n            vertexShaderMain += '  vec4 pos = u_modelViewMatrix * skinMat * vec4(a_position,1.0);\\n';\n        } else {\n            vertexShaderMain += '  vec4 pos = u_modelViewMatrix * vec4(a_position,1.0);\\n';\n        }\n        vertexShaderMain += '  v_positionEC = pos.xyz;\\n';\n        vertexShaderMain += '  gl_Position = u_projectionMatrix * pos;\\n';\n        fragmentShader += 'varying vec3 v_positionEC;\\n';\n\n        // Add normal if we don't have constant lighting\n        if (hasNormals) {\n            techniqueAttributes.a_normal = {\n                semantic: 'NORMAL'\n            };\n            vertexShader += 'attribute vec3 a_normal;\\n';\n            vertexShader += 'varying vec3 v_normal;\\n';\n            if (hasSkinning) {\n                vertexShaderMain += '  v_normal = u_normalMatrix * mat3(skinMat) * a_normal;\\n';\n            } else {\n                vertexShaderMain += '  v_normal = u_normalMatrix * a_normal;\\n';\n            }\n\n            fragmentShader += 'varying vec3 v_normal;\\n';\n        }\n\n        // Add texture coordinates if the material uses them\n        var v_texcoord;\n        if (hasTexCoords) {\n            techniqueAttributes.a_texcoord_0 = {\n                semantic: 'TEXCOORD_0'\n            };\n\n            v_texcoord = 'v_texcoord_0';\n            vertexShader += 'attribute vec2 a_texcoord_0;\\n';\n            vertexShader += 'varying vec2 ' + v_texcoord + ';\\n';\n            vertexShaderMain += '  ' + v_texcoord + ' = a_texcoord_0;\\n';\n\n            fragmentShader += 'varying vec2 ' + v_texcoord + ';\\n';\n        }\n\n        if (hasSkinning) {\n            var attributeType = ModelUtility.getShaderVariable(skinningInfo.type);\n            techniqueAttributes.a_joint = {\n                semantic: 'JOINT'\n            };\n            techniqueAttributes.a_weight = {\n                semantic: 'WEIGHT'\n            };\n\n            vertexShader += 'attribute ' + attributeType + ' a_joint;\\n';\n            vertexShader += 'attribute ' + attributeType + ' a_weight;\\n';\n        }\n\n        if (hasVertexColors) {\n            techniqueAttributes.a_vertexColor = {\n                semantic: 'COLOR_0'\n            };\n            vertexShader += 'attribute vec4 a_vertexColor;\\n';\n            vertexShader += 'varying vec4 v_vertexColor;\\n';\n            vertexShaderMain += '  v_vertexColor = a_vertexColor;\\n';\n            fragmentShader += 'varying vec4 v_vertexColor;\\n';\n        }\n\n        if (addBatchIdToGeneratedShaders) {\n            techniqueAttributes.a_batchId = {\n                semantic: '_BATCHID'\n            };\n            vertexShader += 'attribute float a_batchId;\\n';\n        }\n\n        var hasSpecular = hasNormals && ((lightingModel === 'BLINN') || (lightingModel === 'PHONG')) &&\n            defined(techniqueUniforms.u_specular) && defined(techniqueUniforms.u_shininess) &&\n            (techniqueUniforms.u_shininess > 0.0);\n\n        // Generate lighting code blocks\n        var hasNonAmbientLights = false;\n        var hasAmbientLights = false;\n        var fragmentLightingBlock = '';\n        for (var lightName in lights) {\n            if (lights.hasOwnProperty(lightName)) {\n                var light = lights[lightName];\n                var lightType = light.type.toLowerCase();\n                var lightBaseName = light.baseName;\n                fragmentLightingBlock += '  {\\n';\n                var lightColorName = 'u_' + lightBaseName + 'Color';\n                var varyingDirectionName;\n                var varyingPositionName;\n                if (lightType === 'ambient') {\n                    hasAmbientLights = true;\n                    fragmentLightingBlock += '    ambientLight += ' + lightColorName + ';\\n';\n                } else if (hasNormals) {\n                    hasNonAmbientLights = true;\n                    varyingDirectionName = 'v_' + lightBaseName + 'Direction';\n                    varyingPositionName = 'v_' + lightBaseName + 'Position';\n\n                    if (lightType !== 'point') {\n                        vertexShader += 'varying vec3 ' + varyingDirectionName + ';\\n';\n                        fragmentShader += 'varying vec3 ' + varyingDirectionName + ';\\n';\n\n                        vertexShaderMain += '  ' + varyingDirectionName + ' = mat3(u_' + lightBaseName + 'Transform) * vec3(0.,0.,1.);\\n';\n                        if (lightType === 'directional') {\n                            fragmentLightingBlock += '    vec3 l = normalize(' + varyingDirectionName + ');\\n';\n                        }\n                    }\n\n                    if (lightType !== 'directional') {\n                        vertexShader += 'varying vec3 ' + varyingPositionName + ';\\n';\n                        fragmentShader += 'varying vec3 ' + varyingPositionName + ';\\n';\n\n                        vertexShaderMain += '  ' + varyingPositionName + ' = u_' + lightBaseName + 'Transform[3].xyz;\\n';\n                        fragmentLightingBlock += '    vec3 VP = ' + varyingPositionName + ' - v_positionEC;\\n';\n                        fragmentLightingBlock += '    vec3 l = normalize(VP);\\n';\n                        fragmentLightingBlock += '    float range = length(VP);\\n';\n                        fragmentLightingBlock += '    float attenuation = 1.0 / (u_' + lightBaseName + 'Attenuation.x + ';\n                        fragmentLightingBlock += '(u_' + lightBaseName + 'Attenuation.y * range) + ';\n                        fragmentLightingBlock += '(u_' + lightBaseName + 'Attenuation.z * range * range));\\n';\n                    } else {\n                        fragmentLightingBlock += '    float attenuation = 1.0;\\n';\n                    }\n\n                    if (lightType === 'spot') {\n                        fragmentLightingBlock += '    float spotDot = dot(l, normalize(' + varyingDirectionName + '));\\n';\n                        fragmentLightingBlock += '    if (spotDot < cos(u_' + lightBaseName + 'FallOff.x * 0.5))\\n';\n                        fragmentLightingBlock += '    {\\n';\n                        fragmentLightingBlock += '      attenuation = 0.0;\\n';\n                        fragmentLightingBlock += '    }\\n';\n                        fragmentLightingBlock += '    else\\n';\n                        fragmentLightingBlock += '    {\\n';\n                        fragmentLightingBlock += '        attenuation *= max(0.0, pow(spotDot, u_' + lightBaseName + 'FallOff.y));\\n';\n                        fragmentLightingBlock += '    }\\n';\n                    }\n\n                    fragmentLightingBlock += '    diffuseLight += ' + lightColorName + '* max(dot(normal,l), 0.) * attenuation;\\n';\n\n                    if (hasSpecular) {\n                        if (lightingModel === 'BLINN') {\n                            fragmentLightingBlock += '    vec3 h = normalize(l + viewDir);\\n';\n                            fragmentLightingBlock += '    float specularIntensity = max(0., pow(max(dot(normal, h), 0.), u_shininess)) * attenuation;\\n';\n                        } else { // PHONG\n                            fragmentLightingBlock += '    vec3 reflectDir = reflect(-l, normal);\\n';\n                            fragmentLightingBlock += '    float specularIntensity = max(0., pow(max(dot(reflectDir, viewDir), 0.), u_shininess)) * attenuation;\\n';\n                        }\n                        fragmentLightingBlock += '    specularLight += ' + lightColorName + ' * specularIntensity;\\n';\n                    }\n                }\n                fragmentLightingBlock += '  }\\n';\n            }\n        }\n\n        if (!hasAmbientLights) {\n            // Add an ambient light if we don't have one\n            fragmentLightingBlock += '  ambientLight += vec3(0.2, 0.2, 0.2);\\n';\n        }\n\n        if (!hasNonAmbientLights && (lightingModel !== 'CONSTANT')) {\n            fragmentShader += '#ifdef USE_CUSTOM_LIGHT_COLOR \\n';\n            fragmentShader += 'uniform vec3 gltf_lightColor; \\n';\n            fragmentShader += '#endif \\n';\n\n            fragmentLightingBlock += '#ifndef USE_CUSTOM_LIGHT_COLOR \\n';\n            fragmentLightingBlock += '    vec3 lightColor = czm_lightColor;\\n';\n            fragmentLightingBlock += '#else \\n';\n            fragmentLightingBlock += '    vec3 lightColor = gltf_lightColor;\\n';\n            fragmentLightingBlock += '#endif \\n';\n\n            fragmentLightingBlock += '  vec3 l = normalize(czm_lightDirectionEC);\\n';\n            var minimumLighting = '0.2'; // Use strings instead of values as 0.0 -> 0 when stringified\n            fragmentLightingBlock += '  diffuseLight += lightColor * max(dot(normal,l), ' + minimumLighting + ');\\n';\n\n            if (hasSpecular) {\n                if (lightingModel === 'BLINN') {\n                    fragmentLightingBlock += '  vec3 h = normalize(l + viewDir);\\n';\n                    fragmentLightingBlock += '  float specularIntensity = max(0., pow(max(dot(normal, h), 0.), u_shininess));\\n';\n                } else { // PHONG\n                    fragmentLightingBlock += '  vec3 reflectDir = reflect(-l, normal);\\n';\n                    fragmentLightingBlock += '  float specularIntensity = max(0., pow(max(dot(reflectDir, viewDir), 0.), u_shininess));\\n';\n                }\n\n                fragmentLightingBlock += '  specularLight += lightColor * specularIntensity;\\n';\n            }\n        }\n\n        vertexShader += 'void main(void) {\\n';\n        vertexShader += vertexShaderMain;\n        vertexShader += '}\\n';\n\n        fragmentShader += 'void main(void) {\\n';\n        var colorCreationBlock = '  vec3 color = vec3(0.0, 0.0, 0.0);\\n';\n        if (hasNormals) {\n            fragmentShader += '  vec3 normal = normalize(v_normal);\\n';\n            if (khrMaterialsCommon.doubleSided) {\n                // !gl_FrontFacing doesn't work as expected on Mac/Intel so use the more verbose form instead. See https://github.com/AnalyticalGraphicsInc/cesium/pull/8494.\n                fragmentShader += '  if (gl_FrontFacing == false)\\n';\n                fragmentShader += '  {\\n';\n                fragmentShader += '    normal = -normal;\\n';\n                fragmentShader += '  }\\n';\n            }\n        }\n\n        var finalColorComputation;\n        if (lightingModel !== 'CONSTANT') {\n            if (defined(techniqueUniforms.u_diffuse)) {\n                if (techniqueUniforms.u_diffuse.type === WebGLConstants.SAMPLER_2D) {\n                    fragmentShader += '  vec4 diffuse = texture2D(u_diffuse, ' + v_texcoord + ');\\n';\n                } else {\n                    fragmentShader += '  vec4 diffuse = u_diffuse;\\n';\n                }\n                fragmentShader += '  vec3 diffuseLight = vec3(0.0, 0.0, 0.0);\\n';\n                colorCreationBlock += '  color += diffuse.rgb * diffuseLight;\\n';\n            }\n\n            if (hasSpecular) {\n                if (techniqueUniforms.u_specular.type === WebGLConstants.SAMPLER_2D) {\n                    fragmentShader += '  vec3 specular = texture2D(u_specular, ' + v_texcoord + ').rgb;\\n';\n                } else {\n                    fragmentShader += '  vec3 specular = u_specular.rgb;\\n';\n                }\n                fragmentShader += '  vec3 specularLight = vec3(0.0, 0.0, 0.0);\\n';\n                colorCreationBlock += '  color += specular * specularLight;\\n';\n            }\n\n            if (defined(techniqueUniforms.u_transparency)) {\n                finalColorComputation = '  gl_FragColor = vec4(color * diffuse.a * u_transparency, diffuse.a * u_transparency);\\n';\n            } else {\n                finalColorComputation = '  gl_FragColor = vec4(color * diffuse.a, diffuse.a);\\n';\n            }\n        } else if (defined(techniqueUniforms.u_transparency)) {\n            finalColorComputation = '  gl_FragColor = vec4(color * u_transparency, u_transparency);\\n';\n        } else {\n            finalColorComputation = '  gl_FragColor = vec4(color, 1.0);\\n';\n        }\n\n        if (hasVertexColors) {\n            colorCreationBlock += '  color *= v_vertexColor.rgb;\\n';\n        }\n\n        if (defined(techniqueUniforms.u_emission)) {\n            if (techniqueUniforms.u_emission.type === WebGLConstants.SAMPLER_2D) {\n                fragmentShader += '  vec3 emission = texture2D(u_emission, ' + v_texcoord + ').rgb;\\n';\n            } else {\n                fragmentShader += '  vec3 emission = u_emission.rgb;\\n';\n            }\n            colorCreationBlock += '  color += emission;\\n';\n        }\n\n        if (defined(techniqueUniforms.u_ambient) || (lightingModel !== 'CONSTANT')) {\n            if (defined(techniqueUniforms.u_ambient)) {\n                if (techniqueUniforms.u_ambient.type === WebGLConstants.SAMPLER_2D) {\n                    fragmentShader += '  vec3 ambient = texture2D(u_ambient, ' + v_texcoord + ').rgb;\\n';\n                } else {\n                    fragmentShader += '  vec3 ambient = u_ambient.rgb;\\n';\n                }\n            } else {\n                fragmentShader += '  vec3 ambient = diffuse.rgb;\\n';\n            }\n            colorCreationBlock += '  color += ambient * ambientLight;\\n';\n        }\n        fragmentShader += '  vec3 viewDir = -normalize(v_positionEC);\\n';\n        fragmentShader += '  vec3 ambientLight = vec3(0.0, 0.0, 0.0);\\n';\n\n        // Add in light computations\n        fragmentShader += fragmentLightingBlock;\n\n        fragmentShader += colorCreationBlock;\n        fragmentShader += finalColorComputation;\n        fragmentShader += '}\\n';\n\n        // Add shaders\n        var vertexShaderId = addToArray(shaders, {\n            type: WebGLConstants.VERTEX_SHADER,\n            extras: {\n                _pipeline: {\n                    source: vertexShader,\n                    extension: '.glsl'\n                }\n            }\n        });\n\n        var fragmentShaderId = addToArray(shaders, {\n            type: WebGLConstants.FRAGMENT_SHADER,\n            extras: {\n                _pipeline: {\n                    source: fragmentShader,\n                    extension: '.glsl'\n                }\n            }\n        });\n\n        // Add program\n        var programId = addToArray(programs, {\n            fragmentShader: fragmentShaderId,\n            vertexShader: vertexShaderId\n        });\n\n        var techniqueId = addToArray(techniques, {\n            attributes: techniqueAttributes,\n            program: programId,\n            uniforms: techniqueUniforms\n        });\n\n        return techniqueId;\n    }\n\n    function getKHRMaterialsCommonValueType(paramName, paramValue) {\n        var value;\n\n        // Backwards compatibility for COLLADA2GLTF v1.0-draft when it encoding\n        // materials using KHR_materials_common with explicit type/value members\n        if (defined(paramValue.value)) {\n            value = paramValue.value;\n        } else if (defined(paramValue.index)) {\n            value = [paramValue.index];\n        } else {\n            value = paramValue;\n        }\n\n        switch (paramName) {\n            case 'ambient':\n                return value.length === 1 ? WebGLConstants.SAMPLER_2D : WebGLConstants.FLOAT_VEC4;\n            case 'diffuse':\n                return value.length === 1 ? WebGLConstants.SAMPLER_2D : WebGLConstants.FLOAT_VEC4;\n            case 'emission':\n                return value.length === 1 ? WebGLConstants.SAMPLER_2D : WebGLConstants.FLOAT_VEC4;\n            case 'specular':\n                return value.length === 1 ? WebGLConstants.SAMPLER_2D : WebGLConstants.FLOAT_VEC4;\n            case 'shininess':\n                return WebGLConstants.FLOAT;\n            case 'transparency':\n                return WebGLConstants.FLOAT;\n\n            // these two are usually not used directly within shaders,\n            // they are just added here for completeness\n            case 'transparent':\n                return WebGLConstants.BOOL;\n            case 'doubleSided':\n                return WebGLConstants.BOOL;\n        }\n    }\n\n    function getTechniqueKey(khrMaterialsCommon, primitiveInfo) {\n        var techniqueKey = '';\n        techniqueKey += 'technique:' + khrMaterialsCommon.technique + ';';\n\n        var values = khrMaterialsCommon.values;\n        var keys = Object.keys(values).sort();\n        var keysCount = keys.length;\n        for (var i = 0; i < keysCount; ++i) {\n            var name = keys[i];\n            if (values.hasOwnProperty(name)) {\n                techniqueKey += name + ':' + getKHRMaterialsCommonValueType(name, values[name]);\n                techniqueKey += ';';\n            }\n        }\n\n        var jointCount = defaultValue(khrMaterialsCommon.jointCount, 0);\n        techniqueKey += jointCount.toString() + ';';\n        if (defined(primitiveInfo)) {\n            var skinningInfo = primitiveInfo.skinning;\n            if (jointCount > 0) {\n                techniqueKey += skinningInfo.type + ';';\n            }\n            techniqueKey += primitiveInfo.hasVertexColors;\n        }\n\n        return techniqueKey;\n    }\n\n    function lightDefaults(gltf) {\n        var khrMaterialsCommon = gltf.extensions.KHR_materials_common;\n        if (!defined(khrMaterialsCommon) || !defined(khrMaterialsCommon.lights)) {\n            return;\n        }\n\n        var lights = khrMaterialsCommon.lights;\n\n        var lightsLength = lights.length;\n        for (var lightId = 0; lightId < lightsLength; lightId++) {\n            var light = lights[lightId];\n            if (light.type === 'ambient') {\n                if (!defined(light.ambient)) {\n                    light.ambient = {};\n                }\n                var ambientLight = light.ambient;\n\n                if (!defined(ambientLight.color)) {\n                    ambientLight.color = [1.0, 1.0, 1.0];\n                }\n            } else if (light.type === 'directional') {\n                if (!defined(light.directional)) {\n                    light.directional = {};\n                }\n                var directionalLight = light.directional;\n\n                if (!defined(directionalLight.color)) {\n                    directionalLight.color = [1.0, 1.0, 1.0];\n                }\n            } else if (light.type === 'point') {\n                if (!defined(light.point)) {\n                    light.point = {};\n                }\n                var pointLight = light.point;\n\n                if (!defined(pointLight.color)) {\n                    pointLight.color = [1.0, 1.0, 1.0];\n                }\n\n                pointLight.constantAttenuation = defaultValue(pointLight.constantAttenuation, 1.0);\n                pointLight.linearAttenuation = defaultValue(pointLight.linearAttenuation, 0.0);\n                pointLight.quadraticAttenuation = defaultValue(pointLight.quadraticAttenuation, 0.0);\n            } else if (light.type === 'spot') {\n                if (!defined(light.spot)) {\n                    light.spot = {};\n                }\n                var spotLight = light.spot;\n\n                if (!defined(spotLight.color)) {\n                    spotLight.color = [1.0, 1.0, 1.0];\n                }\n\n                spotLight.constantAttenuation = defaultValue(spotLight.constantAttenuation, 1.0);\n                spotLight.fallOffAngle = defaultValue(spotLight.fallOffAngle, 3.14159265);\n                spotLight.fallOffExponent = defaultValue(spotLight.fallOffExponent, 0.0);\n                spotLight.linearAttenuation = defaultValue(spotLight.linearAttenuation, 0.0);\n                spotLight.quadraticAttenuation = defaultValue(spotLight.quadraticAttenuation, 0.0);\n            }\n        }\n    }\nexport default processModelMaterialsCommon;\n","import defaultValue from '../Core/defaultValue.js';\nimport defined from '../Core/defined.js';\nimport WebGLConstants from '../Core/WebGLConstants.js';\nimport webGLConstantToGlslType from '../Core/webGLConstantToGlslType.js';\nimport addToArray from '../ThirdParty/GltfPipeline/addToArray.js';\nimport ForEach from '../ThirdParty/GltfPipeline/ForEach.js';\nimport hasExtension from '../ThirdParty/GltfPipeline/hasExtension.js';\nimport numberOfComponentsForType from '../ThirdParty/GltfPipeline/numberOfComponentsForType.js';\nimport ModelUtility from './ModelUtility.js';\n\n    /**\n     * @private\n     */\n    function processPbrMaterials(gltf, options) {\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n        // No need to create new techniques if they already exist,\n        // the shader should handle these values\n        if (hasExtension(gltf, 'KHR_techniques_webgl')) {\n            return gltf;\n        }\n\n        // All materials in glTF are PBR by default,\n        // so we should apply PBR unless no materials are found.\n        if (!defined(gltf.materials) || gltf.materials.length === 0) {\n            return gltf;\n        }\n\n        if (!defined(gltf.extensions)) {\n            gltf.extensions = {};\n        }\n\n        if (!defined(gltf.extensionsUsed)) {\n            gltf.extensionsUsed = [];\n        }\n\n        if (!defined(gltf.extensionsRequired)) {\n            gltf.extensionsRequired = [];\n        }\n\n        gltf.extensions.KHR_techniques_webgl = {\n            programs: [],\n            shaders: [],\n            techniques: []\n        };\n\n        gltf.extensionsUsed.push('KHR_techniques_webgl');\n        gltf.extensionsRequired.push('KHR_techniques_webgl');\n\n        var primitiveByMaterial = ModelUtility.splitIncompatibleMaterials(gltf);\n\n        ForEach.material(gltf, function(material, materialIndex) {\n            var generatedMaterialValues = {};\n            var technique = generateTechnique(gltf, material, materialIndex, generatedMaterialValues, primitiveByMaterial, options);\n\n            if (!defined(material.extensions)) {\n                material.extensions = {};\n            }\n\n            material.extensions.KHR_techniques_webgl = {\n                values : generatedMaterialValues,\n                technique : technique\n            };\n        });\n\n        // If any primitives have semantics that aren't declared in the generated\n        // shaders, we want to preserve them.\n        ModelUtility.ensureSemanticExistence(gltf);\n\n        return gltf;\n    }\n\n    function isSpecularGlossinessMaterial(material) {\n        return defined(material.extensions) &&\n               defined(material.extensions.KHR_materials_pbrSpecularGlossiness);\n    }\n\n    function addTextureCoordinates(gltf, textureName, generatedMaterialValues, defaultTexCoord, result) {\n        var texCoord;\n        if (defined(generatedMaterialValues[textureName + 'Offset'])) {\n            texCoord = textureName + 'Coord';\n            result.fragmentShaderMain += '    vec2 ' + texCoord + ' = computeTexCoord(' + defaultTexCoord + ', ' + textureName + 'Offset, ' + textureName + 'Rotation, ' + textureName + 'Scale);\\n';\n        } else {\n            texCoord = defaultTexCoord;\n        }\n        return texCoord;\n    }\n\n    var DEFAULT_TEXTURE_OFFSET = [0.0, 0.0];\n    var DEFAULT_TEXTURE_ROTATION = [0.0];\n    var DEFAULT_TEXTURE_SCALE = [1.0, 1.0];\n\n    function handleKHRTextureTransform(parameterName, value, generatedMaterialValues) {\n        if (parameterName.indexOf('Texture') === -1 || !defined(value.extensions) || !defined(value.extensions.KHR_texture_transform)) {\n            return;\n        }\n\n        var uniformName = 'u_' + parameterName;\n        var extension = value.extensions.KHR_texture_transform;\n        generatedMaterialValues[uniformName + 'Offset'] = defaultValue(extension.offset, DEFAULT_TEXTURE_OFFSET);\n        generatedMaterialValues[uniformName + 'Rotation'] = defaultValue(extension.rotation, DEFAULT_TEXTURE_ROTATION);\n        generatedMaterialValues[uniformName + 'Scale'] = defaultValue(extension.scale, DEFAULT_TEXTURE_SCALE);\n\n        if (defined(value.texCoord) && defined(extension.texCoord)) {\n            generatedMaterialValues[uniformName].texCoord = extension.texCoord;\n        }\n    }\n\n    function generateTechnique(gltf, material, materialIndex, generatedMaterialValues, primitiveByMaterial, options) {\n        var addBatchIdToGeneratedShaders = defaultValue(options.addBatchIdToGeneratedShaders, false);\n\n        var techniquesWebgl = gltf.extensions.KHR_techniques_webgl;\n        var techniques = techniquesWebgl.techniques;\n        var shaders = techniquesWebgl.shaders;\n        var programs = techniquesWebgl.programs;\n\n        var useSpecGloss = isSpecularGlossinessMaterial(material);\n\n        var uniformName;\n        var parameterName;\n        var value;\n        var pbrMetallicRoughness = material.pbrMetallicRoughness;\n        if (defined(pbrMetallicRoughness) && !useSpecGloss) {\n            for (parameterName in pbrMetallicRoughness) {\n                if (pbrMetallicRoughness.hasOwnProperty(parameterName)) {\n                    value = pbrMetallicRoughness[parameterName];\n                    uniformName = 'u_' + parameterName;\n                    generatedMaterialValues[uniformName] = value;\n                    handleKHRTextureTransform(parameterName, value, generatedMaterialValues);\n                }\n            }\n        }\n\n        if (useSpecGloss) {\n            var pbrSpecularGlossiness = material.extensions.KHR_materials_pbrSpecularGlossiness;\n            for (parameterName in pbrSpecularGlossiness) {\n                if (pbrSpecularGlossiness.hasOwnProperty(parameterName)) {\n                    value = pbrSpecularGlossiness[parameterName];\n                    uniformName = 'u_' + parameterName;\n                    generatedMaterialValues[uniformName] = value;\n                    handleKHRTextureTransform(parameterName, value, generatedMaterialValues);\n                }\n            }\n        }\n\n        for (var additional in material) {\n            if (material.hasOwnProperty(additional) && ((additional.indexOf('Texture') >= 0) || additional.indexOf('Factor') >= 0)) {\n                value = material[additional];\n                uniformName = 'u_' + additional;\n                generatedMaterialValues[uniformName] = value;\n                handleKHRTextureTransform(additional, value, generatedMaterialValues);\n            }\n        }\n\n        var vertexShader = 'precision highp float;\\n';\n        var fragmentShader = 'precision highp float;\\n';\n\n        var skin;\n        if (defined(gltf.skins)) {\n            skin = gltf.skins[0];\n        }\n        var joints = (defined(skin)) ? skin.joints : [];\n        var jointCount = joints.length;\n\n        var primitiveInfo = primitiveByMaterial[materialIndex];\n\n        var skinningInfo;\n        var hasSkinning = false;\n        var hasVertexColors = false;\n        var hasMorphTargets = false;\n        var hasNormals = false;\n        var hasTangents = false;\n        var hasTexCoords = false;\n        var isUnlit = false;\n\n        if (defined(primitiveInfo)) {\n            skinningInfo = primitiveInfo.skinning;\n            hasSkinning = skinningInfo.skinned && (joints.length > 0);\n            hasVertexColors = primitiveInfo.hasVertexColors;\n            hasMorphTargets = primitiveInfo.hasMorphTargets;\n            hasNormals = primitiveInfo.hasNormals;\n            hasTangents = primitiveInfo.hasTangents;\n            hasTexCoords = primitiveInfo.hasTexCoords;\n        }\n\n        var morphTargets;\n        if (hasMorphTargets) {\n            ForEach.mesh(gltf, function(mesh) {\n                ForEach.meshPrimitive(mesh, function(primitive) {\n                    if (primitive.material === materialIndex) {\n                        var targets = primitive.targets;\n                        if (defined(targets)) {\n                            morphTargets = targets;\n                        }\n                    }\n                });\n            });\n        }\n\n        // Add techniques\n        var techniqueUniforms = {\n            // Add matrices\n            u_modelViewMatrix : {\n                semantic : hasExtension(gltf, 'CESIUM_RTC') ? 'CESIUM_RTC_MODELVIEW' : 'MODELVIEW',\n                type : WebGLConstants.FLOAT_MAT4\n            },\n            u_projectionMatrix : {\n                semantic : 'PROJECTION',\n                type : WebGLConstants.FLOAT_MAT4\n            }\n        };\n\n        if (defined(material.extensions) && defined(material.extensions.KHR_materials_unlit)) {\n            isUnlit = true;\n            hasNormals = false;\n            hasTangents = false;\n        }\n\n        if (hasNormals) {\n            techniqueUniforms.u_normalMatrix = {\n                semantic : 'MODELVIEWINVERSETRANSPOSE',\n                type : WebGLConstants.FLOAT_MAT3\n            };\n        }\n\n        if (hasSkinning) {\n            techniqueUniforms.u_jointMatrix = {\n                count : jointCount,\n                semantic : 'JOINTMATRIX',\n                type : WebGLConstants.FLOAT_MAT4\n            };\n        }\n\n        if (hasMorphTargets) {\n            techniqueUniforms.u_morphWeights = {\n                count : morphTargets.length,\n                semantic : 'MORPHWEIGHTS',\n                type : WebGLConstants.FLOAT\n            };\n        }\n\n        var alphaMode = material.alphaMode;\n        if (defined(alphaMode) && alphaMode === 'MASK') {\n            techniqueUniforms.u_alphaCutoff = {\n                semantic: 'ALPHACUTOFF',\n                type: WebGLConstants.FLOAT\n            };\n        }\n\n        // Add material values\n        for (uniformName in generatedMaterialValues) {\n            if (generatedMaterialValues.hasOwnProperty(uniformName)) {\n                techniqueUniforms[uniformName] = {\n                    type : getPBRValueType(uniformName)\n                };\n            }\n        }\n\n        var baseColorUniform = defaultValue(techniqueUniforms.u_baseColorTexture, techniqueUniforms.u_baseColorFactor);\n        if (defined(baseColorUniform)) {\n            baseColorUniform.semantic = '_3DTILESDIFFUSE';\n        }\n\n        // Add uniforms to shaders\n        for (uniformName in techniqueUniforms) {\n            if (techniqueUniforms.hasOwnProperty(uniformName)) {\n                var uniform = techniqueUniforms[uniformName];\n                var arraySize = defined(uniform.count) ? '[' + uniform.count + ']' : '';\n                if (((uniform.type !== WebGLConstants.FLOAT_MAT3) && (uniform.type !== WebGLConstants.FLOAT_MAT4) && (uniformName !== 'u_morphWeights')) ||\n                    uniform.useInFragment) {\n                    fragmentShader += 'uniform ' + webGLConstantToGlslType(uniform.type) + ' ' + uniformName + arraySize + ';\\n';\n                    delete uniform.useInFragment;\n                } else {\n                    vertexShader += 'uniform ' + webGLConstantToGlslType(uniform.type) + ' ' + uniformName + arraySize + ';\\n';\n                }\n            }\n        }\n\n        // Add attributes with semantics\n        var vertexShaderMain = '';\n        if (hasSkinning) {\n            var i, j;\n            var numberOfComponents = numberOfComponentsForType(skinningInfo.type);\n            var matrix = false;\n            if (skinningInfo.type.indexOf('MAT') === 0) {\n                matrix = true;\n                numberOfComponents = Math.sqrt(numberOfComponents);\n            }\n            if (!matrix) {\n                for (i = 0; i < numberOfComponents; i++) {\n                    if (i === 0) {\n                        vertexShaderMain += '    mat4 skinMatrix = ';\n                    } else {\n                        vertexShaderMain += '    skinMatrix += ';\n                    }\n                    vertexShaderMain += 'a_weight[' + i + '] * u_jointMatrix[int(a_joint[' + i + '])];\\n';\n                }\n            } else {\n                for (i = 0; i < numberOfComponents; i++) {\n                    for (j = 0; j < numberOfComponents; j++) {\n                        if (i === 0 && j === 0) {\n                            vertexShaderMain += '    mat4 skinMatrix = ';\n                        } else {\n                            vertexShaderMain += '    skinMatrix += ';\n                        }\n                        vertexShaderMain += 'a_weight[' + i + '][' + j + '] * u_jointMatrix[int(a_joint[' + i + '][' + j + '])];\\n';\n                    }\n                }\n            }\n        }\n\n        // Add position always\n        var techniqueAttributes = {\n            a_position : {\n                semantic : 'POSITION'\n            }\n        };\n        vertexShader += 'attribute vec3 a_position;\\n';\n        if (hasNormals) {\n            vertexShader += 'varying vec3 v_positionEC;\\n';\n        }\n\n        // Morph Target Weighting\n        vertexShaderMain += '    vec3 weightedPosition = a_position;\\n';\n        if (hasNormals) {\n            vertexShaderMain += '    vec3 weightedNormal = a_normal;\\n';\n        }\n        if (hasTangents) {\n            vertexShaderMain += '    vec4 weightedTangent = a_tangent;\\n';\n        }\n        if (hasMorphTargets) {\n            for (var k = 0; k < morphTargets.length; k++) {\n                var targetAttributes = morphTargets[k];\n                for (var targetAttribute in targetAttributes) {\n                    if (targetAttributes.hasOwnProperty(targetAttribute) && targetAttribute !== 'extras') {\n                        var attributeName = 'a_' + targetAttribute + '_' + k;\n                        techniqueAttributes[attributeName] = {\n                            semantic : targetAttribute + '_' + k\n                        };\n                        vertexShader += 'attribute vec3 ' + attributeName + ';\\n';\n                        if (targetAttribute === 'POSITION') {\n                            vertexShaderMain += '    weightedPosition += u_morphWeights[' + k + '] * ' + attributeName + ';\\n';\n                        } else if (targetAttribute === 'NORMAL') {\n                            vertexShaderMain += '    weightedNormal += u_morphWeights[' + k + '] * ' + attributeName + ';\\n';\n                        } else if (hasTangents && targetAttribute === 'TANGENT') {\n                            vertexShaderMain += '    weightedTangent.xyz += u_morphWeights[' + k + '] * ' + attributeName + ';\\n';\n                        }\n                    }\n                }\n            }\n        }\n\n        // Final position computation\n        if (hasSkinning) {\n            vertexShaderMain += '    vec4 position = skinMatrix * vec4(weightedPosition, 1.0);\\n';\n        } else {\n            vertexShaderMain += '    vec4 position = vec4(weightedPosition, 1.0);\\n';\n        }\n        vertexShaderMain += '    position = u_modelViewMatrix * position;\\n';\n        if (hasNormals) {\n            vertexShaderMain += '    v_positionEC = position.xyz;\\n';\n        }\n        vertexShaderMain += '    gl_Position = u_projectionMatrix * position;\\n';\n\n        // Final normal computation\n        if (hasNormals) {\n            techniqueAttributes.a_normal = {\n                semantic : 'NORMAL'\n            };\n            vertexShader += 'attribute vec3 a_normal;\\n';\n            vertexShader += 'varying vec3 v_normal;\\n';\n            if (hasSkinning) {\n                vertexShaderMain += '    v_normal = u_normalMatrix * mat3(skinMatrix) * weightedNormal;\\n';\n            } else {\n                vertexShaderMain += '    v_normal = u_normalMatrix * weightedNormal;\\n';\n            }\n\n            fragmentShader += 'varying vec3 v_normal;\\n';\n            fragmentShader += 'varying vec3 v_positionEC;\\n';\n        }\n\n        // Read tangents if available\n        if (hasTangents) {\n            techniqueAttributes.a_tangent = {\n                semantic : 'TANGENT'\n            };\n            vertexShader += 'attribute vec4 a_tangent;\\n';\n            vertexShader += 'varying vec4 v_tangent;\\n';\n            vertexShaderMain += '    v_tangent.xyz = u_normalMatrix * weightedTangent.xyz;\\n';\n            vertexShaderMain += '    v_tangent.w = weightedTangent.w;\\n';\n\n            fragmentShader += 'varying vec4 v_tangent;\\n';\n        }\n\n        var fragmentShaderMain = '';\n\n        // Add texture coordinates if the material uses them\n        var v_texCoord;\n        var normalTexCoord;\n        var baseColorTexCoord;\n        var specularGlossinessTexCoord;\n        var diffuseTexCoord;\n        var metallicRoughnessTexCoord;\n        var occlusionTexCoord;\n        var emissiveTexCoord;\n\n        if (hasTexCoords) {\n            techniqueAttributes.a_texcoord_0 = {\n                semantic : 'TEXCOORD_0'\n            };\n\n            v_texCoord = 'v_texcoord_0';\n            vertexShader += 'attribute vec2 a_texcoord_0;\\n';\n            vertexShader += 'varying vec2 ' + v_texCoord + ';\\n';\n            vertexShaderMain += '    ' + v_texCoord + ' = a_texcoord_0;\\n';\n\n            fragmentShader += 'varying vec2 ' + v_texCoord + ';\\n';\n\n            var result = {\n                fragmentShaderMain : fragmentShaderMain\n            };\n            normalTexCoord = addTextureCoordinates(gltf, 'u_normalTexture', generatedMaterialValues, v_texCoord, result);\n            baseColorTexCoord = addTextureCoordinates(gltf, 'u_baseColorTexture', generatedMaterialValues, v_texCoord, result);\n            specularGlossinessTexCoord = addTextureCoordinates(gltf, 'u_specularGlossinessTexture', generatedMaterialValues, v_texCoord, result);\n            diffuseTexCoord = addTextureCoordinates(gltf, 'u_diffuseTexture', generatedMaterialValues, v_texCoord, result);\n            metallicRoughnessTexCoord = addTextureCoordinates(gltf, 'u_metallicRoughnessTexture', generatedMaterialValues, v_texCoord, result);\n            occlusionTexCoord = addTextureCoordinates(gltf, 'u_occlusionTexture', generatedMaterialValues, v_texCoord, result);\n            emissiveTexCoord = addTextureCoordinates(gltf, 'u_emmissiveTexture', generatedMaterialValues, v_texCoord, result);\n\n            fragmentShaderMain = result.fragmentShaderMain;\n        }\n\n        // Add skinning information if available\n        if (hasSkinning) {\n            var attributeType = ModelUtility.getShaderVariable(skinningInfo.type);\n            techniqueAttributes.a_joint = {\n                semantic : 'JOINTS_0'\n            };\n            techniqueAttributes.a_weight ={\n                semantic : 'WEIGHTS_0'\n            };\n\n            vertexShader += 'attribute ' + attributeType + ' a_joint;\\n';\n            vertexShader += 'attribute ' + attributeType + ' a_weight;\\n';\n        }\n\n        if (hasVertexColors) {\n            techniqueAttributes.a_vertexColor = {\n                semantic: 'COLOR_0'\n            };\n            vertexShader += 'attribute vec4 a_vertexColor;\\n';\n            vertexShader += 'varying vec4 v_vertexColor;\\n';\n            vertexShaderMain += '  v_vertexColor = a_vertexColor;\\n';\n            fragmentShader += 'varying vec4 v_vertexColor;\\n';\n        }\n\n        if (addBatchIdToGeneratedShaders) {\n            techniqueAttributes.a_batchId = {\n                semantic: '_BATCHID'\n            };\n            vertexShader += 'attribute float a_batchId;\\n';\n        }\n\n        vertexShader += 'void main(void) \\n{\\n';\n        vertexShader += vertexShaderMain;\n        vertexShader += '}\\n';\n\n        // Fragment shader lighting\n        if (hasNormals) {\n            fragmentShader += 'const float M_PI = 3.141592653589793;\\n';\n\n            fragmentShader +=\n                'vec3 lambertianDiffuse(vec3 diffuseColor) \\n' +\n                '{\\n' +\n                '    return diffuseColor / M_PI;\\n' +\n                '}\\n\\n';\n\n            fragmentShader +=\n                'vec3 fresnelSchlick2(vec3 f0, vec3 f90, float VdotH) \\n' +\n                '{\\n' +\n                '    return f0 + (f90 - f0) * pow(clamp(1.0 - VdotH, 0.0, 1.0), 5.0);\\n' +\n                '}\\n\\n';\n\n            fragmentShader +=\n                'vec3 fresnelSchlick(float metalness, float VdotH) \\n' +\n                '{\\n' +\n                '    return metalness + (vec3(1.0) - metalness) * pow(1.0 - VdotH, 5.0);\\n' +\n                '}\\n\\n';\n\n            fragmentShader +=\n                'float smithVisibilityG1(float NdotV, float roughness) \\n' +\n                '{\\n' +\n                '    float k = (roughness + 1.0) * (roughness + 1.0) / 8.0;\\n' +\n                '    return NdotV / (NdotV * (1.0 - k) + k);\\n' +\n                '}\\n\\n';\n\n            fragmentShader +=\n                'float smithVisibilityGGX(float roughness, float NdotL, float NdotV) \\n' +\n                '{\\n' +\n                '    return smithVisibilityG1(NdotL, roughness) * smithVisibilityG1(NdotV, roughness);\\n' +\n                '}\\n\\n';\n\n            fragmentShader +=\n                'float GGX(float roughness, float NdotH) \\n' +\n                '{\\n' +\n                '    float roughnessSquared = roughness * roughness;\\n' +\n                '    float f = (NdotH * roughnessSquared - NdotH) * NdotH + 1.0;\\n' +\n                '    return roughnessSquared / (M_PI * f * f);\\n' +\n                '}\\n\\n';\n        }\n\n        fragmentShader +=\n            'vec3 SRGBtoLINEAR3(vec3 srgbIn) \\n' +\n            '{\\n' +\n            '    return pow(srgbIn, vec3(2.2));\\n' +\n            '}\\n\\n';\n\n        fragmentShader +=\n            'vec4 SRGBtoLINEAR4(vec4 srgbIn) \\n' +\n            '{\\n' +\n            '    vec3 linearOut = pow(srgbIn.rgb, vec3(2.2));\\n' +\n            '    return vec4(linearOut, srgbIn.a);\\n' +\n            '}\\n\\n';\n\n        fragmentShader +=\n            'vec3 applyTonemapping(vec3 linearIn) \\n' +\n            '{\\n' +\n            '#ifndef HDR \\n' +\n            '    return czm_acesTonemapping(linearIn);\\n' +\n            '#else \\n' +\n            '    return linearIn;\\n' +\n            '#endif \\n' +\n            '}\\n\\n';\n\n        fragmentShader +=\n            'vec3 LINEARtoSRGB(vec3 linearIn) \\n' +\n            '{\\n' +\n            '#ifndef HDR \\n' +\n            '    return pow(linearIn, vec3(1.0/2.2));\\n' +\n            '#else \\n' +\n            '    return linearIn;\\n' +\n            '#endif \\n' +\n            '}\\n\\n';\n\n        fragmentShader +=\n            'vec2 computeTexCoord(vec2 texCoords, vec2 offset, float rotation, vec2 scale) \\n' +\n            '{\\n' +\n            '    rotation = -rotation; \\n' +\n            '    mat3 transform = mat3(\\n' +\n            '        cos(rotation) * scale.x, sin(rotation) * scale.x, 0.0, \\n' +\n            '       -sin(rotation) * scale.y, cos(rotation) * scale.y, 0.0, \\n' +\n            '        offset.x, offset.y, 1.0); \\n' +\n            '    vec2 transformedTexCoords = (transform * vec3(fract(texCoords), 1.0)).xy; \\n' +\n            '    return transformedTexCoords; \\n' +\n            '}\\n\\n';\n\n        fragmentShader += '#ifdef USE_IBL_LIGHTING \\n';\n        fragmentShader += 'uniform vec2 gltf_iblFactor; \\n';\n        fragmentShader += '#endif \\n';\n        fragmentShader += '#ifdef USE_CUSTOM_LIGHT_COLOR \\n';\n        fragmentShader += 'uniform vec3 gltf_lightColor; \\n';\n        fragmentShader += '#endif \\n';\n\n        fragmentShader += 'void main(void) \\n{\\n';\n        fragmentShader += fragmentShaderMain;\n\n        // Add normal mapping to fragment shader\n        if (hasNormals) {\n            fragmentShader += '    vec3 ng = normalize(v_normal);\\n';\n            fragmentShader += '    vec3 positionWC = vec3(czm_inverseView * vec4(v_positionEC, 1.0));\\n';\n            if (defined(generatedMaterialValues.u_normalTexture)) {\n                if (hasTangents) {\n                    // Read tangents from varying\n                    fragmentShader += '    vec3 t = normalize(v_tangent.xyz);\\n';\n                    fragmentShader += '    vec3 b = normalize(cross(ng, t) * v_tangent.w);\\n';\n                    fragmentShader += '    mat3 tbn = mat3(t, b, ng);\\n';\n                    fragmentShader += '    vec3 n = texture2D(u_normalTexture, ' + normalTexCoord + ').rgb;\\n';\n                    fragmentShader += '    n = normalize(tbn * (2.0 * n - 1.0));\\n';\n                } else {\n                    // Add standard derivatives extension\n                    fragmentShader = '#ifdef GL_OES_standard_derivatives\\n' +\n                        '#extension GL_OES_standard_derivatives : enable\\n' +\n                        '#endif\\n' +\n                        fragmentShader;\n                    // Compute tangents\n                    fragmentShader += '#ifdef GL_OES_standard_derivatives\\n';\n                    fragmentShader += '    vec3 pos_dx = dFdx(v_positionEC);\\n';\n                    fragmentShader += '    vec3 pos_dy = dFdy(v_positionEC);\\n';\n                    fragmentShader += '    vec3 tex_dx = dFdx(vec3(' + normalTexCoord + ',0.0));\\n';\n                    fragmentShader += '    vec3 tex_dy = dFdy(vec3(' + normalTexCoord + ',0.0));\\n';\n                    fragmentShader += '    vec3 t = (tex_dy.t * pos_dx - tex_dx.t * pos_dy) / (tex_dx.s * tex_dy.t - tex_dy.s * tex_dx.t);\\n';\n                    fragmentShader += '    t = normalize(t - ng * dot(ng, t));\\n';\n                    fragmentShader += '    vec3 b = normalize(cross(ng, t));\\n';\n                    fragmentShader += '    mat3 tbn = mat3(t, b, ng);\\n';\n                    fragmentShader += '    vec3 n = texture2D(u_normalTexture, ' + normalTexCoord + ').rgb;\\n';\n                    fragmentShader += '    n = normalize(tbn * (2.0 * n - 1.0));\\n';\n                    fragmentShader += '#else\\n';\n                    fragmentShader += '    vec3 n = ng;\\n';\n                    fragmentShader += '#endif\\n';\n                }\n            } else {\n                fragmentShader += '    vec3 n = ng;\\n';\n            }\n            if (material.doubleSided) {\n                // !gl_FrontFacing doesn't work as expected on Mac/Intel so use the more verbose form instead. See https://github.com/AnalyticalGraphicsInc/cesium/pull/8494.\n                fragmentShader += '    if (gl_FrontFacing == false)\\n';\n                fragmentShader += '    {\\n';\n                fragmentShader += '        n = -n;\\n';\n                fragmentShader += '    }\\n';\n            }\n        }\n\n        // Add base color to fragment shader\n        if (defined(generatedMaterialValues.u_baseColorTexture)) {\n            fragmentShader += '    vec4 baseColorWithAlpha = SRGBtoLINEAR4(texture2D(u_baseColorTexture, ' + baseColorTexCoord + '));\\n';\n            if (defined(generatedMaterialValues.u_baseColorFactor)) {\n                fragmentShader += '    baseColorWithAlpha *= u_baseColorFactor;\\n';\n            }\n        } else if (defined(generatedMaterialValues.u_baseColorFactor)) {\n                fragmentShader += '    vec4 baseColorWithAlpha = u_baseColorFactor;\\n';\n            } else {\n                fragmentShader += '    vec4 baseColorWithAlpha = vec4(1.0);\\n';\n            }\n\n        if (hasVertexColors) {\n            fragmentShader += '    baseColorWithAlpha *= v_vertexColor;\\n';\n        }\n\n        fragmentShader += '    vec3 baseColor = baseColorWithAlpha.rgb;\\n';\n\n        if (hasNormals) {\n            if (useSpecGloss) {\n                if (defined(generatedMaterialValues.u_specularGlossinessTexture)) {\n                    fragmentShader += '    vec4 specularGlossiness = SRGBtoLINEAR4(texture2D(u_specularGlossinessTexture, ' + specularGlossinessTexCoord + '));\\n';\n                    fragmentShader += '    vec3 specular = specularGlossiness.rgb;\\n';\n                    fragmentShader += '    float glossiness = specularGlossiness.a;\\n';\n                    if (defined(generatedMaterialValues.u_specularFactor)) {\n                        fragmentShader += '    specular *= u_specularFactor;\\n';\n                    }\n                    if (defined(generatedMaterialValues.u_glossinessFactor)) {\n                        fragmentShader += '    glossiness *= u_glossinessFactor;\\n';\n                    }\n                } else {\n                    if (defined(generatedMaterialValues.u_specularFactor)) {\n                        fragmentShader += '    vec3 specular = clamp(u_specularFactor, vec3(0.0), vec3(1.0));\\n';\n                    } else {\n                        fragmentShader += '    vec3 specular = vec3(1.0);\\n';\n                    }\n                    if (defined(generatedMaterialValues.u_glossinessFactor)) {\n                        fragmentShader += '    float glossiness = clamp(u_glossinessFactor, 0.0, 1.0);\\n';\n                    } else {\n                        fragmentShader += '    float glossiness = 1.0;\\n';\n                    }\n                }\n                if (defined(generatedMaterialValues.u_diffuseTexture)) {\n                    fragmentShader += '    vec4 diffuse = SRGBtoLINEAR4(texture2D(u_diffuseTexture, ' + diffuseTexCoord + '));\\n';\n                    if (defined(generatedMaterialValues.u_diffuseFactor)) {\n                        fragmentShader += '    diffuse *= u_diffuseFactor;\\n';\n                    }\n                } else if (defined(generatedMaterialValues.u_diffuseFactor)) {\n                    fragmentShader += '    vec4 diffuse = clamp(u_diffuseFactor, vec4(0.0), vec4(1.0));\\n';\n                } else {\n                    fragmentShader += '    vec4 diffuse = vec4(1.0);\\n';\n                }\n            } else if (defined(generatedMaterialValues.u_metallicRoughnessTexture)) {\n                fragmentShader += '    vec3 metallicRoughness = texture2D(u_metallicRoughnessTexture, ' + metallicRoughnessTexCoord + ').rgb;\\n';\n                fragmentShader += '    float metalness = clamp(metallicRoughness.b, 0.0, 1.0);\\n';\n                fragmentShader += '    float roughness = clamp(metallicRoughness.g, 0.04, 1.0);\\n';\n                if (defined(generatedMaterialValues.u_metallicFactor)) {\n                    fragmentShader += '    metalness *= u_metallicFactor;\\n';\n                }\n                if (defined(generatedMaterialValues.u_roughnessFactor)) {\n                    fragmentShader += '    roughness *= u_roughnessFactor;\\n';\n                }\n            } else {\n                if (defined(generatedMaterialValues.u_metallicFactor)) {\n                    fragmentShader += '    float metalness = clamp(u_metallicFactor, 0.0, 1.0);\\n';\n                } else {\n                    fragmentShader += '    float metalness = 1.0;\\n';\n                }\n                if (defined(generatedMaterialValues.u_roughnessFactor)) {\n                    fragmentShader += '    float roughness = clamp(u_roughnessFactor, 0.04, 1.0);\\n';\n                } else {\n                    fragmentShader += '    float roughness = 1.0;\\n';\n                }\n            }\n\n            fragmentShader += '    vec3 v = -normalize(v_positionEC);\\n';\n\n            // Generate fragment shader's lighting block\n            fragmentShader += '#ifndef USE_CUSTOM_LIGHT_COLOR \\n';\n            fragmentShader += '    vec3 lightColorHdr = czm_lightColorHdr;\\n';\n            fragmentShader += '#else \\n';\n            fragmentShader += '    vec3 lightColorHdr = gltf_lightColor;\\n';\n            fragmentShader += '#endif \\n';\n            fragmentShader += '    vec3 l = normalize(czm_lightDirectionEC);\\n';\n            fragmentShader += '    vec3 h = normalize(v + l);\\n';\n            fragmentShader += '    float NdotL = clamp(dot(n, l), 0.001, 1.0);\\n';\n            fragmentShader += '    float NdotV = abs(dot(n, v)) + 0.001;\\n';\n            fragmentShader += '    float NdotH = clamp(dot(n, h), 0.0, 1.0);\\n';\n            fragmentShader += '    float LdotH = clamp(dot(l, h), 0.0, 1.0);\\n';\n            fragmentShader += '    float VdotH = clamp(dot(v, h), 0.0, 1.0);\\n';\n            fragmentShader += '    vec3 f0 = vec3(0.04);\\n';\n            // Whether the material uses metallic-roughness or specular-glossiness changes how the BRDF inputs are computed.\n            // It does not change the implementation of the BRDF itself.\n            if (useSpecGloss) {\n                fragmentShader += '    float roughness = 1.0 - glossiness;\\n';\n                fragmentShader += '    vec3 diffuseColor = diffuse.rgb * (1.0 - max(max(specular.r, specular.g), specular.b));\\n';\n                fragmentShader += '    vec3 specularColor = specular;\\n';\n            } else {\n                fragmentShader += '    vec3 diffuseColor = baseColor * (1.0 - metalness) * (1.0 - f0);\\n';\n                fragmentShader += '    vec3 specularColor = mix(f0, baseColor, metalness);\\n';\n            }\n\n            fragmentShader += '    float alpha = roughness * roughness;\\n';\n            fragmentShader += '    float reflectance = max(max(specularColor.r, specularColor.g), specularColor.b);\\n';\n            fragmentShader += '    vec3 r90 = vec3(clamp(reflectance * 25.0, 0.0, 1.0));\\n';\n            fragmentShader += '    vec3 r0 = specularColor.rgb;\\n';\n\n            fragmentShader += '    vec3 F = fresnelSchlick2(r0, r90, VdotH);\\n';\n            fragmentShader += '    float G = smithVisibilityGGX(alpha, NdotL, NdotV);\\n';\n            fragmentShader += '    float D = GGX(alpha, NdotH);\\n';\n\n            fragmentShader += '    vec3 diffuseContribution = (1.0 - F) * lambertianDiffuse(diffuseColor);\\n';\n            fragmentShader += '    vec3 specularContribution = F * G * D / (4.0 * NdotL * NdotV);\\n';\n            fragmentShader += '    vec3 color = NdotL * lightColorHdr * (diffuseContribution + specularContribution);\\n';\n\n            // Use the procedural IBL if there are no environment maps\n            fragmentShader += '#if defined(USE_IBL_LIGHTING) && !defined(DIFFUSE_IBL) && !defined(SPECULAR_IBL) \\n';\n\n            fragmentShader += '    vec3 r = normalize(czm_inverseViewRotation * normalize(reflect(v, n)));\\n';\n            // Figure out if the reflection vector hits the ellipsoid\n            fragmentShader += '    float vertexRadius = length(positionWC);\\n';\n            fragmentShader += '    float horizonDotNadir = 1.0 - min(1.0, czm_ellipsoidRadii.x / vertexRadius);\\n';\n            fragmentShader += '    float reflectionDotNadir = dot(r, normalize(positionWC));\\n';\n            // Flipping the X vector is a cheap way to get the inverse of czm_temeToPseudoFixed, since that's a rotation about Z.\n            fragmentShader += '    r.x = -r.x;\\n';\n            fragmentShader += '    r = -normalize(czm_temeToPseudoFixed * r);\\n';\n            fragmentShader += '    r.x = -r.x;\\n';\n\n            fragmentShader += '    float inverseRoughness = 1.04 - roughness;\\n';\n            fragmentShader += '    inverseRoughness *= inverseRoughness;\\n';\n            fragmentShader += '    vec3 sceneSkyBox = textureCube(czm_environmentMap, r).rgb * inverseRoughness;\\n';\n\n            fragmentShader += '    float atmosphereHeight = 0.05;\\n';\n            fragmentShader += '    float blendRegionSize = 0.1 * ((1.0 - inverseRoughness) * 8.0 + 1.1 - horizonDotNadir);\\n';\n            fragmentShader += '    float blendRegionOffset = roughness * -1.0;\\n';\n            fragmentShader += '    float farAboveHorizon = clamp(horizonDotNadir - blendRegionSize * 0.5 + blendRegionOffset, 1.0e-10 - blendRegionSize, 0.99999);\\n';\n            fragmentShader += '    float aroundHorizon = clamp(horizonDotNadir + blendRegionSize * 0.5, 1.0e-10 - blendRegionSize, 0.99999);\\n';\n            fragmentShader += '    float farBelowHorizon = clamp(horizonDotNadir + blendRegionSize * 1.5, 1.0e-10 - blendRegionSize, 0.99999);\\n';\n            fragmentShader += '    float smoothstepHeight = smoothstep(0.0, atmosphereHeight, horizonDotNadir);\\n';\n\n            fragmentShader += '    vec3 belowHorizonColor = mix(vec3(0.1, 0.15, 0.25), vec3(0.4, 0.7, 0.9), smoothstepHeight);\\n';\n            fragmentShader += '    vec3 nadirColor = belowHorizonColor * 0.5;\\n';\n            fragmentShader += '    vec3 aboveHorizonColor = mix(vec3(0.9, 1.0, 1.2), belowHorizonColor, roughness * 0.5);\\n';\n            fragmentShader += '    vec3 blueSkyColor = mix(vec3(0.18, 0.26, 0.48), aboveHorizonColor, reflectionDotNadir * inverseRoughness * 0.5 + 0.75);\\n';\n            fragmentShader += '    vec3 zenithColor = mix(blueSkyColor, sceneSkyBox, smoothstepHeight);\\n';\n\n            fragmentShader += '    vec3 blueSkyDiffuseColor = vec3(0.7, 0.85, 0.9);\\n';\n            fragmentShader += '    float diffuseIrradianceFromEarth = (1.0 - horizonDotNadir) * (reflectionDotNadir * 0.25 + 0.75) * smoothstepHeight;\\n';\n            fragmentShader += '    float diffuseIrradianceFromSky = (1.0 - smoothstepHeight) * (1.0 - (reflectionDotNadir * 0.25 + 0.25));\\n';\n            fragmentShader += '    vec3 diffuseIrradiance = blueSkyDiffuseColor * clamp(diffuseIrradianceFromEarth + diffuseIrradianceFromSky, 0.0, 1.0);\\n';\n\n            fragmentShader += '    float notDistantRough = (1.0 - horizonDotNadir * roughness * 0.8);\\n';\n            fragmentShader += '    vec3 specularIrradiance = mix(zenithColor, aboveHorizonColor, smoothstep(farAboveHorizon, aroundHorizon, reflectionDotNadir) * notDistantRough);\\n';\n            fragmentShader += '    specularIrradiance = mix(specularIrradiance, belowHorizonColor, smoothstep(aroundHorizon, farBelowHorizon, reflectionDotNadir) * inverseRoughness);\\n';\n            fragmentShader += '    specularIrradiance = mix(specularIrradiance, nadirColor, smoothstep(farBelowHorizon, 1.0, reflectionDotNadir) * inverseRoughness);\\n';\n\n            // Luminance model from page 40 of http://silviojemma.com/public/papers/lighting/spherical-harmonic-lighting.pdf\n            fragmentShader += '#ifdef USE_SUN_LUMINANCE \\n';\n            // Angle between sun and zenith\n            fragmentShader += '    float LdotZenith = clamp(dot(normalize(czm_inverseViewRotation * l), normalize(positionWC * -1.0)), 0.001, 1.0);\\n';\n            fragmentShader += '    float S = acos(LdotZenith);\\n';\n            // Angle between zenith and current pixel\n            fragmentShader += '    float NdotZenith = clamp(dot(normalize(czm_inverseViewRotation * n), normalize(positionWC * -1.0)), 0.001, 1.0);\\n';\n            // Angle between sun and current pixel\n            fragmentShader += '    float gamma = acos(NdotL);\\n';\n            fragmentShader += '    float numerator = ((0.91 + 10.0 * exp(-3.0 * gamma) + 0.45 * pow(NdotL, 2.0)) * (1.0 - exp(-0.32 / NdotZenith)));\\n';\n            fragmentShader += '    float denominator = (0.91 + 10.0 * exp(-3.0 * S) + 0.45 * pow(LdotZenith,2.0)) * (1.0 - exp(-0.32));\\n';\n            fragmentShader += '    float luminance = gltf_luminanceAtZenith * (numerator / denominator);\\n';\n            fragmentShader += '#endif \\n';\n\n            fragmentShader += '    vec2 brdfLut = texture2D(czm_brdfLut, vec2(NdotV, roughness)).rg;\\n';\n            fragmentShader += '    vec3 IBLColor = (diffuseIrradiance * diffuseColor * gltf_iblFactor.x) + (specularIrradiance * SRGBtoLINEAR3(specularColor * brdfLut.x + brdfLut.y) * gltf_iblFactor.y);\\n';\n\n            fragmentShader += '    float maximumComponent = max(max(lightColorHdr.x, lightColorHdr.y), lightColorHdr.z);\\n';\n            fragmentShader += '    vec3 lightColor = lightColorHdr / max(maximumComponent, 1.0);\\n';\n            fragmentShader += '    IBLColor *= lightColor;\\n';\n\n            fragmentShader += '#ifdef USE_SUN_LUMINANCE \\n';\n            fragmentShader += '    color += IBLColor * luminance;\\n';\n            fragmentShader += '#else \\n';\n            fragmentShader += '    color += IBLColor; \\n';\n            fragmentShader += '#endif \\n';\n\n            // Environment maps were provided, use them for IBL\n            fragmentShader += '#elif defined(DIFFUSE_IBL) || defined(SPECULAR_IBL) \\n';\n\n            fragmentShader += '    mat3 fixedToENU = mat3(gltf_clippingPlanesMatrix[0][0], gltf_clippingPlanesMatrix[1][0], gltf_clippingPlanesMatrix[2][0], \\n';\n            fragmentShader += '                           gltf_clippingPlanesMatrix[0][1], gltf_clippingPlanesMatrix[1][1], gltf_clippingPlanesMatrix[2][1], \\n';\n            fragmentShader += '                           gltf_clippingPlanesMatrix[0][2], gltf_clippingPlanesMatrix[1][2], gltf_clippingPlanesMatrix[2][2]); \\n';\n            fragmentShader += '    const mat3 yUpToZUp = mat3(-1.0, 0.0, 0.0, 0.0, 0.0, -1.0, 0.0, 1.0, 0.0); \\n';\n            fragmentShader += '    vec3 cubeDir = normalize(yUpToZUp * fixedToENU * normalize(reflect(-v, n))); \\n';\n\n            fragmentShader += '#ifdef DIFFUSE_IBL \\n';\n            fragmentShader += '#ifdef CUSTOM_SPHERICAL_HARMONICS \\n';\n            fragmentShader += '    vec3 diffuseIrradiance = czm_sphericalHarmonics(cubeDir, gltf_sphericalHarmonicCoefficients); \\n';\n            fragmentShader += '#else \\n';\n            fragmentShader += '    vec3 diffuseIrradiance = czm_sphericalHarmonics(cubeDir, czm_sphericalHarmonicCoefficients); \\n';\n            fragmentShader += '#endif \\n';\n            fragmentShader += '#else \\n';\n            fragmentShader += '    vec3 diffuseIrradiance = vec3(0.0); \\n';\n            fragmentShader += '#endif \\n';\n\n            fragmentShader += '#ifdef SPECULAR_IBL \\n';\n            fragmentShader += '    vec2 brdfLut = texture2D(czm_brdfLut, vec2(NdotV, roughness)).rg;\\n';\n            fragmentShader += '#ifdef CUSTOM_SPECULAR_IBL \\n';\n            fragmentShader += '    vec3 specularIBL = czm_sampleOctahedralProjection(gltf_specularMap, gltf_specularMapSize, cubeDir,  roughness * gltf_maxSpecularLOD, gltf_maxSpecularLOD);\\n';\n            fragmentShader += '#else \\n';\n            fragmentShader += '    vec3 specularIBL = czm_sampleOctahedralProjection(czm_specularEnvironmentMaps, czm_specularEnvironmentMapSize, cubeDir,  roughness * czm_specularEnvironmentMapsMaximumLOD, czm_specularEnvironmentMapsMaximumLOD);\\n';\n            fragmentShader += '#endif \\n';\n            fragmentShader += '    specularIBL *= F * brdfLut.x + brdfLut.y;\\n';\n            fragmentShader += '#else \\n';\n            fragmentShader += '    vec3 specularIBL = vec3(0.0); \\n';\n            fragmentShader += '#endif \\n';\n\n            fragmentShader += '    color += diffuseIrradiance * diffuseColor + specularColor * specularIBL;\\n';\n\n            fragmentShader += '#endif \\n';\n        } else {\n            fragmentShader += '    vec3 color = baseColor;\\n';\n        }\n\n        // Ignore occlusion and emissive when unlit\n        if (!isUnlit) {\n            if (defined(generatedMaterialValues.u_occlusionTexture)) {\n                fragmentShader += '    color *= texture2D(u_occlusionTexture, ' + occlusionTexCoord + ').r;\\n';\n            }\n            if (defined(generatedMaterialValues.u_emissiveTexture)) {\n                fragmentShader += '    vec3 emissive = SRGBtoLINEAR3(texture2D(u_emissiveTexture, ' + emissiveTexCoord + ').rgb);\\n';\n                if (defined(generatedMaterialValues.u_emissiveFactor)) {\n                    fragmentShader += '    emissive *= u_emissiveFactor;\\n';\n                }\n                fragmentShader += '    color += emissive;\\n';\n            } else if (defined(generatedMaterialValues.u_emissiveFactor)) {\n                fragmentShader += '    color += u_emissiveFactor;\\n';\n            }\n        }\n\n        if (!isUnlit) {\n            fragmentShader += '    color = applyTonemapping(color);\\n';\n        }\n\n        fragmentShader += '    color = LINEARtoSRGB(color);\\n';\n\n        if (defined(alphaMode)) {\n            if (alphaMode === 'MASK') {\n                fragmentShader += '    if (baseColorWithAlpha.a < u_alphaCutoff) {\\n';\n                fragmentShader += '        discard;\\n';\n                fragmentShader += '    }\\n';\n                fragmentShader += '    gl_FragColor = vec4(color, 1.0);\\n';\n            } else if (alphaMode === 'BLEND') {\n                fragmentShader += '    gl_FragColor = vec4(color, baseColorWithAlpha.a);\\n';\n            } else {\n                fragmentShader += '    gl_FragColor = vec4(color, 1.0);\\n';\n            }\n        } else {\n            fragmentShader += '    gl_FragColor = vec4(color, 1.0);\\n';\n        }\n\n        fragmentShader += '}\\n';\n\n        // Add shaders\n        var vertexShaderId = addToArray(shaders, {\n            type : WebGLConstants.VERTEX_SHADER,\n            extras : {\n                _pipeline : {\n                    source : vertexShader,\n                    extension : '.glsl'\n                }\n            }\n        });\n\n        var fragmentShaderId = addToArray(shaders, {\n            type : WebGLConstants.FRAGMENT_SHADER,\n            extras : {\n                _pipeline : {\n                    source : fragmentShader,\n                    extension : '.glsl'\n                }\n            }\n        });\n\n        // Add program\n        var programId = addToArray(programs, {\n            isOutline : defined(material.extensions) ? defined(material.extensions.TERRIA_solid_outlines) : false,\n            fragmentShader : fragmentShaderId,\n            vertexShader : vertexShaderId\n        });\n\n        var techniqueId = addToArray(techniques, {\n            attributes : techniqueAttributes,\n            program : programId,\n            uniforms : techniqueUniforms\n        });\n\n        return techniqueId;\n    }\n\n    function getPBRValueType(paramName) {\n        if (paramName.indexOf('Offset') !== -1) {\n            return WebGLConstants.FLOAT_VEC2;\n        } else if (paramName.indexOf('Rotation') !== -1) {\n            return WebGLConstants.FLOAT;\n        } else if (paramName.indexOf('Scale') !== -1) {\n            return WebGLConstants.FLOAT_VEC2;\n        } else if (paramName.indexOf('Texture') !== -1) {\n            return WebGLConstants.SAMPLER_2D;\n        }\n\n        switch (paramName) {\n            case 'u_baseColorFactor':\n                return WebGLConstants.FLOAT_VEC4;\n            case 'u_metallicFactor':\n                return WebGLConstants.FLOAT;\n            case 'u_roughnessFactor':\n                return WebGLConstants.FLOAT;\n            case 'u_emissiveFactor':\n                return WebGLConstants.FLOAT_VEC3;\n            // Specular Glossiness Types\n            case 'u_diffuseFactor':\n                return WebGLConstants.FLOAT_VEC4;\n            case 'u_specularFactor':\n                return WebGLConstants.FLOAT_VEC3;\n            case 'u_glossinessFactor':\n                return WebGLConstants.FLOAT;\n        }\n    }\nexport default processPbrMaterials;\n","import BoundingSphere from '../Core/BoundingSphere.js';\nimport Cartesian2 from '../Core/Cartesian2.js';\nimport Cartesian3 from '../Core/Cartesian3.js';\nimport Cartesian4 from '../Core/Cartesian4.js';\nimport Cartographic from '../Core/Cartographic.js';\nimport Check from '../Core/Check.js';\nimport clone from '../Core/clone.js';\nimport Color from '../Core/Color.js';\nimport combine from '../Core/combine.js';\nimport createGuid from '../Core/createGuid.js';\nimport Credit from '../Core/Credit.js';\nimport defaultValue from '../Core/defaultValue.js';\nimport defined from '../Core/defined.js';\nimport defineProperties from '../Core/defineProperties.js';\nimport destroyObject from '../Core/destroyObject.js';\nimport DeveloperError from '../Core/DeveloperError.js';\nimport DistanceDisplayCondition from '../Core/DistanceDisplayCondition.js';\nimport FeatureDetection from '../Core/FeatureDetection.js';\nimport getAbsoluteUri from '../Core/getAbsoluteUri.js';\nimport getMagic from '../Core/getMagic.js';\nimport getStringFromTypedArray from '../Core/getStringFromTypedArray.js';\nimport IndexDatatype from '../Core/IndexDatatype.js';\nimport isArray from '../Core/isArray.js';\nimport loadCRN from '../Core/loadCRN.js';\nimport loadImageFromTypedArray from '../Core/loadImageFromTypedArray.js';\nimport loadKTX from '../Core/loadKTX.js';\nimport CesiumMath from '../Core/Math.js';\nimport Matrix3 from '../Core/Matrix3.js';\nimport Matrix4 from '../Core/Matrix4.js';\nimport PixelFormat from '../Core/PixelFormat.js';\nimport PrimitiveType from '../Core/PrimitiveType.js';\nimport Quaternion from '../Core/Quaternion.js';\nimport Resource from '../Core/Resource.js';\nimport Transforms from '../Core/Transforms.js';\nimport WebGLConstants from '../Core/WebGLConstants.js';\nimport Buffer from '../Renderer/Buffer.js';\nimport BufferUsage from '../Renderer/BufferUsage.js';\nimport DrawCommand from '../Renderer/DrawCommand.js';\nimport Pass from '../Renderer/Pass.js';\nimport RenderState from '../Renderer/RenderState.js';\nimport Sampler from '../Renderer/Sampler.js';\nimport ShaderProgram from '../Renderer/ShaderProgram.js';\nimport ShaderSource from '../Renderer/ShaderSource.js';\nimport Texture from '../Renderer/Texture.js';\nimport TextureMinificationFilter from '../Renderer/TextureMinificationFilter.js';\nimport TextureWrap from '../Renderer/TextureWrap.js';\nimport VertexArray from '../Renderer/VertexArray.js';\nimport addDefaults from '../ThirdParty/GltfPipeline/addDefaults.js';\nimport addPipelineExtras from '../ThirdParty/GltfPipeline/addPipelineExtras.js';\nimport ForEach from '../ThirdParty/GltfPipeline/ForEach.js';\nimport getAccessorByteStride from '../ThirdParty/GltfPipeline/getAccessorByteStride.js';\nimport hasExtension from '../ThirdParty/GltfPipeline/hasExtension.js';\nimport numberOfComponentsForType from '../ThirdParty/GltfPipeline/numberOfComponentsForType.js';\nimport parseGlb from '../ThirdParty/GltfPipeline/parseGlb.js';\nimport updateVersion from '../ThirdParty/GltfPipeline/updateVersion.js';\nimport when from '../ThirdParty/when.js';\nimport Axis from './Axis.js';\nimport BlendingState from './BlendingState.js';\nimport ClippingPlaneCollection from './ClippingPlaneCollection.js';\nimport ColorBlendMode from './ColorBlendMode.js';\nimport DracoLoader from './DracoLoader.js';\nimport getClipAndStyleCode from './getClipAndStyleCode.js';\nimport getClippingFunction from './getClippingFunction.js';\nimport HeightReference from './HeightReference.js';\nimport JobType from './JobType.js';\nimport ModelAnimationCache from './ModelAnimationCache.js';\nimport ModelAnimationCollection from './ModelAnimationCollection.js';\nimport ModelLoadResources from './ModelLoadResources.js';\nimport ModelMaterial from './ModelMaterial.js';\nimport ModelMesh from './ModelMesh.js';\nimport ModelNode from './ModelNode.js';\nimport ModelUtility from './ModelUtility.js';\nimport OctahedralProjectedCubeMap from './OctahedralProjectedCubeMap.js';\nimport processModelMaterialsCommon from './processModelMaterialsCommon.js';\nimport processPbrMaterials from './processPbrMaterials.js';\nimport SceneMode from './SceneMode.js';\nimport ShadowMode from './ShadowMode.js';\n\n    var boundingSphereCartesian3Scratch = new Cartesian3();\n\n    var ModelState = ModelUtility.ModelState;\n\n    // glTF MIME types discussed in https://github.com/KhronosGroup/glTF/issues/412 and https://github.com/KhronosGroup/glTF/issues/943\n    var defaultModelAccept = 'model/gltf-binary,model/gltf+json;q=0.8,application/json;q=0.2,*/*;q=0.01';\n\n    var articulationEpsilon = CesiumMath.EPSILON16;\n\n    ///////////////////////////////////////////////////////////////////////////\n\n    function setCachedGltf(model, cachedGltf) {\n        model._cachedGltf = cachedGltf;\n    }\n\n    // glTF JSON can be big given embedded geometry, textures, and animations, so we\n    // cache it across all models using the same url/cache-key.  This also reduces the\n    // slight overhead in assigning defaults to missing values.\n    //\n    // Note that this is a global cache, compared to renderer resources, which\n    // are cached per context.\n    function CachedGltf(options) {\n        this._gltf = options.gltf;\n        this.ready = options.ready;\n        this.modelsToLoad = [];\n        this.count = 0;\n    }\n\n    defineProperties(CachedGltf.prototype, {\n        gltf : {\n            set : function(value) {\n                this._gltf = value;\n            },\n\n            get : function() {\n                return this._gltf;\n            }\n        }\n    });\n\n    CachedGltf.prototype.makeReady = function(gltfJson) {\n        this.gltf = gltfJson;\n\n        var models = this.modelsToLoad;\n        var length = models.length;\n        for (var i = 0; i < length; ++i) {\n            var m = models[i];\n            if (!m.isDestroyed()) {\n                setCachedGltf(m, this);\n            }\n        }\n        this.modelsToLoad = undefined;\n        this.ready = true;\n    };\n\n    var gltfCache = {};\n    var uriToGuid = {};\n    ///////////////////////////////////////////////////////////////////////////\n\n    /**\n     * A 3D model based on glTF, the runtime asset format for WebGL, OpenGL ES, and OpenGL.\n     * <p>\n     * Cesium includes support for geometry and materials, glTF animations, and glTF skinning.\n     * In addition, individual glTF nodes are pickable with {@link Scene#pick} and animatable\n     * with {@link Model#getNode}.  glTF cameras and lights are not currently supported.\n     * </p>\n     * <p>\n     * An external glTF asset is created with {@link Model.fromGltf}.  glTF JSON can also be\n     * created at runtime and passed to this constructor function.  In either case, the\n     * {@link Model#readyPromise} is resolved when the model is ready to render, i.e.,\n     * when the external binary, image, and shader files are downloaded and the WebGL\n     * resources are created.\n     * </p>\n     * <p>\n     * Cesium supports glTF assets with the following extensions:\n     * <ul>\n     * <li>\n     * {@link https://github.com/KhronosGroup/glTF/blob/master/extensions/1.0/Khronos/KHR_binary_glTF/README.md|KHR_binary_glTF (glTF 1.0)}\n     * </li><li>\n     * {@link https://github.com/KhronosGroup/glTF/blob/master/extensions/1.0/Khronos/KHR_materials_common/README.md|KHR_materials_common (glTF 1.0)}\n     * </li><li>\n     * {@link https://github.com/KhronosGroup/glTF/blob/master/extensions/1.0/Vendor/WEB3D_quantized_attributes/README.md|WEB3D_quantized_attributes (glTF 1.0)}\n     * </li><li>\n     * {@link https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/AGI_articulations/README.md|AGI_articulations}\n     * </li><li>\n     * {@link https://github.com/KhronosGroup/glTF/pull/1302|KHR_blend (draft)}\n     * </li><li>\n     * {@link https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_draco_mesh_compression/README.md|KHR_draco_mesh_compression}\n     * </li><li>\n     * {@link https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_pbrSpecularGlossiness/README.md|KHR_materials_pbrSpecularGlossiness}\n     * </li><li>\n     * {@link https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit/README.md|KHR_materials_unlit}\n     * </li><li>\n     * {@link https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_techniques_webgl/README.md|KHR_techniques_webgl}\n     * </li><li>\n     * {@link https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_texture_transform/README.md|KHR_texture_transform}\n     * </li>\n     * </ul>\n     * </p>\n     * <p>\n     * For high-precision rendering, Cesium supports the {@link https://github.com/KhronosGroup/glTF/blob/master/extensions/1.0/Vendor/CESIUM_RTC/README.md|CESIUM_RTC} extension, which introduces the\n     * CESIUM_RTC_MODELVIEW parameter semantic that says the node is in WGS84 coordinates translated\n     * relative to a local origin.\n     * </p>\n     *\n     * @alias Model\n     * @constructor\n     *\n     * @param {Object} [options] Object with the following properties:\n     * @param {Object|ArrayBuffer|Uint8Array} [options.gltf] A glTF JSON object, or a binary glTF buffer.\n     * @param {Resource|String} [options.basePath=''] The base path that paths in the glTF JSON are relative to.\n     * @param {Boolean} [options.show=true] Determines if the model primitive will be shown.\n     * @param {Matrix4} [options.modelMatrix=Matrix4.IDENTITY] The 4x4 transformation matrix that transforms the model from model to world coordinates.\n     * @param {Number} [options.scale=1.0] A uniform scale applied to this model.\n     * @param {Number} [options.minimumPixelSize=0.0] The approximate minimum pixel size of the model regardless of zoom.\n     * @param {Number} [options.maximumScale] The maximum scale size of a model. An upper limit for minimumPixelSize.\n     * @param {Object} [options.id] A user-defined object to return when the model is picked with {@link Scene#pick}.\n     * @param {Boolean} [options.allowPicking=true] When <code>true</code>, each glTF mesh and primitive is pickable with {@link Scene#pick}.\n     * @param {Boolean} [options.incrementallyLoadTextures=true] Determine if textures may continue to stream in after the model is loaded.\n     * @param {Boolean} [options.asynchronous=true] Determines if model WebGL resource creation will be spread out over several frames or block until completion once all glTF files are loaded.\n     * @param {Boolean} [options.clampAnimations=true] Determines if the model's animations should hold a pose over frames where no keyframes are specified.\n     * @param {ShadowMode} [options.shadows=ShadowMode.ENABLED] Determines whether the model casts or receives shadows from light sources.\n     * @param {Boolean} [options.debugShowBoundingVolume=false] For debugging only. Draws the bounding sphere for each draw command in the model.\n     * @param {Boolean} [options.debugWireframe=false] For debugging only. Draws the model in wireframe.\n     * @param {HeightReference} [options.heightReference=HeightReference.NONE] Determines how the model is drawn relative to terrain.\n     * @param {Scene} [options.scene] Must be passed in for models that use the height reference property.\n     * @param {DistanceDisplayCondition} [options.distanceDisplayCondition] The condition specifying at what distance from the camera that this model will be displayed.\n     * @param {Color} [options.color=Color.WHITE] A color that blends with the model's rendered color.\n     * @param {ColorBlendMode} [options.colorBlendMode=ColorBlendMode.HIGHLIGHT] Defines how the color blends with the model.\n     * @param {Number} [options.colorBlendAmount=0.5] Value used to determine the color strength when the <code>colorBlendMode</code> is <code>MIX</code>. A value of 0.0 results in the model's rendered color while a value of 1.0 results in a solid color, with any value in-between resulting in a mix of the two.\n     * @param {Color} [options.silhouetteColor=Color.RED] The silhouette color. If more than 256 models have silhouettes enabled, there is a small chance that overlapping models will have minor artifacts.\n     * @param {Number} [options.silhouetteSize=0.0] The size of the silhouette in pixels.\n     * @param {ClippingPlaneCollection} [options.clippingPlanes] The {@link ClippingPlaneCollection} used to selectively disable rendering the model.\n     * @param {Boolean} [options.dequantizeInShader=true] Determines if a {@link https://github.com/google/draco|Draco} encoded model is dequantized on the GPU. This decreases total memory usage for encoded models.\n     * @param {Cartesian2} [options.imageBasedLightingFactor=Cartesian2(1.0, 1.0)] Scales diffuse and specular image-based lighting from the earth, sky, atmosphere and star skybox.\n     * @param {Cartesian3} [options.lightColor] The light color when shading the model. When <code>undefined</code> the scene's light color are used instead.\n     * @param {Number} [options.luminanceAtZenith=0.2] The sun's luminance at the zenith in kilo candela per meter squared to use for this model's procedural environment map.\n     * @param {Cartesian3[]} [options.sphericalHarmonicCoefficients] The third order spherical harmonic coefficients used for the diffuse color of image-based lighting.\n     * @param {String} [options.specularEnvironmentMaps] A URL to a KTX file that contains a cube map of the specular lighting and the convoluted specular mipmaps.\n     * @param {Credit|String} [options.credit] A credit for the data source, which is displayed on the canvas.\n     *\n     * @see Model.fromGltf\n     *\n     * @demo {@link https://sandcastle.cesium.com/index.html?src=3D%20Models.html|Cesium Sandcastle Models Demo}\n     */\n    function Model(options) {\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n        var cacheKey = options.cacheKey;\n        this._cacheKey = cacheKey;\n        this._cachedGltf = undefined;\n        this._releaseGltfJson = defaultValue(options.releaseGltfJson, false);\n\n        var cachedGltf;\n        if (defined(cacheKey) && defined(gltfCache[cacheKey]) && gltfCache[cacheKey].ready) {\n            // glTF JSON is in cache and ready\n            cachedGltf = gltfCache[cacheKey];\n            ++cachedGltf.count;\n        } else {\n            // glTF was explicitly provided, e.g., when a user uses the Model constructor directly\n            var gltf = options.gltf;\n\n            if (defined(gltf)) {\n                if (gltf instanceof ArrayBuffer) {\n                    gltf = new Uint8Array(gltf);\n                }\n\n                if (gltf instanceof Uint8Array) {\n                    // Binary glTF\n                    var parsedGltf = parseGlb(gltf);\n\n                    cachedGltf = new CachedGltf({\n                        gltf : parsedGltf,\n                        ready : true\n                    });\n                } else {\n                    // Normal glTF (JSON)\n                    cachedGltf = new CachedGltf({\n                        gltf : options.gltf,\n                        ready : true\n                    });\n                }\n\n                cachedGltf.count = 1;\n\n                if (defined(cacheKey)) {\n                    gltfCache[cacheKey] = cachedGltf;\n                }\n            }\n        }\n        setCachedGltf(this, cachedGltf);\n\n        var basePath = defaultValue(options.basePath, '');\n        this._resource = Resource.createIfNeeded(basePath);\n\n        // User specified credit\n        var credit = options.credit;\n        if (typeof credit === 'string') {\n            credit = new Credit(credit);\n        }\n        this._credit = credit;\n\n        // Create a list of Credit's so they can be added from the Resource later\n        this._resourceCredits = [];\n\n        /**\n         * Determines if the model primitive will be shown.\n         *\n         * @type {Boolean}\n         *\n         * @default true\n         */\n        this.show = defaultValue(options.show, true);\n\n        /**\n         * The silhouette color.\n         *\n         * @type {Color}\n         *\n         * @default Color.RED\n         */\n        this.silhouetteColor = defaultValue(options.silhouetteColor, Color.RED);\n        this._silhouetteColor = new Color();\n        this._silhouetteColorPreviousAlpha = 1.0;\n        this._normalAttributeName = undefined;\n\n        /**\n         * The size of the silhouette in pixels.\n         *\n         * @type {Number}\n         *\n         * @default 0.0\n         */\n        this.silhouetteSize = defaultValue(options.silhouetteSize, 0.0);\n\n        /**\n         * The 4x4 transformation matrix that transforms the model from model to world coordinates.\n         * When this is the identity matrix, the model is drawn in world coordinates, i.e., Earth's WGS84 coordinates.\n         * Local reference frames can be used by providing a different transformation matrix, like that returned\n         * by {@link Transforms.eastNorthUpToFixedFrame}.\n         *\n         * @type {Matrix4}\n         *\n         * @default {@link Matrix4.IDENTITY}\n         *\n         * @example\n         * var origin = Cesium.Cartesian3.fromDegrees(-95.0, 40.0, 200000.0);\n         * m.modelMatrix = Cesium.Transforms.eastNorthUpToFixedFrame(origin);\n         */\n        this.modelMatrix = Matrix4.clone(defaultValue(options.modelMatrix, Matrix4.IDENTITY));\n        this._modelMatrix = Matrix4.clone(this.modelMatrix);\n        this._clampedModelMatrix = undefined;\n\n        /**\n         * A uniform scale applied to this model before the {@link Model#modelMatrix}.\n         * Values greater than <code>1.0</code> increase the size of the model; values\n         * less than <code>1.0</code> decrease.\n         *\n         * @type {Number}\n         *\n         * @default 1.0\n         */\n        this.scale = defaultValue(options.scale, 1.0);\n        this._scale = this.scale;\n\n        /**\n         * The approximate minimum pixel size of the model regardless of zoom.\n         * This can be used to ensure that a model is visible even when the viewer\n         * zooms out.  When <code>0.0</code>, no minimum size is enforced.\n         *\n         * @type {Number}\n         *\n         * @default 0.0\n         */\n        this.minimumPixelSize = defaultValue(options.minimumPixelSize, 0.0);\n        this._minimumPixelSize = this.minimumPixelSize;\n\n        /**\n         * The maximum scale size for a model. This can be used to give\n         * an upper limit to the {@link Model#minimumPixelSize}, ensuring that the model\n         * is never an unreasonable scale.\n         *\n         * @type {Number}\n         */\n        this.maximumScale = options.maximumScale;\n        this._maximumScale = this.maximumScale;\n\n        /**\n         * User-defined object returned when the model is picked.\n         *\n         * @type Object\n         *\n         * @default undefined\n         *\n         * @see Scene#pick\n         */\n        this.id = options.id;\n        this._id = options.id;\n\n        /**\n         * Returns the height reference of the model\n         *\n         * @type {HeightReference}\n         *\n         * @default HeightReference.NONE\n         */\n        this.heightReference = defaultValue(options.heightReference, HeightReference.NONE);\n        this._heightReference = this.heightReference;\n        this._heightChanged = false;\n        this._removeUpdateHeightCallback = undefined;\n        var scene = options.scene;\n        this._scene = scene;\n        if (defined(scene) && defined(scene.terrainProviderChanged)) {\n            this._terrainProviderChangedCallback = scene.terrainProviderChanged.addEventListener(function() {\n                this._heightChanged = true;\n            }, this);\n        }\n\n        /**\n         * Used for picking primitives that wrap a model.\n         *\n         * @private\n         */\n        this._pickObject = options.pickObject;\n        this._allowPicking = defaultValue(options.allowPicking, true);\n\n        this._ready = false;\n        this._readyPromise = when.defer();\n\n        /**\n         * The currently playing glTF animations.\n         *\n         * @type {ModelAnimationCollection}\n         */\n        this.activeAnimations = new ModelAnimationCollection(this);\n\n        /**\n         * Determines if the model's animations should hold a pose over frames where no keyframes are specified.\n         *\n         * @type {Boolean}\n         */\n        this.clampAnimations = defaultValue(options.clampAnimations, true);\n\n        this._defaultTexture = undefined;\n        this._incrementallyLoadTextures = defaultValue(options.incrementallyLoadTextures, true);\n        this._asynchronous = defaultValue(options.asynchronous, true);\n\n        /**\n         * Determines whether the model casts or receives shadows from light sources.\n         *\n         * @type {ShadowMode}\n         *\n         * @default ShadowMode.ENABLED\n         */\n        this.shadows = defaultValue(options.shadows, ShadowMode.ENABLED);\n        this._shadows = this.shadows;\n\n        /**\n         * A color that blends with the model's rendered color.\n         *\n         * @type {Color}\n         *\n         * @default Color.WHITE\n         */\n        this.color = Color.clone(defaultValue(options.color, Color.WHITE));\n        this._colorPreviousAlpha = 1.0;\n\n        /**\n         * Defines how the color blends with the model.\n         *\n         * @type {ColorBlendMode}\n         *\n         * @default ColorBlendMode.HIGHLIGHT\n         */\n        this.colorBlendMode = defaultValue(options.colorBlendMode, ColorBlendMode.HIGHLIGHT);\n\n        /**\n         * Value used to determine the color strength when the <code>colorBlendMode</code> is <code>MIX</code>.\n         * A value of 0.0 results in the model's rendered color while a value of 1.0 results in a solid color, with\n         * any value in-between resulting in a mix of the two.\n         *\n         * @type {Number}\n         *\n         * @default 0.5\n         */\n        this.colorBlendAmount = defaultValue(options.colorBlendAmount, 0.5);\n\n        this._colorShadingEnabled = false;\n\n        this._clippingPlanes = undefined;\n        this.clippingPlanes = options.clippingPlanes;\n        // Used for checking if shaders need to be regenerated due to clipping plane changes.\n        this._clippingPlanesState = 0;\n        // If defined, use this matrix to position the clipping planes instead of the modelMatrix.\n        // This is so that when models are part of a tileset they all get clipped relative\n        // to the root tile.\n        this.clippingPlanesOriginMatrix = undefined;\n\n        /**\n         * This property is for debugging only; it is not for production use nor is it optimized.\n         * <p>\n         * Draws the bounding sphere for each draw command in the model.  A glTF primitive corresponds\n         * to one draw command.  A glTF mesh has an array of primitives, often of length one.\n         * </p>\n         *\n         * @type {Boolean}\n         *\n         * @default false\n         */\n        this.debugShowBoundingVolume = defaultValue(options.debugShowBoundingVolume, false);\n        this._debugShowBoundingVolume = false;\n\n        /**\n         * This property is for debugging only; it is not for production use nor is it optimized.\n         * <p>\n         * Draws the model in wireframe.\n         * </p>\n         *\n         * @type {Boolean}\n         *\n         * @default false\n         */\n        this.debugWireframe = defaultValue(options.debugWireframe, false);\n        this._debugWireframe = false;\n\n        this._distanceDisplayCondition = options.distanceDisplayCondition;\n\n        // Undocumented options\n        this._addBatchIdToGeneratedShaders = options.addBatchIdToGeneratedShaders;\n        this._precreatedAttributes = options.precreatedAttributes;\n        this._vertexShaderLoaded = options.vertexShaderLoaded;\n        this._fragmentShaderLoaded = options.fragmentShaderLoaded;\n        this._uniformMapLoaded = options.uniformMapLoaded;\n        this._pickIdLoaded = options.pickIdLoaded;\n        this._ignoreCommands = defaultValue(options.ignoreCommands, false);\n        this._requestType = options.requestType;\n        this._upAxis = defaultValue(options.upAxis, Axis.Y);\n        this._gltfForwardAxis = Axis.Z;\n        this._forwardAxis = options.forwardAxis;\n\n        /**\n         * @private\n         * @readonly\n         */\n        this.cull = defaultValue(options.cull, true);\n\n        /**\n         * @private\n         * @readonly\n         */\n        this.opaquePass = defaultValue(options.opaquePass, Pass.OPAQUE);\n\n        this._computedModelMatrix = new Matrix4(); // Derived from modelMatrix and scale\n        this._clippingPlaneModelViewMatrix = Matrix4.clone(Matrix4.IDENTITY); // Derived from modelMatrix, scale, and the current view matrix\n        this._initialRadius = undefined;           // Radius without model's scale property, model-matrix scale, animations, or skins\n        this._boundingSphere = undefined;\n        this._scaledBoundingSphere = new BoundingSphere();\n        this._state = ModelState.NEEDS_LOAD;\n        this._loadResources = undefined;\n\n        this._mode = undefined;\n\n        this._perNodeShowDirty = false;            // true when the Cesium API was used to change a node's show property\n        this._cesiumAnimationsDirty = false;       // true when the Cesium API, not a glTF animation, changed a node transform\n        this._dirty = false;                       // true when the model was transformed this frame\n        this._maxDirtyNumber = 0;                  // Used in place of a dirty boolean flag to avoid an extra graph traversal\n\n        this._runtime = {\n            animations : undefined,\n            articulationsByName : undefined,\n            articulationsByStageKey : undefined,\n            stagesByKey : undefined,\n            rootNodes : undefined,\n            nodes : undefined,            // Indexed with the node's index\n            nodesByName : undefined,      // Indexed with name property in the node\n            skinnedNodes : undefined,\n            meshesByName : undefined,     // Indexed with the name property in the mesh\n            materialsByName : undefined,  // Indexed with the name property in the material\n            materialsById : undefined     // Indexed with the material's index\n        };\n\n        this._uniformMaps = {};           // Not cached since it can be targeted by glTF animation\n        this._extensionsUsed = undefined;     // Cached used glTF extensions\n        this._extensionsRequired = undefined; // Cached required glTF extensions\n        this._quantizedUniforms = {};     // Quantized uniforms for each program for WEB3D_quantized_attributes\n        this._programPrimitives = {};\n        this._rendererResources = {       // Cached between models with the same url/cache-key\n            buffers : {},\n            vertexArrays : {},\n            programs : {},\n            sourceShaders : {},\n            silhouettePrograms : {},\n            textures : {},\n            samplers : {},\n            renderStates : {}\n        };\n        this._cachedRendererResources = undefined;\n        this._loadRendererResourcesFromCache = false;\n\n        this._dequantizeInShader = defaultValue(options.dequantizeInShader, true);\n        this._decodedData = {};\n\n        this._cachedGeometryByteLength = 0;\n        this._cachedTexturesByteLength = 0;\n        this._geometryByteLength = 0;\n        this._texturesByteLength = 0;\n        this._trianglesLength = 0;\n\n        // Hold references for shader reconstruction.\n        // Hold these separately because _cachedGltf may get released (this.releaseGltfJson)\n        this._sourceTechniques = {};\n        this._sourcePrograms = {};\n        this._quantizedVertexShaders = {};\n\n        this._nodeCommands = [];\n        this._pickIds = [];\n\n        // CESIUM_RTC extension\n        this._rtcCenter = undefined;    // reference to either 3D or 2D\n        this._rtcCenterEye = undefined; // in eye coordinates\n        this._rtcCenter3D = undefined;  // in world coordinates\n        this._rtcCenter2D = undefined;  // in projected world coordinates\n\n        this._sourceVersion = undefined;\n        this._sourceKHRTechniquesWebGL = undefined;\n\n        this._imageBasedLightingFactor = new Cartesian2(1.0, 1.0);\n        Cartesian2.clone(options.imageBasedLightingFactor, this._imageBasedLightingFactor);\n        this._lightColor = Cartesian3.clone(options.lightColor);\n\n        this._luminanceAtZenith = undefined;\n        this.luminanceAtZenith = defaultValue(options.luminanceAtZenith, 0.2);\n\n        this._sphericalHarmonicCoefficients = options.sphericalHarmonicCoefficients;\n        this._specularEnvironmentMaps = options.specularEnvironmentMaps;\n        this._shouldUpdateSpecularMapAtlas = true;\n        this._specularEnvironmentMapAtlas = undefined;\n\n        this._useDefaultSphericalHarmonics = false;\n        this._useDefaultSpecularMaps = false;\n\n        this._shouldRegenerateShaders = false;\n    }\n\n    defineProperties(Model.prototype, {\n        /**\n         * The object for the glTF JSON, including properties with default values omitted\n         * from the JSON provided to this model.\n         *\n         * @memberof Model.prototype\n         *\n         * @type {Object}\n         * @readonly\n         *\n         * @default undefined\n         */\n        gltf : {\n            get : function() {\n                return defined(this._cachedGltf) ? this._cachedGltf.gltf : undefined;\n            }\n        },\n\n        /**\n         * When <code>true</code>, the glTF JSON is not stored with the model once the model is\n         * loaded (when {@link Model#ready} is <code>true</code>).  This saves memory when\n         * geometry, textures, and animations are embedded in the .gltf file.\n         * This is especially useful for cases like 3D buildings, where each .gltf model is unique\n         * and caching the glTF JSON is not effective.\n         *\n         * @memberof Model.prototype\n         *\n         * @type {Boolean}\n         * @readonly\n         *\n         * @default false\n         *\n         * @private\n         */\n        releaseGltfJson : {\n            get : function() {\n                return this._releaseGltfJson;\n            }\n        },\n\n        /**\n         * The key identifying this model in the model cache for glTF JSON, renderer resources, and animations.\n         * Caching saves memory and improves loading speed when several models with the same url are created.\n         * <p>\n         * This key is automatically generated when the model is created with {@link Model.fromGltf}.  If the model\n         * is created directly from glTF JSON using the {@link Model} constructor, this key can be manually\n         * provided; otherwise, the model will not be changed.\n         * </p>\n         *\n         * @memberof Model.prototype\n         *\n         * @type {String}\n         * @readonly\n         *\n         * @private\n         */\n        cacheKey : {\n            get : function() {\n                return this._cacheKey;\n            }\n        },\n\n        /**\n         * The base path that paths in the glTF JSON are relative to.  The base\n         * path is the same path as the path containing the .gltf file\n         * minus the .gltf file, when binary, image, and shader files are\n         * in the same directory as the .gltf.  When this is <code>''</code>,\n         * the app's base path is used.\n         *\n         * @memberof Model.prototype\n         *\n         * @type {String}\n         * @readonly\n         *\n         * @default ''\n         */\n        basePath : {\n            get : function() {\n                return this._resource.url;\n            }\n        },\n\n        /**\n         * The model's bounding sphere in its local coordinate system.  This does not take into\n         * account glTF animations and skins nor does it take into account {@link Model#minimumPixelSize}.\n         *\n         * @memberof Model.prototype\n         *\n         * @type {BoundingSphere}\n         * @readonly\n         *\n         * @default undefined\n         *\n         * @exception {DeveloperError} The model is not loaded.  Use Model.readyPromise or wait for Model.ready to be true.\n         *\n         * @example\n         * // Center in WGS84 coordinates\n         * var center = Cesium.Matrix4.multiplyByPoint(model.modelMatrix, model.boundingSphere.center, new Cesium.Cartesian3());\n         */\n        boundingSphere : {\n            get : function() {\n                \n\n                var modelMatrix = this.modelMatrix;\n                if ((this.heightReference !== HeightReference.NONE) && this._clampedModelMatrix) {\n                    modelMatrix = this._clampedModelMatrix;\n                }\n\n                var nonUniformScale = Matrix4.getScale(modelMatrix, boundingSphereCartesian3Scratch);\n                var scale = defined(this.maximumScale) ? Math.min(this.maximumScale, this.scale) : this.scale;\n                Cartesian3.multiplyByScalar(nonUniformScale, scale, nonUniformScale);\n\n                var scaledBoundingSphere = this._scaledBoundingSphere;\n                scaledBoundingSphere.center = Cartesian3.multiplyComponents(this._boundingSphere.center, nonUniformScale, scaledBoundingSphere.center);\n                scaledBoundingSphere.radius = Cartesian3.maximumComponent(nonUniformScale) * this._initialRadius;\n\n                if (defined(this._rtcCenter)) {\n                    Cartesian3.add(this._rtcCenter, scaledBoundingSphere.center, scaledBoundingSphere.center);\n                }\n\n                return scaledBoundingSphere;\n            }\n        },\n\n        /**\n         * When <code>true</code>, this model is ready to render, i.e., the external binary, image,\n         * and shader files were downloaded and the WebGL resources were created.  This is set to\n         * <code>true</code> right before {@link Model#readyPromise} is resolved.\n         *\n         * @memberof Model.prototype\n         *\n         * @type {Boolean}\n         * @readonly\n         *\n         * @default false\n         */\n        ready : {\n            get : function() {\n                return this._ready;\n            }\n        },\n\n        /**\n         * Gets the promise that will be resolved when this model is ready to render, i.e., when the external binary, image,\n         * and shader files were downloaded and the WebGL resources were created.\n         * <p>\n         * This promise is resolved at the end of the frame before the first frame the model is rendered in.\n         * </p>\n         *\n         * @memberof Model.prototype\n         * @type {Promise.<Model>}\n         * @readonly\n         *\n         * @example\n         * // Play all animations at half-speed when the model is ready to render\n         * Cesium.when(model.readyPromise).then(function(model) {\n         *   model.activeAnimations.addAll({\n         *     multiplier : 0.5\n         *   });\n         * }).otherwise(function(error){\n         *   window.alert(error);\n         * });\n         *\n         * @see Model#ready\n         */\n        readyPromise : {\n            get : function() {\n                return this._readyPromise.promise;\n            }\n        },\n\n        /**\n         * Determines if model WebGL resource creation will be spread out over several frames or\n         * block until completion once all glTF files are loaded.\n         *\n         * @memberof Model.prototype\n         *\n         * @type {Boolean}\n         * @readonly\n         *\n         * @default true\n         */\n        asynchronous : {\n            get : function() {\n                return this._asynchronous;\n            }\n        },\n\n        /**\n         * When <code>true</code>, each glTF mesh and primitive is pickable with {@link Scene#pick}.  When <code>false</code>, GPU memory is saved.\n         *\n         * @memberof Model.prototype\n         *\n         * @type {Boolean}\n         * @readonly\n         *\n         * @default true\n         */\n        allowPicking : {\n            get : function() {\n                return this._allowPicking;\n            }\n        },\n\n        /**\n         * Determine if textures may continue to stream in after the model is loaded.\n         *\n         * @memberof Model.prototype\n         *\n         * @type {Boolean}\n         * @readonly\n         *\n         * @default true\n         */\n        incrementallyLoadTextures : {\n            get : function() {\n                return this._incrementallyLoadTextures;\n            }\n        },\n\n        /**\n         * Return the number of pending texture loads.\n         *\n         * @memberof Model.prototype\n         *\n         * @type {Number}\n         * @readonly\n         */\n        pendingTextureLoads : {\n            get : function() {\n                return defined(this._loadResources) ? this._loadResources.pendingTextureLoads : 0;\n            }\n        },\n\n        /**\n         * Returns true if the model was transformed this frame\n         *\n         * @memberof Model.prototype\n         *\n         * @type {Boolean}\n         * @readonly\n         *\n         * @private\n         */\n        dirty : {\n            get : function() {\n                return this._dirty;\n            }\n        },\n\n        /**\n         * Gets or sets the condition specifying at what distance from the camera that this model will be displayed.\n         * @memberof Model.prototype\n         * @type {DistanceDisplayCondition}\n         * @default undefined\n         */\n        distanceDisplayCondition : {\n            get : function() {\n                return this._distanceDisplayCondition;\n            },\n            set : function(value) {\n                \n                this._distanceDisplayCondition = DistanceDisplayCondition.clone(value, this._distanceDisplayCondition);\n            }\n        },\n\n        extensionsUsed : {\n            get : function() {\n                if (!defined(this._extensionsUsed)) {\n                    this._extensionsUsed = ModelUtility.getUsedExtensions(this.gltf);\n                }\n                return this._extensionsUsed;\n            }\n        },\n\n        extensionsRequired : {\n            get : function() {\n                if (!defined(this._extensionsRequired)) {\n                    this._extensionsRequired = ModelUtility.getRequiredExtensions(this.gltf);\n                }\n                return this._extensionsRequired;\n            }\n        },\n\n        /**\n         * Gets the model's up-axis.\n         * By default models are y-up according to the glTF spec, however geo-referenced models will typically be z-up.\n         *\n         * @memberof Model.prototype\n         *\n         * @type {Number}\n         * @default Axis.Y\n         * @readonly\n         *\n         * @private\n         */\n        upAxis : {\n            get : function() {\n                return this._upAxis;\n            }\n        },\n\n        /**\n         * Gets the model's forward axis.\n         * By default, glTF 2.0 models are z-forward according to the glTF spec, however older\n         * glTF (1.0, 0.8) models used x-forward.  Note that only Axis.X and Axis.Z are supported.\n         *\n         * @memberof Model.prototype\n         *\n         * @type {Number}\n         * @default Axis.Z\n         * @readonly\n         *\n         * @private\n         */\n        forwardAxis : {\n            get : function() {\n                if (defined(this._forwardAxis)) {\n                    return this._forwardAxis;\n                }\n                return this._gltfForwardAxis;\n            }\n        },\n\n        /**\n         * Gets the model's triangle count.\n         *\n         * @private\n         */\n        trianglesLength : {\n            get : function() {\n                return this._trianglesLength;\n            }\n        },\n\n        /**\n         * Gets the model's geometry memory in bytes. This includes all vertex and index buffers.\n         *\n         * @private\n         */\n        geometryByteLength : {\n            get : function() {\n                return this._geometryByteLength;\n            }\n        },\n\n        /**\n         * Gets the model's texture memory in bytes.\n         *\n         * @private\n         */\n        texturesByteLength : {\n            get : function() {\n                return this._texturesByteLength;\n            }\n        },\n\n        /**\n         * Gets the model's cached geometry memory in bytes. This includes all vertex and index buffers.\n         *\n         * @private\n         */\n        cachedGeometryByteLength : {\n            get : function() {\n                return this._cachedGeometryByteLength;\n            }\n        },\n\n        /**\n         * Gets the model's cached texture memory in bytes.\n         *\n         * @private\n         */\n        cachedTexturesByteLength : {\n            get : function() {\n                return this._cachedTexturesByteLength;\n            }\n        },\n\n        /**\n         * The {@link ClippingPlaneCollection} used to selectively disable rendering the model.\n         *\n         * @memberof Model.prototype\n         *\n         * @type {ClippingPlaneCollection}\n         */\n        clippingPlanes : {\n            get : function() {\n                return this._clippingPlanes;\n            },\n            set : function(value) {\n                if (value === this._clippingPlanes) {\n                    return;\n                }\n                // Handle destroying, checking of unknown, checking for existing ownership\n                ClippingPlaneCollection.setOwner(value, this, '_clippingPlanes');\n            }\n        },\n\n        /**\n         * @private\n         */\n        pickIds : {\n            get : function() {\n                return this._pickIds;\n            }\n        },\n\n        /**\n         * Cesium adds lighting from the earth, sky, atmosphere, and star skybox. This cartesian is used to scale the final\n         * diffuse and specular lighting contribution from those sources to the final color. A value of 0.0 will disable those light sources.\n         *\n         * @memberof Model.prototype\n         *\n         * @type {Cartesian2}\n         * @default Cartesian2(1.0, 1.0)\n         */\n        imageBasedLightingFactor : {\n            get : function() {\n                return this._imageBasedLightingFactor;\n            },\n            set : function(value) {\n                \n                var imageBasedLightingFactor = this._imageBasedLightingFactor;\n                if ((value === imageBasedLightingFactor) || Cartesian2.equals(value, imageBasedLightingFactor)) {\n                    return;\n                }\n                this._shouldRegenerateShaders = this._shouldRegenerateShaders || (this._imageBasedLightingFactor.x > 0.0 && value.x === 0.0) || (this._imageBasedLightingFactor.x === 0.0 && value.x > 0.0);\n                this._shouldRegenerateShaders = this._shouldRegenerateShaders || (this._imageBasedLightingFactor.y > 0.0 && value.y === 0.0) || (this._imageBasedLightingFactor.y === 0.0 && value.y > 0.0);\n                Cartesian2.clone(value, this._imageBasedLightingFactor);\n            }\n        },\n\n        /**\n         * The light color when shading the model. When <code>undefined</code> the scene's light color are used instead.\n         * <p>\n         * For example, disabling additional light sources by setting <code>model.imageBasedLightingFactor = new Cesium.Cartesian2(0.0, 0.0)</code> will make the\n         * model much darker. Here, increasing the intensity of the light source will make the model brighter.\n         * </p>\n         *\n         * @memberof Model.prototype\n         *\n         * @type {Cartesian3}\n         * @default undefined\n         */\n        lightColor : {\n            get : function() {\n                return this._lightColor;\n            },\n            set : function(value) {\n                var lightColor = this._lightColor;\n                if (value === lightColor || Cartesian3.equals(value, lightColor)) {\n                    return;\n                }\n                this._shouldRegenerateShaders = this._shouldRegenerateShaders || (defined(lightColor) && !defined(value)) || (defined(value) && !defined(lightColor));\n                this._lightColor = Cartesian3.clone(value, lightColor);\n            }\n        },\n\n        /**\n         * The sun's luminance at the zenith in kilo candela per meter squared to use for this model's procedural environment map.\n         * This is used when {@link Model#specularEnvironmentMaps} and {@link Model#sphericalHarmonicCoefficients} are not defined.\n         *\n         * @memberof Model.prototype\n         *\n         * @demo {@link https://sandcastle.cesium.com/index.html?src=Image-Based Lighting.html|Sandcastle Image Based Lighting Demo}\n         * @type {Number}\n         * @default 0.2\n         */\n        luminanceAtZenith : {\n            get : function() {\n                return this._luminanceAtZenith;\n            },\n            set : function(value) {\n                var lum = this._luminanceAtZenith;\n                if (value === lum) {\n                    return;\n                }\n                this._shouldRegenerateShaders = this._shouldRegenerateShaders || (defined(lum) && !defined(value)) || (defined(value) && !defined(lum));\n                this._luminanceAtZenith = value;\n            }\n        },\n\n        /**\n         * The third order spherical harmonic coefficients used for the diffuse color of image-based lighting. When <code>undefined</code>, a diffuse irradiance\n         * computed from the atmosphere color is used.\n         * <p>\n         * There are nine <code>Cartesian3</code> coefficients.\n         * The order of the coefficients is: L<sub>00</sub>, L<sub>1-1</sub>, L<sub>10</sub>, L<sub>11</sub>, L<sub>2-2</sub>, L<sub>2-1</sub>, L<sub>20</sub>, L<sub>21</sub>, L<sub>22</sub>\n         * </p>\n         *\n         * These values can be obtained by preprocessing the environment map using the <code>cmgen</code> tool of\n         * {@link https://github.com/google/filament/releases|Google's Filament project}. This will also generate a KTX file that can be\n         * supplied to {@link Model#specularEnvironmentMaps}.\n         *\n         * @memberof Model.prototype\n         *\n         * @type {Cartesian3[]}\n         * @demo {@link https://sandcastle.cesium.com/index.html?src=Image-Based Lighting.html|Sandcastle Image Based Lighting Demo}\n         * @see {@link https://graphics.stanford.edu/papers/envmap/envmap.pdf|An Efficient Representation for Irradiance Environment Maps}\n         */\n        sphericalHarmonicCoefficients : {\n            get : function() {\n                return this._sphericalHarmonicCoefficients;\n            },\n            set : function(value) {\n                \n                if (value === this._sphericalHarmonicCoefficients) {\n                    return;\n                }\n                this._sphericalHarmonicCoefficients = value;\n                this._shouldRegenerateShaders = true;\n            }\n        },\n\n        /**\n         * A URL to a KTX file that contains a cube map of the specular lighting and the convoluted specular mipmaps.\n         *\n         * @memberof Model.prototype\n         * @demo {@link https://sandcastle.cesium.com/index.html?src=Image-Based Lighting.html|Sandcastle Image Based Lighting Demo}\n         * @type {String}\n         * @see Model#sphericalHarmonicCoefficients\n         */\n        specularEnvironmentMaps : {\n            get : function() {\n                return this._specularEnvironmentMaps;\n            },\n            set : function(value) {\n                this._shouldUpdateSpecularMapAtlas = this._shouldUpdateSpecularMapAtlas || value !== this._specularEnvironmentMaps;\n                this._specularEnvironmentMaps = value;\n            }\n        },\n        /**\n         * Gets the credit that will be displayed for the model\n         * @memberof Model.prototype\n         * @type {Credit}\n         */\n        credit : {\n            get : function() {\n                return this._credit;\n            }\n        }\n    });\n\n    function silhouetteSupported(context) {\n        return context.stencilBuffer;\n    }\n\n    function isColorShadingEnabled(model) {\n        return !Color.equals(model.color, Color.WHITE) || (model.colorBlendMode !== ColorBlendMode.HIGHLIGHT);\n    }\n\n    function isClippingEnabled(model) {\n        var clippingPlanes = model._clippingPlanes;\n        return defined(clippingPlanes) && clippingPlanes.enabled && clippingPlanes.length !== 0;\n    }\n\n    /**\n     * Determines if silhouettes are supported.\n     *\n     * @param {Scene} scene The scene.\n     * @returns {Boolean} <code>true</code> if silhouettes are supported; otherwise, returns <code>false</code>\n     */\n    Model.silhouetteSupported = function(scene) {\n        return silhouetteSupported(scene.context);\n    };\n\n    function containsGltfMagic(uint8Array) {\n        var magic = getMagic(uint8Array);\n        return magic === 'glTF';\n    }\n\n    /**\n     * <p>\n     * Creates a model from a glTF asset.  When the model is ready to render, i.e., when the external binary, image,\n     * and shader files are downloaded and the WebGL resources are created, the {@link Model#readyPromise} is resolved.\n     * </p>\n     * <p>\n     * The model can be a traditional glTF asset with a .gltf extension or a Binary glTF using the .glb extension.\n     * </p>\n     * <p>\n     * Cesium supports glTF assets with the following extensions:\n     * <ul>\n     * <li>\n     * {@link https://github.com/KhronosGroup/glTF/blob/master/extensions/1.0/Khronos/KHR_binary_glTF/README.md|KHR_binary_glTF (glTF 1.0)}\n     * </li><li>\n     * {@link https://github.com/KhronosGroup/glTF/blob/master/extensions/1.0/Khronos/KHR_materials_common/README.md|KHR_materials_common (glTF 1.0)}\n     * </li><li>\n     * {@link https://github.com/KhronosGroup/glTF/blob/master/extensions/1.0/Vendor/WEB3D_quantized_attributes/README.md|WEB3D_quantized_attributes (glTF 1.0)}\n     * </li><li>\n     * {@link https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/AGI_articulations/README.md|AGI_articulations}\n     * </li><li>\n     * {@link https://github.com/KhronosGroup/glTF/pull/1302|KHR_blend (draft)}\n     * </li><li>\n     * {@link https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_draco_mesh_compression/README.md|KHR_draco_mesh_compression}\n     * </li><li>\n     * {@link https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_pbrSpecularGlossiness/README.md|KHR_materials_pbrSpecularGlossiness}\n     * </li><li>\n     * {@link https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit/README.md|KHR_materials_unlit}\n     * </li><li>\n     * {@link https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_techniques_webgl/README.md|KHR_techniques_webgl}\n     * </li><li>\n     * {@link https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_texture_transform/README.md|KHR_texture_transform}\n     * </li>\n     * </ul>\n     * </p>\n     * <p>\n     * For high-precision rendering, Cesium supports the {@link https://github.com/KhronosGroup/glTF/blob/master/extensions/1.0/Vendor/CESIUM_RTC/README.md|CESIUM_RTC} extension, which introduces the\n     * CESIUM_RTC_MODELVIEW parameter semantic that says the node is in WGS84 coordinates translated\n     * relative to a local origin.\n     * </p>\n     *\n     * @param {Object} options Object with the following properties:\n     * @param {Resource|String} options.url The url to the .gltf file.\n     * @param {Resource|String} [options.basePath] The base path that paths in the glTF JSON are relative to.\n     * @param {Boolean} [options.show=true] Determines if the model primitive will be shown.\n     * @param {Matrix4} [options.modelMatrix=Matrix4.IDENTITY] The 4x4 transformation matrix that transforms the model from model to world coordinates.\n     * @param {Number} [options.scale=1.0] A uniform scale applied to this model.\n     * @param {Number} [options.minimumPixelSize=0.0] The approximate minimum pixel size of the model regardless of zoom.\n     * @param {Number} [options.maximumScale] The maximum scale for the model.\n     * @param {Object} [options.id] A user-defined object to return when the model is picked with {@link Scene#pick}.\n     * @param {Boolean} [options.allowPicking=true] When <code>true</code>, each glTF mesh and primitive is pickable with {@link Scene#pick}.\n     * @param {Boolean} [options.incrementallyLoadTextures=true] Determine if textures may continue to stream in after the model is loaded.\n     * @param {Boolean} [options.asynchronous=true] Determines if model WebGL resource creation will be spread out over several frames or block until completion once all glTF files are loaded.\n     * @param {Boolean} [options.clampAnimations=true] Determines if the model's animations should hold a pose over frames where no keyframes are specified.\n     * @param {ShadowMode} [options.shadows=ShadowMode.ENABLED] Determines whether the model casts or receives shadows from light sources.\n     * @param {Boolean} [options.debugShowBoundingVolume=false] For debugging only. Draws the bounding sphere for each draw command in the model.\n     * @param {Boolean} [options.debugWireframe=false] For debugging only. Draws the model in wireframe.\n     * @param {HeightReference} [options.heightReference=HeightReference.NONE] Determines how the model is drawn relative to terrain.\n     * @param {Scene} [options.scene] Must be passed in for models that use the height reference property.\n     * @param {DistanceDisplayCondition} [options.distanceDisplayCondition] The condition specifying at what distance from the camera that this model will be displayed.\n     * @param {Color} [options.color=Color.WHITE] A color that blends with the model's rendered color.\n     * @param {ColorBlendMode} [options.colorBlendMode=ColorBlendMode.HIGHLIGHT] Defines how the color blends with the model.\n     * @param {Number} [options.colorBlendAmount=0.5] Value used to determine the color strength when the <code>colorBlendMode</code> is <code>MIX</code>. A value of 0.0 results in the model's rendered color while a value of 1.0 results in a solid color, with any value in-between resulting in a mix of the two.\n     * @param {Color} [options.silhouetteColor=Color.RED] The silhouette color. If more than 256 models have silhouettes enabled, there is a small chance that overlapping models will have minor artifacts.\n     * @param {Number} [options.silhouetteSize=0.0] The size of the silhouette in pixels.\n     * @param {ClippingPlaneCollection} [options.clippingPlanes] The {@link ClippingPlaneCollection} used to selectively disable rendering the model.\n     * @param {Boolean} [options.dequantizeInShader=true] Determines if a {@link https://github.com/google/draco|Draco} encoded model is dequantized on the GPU. This decreases total memory usage for encoded models.\n     * @param {Credit|String} [options.credit] A credit for the model, which is displayed on the canvas.\n     *\n     * @returns {Model} The newly created model.\n     *\n     * @example\n     * // Example 1. Create a model from a glTF asset\n     * var model = scene.primitives.add(Cesium.Model.fromGltf({\n     *   url : './duck/duck.gltf'\n     * }));\n     *\n     * @example\n     * // Example 2. Create model and provide all properties and events\n     * var origin = Cesium.Cartesian3.fromDegrees(-95.0, 40.0, 200000.0);\n     * var modelMatrix = Cesium.Transforms.eastNorthUpToFixedFrame(origin);\n     *\n     * var model = scene.primitives.add(Cesium.Model.fromGltf({\n     *   url : './duck/duck.gltf',\n     *   show : true,                     // default\n     *   modelMatrix : modelMatrix,\n     *   scale : 2.0,                     // double size\n     *   minimumPixelSize : 128,          // never smaller than 128 pixels\n     *   maximumScale: 20000,             // never larger than 20000 * model size (overrides minimumPixelSize)\n     *   allowPicking : false,            // not pickable\n     *   debugShowBoundingVolume : false, // default\n     *   debugWireframe : false\n     * }));\n     *\n     * model.readyPromise.then(function(model) {\n     *   // Play all animations when the model is ready to render\n     *   model.activeAnimations.addAll();\n     * });\n     */\n    Model.fromGltf = function(options) {\n        \n\n        var url = options.url;\n        options = clone(options);\n\n        // Create resource for the model file\n        var modelResource = Resource.createIfNeeded(url);\n\n        // Setup basePath to get dependent files\n        var basePath = defaultValue(options.basePath, modelResource.clone());\n        var resource = Resource.createIfNeeded(basePath);\n\n        // If no cache key is provided, use a GUID.\n        // Check using a URI to GUID dictionary that we have not already added this model.\n        var cacheKey = defaultValue(options.cacheKey, uriToGuid[getAbsoluteUri(modelResource.url)]);\n        if (!defined(cacheKey)) {\n            cacheKey = createGuid();\n            uriToGuid[getAbsoluteUri(modelResource.url)] = cacheKey;\n        }\n\n        if (defined(options.basePath) && !defined(options.cacheKey)) {\n            cacheKey += resource.url;\n        }\n        options.cacheKey = cacheKey;\n        options.basePath = resource;\n\n        var model = new Model(options);\n\n        var cachedGltf = gltfCache[cacheKey];\n        if (!defined(cachedGltf)) {\n            cachedGltf = new CachedGltf({\n                ready : false\n            });\n            cachedGltf.count = 1;\n            cachedGltf.modelsToLoad.push(model);\n            setCachedGltf(model, cachedGltf);\n            gltfCache[cacheKey] = cachedGltf;\n\n            // Add Accept header if we need it\n            if (!defined(modelResource.headers.Accept)) {\n                modelResource.headers.Accept = defaultModelAccept;\n            }\n\n            modelResource.fetchArrayBuffer().then(function(arrayBuffer) {\n                var array = new Uint8Array(arrayBuffer);\n                if (containsGltfMagic(array)) {\n                    // Load binary glTF\n                    var parsedGltf = parseGlb(array);\n                    cachedGltf.makeReady(parsedGltf);\n                } else {\n                    // Load text (JSON) glTF\n                    var json = getStringFromTypedArray(array);\n                    cachedGltf.makeReady(JSON.parse(json));\n                }\n\n                var resourceCredits = model._resourceCredits;\n                var credits = modelResource.credits;\n                if (defined(credits)) {\n                    var length = credits.length;\n                    for (var i = 0; i < length; i++) {\n                        resourceCredits.push(credits[i]);\n                    }\n                }\n            }).otherwise(ModelUtility.getFailedLoadFunction(model, 'model', modelResource.url));\n        } else if (!cachedGltf.ready) {\n            // Cache hit but the fetchArrayBuffer() or fetchText() request is still pending\n            ++cachedGltf.count;\n            cachedGltf.modelsToLoad.push(model);\n        }\n        // else if the cached glTF is defined and ready, the\n        // model constructor will pick it up using the cache key.\n\n        return model;\n    };\n\n    /**\n     * For the unit tests to verify model caching.\n     *\n     * @private\n     */\n    Model._gltfCache = gltfCache;\n\n    function getRuntime(model, runtimeName, name) {\n        \n\n        return (model._runtime[runtimeName])[name];\n    }\n\n    /**\n     * Returns the glTF node with the given <code>name</code> property.  This is used to\n     * modify a node's transform for animation outside of glTF animations.\n     *\n     * @param {String} name The glTF name of the node.\n     * @returns {ModelNode} The node or <code>undefined</code> if no node with <code>name</code> exists.\n     *\n     * @exception {DeveloperError} The model is not loaded.  Use Model.readyPromise or wait for Model.ready to be true.\n     *\n     * @example\n     * // Apply non-uniform scale to node LOD3sp\n     * var node = model.getNode('LOD3sp');\n     * node.matrix = Cesium.Matrix4.fromScale(new Cesium.Cartesian3(5.0, 1.0, 1.0), node.matrix);\n     */\n    Model.prototype.getNode = function(name) {\n        var node = getRuntime(this, 'nodesByName', name);\n        return defined(node) ? node.publicNode : undefined;\n    };\n\n    /**\n     * Returns the glTF mesh with the given <code>name</code> property.\n     *\n     * @param {String} name The glTF name of the mesh.\n     *\n     * @returns {ModelMesh} The mesh or <code>undefined</code> if no mesh with <code>name</code> exists.\n     *\n     * @exception {DeveloperError} The model is not loaded.  Use Model.readyPromise or wait for Model.ready to be true.\n     */\n    Model.prototype.getMesh = function(name) {\n        return getRuntime(this, 'meshesByName', name);\n    };\n\n    /**\n     * Returns the glTF material with the given <code>name</code> property.\n     *\n     * @param {String} name The glTF name of the material.\n     * @returns {ModelMaterial} The material or <code>undefined</code> if no material with <code>name</code> exists.\n     *\n     * @exception {DeveloperError} The model is not loaded.  Use Model.readyPromise or wait for Model.ready to be true.\n     */\n    Model.prototype.getMaterial = function(name) {\n        return getRuntime(this, 'materialsByName', name);\n    };\n\n    /**\n     * Sets the current value of an articulation stage.  After setting one or multiple stage values, call\n     * Model.applyArticulations() to cause the node matrices to be recalculated.\n     *\n     * @param {String} articulationStageKey The name of the articulation, a space, and the name of the stage.\n     * @param {Number} value The numeric value of this stage of the articulation.\n     *\n     * @exception {DeveloperError} The model is not loaded.  Use Model.readyPromise or wait for Model.ready to be true.\n     *\n     * @see Model#applyArticulations\n     */\n    Model.prototype.setArticulationStage = function(articulationStageKey, value) {\n        \n\n        var stage = getRuntime(this, 'stagesByKey', articulationStageKey);\n        var articulation = getRuntime(this, 'articulationsByStageKey', articulationStageKey);\n        if (defined(stage) && defined(articulation)) {\n            value = CesiumMath.clamp(value, stage.minimumValue, stage.maximumValue);\n            if (!CesiumMath.equalsEpsilon(stage.currentValue, value, articulationEpsilon)) {\n                stage.currentValue = value;\n                articulation.isDirty = true;\n            }\n        }\n    };\n\n    var scratchArticulationCartesian = new Cartesian3();\n    var scratchArticulationRotation = new Matrix3();\n\n    /**\n     * Modifies a Matrix4 by applying a transformation for a given value of a stage.  Note this is different usage\n     * from the typical <code>result</code> parameter, in that the incoming value of <code>result</code> is\n     * meaningful.  Various stages of an articulation can be multiplied together, so their\n     * transformations are all merged into a composite Matrix4 representing them all.\n     *\n     * @param {object} stage The stage of an articulation that is being evaluated.\n     * @param {Matrix4} result The matrix to be modified.\n     * @returns {Matrix4} A matrix transformed as requested by the articulation stage.\n     *\n     * @private\n     */\n    function applyArticulationStageMatrix(stage, result) {\n        \n\n        var value = stage.currentValue;\n        var cartesian = scratchArticulationCartesian;\n        var rotation;\n        switch (stage.type) {\n            case 'xRotate':\n                rotation = Matrix3.fromRotationX(CesiumMath.toRadians(value), scratchArticulationRotation);\n                Matrix4.multiplyByMatrix3(result, rotation, result);\n                break;\n            case 'yRotate':\n                rotation = Matrix3.fromRotationY(CesiumMath.toRadians(value), scratchArticulationRotation);\n                Matrix4.multiplyByMatrix3(result, rotation, result);\n                break;\n            case 'zRotate':\n                rotation = Matrix3.fromRotationZ(CesiumMath.toRadians(value), scratchArticulationRotation);\n                Matrix4.multiplyByMatrix3(result, rotation, result);\n                break;\n            case 'xTranslate':\n                cartesian.x = value;\n                cartesian.y = 0.0;\n                cartesian.z = 0.0;\n                Matrix4.multiplyByTranslation(result, cartesian, result);\n                break;\n            case 'yTranslate':\n                cartesian.x = 0.0;\n                cartesian.y = value;\n                cartesian.z = 0.0;\n                Matrix4.multiplyByTranslation(result, cartesian, result);\n                break;\n            case 'zTranslate':\n                cartesian.x = 0.0;\n                cartesian.y = 0.0;\n                cartesian.z = value;\n                Matrix4.multiplyByTranslation(result, cartesian, result);\n                break;\n            case 'xScale':\n                cartesian.x = value;\n                cartesian.y = 1.0;\n                cartesian.z = 1.0;\n                Matrix4.multiplyByScale(result, cartesian, result);\n                break;\n            case 'yScale':\n                cartesian.x = 1.0;\n                cartesian.y = value;\n                cartesian.z = 1.0;\n                Matrix4.multiplyByScale(result, cartesian, result);\n                break;\n            case 'zScale':\n                cartesian.x = 1.0;\n                cartesian.y = 1.0;\n                cartesian.z = value;\n                Matrix4.multiplyByScale(result, cartesian, result);\n                break;\n            case 'uniformScale':\n                Matrix4.multiplyByUniformScale(result, value, result);\n                break;\n            default:\n                break;\n        }\n        return result;\n    }\n\n    var scratchApplyArticulationTransform = new Matrix4();\n\n    /**\n     * Applies any modified articulation stages to the matrix of each node that participates\n     * in any articulation.  Note that this will overwrite any nodeTransformations on participating nodes.\n     *\n     * @exception {DeveloperError} The model is not loaded.  Use Model.readyPromise or wait for Model.ready to be true.\n     */\n    Model.prototype.applyArticulations = function() {\n        var articulationsByName = this._runtime.articulationsByName;\n        for (var articulationName in articulationsByName) {\n            if (articulationsByName.hasOwnProperty(articulationName)) {\n                var articulation = articulationsByName[articulationName];\n                if (articulation.isDirty) {\n                    articulation.isDirty = false;\n                    var numNodes = articulation.nodes.length;\n                    for (var n = 0; n < numNodes; ++n) {\n                        var node = articulation.nodes[n];\n                        var transform = Matrix4.clone(node.originalMatrix, scratchApplyArticulationTransform);\n\n                        var numStages = articulation.stages.length;\n                        for (var s = 0; s < numStages; ++s) {\n                            var stage = articulation.stages[s];\n                            transform = applyArticulationStageMatrix(stage, transform);\n                        }\n                        node.matrix = transform;\n                    }\n                }\n            }\n        }\n    };\n\n    ///////////////////////////////////////////////////////////////////////////\n\n    function addBuffersToLoadResources(model) {\n        var gltf = model.gltf;\n        var loadResources = model._loadResources;\n        ForEach.buffer(gltf, function(buffer, id) {\n            loadResources.buffers[id] = buffer.extras._pipeline.source;\n        });\n    }\n\n    function bufferLoad(model, id) {\n        return function(arrayBuffer) {\n            var loadResources = model._loadResources;\n            var buffer = new Uint8Array(arrayBuffer);\n            --loadResources.pendingBufferLoads;\n            model.gltf.buffers[id].extras._pipeline.source = buffer;\n        };\n    }\n\n    function parseBufferViews(model) {\n        var bufferViews = model.gltf.bufferViews;\n        var vertexBuffersToCreate = model._loadResources.vertexBuffersToCreate;\n\n        // Only ARRAY_BUFFER here.  ELEMENT_ARRAY_BUFFER created below.\n        ForEach.bufferView(model.gltf, function(bufferView, id) {\n            if (bufferView.target === WebGLConstants.ARRAY_BUFFER) {\n                vertexBuffersToCreate.enqueue(id);\n            }\n        });\n\n        var indexBuffersToCreate = model._loadResources.indexBuffersToCreate;\n        var indexBufferIds = {};\n\n        // The Cesium Renderer requires knowing the datatype for an index buffer\n        // at creation type, which is not part of the glTF bufferview so loop\n        // through glTF accessors to create the bufferview's index buffer.\n        ForEach.accessor(model.gltf, function(accessor) {\n            var bufferViewId = accessor.bufferView;\n            if (!defined(bufferViewId)) {\n                return;\n            }\n\n            var bufferView = bufferViews[bufferViewId];\n            if ((bufferView.target === WebGLConstants.ELEMENT_ARRAY_BUFFER) && !defined(indexBufferIds[bufferViewId])) {\n                indexBufferIds[bufferViewId] = true;\n                indexBuffersToCreate.enqueue({\n                    id : bufferViewId,\n                    componentType : accessor.componentType\n                });\n            }\n        });\n    }\n\n    function parseTechniques(model) {\n        // retain references to gltf techniques\n        var gltf = model.gltf;\n        if (!hasExtension(gltf, 'KHR_techniques_webgl')) {\n            return;\n        }\n\n        var sourcePrograms = model._sourcePrograms;\n        var sourceTechniques = model._sourceTechniques;\n        var programs = gltf.extensions.KHR_techniques_webgl.programs;\n\n        ForEach.technique(gltf, function(technique, techniqueId) {\n            sourceTechniques[techniqueId] = clone(technique);\n\n            var programId = technique.program;\n            if (!defined(sourcePrograms[programId])) {\n                sourcePrograms[programId] = clone(programs[programId]);\n            }\n        });\n    }\n\n    function shaderLoad(model, type, id) {\n        return function(source) {\n            var loadResources = model._loadResources;\n            loadResources.shaders[id] = {\n                source : source,\n                type : type,\n                bufferView : undefined\n            };\n            --loadResources.pendingShaderLoads;\n            model._rendererResources.sourceShaders[id] = source;\n        };\n    }\n\n    function parseShaders(model) {\n        var gltf = model.gltf;\n        var buffers = gltf.buffers;\n        var bufferViews = gltf.bufferViews;\n        var sourceShaders = model._rendererResources.sourceShaders;\n        ForEach.shader(gltf, function(shader, id) {\n            // Shader references either uri (external or base64-encoded) or bufferView\n            if (defined(shader.bufferView)) {\n                var bufferViewId = shader.bufferView;\n                var bufferView = bufferViews[bufferViewId];\n                var bufferId = bufferView.buffer;\n                var buffer = buffers[bufferId];\n                var source = getStringFromTypedArray(buffer.extras._pipeline.source, bufferView.byteOffset, bufferView.byteLength);\n                sourceShaders[id] = source;\n            } else if (defined(shader.extras._pipeline.source)) {\n                sourceShaders[id] = shader.extras._pipeline.source;\n            } else {\n                ++model._loadResources.pendingShaderLoads;\n\n                var shaderResource = model._resource.getDerivedResource({\n                    url: shader.uri\n                });\n\n                shaderResource.fetchText()\n                    .then(shaderLoad(model, shader.type, id))\n                    .otherwise(ModelUtility.getFailedLoadFunction(model, 'shader', shaderResource.url));\n            }\n        });\n    }\n\n    function parsePrograms(model) {\n        var sourceTechniques = model._sourceTechniques;\n        for (var techniqueId in sourceTechniques) {\n            if (sourceTechniques.hasOwnProperty(techniqueId)) {\n                var technique = sourceTechniques[techniqueId];\n                model._loadResources.programsToCreate.enqueue({\n                    programId: technique.program,\n                    techniqueId: techniqueId\n                });\n            }\n        }\n    }\n\n    function parseArticulations(model) {\n        var articulationsByName = {};\n        var articulationsByStageKey = {};\n        var runtimeStagesByKey = {};\n\n        model._runtime.articulationsByName = articulationsByName;\n        model._runtime.articulationsByStageKey = articulationsByStageKey;\n        model._runtime.stagesByKey = runtimeStagesByKey;\n\n        var gltf = model.gltf;\n        if (!hasExtension(gltf, 'AGI_articulations') || !defined(gltf.extensions) || !defined(gltf.extensions.AGI_articulations)) {\n            return;\n        }\n\n        var gltfArticulations = gltf.extensions.AGI_articulations.articulations;\n        if (!defined(gltfArticulations)) {\n            return;\n        }\n\n        var numArticulations = gltfArticulations.length;\n        for (var i = 0; i < numArticulations; ++i) {\n            var articulation = clone(gltfArticulations[i]);\n            articulation.nodes = [];\n            articulation.isDirty = true;\n            articulationsByName[articulation.name] = articulation;\n\n            var numStages = articulation.stages.length;\n            for (var s = 0; s < numStages; ++s) {\n                var stage = articulation.stages[s];\n                stage.currentValue = stage.initialValue;\n\n                var stageKey = articulation.name + ' ' + stage.name;\n                articulationsByStageKey[stageKey] = articulation;\n                runtimeStagesByKey[stageKey] = stage;\n            }\n        }\n    }\n\n    function imageLoad(model, textureId) {\n        return function(image) {\n            var loadResources = model._loadResources;\n            --loadResources.pendingTextureLoads;\n            loadResources.texturesToCreate.enqueue({\n                id : textureId,\n                image : image,\n                bufferView : image.bufferView,\n                width : image.width,\n                height : image.height,\n                internalFormat : image.internalFormat\n            });\n        };\n    }\n\n    var ktxRegex = /(^data:image\\/ktx)|(\\.ktx$)/i;\n    var crnRegex = /(^data:image\\/crn)|(\\.crn$)/i;\n\n    function parseTextures(model, context, supportsWebP) {\n        var gltf = model.gltf;\n        var images = gltf.images;\n        var uri;\n        ForEach.texture(gltf, function(texture, id) {\n            var imageId = texture.source;\n\n            if (defined(texture.extensions) && defined(texture.extensions.EXT_texture_webp) && supportsWebP) {\n                imageId = texture.extensions.EXT_texture_webp.source;\n            }\n\n            var gltfImage = images[imageId];\n            var extras = gltfImage.extras;\n\n            var bufferViewId = gltfImage.bufferView;\n            var mimeType = gltfImage.mimeType;\n            uri = gltfImage.uri;\n\n            // First check for a compressed texture\n            if (defined(extras) && defined(extras.compressedImage3DTiles)) {\n                var crunch = extras.compressedImage3DTiles.crunch;\n                var s3tc = extras.compressedImage3DTiles.s3tc;\n                var pvrtc = extras.compressedImage3DTiles.pvrtc1;\n                var etc1 = extras.compressedImage3DTiles.etc1;\n\n                if (context.s3tc && defined(crunch)) {\n                    mimeType = crunch.mimeType;\n                    if (defined(crunch.bufferView)) {\n                        bufferViewId = crunch.bufferView;\n                    } else {\n                        uri = crunch.uri;\n                    }\n                } else if (context.s3tc && defined(s3tc)) {\n                    mimeType = s3tc.mimeType;\n                    if (defined(s3tc.bufferView)) {\n                        bufferViewId = s3tc.bufferView;\n                    } else {\n                        uri = s3tc.uri;\n                    }\n                } else if (context.pvrtc && defined(pvrtc)) {\n                    mimeType = pvrtc.mimeType;\n                    if (defined(pvrtc.bufferView)) {\n                        bufferViewId = pvrtc.bufferView;\n                    } else {\n                        uri = pvrtc.uri;\n                    }\n                } else if (context.etc1 && defined(etc1)) {\n                    mimeType = etc1.mimeType;\n                    if (defined(etc1.bufferView)) {\n                        bufferViewId = etc1.bufferView;\n                    } else {\n                        uri = etc1.uri;\n                    }\n                }\n            }\n\n            // Image references either uri (external or base64-encoded) or bufferView\n            if (defined(bufferViewId)) {\n                model._loadResources.texturesToCreateFromBufferView.enqueue({\n                    id : id,\n                    image : undefined,\n                    bufferView : bufferViewId,\n                    mimeType : mimeType\n                });\n            } else {\n                ++model._loadResources.pendingTextureLoads;\n\n                var imageResource = model._resource.getDerivedResource({\n                    url : uri\n                });\n\n                var promise;\n                if (ktxRegex.test(uri)) {\n                    promise = loadKTX(imageResource);\n                } else if (crnRegex.test(uri)) {\n                    promise = loadCRN(imageResource);\n                } else {\n                    promise = imageResource.fetchImage();\n                }\n                promise.then(imageLoad(model, id, imageId)).otherwise(ModelUtility.getFailedLoadFunction(model, 'image', imageResource.url));\n            }\n        });\n    }\n\n    var scratchArticulationStageInitialTransform = new Matrix4();\n\n    function parseNodes(model) {\n        var runtimeNodes = {};\n        var runtimeNodesByName = {};\n        var skinnedNodes = [];\n\n        var skinnedNodesIds = model._loadResources.skinnedNodesIds;\n        var articulationsByName = model._runtime.articulationsByName;\n\n        ForEach.node(model.gltf, function(node, id) {\n            var runtimeNode = {\n                // Animation targets\n                matrix : undefined,\n                translation : undefined,\n                rotation : undefined,\n                scale : undefined,\n\n                // Per-node show inherited from parent\n                computedShow : true,\n\n                // Computed transforms\n                transformToRoot : new Matrix4(),\n                computedMatrix : new Matrix4(),\n                dirtyNumber : 0,                    // The frame this node was made dirty by an animation; for graph traversal\n\n                // Rendering\n                commands : [],                      // empty for transform, light, and camera nodes\n\n                // Skinned node\n                inverseBindMatrices : undefined,    // undefined when node is not skinned\n                bindShapeMatrix : undefined,        // undefined when node is not skinned or identity\n                joints : [],                        // empty when node is not skinned\n                computedJointMatrices : [],         // empty when node is not skinned\n\n                // Joint node\n                jointName : node.jointName,         // undefined when node is not a joint\n\n                weights : [],\n\n                // Graph pointers\n                children : [],                      // empty for leaf nodes\n                parents : [],                       // empty for root nodes\n\n                // Publicly-accessible ModelNode instance to modify animation targets\n                publicNode : undefined\n            };\n            runtimeNode.publicNode = new ModelNode(model, node, runtimeNode, id, ModelUtility.getTransform(node));\n\n            runtimeNodes[id] = runtimeNode;\n            runtimeNodesByName[node.name] = runtimeNode;\n\n            if (defined(node.skin)) {\n                skinnedNodesIds.push(id);\n                skinnedNodes.push(runtimeNode);\n            }\n\n            if (defined(node.extensions) && defined(node.extensions.AGI_articulations)) {\n                var articulationName = node.extensions.AGI_articulations.articulationName;\n                if (defined(articulationName)) {\n                    var transform = Matrix4.clone(runtimeNode.publicNode.originalMatrix, scratchArticulationStageInitialTransform);\n                    var articulation = articulationsByName[articulationName];\n                    articulation.nodes.push(runtimeNode.publicNode);\n\n                    var numStages = articulation.stages.length;\n                    for (var s = 0; s < numStages; ++s) {\n                        var stage = articulation.stages[s];\n                        transform = applyArticulationStageMatrix(stage, transform);\n                    }\n                    runtimeNode.publicNode.matrix = transform;\n                }\n            }\n        });\n\n        model._runtime.nodes = runtimeNodes;\n        model._runtime.nodesByName = runtimeNodesByName;\n        model._runtime.skinnedNodes = skinnedNodes;\n    }\n\n    function parseMaterials(model) {\n        var gltf = model.gltf;\n        var techniques = model._sourceTechniques;\n\n        var runtimeMaterialsByName = {};\n        var runtimeMaterialsById = {};\n        var uniformMaps = model._uniformMaps;\n\n        ForEach.material(gltf, function(material, materialId) {\n            // Allocated now so ModelMaterial can keep a reference to it.\n            uniformMaps[materialId] = {\n                uniformMap : undefined,\n                values : undefined,\n                jointMatrixUniformName : undefined,\n                morphWeightsUniformName : undefined\n            };\n\n            var modelMaterial = new ModelMaterial(model, material, materialId);\n\n            if (defined(material.extensions) && defined(material.extensions.KHR_techniques_webgl)) {\n                var techniqueId = material.extensions.KHR_techniques_webgl.technique;\n                modelMaterial._technique = techniqueId;\n                modelMaterial._program = techniques[techniqueId].program;\n\n                ForEach.materialValue(material, function(value, uniformName) {\n                    if (!defined(modelMaterial._values)) {\n                        modelMaterial._values = {};\n                    }\n\n                    modelMaterial._values[uniformName] = clone(value);\n                });\n            }\n\n            runtimeMaterialsByName[material.name] = modelMaterial;\n            runtimeMaterialsById[materialId] = modelMaterial;\n        });\n\n        model._runtime.materialsByName = runtimeMaterialsByName;\n        model._runtime.materialsById = runtimeMaterialsById;\n    }\n\n    function parseMeshes(model) {\n        var runtimeMeshesByName = {};\n        var runtimeMaterialsById = model._runtime.materialsById;\n\n        ForEach.mesh(model.gltf, function(mesh, meshId) {\n            runtimeMeshesByName[mesh.name] = new ModelMesh(mesh, runtimeMaterialsById, meshId);\n            if (defined(model.extensionsUsed.WEB3D_quantized_attributes) || model._dequantizeInShader) {\n                // Cache primitives according to their program\n                ForEach.meshPrimitive(mesh, function(primitive, primitiveId) {\n                    var programId = getProgramForPrimitive(model, primitive);\n                    var programPrimitives = model._programPrimitives[programId];\n                    if (!defined(programPrimitives)) {\n                        programPrimitives = {};\n                        model._programPrimitives[programId] = programPrimitives;\n                    }\n                    programPrimitives[meshId + '.primitive.' + primitiveId] = primitive;\n                });\n            }\n        });\n\n        model._runtime.meshesByName = runtimeMeshesByName;\n    }\n\n    ///////////////////////////////////////////////////////////////////////////\n\n    var CreateVertexBufferJob = function() {\n        this.id = undefined;\n        this.model = undefined;\n        this.context = undefined;\n    };\n\n    CreateVertexBufferJob.prototype.set = function(id, model, context) {\n        this.id = id;\n        this.model = model;\n        this.context = context;\n    };\n\n    CreateVertexBufferJob.prototype.execute = function() {\n        createVertexBuffer(this.id, this.model, this.context);\n    };\n\n    ///////////////////////////////////////////////////////////////////////////\n\n    function createVertexBuffer(bufferViewId, model, context) {\n        var loadResources = model._loadResources;\n        var bufferViews = model.gltf.bufferViews;\n        var bufferView = bufferViews[bufferViewId];\n\n        // Use bufferView created at runtime\n        if (!defined(bufferView)) {\n            bufferView = loadResources.createdBufferViews[bufferViewId];\n        }\n\n        var vertexBuffer = Buffer.createVertexBuffer({\n            context : context,\n            typedArray : loadResources.getBuffer(bufferView),\n            usage : BufferUsage.STATIC_DRAW\n        });\n        vertexBuffer.vertexArrayDestroyable = false;\n        model._rendererResources.buffers[bufferViewId] = vertexBuffer;\n        model._geometryByteLength += vertexBuffer.sizeInBytes;\n    }\n\n    ///////////////////////////////////////////////////////////////////////////\n\n    var CreateIndexBufferJob = function() {\n        this.id = undefined;\n        this.componentType = undefined;\n        this.model = undefined;\n        this.context = undefined;\n    };\n\n    CreateIndexBufferJob.prototype.set = function(id, componentType, model, context) {\n        this.id = id;\n        this.componentType = componentType;\n        this.model = model;\n        this.context = context;\n    };\n\n    CreateIndexBufferJob.prototype.execute = function() {\n        createIndexBuffer(this.id, this.componentType, this.model, this.context);\n    };\n\n    ///////////////////////////////////////////////////////////////////////////\n\n    function createIndexBuffer(bufferViewId, componentType, model, context) {\n        var loadResources = model._loadResources;\n        var bufferViews = model.gltf.bufferViews;\n        var bufferView = bufferViews[bufferViewId];\n\n        // Use bufferView created at runtime\n        if (!defined(bufferView)) {\n            bufferView = loadResources.createdBufferViews[bufferViewId];\n        }\n\n        var indexBuffer = Buffer.createIndexBuffer({\n            context : context,\n            typedArray : loadResources.getBuffer(bufferView),\n            usage : BufferUsage.STATIC_DRAW,\n            indexDatatype : componentType\n        });\n        indexBuffer.vertexArrayDestroyable = false;\n        model._rendererResources.buffers[bufferViewId] = indexBuffer;\n        model._geometryByteLength += indexBuffer.sizeInBytes;\n    }\n\n    var scratchVertexBufferJob = new CreateVertexBufferJob();\n    var scratchIndexBufferJob = new CreateIndexBufferJob();\n\n    function createBuffers(model, frameState) {\n        var loadResources = model._loadResources;\n\n        if (loadResources.pendingBufferLoads !== 0) {\n            return;\n        }\n\n        var context = frameState.context;\n        var vertexBuffersToCreate = loadResources.vertexBuffersToCreate;\n        var indexBuffersToCreate = loadResources.indexBuffersToCreate;\n        var i;\n\n        if (model.asynchronous) {\n            while (vertexBuffersToCreate.length > 0) {\n                scratchVertexBufferJob.set(vertexBuffersToCreate.peek(), model, context);\n                if (!frameState.jobScheduler.execute(scratchVertexBufferJob, JobType.BUFFER)) {\n                    break;\n                }\n                vertexBuffersToCreate.dequeue();\n            }\n\n            while (indexBuffersToCreate.length > 0) {\n                i = indexBuffersToCreate.peek();\n                scratchIndexBufferJob.set(i.id, i.componentType, model, context);\n                if (!frameState.jobScheduler.execute(scratchIndexBufferJob, JobType.BUFFER)) {\n                    break;\n                }\n                indexBuffersToCreate.dequeue();\n            }\n        } else {\n            while (vertexBuffersToCreate.length > 0) {\n                createVertexBuffer(vertexBuffersToCreate.dequeue(), model, context);\n            }\n\n            while (indexBuffersToCreate.length > 0) {\n                i = indexBuffersToCreate.dequeue();\n                createIndexBuffer(i.id, i.componentType, model, context);\n            }\n        }\n    }\n\n    function getProgramForPrimitive(model, primitive) {\n        var material = model._runtime.materialsById[primitive.material];\n        if (!defined(material)) {\n            return;\n        }\n\n        return material._program;\n    }\n\n    function modifyShaderForQuantizedAttributes(shader, programName, model) {\n        var primitive;\n        var primitives = model._programPrimitives[programName];\n\n        // If no primitives were cached for this program, there's no need to modify the shader\n        if (!defined(primitives)) {\n            return shader;\n        }\n\n        var primitiveId;\n        for (primitiveId in primitives) {\n            if (primitives.hasOwnProperty(primitiveId)) {\n                primitive = primitives[primitiveId];\n                if (getProgramForPrimitive(model, primitive) === programName) {\n                    break;\n                }\n            }\n        }\n\n        // This is not needed after the program is processed, free the memory\n        model._programPrimitives[programName] = undefined;\n\n        var result;\n        if (model.extensionsUsed.WEB3D_quantized_attributes) {\n            result = ModelUtility.modifyShaderForQuantizedAttributes(model.gltf, primitive, shader);\n            model._quantizedUniforms[programName] = result.uniforms;\n        } else {\n            var decodedData = model._decodedData[primitiveId];\n            if (defined(decodedData)) {\n                result = ModelUtility.modifyShaderForDracoQuantizedAttributes(model.gltf, primitive, shader, decodedData.attributes);\n            } else {\n                return shader;\n            }\n        }\n\n        return result.shader;\n    }\n\n    function modifyShaderForColor(shader) {\n        shader = ShaderSource.replaceMain(shader, 'gltf_blend_main');\n        shader +=\n            'uniform vec4 gltf_color; \\n' +\n            'uniform float gltf_colorBlend; \\n' +\n            'void main() \\n' +\n            '{ \\n' +\n            '    gltf_blend_main(); \\n' +\n            '    gl_FragColor.rgb = mix(gl_FragColor.rgb, gltf_color.rgb, gltf_colorBlend); \\n' +\n            '    float highlight = ceil(gltf_colorBlend); \\n' +\n            '    gl_FragColor.rgb *= mix(gltf_color.rgb, vec3(1.0), highlight); \\n' +\n            '    gl_FragColor.a *= gltf_color.a; \\n' +\n            '} \\n';\n\n        return shader;\n    }\n\n    function modifyShader(shader, programName, callback) {\n        if (defined(callback)) {\n            shader = callback(shader, programName);\n        }\n        return shader;\n    }\n\n    var CreateProgramJob = function() {\n        this.programToCreate = undefined;\n        this.model = undefined;\n        this.context = undefined;\n    };\n\n    CreateProgramJob.prototype.set = function(programToCreate, model, context) {\n        this.programToCreate = programToCreate;\n        this.model = model;\n        this.context = context;\n    };\n\n    CreateProgramJob.prototype.execute = function() {\n        createProgram(this.programToCreate, this.model, this.context);\n    };\n\n    ///////////////////////////////////////////////////////////////////////////\n\n    // When building programs for the first time, do not include modifiers for clipping planes and color\n    // since this is the version of the program that will be cached for use with other Models.\n    function createProgram(programToCreate, model, context) {\n        var programId = programToCreate.programId;\n        var techniqueId = programToCreate.techniqueId;\n        var program = model._sourcePrograms[programId];\n        var shaders = model._rendererResources.sourceShaders;\n\n        var vs = shaders[program.vertexShader];\n        var fs = shaders[program.fragmentShader];\n        var isOutline = program.isOutline;\n\n        var quantizedVertexShaders = model._quantizedVertexShaders;\n        var toClipCoordinatesGLSL = model._toClipCoordinatesGLSL[programId];\n\n        if (model.extensionsUsed.WEB3D_quantized_attributes || model._dequantizeInShader) {\n            var quantizedVS = quantizedVertexShaders[programId];\n            if (!defined(quantizedVS)) {\n                quantizedVS = modifyShaderForQuantizedAttributes(vs, programId, model);\n                quantizedVertexShaders[programId] = quantizedVS;\n            }\n            vs = quantizedVS;\n        }\n\n        var drawVS = modifyShader(vs, programId, model._vertexShaderLoaded);\n        var drawFS = modifyShader(fs, programId, model._fragmentShaderLoaded);\n\n        // Internet Explorer seems to have problems with discard (for clipping planes) after too many levels of indirection:\n        // https://github.com/AnalyticalGraphicsInc/cesium/issues/6575.\n        // For IE log depth code is defined out anyway due to unsupported WebGL extensions, so the wrappers can be omitted.\n        if (!FeatureDetection.isInternetExplorer()) {\n            drawVS = ModelUtility.modifyVertexShaderForLogDepth(drawVS, toClipCoordinatesGLSL);\n            drawFS = ModelUtility.modifyFragmentShaderForLogDepth(drawFS);\n\n            if (isOutline) {\n                drawFS = drawFS.replace('czm_writeLogDepth();',\n                    '    czm_writeLogDepth();\\n' +\n                    '#if defined(LOG_DEPTH) && !defined(DISABLE_LOG_DEPTH_FRAGMENT_WRITE)\\n' +\n                    '    gl_FragDepthEXT -= 5e-5;\\n' +\n                    '#endif');\n            }\n        }\n\n        if (!defined(model._uniformMapLoaded)) {\n            drawFS = 'uniform vec4 czm_pickColor;\\n' + drawFS;\n        }\n\n        var useIBL = model._imageBasedLightingFactor.x > 0.0 || model._imageBasedLightingFactor.y > 0.0;\n        if (useIBL) {\n            drawFS = '#define USE_IBL_LIGHTING \\n\\n' + drawFS;\n        }\n\n        if (defined(model._lightColor)) {\n            drawFS = '#define USE_CUSTOM_LIGHT_COLOR \\n\\n' + drawFS;\n        }\n\n        if (model._sourceVersion !== '2.0' || model._sourceKHRTechniquesWebGL) {\n            drawFS = ShaderSource.replaceMain(drawFS, 'non_gamma_corrected_main');\n            drawFS =\n                drawFS +\n                '\\n' +\n                'void main() { \\n' +\n                '    non_gamma_corrected_main(); \\n' +\n                '    gl_FragColor = czm_gammaCorrect(gl_FragColor); \\n' +\n                '} \\n';\n        }\n\n        if (OctahedralProjectedCubeMap.isSupported(context)) {\n            var usesSH = defined(model._sphericalHarmonicCoefficients) || model._useDefaultSphericalHarmonics;\n            var usesSM = (defined(model._specularEnvironmentMapAtlas) && model._specularEnvironmentMapAtlas.ready) || model._useDefaultSpecularMaps;\n            var addMatrix = usesSH || usesSM || useIBL;\n            if (addMatrix) {\n                drawFS = 'uniform mat4 gltf_clippingPlanesMatrix; \\n' + drawFS;\n            }\n\n            if (defined(model._sphericalHarmonicCoefficients)) {\n                drawFS = '#define DIFFUSE_IBL \\n' + '#define CUSTOM_SPHERICAL_HARMONICS \\n' + 'uniform vec3 gltf_sphericalHarmonicCoefficients[9]; \\n' + drawFS;\n            } else if (model._useDefaultSphericalHarmonics) {\n                drawFS = '#define DIFFUSE_IBL \\n' + drawFS;\n            }\n\n            if (defined(model._specularEnvironmentMapAtlas) && model._specularEnvironmentMapAtlas.ready) {\n                drawFS = '#define SPECULAR_IBL \\n' + '#define CUSTOM_SPECULAR_IBL \\n' + 'uniform sampler2D gltf_specularMap; \\n' + 'uniform vec2 gltf_specularMapSize; \\n' + 'uniform float gltf_maxSpecularLOD; \\n' + drawFS;\n            } else if (model._useDefaultSpecularMaps) {\n                drawFS = '#define SPECULAR_IBL \\n' + drawFS;\n            }\n        }\n\n        if (defined(model._luminanceAtZenith)) {\n            drawFS = '#define USE_SUN_LUMINANCE \\n' + 'uniform float gltf_luminanceAtZenith;\\n' + drawFS;\n        }\n\n        createAttributesAndProgram(programId, techniqueId, drawFS, drawVS, model, context);\n    }\n\n    function recreateProgram(programToCreate, model, context) {\n        var programId = programToCreate.programId;\n        var techniqueId = programToCreate.techniqueId;\n        var program = model._sourcePrograms[programId];\n        var shaders = model._rendererResources.sourceShaders;\n\n        var quantizedVertexShaders = model._quantizedVertexShaders;\n        var toClipCoordinatesGLSL = model._toClipCoordinatesGLSL[programId];\n\n        var clippingPlaneCollection = model.clippingPlanes;\n        var addClippingPlaneCode = isClippingEnabled(model);\n\n        var vs = shaders[program.vertexShader];\n        var fs = shaders[program.fragmentShader];\n\n        if (model.extensionsUsed.WEB3D_quantized_attributes || model._dequantizeInShader) {\n            vs = quantizedVertexShaders[programId];\n        }\n\n        var finalFS = fs;\n        if (isColorShadingEnabled(model)) {\n            finalFS = Model._modifyShaderForColor(finalFS);\n        }\n        if (addClippingPlaneCode) {\n            finalFS = modifyShaderForClippingPlanes(finalFS, clippingPlaneCollection, context);\n        }\n\n        var drawVS = modifyShader(vs, programId, model._vertexShaderLoaded);\n        var drawFS = modifyShader(finalFS, programId, model._fragmentShaderLoaded);\n\n        if (!FeatureDetection.isInternetExplorer()) {\n            drawVS = ModelUtility.modifyVertexShaderForLogDepth(drawVS, toClipCoordinatesGLSL);\n            drawFS = ModelUtility.modifyFragmentShaderForLogDepth(drawFS);\n\n            var isOutline = program.isOutline;\n            if (isOutline) {\n                drawFS = drawFS.replace('czm_writeLogDepth();',\n                    '    czm_writeLogDepth();\\n' +\n                    '#if defined(LOG_DEPTH) && !defined(DISABLE_LOG_DEPTH_FRAGMENT_WRITE)\\n' +\n                    '    gl_FragDepthEXT -= 5e-5;\\n' +\n                    '#endif');\n            }\n        }\n\n        if (!defined(model._uniformMapLoaded)) {\n            drawFS = 'uniform vec4 czm_pickColor;\\n' + drawFS;\n        }\n\n        var useIBL = model._imageBasedLightingFactor.x > 0.0 || model._imageBasedLightingFactor.y > 0.0;\n        if (useIBL) {\n            drawFS = '#define USE_IBL_LIGHTING \\n\\n' + drawFS;\n        }\n\n        if (defined(model._lightColor)) {\n            drawFS = '#define USE_CUSTOM_LIGHT_COLOR \\n\\n' + drawFS;\n        }\n\n        if (model._sourceVersion !== '2.0' || model._sourceKHRTechniquesWebGL) {\n            drawFS = ShaderSource.replaceMain(drawFS, 'non_gamma_corrected_main');\n            drawFS =\n                drawFS +\n                '\\n' +\n                'void main() { \\n' +\n                '    non_gamma_corrected_main(); \\n' +\n                '    gl_FragColor = czm_gammaCorrect(gl_FragColor); \\n' +\n                '} \\n';\n        }\n\n        if (OctahedralProjectedCubeMap.isSupported(context)) {\n            var usesSH = defined(model._sphericalHarmonicCoefficients) || model._useDefaultSphericalHarmonics;\n            var usesSM = (defined(model._specularEnvironmentMapAtlas) && model._specularEnvironmentMapAtlas.ready) || model._useDefaultSpecularMaps;\n            var addMatrix = !addClippingPlaneCode && (usesSH || usesSM || useIBL);\n            if (addMatrix) {\n                drawFS = 'uniform mat4 gltf_clippingPlanesMatrix; \\n' + drawFS;\n            }\n\n            if (defined(model._sphericalHarmonicCoefficients)) {\n                drawFS = '#define DIFFUSE_IBL \\n' + '#define CUSTOM_SPHERICAL_HARMONICS \\n' + 'uniform vec3 gltf_sphericalHarmonicCoefficients[9]; \\n' + drawFS;\n            } else if (model._useDefaultSphericalHarmonics) {\n                drawFS = '#define DIFFUSE_IBL \\n' + drawFS;\n            }\n\n            if (defined(model._specularEnvironmentMapAtlas) && model._specularEnvironmentMapAtlas.ready) {\n                drawFS = '#define SPECULAR_IBL \\n' + '#define CUSTOM_SPECULAR_IBL \\n' + 'uniform sampler2D gltf_specularMap; \\n' + 'uniform vec2 gltf_specularMapSize; \\n' + 'uniform float gltf_maxSpecularLOD; \\n' + drawFS;\n            } else if (model._useDefaultSpecularMaps) {\n                drawFS = '#define SPECULAR_IBL \\n' + drawFS;\n            }\n        }\n\n        if (defined(model._luminanceAtZenith)) {\n            drawFS = '#define USE_SUN_LUMINANCE \\n' + 'uniform float gltf_luminanceAtZenith;\\n' + drawFS;\n        }\n\n        createAttributesAndProgram(programId, techniqueId, drawFS, drawVS, model, context);\n    }\n\n    function createAttributesAndProgram(programId, techniqueId, drawFS, drawVS, model, context) {\n        var technique = model._sourceTechniques[techniqueId];\n        var attributeLocations = ModelUtility.createAttributeLocations(technique, model._precreatedAttributes);\n\n        model._rendererResources.programs[programId] = ShaderProgram.fromCache({\n            context : context,\n            vertexShaderSource : drawVS,\n            fragmentShaderSource : drawFS,\n            attributeLocations : attributeLocations\n        });\n    }\n\n    var scratchCreateProgramJob = new CreateProgramJob();\n\n    function createPrograms(model, frameState) {\n        var loadResources = model._loadResources;\n        var programsToCreate = loadResources.programsToCreate;\n\n        if (loadResources.pendingShaderLoads !== 0) {\n            return;\n        }\n\n        // PERFORMANCE_IDEA: this could be more fine-grained by looking\n        // at the shader's bufferView's to determine the buffer dependencies.\n        if (loadResources.pendingBufferLoads !== 0) {\n            return;\n        }\n\n        var context = frameState.context;\n\n        if (model.asynchronous) {\n            while (programsToCreate.length > 0) {\n                scratchCreateProgramJob.set(programsToCreate.peek(), model, context);\n                if (!frameState.jobScheduler.execute(scratchCreateProgramJob, JobType.PROGRAM)) {\n                    break;\n                }\n                programsToCreate.dequeue();\n            }\n        } else {\n            // Create all loaded programs this frame\n            while (programsToCreate.length > 0) {\n                createProgram(programsToCreate.dequeue(), model, context);\n            }\n        }\n    }\n\n    function getOnImageCreatedFromTypedArray(loadResources, gltfTexture) {\n        return function(image) {\n            loadResources.texturesToCreate.enqueue({\n                id : gltfTexture.id,\n                image : image,\n                bufferView : undefined\n            });\n\n            --loadResources.pendingBufferViewToImage;\n        };\n    }\n\n    function loadTexturesFromBufferViews(model) {\n        var loadResources = model._loadResources;\n\n        if (loadResources.pendingBufferLoads !== 0) {\n            return;\n        }\n\n        while (loadResources.texturesToCreateFromBufferView.length > 0) {\n            var gltfTexture = loadResources.texturesToCreateFromBufferView.dequeue();\n\n            var gltf = model.gltf;\n            var bufferView = gltf.bufferViews[gltfTexture.bufferView];\n            var imageId = gltf.textures[gltfTexture.id].source;\n\n            var onerror = ModelUtility.getFailedLoadFunction(model, 'image', 'id: ' + gltfTexture.id + ', bufferView: ' + gltfTexture.bufferView);\n\n            if (gltfTexture.mimeType === 'image/ktx') {\n                loadKTX(loadResources.getBuffer(bufferView)).then(imageLoad(model, gltfTexture.id, imageId)).otherwise(onerror);\n                ++model._loadResources.pendingTextureLoads;\n            } else if (gltfTexture.mimeType === 'image/crn') {\n                loadCRN(loadResources.getBuffer(bufferView)).then(imageLoad(model, gltfTexture.id, imageId)).otherwise(onerror);\n                ++model._loadResources.pendingTextureLoads;\n            } else {\n                var onload = getOnImageCreatedFromTypedArray(loadResources, gltfTexture);\n                loadImageFromTypedArray({\n                    uint8Array: loadResources.getBuffer(bufferView),\n                    format: gltfTexture.mimeType,\n                    flipY: false\n                })\n                    .then(onload).otherwise(onerror);\n                ++loadResources.pendingBufferViewToImage;\n            }\n        }\n    }\n\n    function createSamplers(model) {\n        var loadResources = model._loadResources;\n        if (loadResources.createSamplers) {\n            loadResources.createSamplers = false;\n\n            var rendererSamplers = model._rendererResources.samplers;\n            ForEach.sampler(model.gltf, function(sampler, samplerId) {\n                rendererSamplers[samplerId] = new Sampler({\n                    wrapS: sampler.wrapS,\n                    wrapT: sampler.wrapT,\n                    minificationFilter: sampler.minFilter,\n                    magnificationFilter: sampler.magFilter\n                });\n            });\n        }\n    }\n\n    ///////////////////////////////////////////////////////////////////////////\n\n    var CreateTextureJob = function() {\n        this.gltfTexture = undefined;\n        this.model = undefined;\n        this.context = undefined;\n    };\n\n    CreateTextureJob.prototype.set = function(gltfTexture, model, context) {\n        this.gltfTexture = gltfTexture;\n        this.model = model;\n        this.context = context;\n    };\n\n    CreateTextureJob.prototype.execute = function() {\n        createTexture(this.gltfTexture, this.model, this.context);\n    };\n\n    ///////////////////////////////////////////////////////////////////////////\n\n    function createTexture(gltfTexture, model, context) {\n        var textures = model.gltf.textures;\n        var texture = textures[gltfTexture.id];\n\n        var rendererSamplers = model._rendererResources.samplers;\n        var sampler = rendererSamplers[texture.sampler];\n        if (!defined(sampler)) {\n            sampler = new Sampler({\n                wrapS : TextureWrap.REPEAT,\n                wrapT : TextureWrap.REPEAT\n            });\n        }\n\n        var usesTextureTransform = false;\n        var materials = model.gltf.materials;\n        var materialsLength = materials.length;\n        for (var i = 0; i < materialsLength; ++i) {\n            var material = materials[i];\n            if (defined(material.extensions) && defined(material.extensions.KHR_techniques_webgl)) {\n                var values = material.extensions.KHR_techniques_webgl.values;\n                for (var valueName in values) {\n                    if (values.hasOwnProperty(valueName) && valueName.indexOf('Texture') !== -1) {\n                        var value = values[valueName];\n                        if (value.index === gltfTexture.id && defined(value.extensions) && defined(value.extensions.KHR_texture_transform)) {\n                            usesTextureTransform = true;\n                            break;\n                        }\n                    }\n                }\n            }\n            if (usesTextureTransform) {\n                break;\n            }\n        }\n\n        var wrapS = sampler.wrapS;\n        var wrapT = sampler.wrapT;\n        var minFilter = sampler.minificationFilter;\n\n        if (usesTextureTransform && minFilter !== TextureMinificationFilter.LINEAR && minFilter !== TextureMinificationFilter.NEAREST) {\n            if (minFilter === TextureMinificationFilter.NEAREST_MIPMAP_NEAREST || minFilter === TextureMinificationFilter.NEAREST_MIPMAP_LINEAR) {\n                minFilter = TextureMinificationFilter.NEAREST;\n            } else {\n                minFilter = TextureMinificationFilter.LINEAR;\n            }\n\n            sampler = new Sampler({\n                wrapS : sampler.wrapS,\n                wrapT : sampler.wrapT,\n                textureMinificationFilter : minFilter,\n                textureMagnificationFilter : sampler.magnificationFilter\n            });\n        }\n\n        var internalFormat = gltfTexture.internalFormat;\n\n        var mipmap =\n            (!(defined(internalFormat) && PixelFormat.isCompressedFormat(internalFormat))) &&\n            ((minFilter === TextureMinificationFilter.NEAREST_MIPMAP_NEAREST) ||\n             (minFilter === TextureMinificationFilter.NEAREST_MIPMAP_LINEAR) ||\n             (minFilter === TextureMinificationFilter.LINEAR_MIPMAP_NEAREST) ||\n             (minFilter === TextureMinificationFilter.LINEAR_MIPMAP_LINEAR));\n        var requiresNpot = mipmap ||\n           (wrapS === TextureWrap.REPEAT) ||\n           (wrapS === TextureWrap.MIRRORED_REPEAT) ||\n           (wrapT === TextureWrap.REPEAT) ||\n           (wrapT === TextureWrap.MIRRORED_REPEAT);\n\n        var tx;\n        var source = gltfTexture.image;\n\n        if (defined(internalFormat)) {\n            tx = new Texture({\n                context : context,\n                source : {\n                    arrayBufferView : gltfTexture.bufferView\n                },\n                width : gltfTexture.width,\n                height : gltfTexture.height,\n                pixelFormat : internalFormat,\n                sampler : sampler\n            });\n        } else if (defined(source)) {\n            var npot = !CesiumMath.isPowerOfTwo(source.width) || !CesiumMath.isPowerOfTwo(source.height);\n\n            if (requiresNpot && npot) {\n                // WebGL requires power-of-two texture dimensions for mipmapping and REPEAT/MIRRORED_REPEAT wrap modes.\n                var canvas = document.createElement('canvas');\n                canvas.width = CesiumMath.nextPowerOfTwo(source.width);\n                canvas.height = CesiumMath.nextPowerOfTwo(source.height);\n                var canvasContext = canvas.getContext('2d');\n                canvasContext.drawImage(source, 0, 0, source.width, source.height, 0, 0, canvas.width, canvas.height);\n                source = canvas;\n            }\n\n            tx = new Texture({\n                context : context,\n                source : source,\n                pixelFormat : texture.internalFormat,\n                pixelDatatype : texture.type,\n                sampler : sampler,\n                flipY : false\n            });\n            // GLTF_SPEC: Support TEXTURE_CUBE_MAP.  https://github.com/KhronosGroup/glTF/issues/40\n            if (mipmap) {\n                tx.generateMipmap();\n            }\n        }\n        if (defined(tx)) {\n            model._rendererResources.textures[gltfTexture.id] = tx;\n            model._texturesByteLength += tx.sizeInBytes;\n        }\n    }\n\n    var scratchCreateTextureJob = new CreateTextureJob();\n\n    function createTextures(model, frameState) {\n        var context = frameState.context;\n        var texturesToCreate = model._loadResources.texturesToCreate;\n\n        if (model.asynchronous) {\n            while (texturesToCreate.length > 0) {\n                scratchCreateTextureJob.set(texturesToCreate.peek(), model, context);\n                if (!frameState.jobScheduler.execute(scratchCreateTextureJob, JobType.TEXTURE)) {\n                    break;\n                }\n                texturesToCreate.dequeue();\n            }\n        } else {\n            // Create all loaded textures this frame\n            while (texturesToCreate.length > 0) {\n                createTexture(texturesToCreate.dequeue(), model, context);\n            }\n        }\n    }\n\n    function getAttributeLocations(model, primitive) {\n        var techniques = model._sourceTechniques;\n\n        // Retrieve the compiled shader program to assign index values to attributes\n        var attributeLocations = {};\n\n        var location;\n        var index;\n        var material = model._runtime.materialsById[primitive.material];\n        if (!defined(material)) {\n            return attributeLocations;\n        }\n\n        var technique = techniques[material._technique];\n        if (!defined(technique)) {\n            return attributeLocations;\n        }\n\n        var attributes = technique.attributes;\n        var program = model._rendererResources.programs[technique.program];\n        var programVertexAttributes = program.vertexAttributes;\n        var programAttributeLocations = program._attributeLocations;\n\n        // Note: WebGL shader compiler may have optimized and removed some attributes from programVertexAttributes\n        for (location in programVertexAttributes) {\n            if (programVertexAttributes.hasOwnProperty(location)) {\n                var attribute = attributes[location];\n                if (defined(attribute)) {\n                    index = programAttributeLocations[location];\n                    attributeLocations[attribute.semantic] = index;\n                }\n            }\n        }\n\n        // Always add pre-created attributes.\n        // Some pre-created attributes, like per-instance pickIds, may be compiled out of the draw program\n        // but should be included in the list of attribute locations for the pick program.\n        // This is safe to do since programVertexAttributes and programAttributeLocations are equivalent except\n        // that programVertexAttributes optimizes out unused attributes.\n        var precreatedAttributes = model._precreatedAttributes;\n        if (defined(precreatedAttributes)) {\n            for (location in precreatedAttributes) {\n                if (precreatedAttributes.hasOwnProperty(location)) {\n                    index = programAttributeLocations[location];\n                    attributeLocations[location] = index;\n                }\n            }\n        }\n\n        return attributeLocations;\n    }\n\n    function mapJointNames(forest, nodes) {\n        var length = forest.length;\n        var jointNodes = {};\n        for (var i = 0; i < length; ++i) {\n            var stack = [forest[i]]; // Push root node of tree\n\n            while (stack.length > 0) {\n                var id = stack.pop();\n                var n = nodes[id];\n\n                if (defined(n)) {\n                    jointNodes[id] = id;\n                }\n\n                var children = n.children;\n                if (defined(children)) {\n                    var childrenLength = children.length;\n                    for (var k = 0; k < childrenLength; ++k) {\n                        stack.push(children[k]);\n                    }\n                }\n            }\n        }\n        return jointNodes;\n    }\n\n    function createJoints(model, runtimeSkins) {\n        var gltf = model.gltf;\n        var skins = gltf.skins;\n        var nodes = gltf.nodes;\n        var runtimeNodes = model._runtime.nodes;\n\n        var skinnedNodesIds = model._loadResources.skinnedNodesIds;\n        var length = skinnedNodesIds.length;\n        for (var j = 0; j < length; ++j) {\n            var id = skinnedNodesIds[j];\n            var skinnedNode = runtimeNodes[id];\n            var node = nodes[id];\n\n            var runtimeSkin = runtimeSkins[node.skin];\n            skinnedNode.inverseBindMatrices = runtimeSkin.inverseBindMatrices;\n            skinnedNode.bindShapeMatrix = runtimeSkin.bindShapeMatrix;\n\n            // 1. Find nodes with the names in node.skeletons (the node's skeletons)\n            // 2. These nodes form the root nodes of the forest to search for each joint in skin.jointNames.  This search uses jointName, not the node's name.\n            // 3. Search for the joint name among the gltf node hierarchy instead of the runtime node hierarchy. Child links aren't set up yet for runtime nodes.\n            var forest = [];\n            var skin = skins[node.skin];\n            if (defined(skin.skeleton)) {\n                forest.push(skin.skeleton);\n            }\n\n            var mappedJointNames = mapJointNames(forest, nodes);\n            var gltfJointNames = skins[node.skin].joints;\n            var jointNamesLength = gltfJointNames.length;\n            for (var i = 0; i < jointNamesLength; ++i) {\n                var jointName = gltfJointNames[i];\n                var nodeId = mappedJointNames[jointName];\n                var jointNode = runtimeNodes[nodeId];\n                skinnedNode.joints.push(jointNode);\n            }\n        }\n    }\n\n    function createSkins(model) {\n        var loadResources = model._loadResources;\n\n        if (loadResources.pendingBufferLoads !== 0) {\n            return;\n        }\n\n        if (!loadResources.createSkins) {\n            return;\n        }\n        loadResources.createSkins = false;\n\n        var gltf = model.gltf;\n        var accessors = gltf.accessors;\n        var runtimeSkins = {};\n\n        ForEach.skin(gltf, function(skin, id) {\n            var accessor = accessors[skin.inverseBindMatrices];\n\n            var bindShapeMatrix;\n            if (!Matrix4.equals(skin.bindShapeMatrix, Matrix4.IDENTITY)) {\n                bindShapeMatrix = Matrix4.clone(skin.bindShapeMatrix);\n            }\n\n            runtimeSkins[id] = {\n                inverseBindMatrices : ModelAnimationCache.getSkinInverseBindMatrices(model, accessor),\n                bindShapeMatrix : bindShapeMatrix // not used when undefined\n            };\n        });\n\n        createJoints(model, runtimeSkins);\n    }\n\n    function getChannelEvaluator(model, runtimeNode, targetPath, spline) {\n        return function(localAnimationTime) {\n            //  Workaround for https://github.com/KhronosGroup/glTF/issues/219\n\n            //if (targetPath === 'translation') {\n            //    return;\n            //}\n            if (defined(spline)) {\n                localAnimationTime = model.clampAnimations ? spline.clampTime(localAnimationTime) : spline.wrapTime(localAnimationTime);\n                runtimeNode[targetPath] = spline.evaluate(localAnimationTime, runtimeNode[targetPath]);\n                runtimeNode.dirtyNumber = model._maxDirtyNumber;\n            }\n        };\n    }\n\n    function createRuntimeAnimations(model) {\n        var loadResources = model._loadResources;\n\n        if (!loadResources.finishedPendingBufferLoads()) {\n            return;\n        }\n\n        if (!loadResources.createRuntimeAnimations) {\n            return;\n        }\n        loadResources.createRuntimeAnimations = false;\n\n        model._runtime.animations = [];\n\n        var runtimeNodes = model._runtime.nodes;\n        var accessors = model.gltf.accessors;\n\n        ForEach.animation(model.gltf, function (animation, i) {\n            var channels = animation.channels;\n            var samplers = animation.samplers;\n\n            // Find start and stop time for the entire animation\n            var startTime = Number.MAX_VALUE;\n            var stopTime = -Number.MAX_VALUE;\n\n            var channelsLength = channels.length;\n            var channelEvaluators = new Array(channelsLength);\n\n            for (var j = 0; j < channelsLength; ++j) {\n                var channel = channels[j];\n                var target = channel.target;\n                var path = target.path;\n                var sampler = samplers[channel.sampler];\n                var input = ModelAnimationCache.getAnimationParameterValues(model, accessors[sampler.input]);\n                var output = ModelAnimationCache.getAnimationParameterValues(model, accessors[sampler.output]);\n\n                startTime = Math.min(startTime, input[0]);\n                stopTime = Math.max(stopTime, input[input.length - 1]);\n\n                var spline = ModelAnimationCache.getAnimationSpline(model, i, animation, channel.sampler, sampler, input, path, output);\n\n                // GLTF_SPEC: Support more targets like materials. https://github.com/KhronosGroup/glTF/issues/142\n                channelEvaluators[j] = getChannelEvaluator(model, runtimeNodes[target.node], target.path, spline);\n            }\n\n            model._runtime.animations[i] = {\n                name : animation.name,\n                startTime : startTime,\n                stopTime : stopTime,\n                channelEvaluators : channelEvaluators\n            };\n        });\n    }\n\n    function createVertexArrays(model, context) {\n        var loadResources = model._loadResources;\n        if (!loadResources.finishedBuffersCreation() || !loadResources.finishedProgramCreation()\n                || !loadResources.createVertexArrays) {\n            return;\n        }\n        loadResources.createVertexArrays = false;\n\n        var rendererBuffers = model._rendererResources.buffers;\n        var rendererVertexArrays = model._rendererResources.vertexArrays;\n        var gltf = model.gltf;\n        var accessors = gltf.accessors;\n        ForEach.mesh(gltf, function(mesh, meshId) {\n            ForEach.meshPrimitive(mesh, function(primitive, primitiveId) {\n                var attributes = [];\n                var attributeLocation;\n                var attributeLocations = getAttributeLocations(model, primitive);\n                var decodedData = model._decodedData[meshId + '.primitive.' + primitiveId];\n                ForEach.meshPrimitiveAttribute(primitive, function(accessorId, attributeName) {\n                    // Skip if the attribute is not used by the material, e.g., because the asset\n                    // was exported with an attribute that wasn't used and the asset wasn't optimized.\n                    attributeLocation = attributeLocations[attributeName];\n                    if (defined(attributeLocation)) {\n                        // Use attributes of previously decoded draco geometry\n                        if (defined(decodedData)) {\n                            var decodedAttributes = decodedData.attributes;\n                            if (decodedAttributes.hasOwnProperty(attributeName)) {\n                                var decodedAttribute = decodedAttributes[attributeName];\n                                attributes.push({\n                                    index: attributeLocation,\n                                    vertexBuffer: rendererBuffers[decodedAttribute.bufferView],\n                                    componentsPerAttribute: decodedAttribute.componentsPerAttribute,\n                                    componentDatatype: decodedAttribute.componentDatatype,\n                                    normalize: decodedAttribute.normalized,\n                                    offsetInBytes: decodedAttribute.byteOffset,\n                                    strideInBytes: decodedAttribute.byteStride\n                                });\n\n                                return;\n                            }\n                        }\n\n                        var a = accessors[accessorId];\n                        var normalize = defined(a.normalized) && a.normalized;\n                        attributes.push({\n                            index: attributeLocation,\n                            vertexBuffer: rendererBuffers[a.bufferView],\n                            componentsPerAttribute: numberOfComponentsForType(a.type),\n                            componentDatatype: a.componentType,\n                            normalize: normalize,\n                            offsetInBytes: a.byteOffset,\n                            strideInBytes: getAccessorByteStride(gltf, a)\n                        });\n                    }\n                });\n\n                // Add pre-created attributes\n                var attribute;\n                var attributeName;\n                var precreatedAttributes = model._precreatedAttributes;\n                if (defined(precreatedAttributes)) {\n                    for (attributeName in precreatedAttributes) {\n                        if (precreatedAttributes.hasOwnProperty(attributeName)) {\n                            attributeLocation = attributeLocations[attributeName];\n                            if (defined(attributeLocation)) {\n                                attribute = precreatedAttributes[attributeName];\n                                attribute.index = attributeLocation;\n                                attributes.push(attribute);\n                            }\n                        }\n                    }\n                }\n\n                var indexBuffer;\n                if (defined(primitive.indices)) {\n                    var accessor = accessors[primitive.indices];\n                    var bufferView = accessor.bufferView;\n\n                    // Use buffer of previously decoded draco geometry\n                    if (defined(decodedData)) {\n                        bufferView = decodedData.bufferView;\n                    }\n\n                    indexBuffer = rendererBuffers[bufferView];\n                }\n                rendererVertexArrays[meshId + '.primitive.' + primitiveId] = new VertexArray({\n                    context: context,\n                    attributes: attributes,\n                    indexBuffer: indexBuffer\n                });\n            });\n        });\n    }\n\n    function createRenderStates(model) {\n        var loadResources = model._loadResources;\n        if (loadResources.createRenderStates) {\n            loadResources.createRenderStates = false;\n\n            ForEach.material(model.gltf, function (material, materialId) {\n                createRenderStateForMaterial(model, material, materialId);\n            });\n        }\n    }\n\n    function createRenderStateForMaterial(model, material, materialId) {\n        var rendererRenderStates = model._rendererResources.renderStates;\n\n        var blendEquationSeparate = [\n            WebGLConstants.FUNC_ADD,\n            WebGLConstants.FUNC_ADD\n        ];\n        var blendFuncSeparate = [\n            WebGLConstants.ONE,\n            WebGLConstants.ONE_MINUS_SRC_ALPHA,\n            WebGLConstants.ONE,\n            WebGLConstants.ONE_MINUS_SRC_ALPHA\n        ];\n\n        if (defined(material.extensions) && defined(material.extensions.KHR_blend)) {\n            blendEquationSeparate = material.extensions.KHR_blend.blendEquation;\n            blendFuncSeparate = material.extensions.KHR_blend.blendFactors;\n        }\n\n        // If we have outlines but this material is not one of them, set the\n        // polygonOffset render state to push this material back slightly in the\n        // depth buffer so that the outlines are clearly visible.\n        // Note that this render state will have no effect when we're using\n        // logarithmic depth; that is handled separately.\n        var hasOutlines = hasExtension(model.gltf, 'TERRIA_solid_outlines');\n        var isOutline = defined(material.extensions) && defined(material.extensions.TERRIA_solid_outlines);\n\n        var polygonOffset;\n        if (hasOutlines && !isOutline) {\n            polygonOffset = {\n                enabled : true,\n                factor : 0.75,\n                units : 1.0\n            };\n        }\n\n        var enableCulling = !material.doubleSided;\n        var blendingEnabled = (material.alphaMode === 'BLEND');\n        rendererRenderStates[materialId] = RenderState.fromCache({\n            cull : {\n                enabled : enableCulling\n            },\n            depthTest : {\n                enabled : true\n            },\n            depthMask : !blendingEnabled,\n            blending : {\n                enabled : blendingEnabled,\n                equationRgb : blendEquationSeparate[0],\n                equationAlpha : blendEquationSeparate[1],\n                functionSourceRgb : blendFuncSeparate[0],\n                functionDestinationRgb : blendFuncSeparate[1],\n                functionSourceAlpha : blendFuncSeparate[2],\n                functionDestinationAlpha : blendFuncSeparate[3]\n            },\n            polygonOffset : polygonOffset\n        });\n    }\n\n    ///////////////////////////////////////////////////////////////////////////\n\n    var gltfUniformsFromNode = {\n        MODEL : function(uniformState, model, runtimeNode) {\n            return function() {\n                return runtimeNode.computedMatrix;\n            };\n        },\n        VIEW : function(uniformState, model, runtimeNode) {\n            return function() {\n                return uniformState.view;\n            };\n        },\n        PROJECTION : function(uniformState, model, runtimeNode) {\n            return function() {\n                return uniformState.projection;\n            };\n        },\n        MODELVIEW : function(uniformState, model, runtimeNode) {\n            var mv = new Matrix4();\n            return function() {\n                return Matrix4.multiplyTransformation(uniformState.view, runtimeNode.computedMatrix, mv);\n            };\n        },\n        CESIUM_RTC_MODELVIEW : function(uniformState, model, runtimeNode) {\n            // CESIUM_RTC extension\n            var mvRtc = new Matrix4();\n            return function() {\n                Matrix4.multiplyTransformation(uniformState.view, runtimeNode.computedMatrix, mvRtc);\n                return Matrix4.setTranslation(mvRtc, model._rtcCenterEye, mvRtc);\n            };\n        },\n        MODELVIEWPROJECTION : function(uniformState, model, runtimeNode) {\n            var mvp = new Matrix4();\n            return function() {\n                Matrix4.multiplyTransformation(uniformState.view, runtimeNode.computedMatrix, mvp);\n                return Matrix4.multiply(uniformState._projection, mvp, mvp);\n            };\n        },\n        MODELINVERSE : function(uniformState, model, runtimeNode) {\n            var mInverse = new Matrix4();\n            return function() {\n                return Matrix4.inverse(runtimeNode.computedMatrix, mInverse);\n            };\n        },\n        VIEWINVERSE : function(uniformState, model) {\n            return function() {\n                return uniformState.inverseView;\n            };\n        },\n        PROJECTIONINVERSE : function(uniformState, model, runtimeNode) {\n            return function() {\n                return uniformState.inverseProjection;\n            };\n        },\n        MODELVIEWINVERSE : function(uniformState, model, runtimeNode) {\n            var mv = new Matrix4();\n            var mvInverse = new Matrix4();\n            return function() {\n                Matrix4.multiplyTransformation(uniformState.view, runtimeNode.computedMatrix, mv);\n                return Matrix4.inverse(mv, mvInverse);\n            };\n        },\n        MODELVIEWPROJECTIONINVERSE : function(uniformState, model, runtimeNode) {\n            var mvp = new Matrix4();\n            var mvpInverse = new Matrix4();\n            return function() {\n                Matrix4.multiplyTransformation(uniformState.view, runtimeNode.computedMatrix, mvp);\n                Matrix4.multiply(uniformState._projection, mvp, mvp);\n                return Matrix4.inverse(mvp, mvpInverse);\n            };\n        },\n        MODELINVERSETRANSPOSE : function(uniformState, model, runtimeNode) {\n            var mInverse = new Matrix4();\n            var mInverseTranspose = new Matrix3();\n            return function() {\n                Matrix4.inverse(runtimeNode.computedMatrix, mInverse);\n                Matrix4.getMatrix3(mInverse, mInverseTranspose);\n                return Matrix3.transpose(mInverseTranspose, mInverseTranspose);\n            };\n        },\n        MODELVIEWINVERSETRANSPOSE : function(uniformState, model, runtimeNode) {\n            var mv = new Matrix4();\n            var mvInverse = new Matrix4();\n            var mvInverseTranspose = new Matrix3();\n            return function() {\n                Matrix4.multiplyTransformation(uniformState.view, runtimeNode.computedMatrix, mv);\n                Matrix4.inverse(mv, mvInverse);\n                Matrix4.getMatrix3(mvInverse, mvInverseTranspose);\n                return Matrix3.transpose(mvInverseTranspose, mvInverseTranspose);\n            };\n        },\n        VIEWPORT : function(uniformState, model, runtimeNode) {\n            return function() {\n                return uniformState.viewportCartesian4;\n            };\n        }\n    };\n\n    function getUniformFunctionFromSource(source, model, semantic, uniformState) {\n        var runtimeNode = model._runtime.nodes[source];\n        return gltfUniformsFromNode[semantic](uniformState, model, runtimeNode);\n    }\n\n    function createUniformsForMaterial(model, material, technique, instanceValues, context, textures, defaultTexture) {\n        var uniformMap = {};\n        var uniformValues = {};\n        var jointMatrixUniformName;\n        var morphWeightsUniformName;\n\n        ForEach.techniqueUniform(technique, function(uniform, uniformName) {\n            // GLTF_SPEC: This does not take into account uniform arrays,\n            // indicated by uniforms with a count property.\n            //\n            // https://github.com/KhronosGroup/glTF/issues/258\n\n            // GLTF_SPEC: In this implementation, material parameters with a\n            // semantic or targeted via a source (for animation) are not\n            // targetable for material animations.  Is this too strict?\n            //\n            // https://github.com/KhronosGroup/glTF/issues/142\n\n            var uv;\n            if (defined(instanceValues) && defined(instanceValues[uniformName])) {\n                // Parameter overrides by the instance technique\n                uv = ModelUtility.createUniformFunction(uniform.type, instanceValues[uniformName], textures, defaultTexture);\n                uniformMap[uniformName] = uv.func;\n                uniformValues[uniformName] = uv;\n            } else if (defined(uniform.node)) {\n                uniformMap[uniformName] = getUniformFunctionFromSource(uniform.node, model, uniform.semantic, context.uniformState);\n            } else if (defined(uniform.semantic)) {\n                if (uniform.semantic === 'JOINTMATRIX') {\n                    jointMatrixUniformName = uniformName;\n                } else if (uniform.semantic === 'MORPHWEIGHTS') {\n                    morphWeightsUniformName = uniformName;\n                } else if (uniform.semantic === 'ALPHACUTOFF') {\n                    // The material's alphaCutoff value uses a uniform with semantic ALPHACUTOFF.\n                    // A uniform with this semantic will ignore the instance or default values.\n                    var alphaMode = material.alphaMode;\n                    if (defined(alphaMode) && alphaMode === 'MASK') {\n                        var alphaCutoffValue = defaultValue(material.alphaCutoff, 0.5);\n                        uv = ModelUtility.createUniformFunction(uniform.type, alphaCutoffValue, textures, defaultTexture);\n                        uniformMap[uniformName] = uv.func;\n                        uniformValues[uniformName] = uv;\n                    }\n                } else {\n                    // Map glTF semantic to Cesium automatic uniform\n                    uniformMap[uniformName] = ModelUtility.getGltfSemanticUniforms()[uniform.semantic](context.uniformState, model);\n                }\n            } else if (defined(uniform.value)) {\n                // Technique value that isn't overridden by a material\n                var uv2 = ModelUtility.createUniformFunction(uniform.type, uniform.value, textures, defaultTexture);\n                uniformMap[uniformName] = uv2.func;\n                uniformValues[uniformName] = uv2;\n            }\n        });\n\n        return {\n            map : uniformMap,\n            values : uniformValues,\n            jointMatrixUniformName : jointMatrixUniformName,\n            morphWeightsUniformName : morphWeightsUniformName\n        };\n    }\n\n    function createUniformMaps(model, context) {\n        var loadResources = model._loadResources;\n\n        if (!loadResources.finishedProgramCreation()) {\n            return;\n        }\n\n        if (!loadResources.createUniformMaps) {\n            return;\n        }\n        loadResources.createUniformMaps = false;\n\n        var gltf = model.gltf;\n        var techniques = model._sourceTechniques;\n        var uniformMaps = model._uniformMaps;\n\n        var textures = model._rendererResources.textures;\n        var defaultTexture = model._defaultTexture;\n\n        ForEach.material(gltf, function (material, materialId) {\n            var modelMaterial = model._runtime.materialsById[materialId];\n            var technique = techniques[modelMaterial._technique];\n            var instanceValues = modelMaterial._values;\n\n            var uniforms = createUniformsForMaterial(model, material, technique, instanceValues, context, textures, defaultTexture);\n\n            var u = uniformMaps[materialId];\n            u.uniformMap = uniforms.map;                          // uniform name -> function for the renderer\n            u.values = uniforms.values;                           // material parameter name -> ModelMaterial for modifying the parameter at runtime\n            u.jointMatrixUniformName = uniforms.jointMatrixUniformName;\n            u.morphWeightsUniformName = uniforms.morphWeightsUniformName;\n        });\n    }\n\n    function createUniformsForDracoQuantizedAttributes(decodedData) {\n        return ModelUtility.createUniformsForDracoQuantizedAttributes(decodedData.attributes);\n    }\n\n    function createUniformsForQuantizedAttributes(model, primitive) {\n        var programId = getProgramForPrimitive(model, primitive);\n        var quantizedUniforms = model._quantizedUniforms[programId];\n        return ModelUtility.createUniformsForQuantizedAttributes(model.gltf, primitive, quantizedUniforms);\n    }\n\n    function createPickColorFunction(color) {\n        return function() {\n            return color;\n        };\n    }\n\n    function createJointMatricesFunction(runtimeNode) {\n        return function() {\n            return runtimeNode.computedJointMatrices;\n        };\n    }\n\n    function createMorphWeightsFunction(runtimeNode) {\n        return function() {\n            return runtimeNode.weights;\n        };\n    }\n\n    function createSilhouetteColorFunction(model) {\n        return function() {\n            return model.silhouetteColor;\n        };\n    }\n\n    function createSilhouetteSizeFunction(model) {\n        return function() {\n            return model.silhouetteSize;\n        };\n    }\n\n    function createColorFunction(model) {\n        return function() {\n            return model.color;\n        };\n    }\n\n    var scratchClippingPlaneMatrix = new Matrix4();\n    function createClippingPlanesMatrixFunction(model) {\n        return function() {\n            var clippingPlanes = model.clippingPlanes;\n            if (!defined(clippingPlanes) && !defined(model._sphericalHarmonicCoefficients) && !defined(model._specularEnvironmentMaps)) {\n                return Matrix4.IDENTITY;\n            }\n            var modelMatrix = defined(clippingPlanes) ? clippingPlanes.modelMatrix : Matrix4.IDENTITY;\n            return Matrix4.multiply(model._clippingPlaneModelViewMatrix, modelMatrix, scratchClippingPlaneMatrix);\n        };\n    }\n\n    function createClippingPlanesFunction(model) {\n        return function() {\n            var clippingPlanes = model.clippingPlanes;\n            return (!defined(clippingPlanes) || !clippingPlanes.enabled) ? model._defaultTexture : clippingPlanes.texture;\n        };\n    }\n\n    function createClippingPlanesEdgeStyleFunction(model) {\n        return function() {\n            var clippingPlanes = model.clippingPlanes;\n            if (!defined(clippingPlanes)) {\n                return Color.WHITE.withAlpha(0.0);\n            }\n\n            var style = Color.clone(clippingPlanes.edgeColor);\n            style.alpha = clippingPlanes.edgeWidth;\n            return style;\n        };\n    }\n\n    function createColorBlendFunction(model) {\n        return function() {\n            return ColorBlendMode.getColorBlend(model.colorBlendMode, model.colorBlendAmount);\n        };\n    }\n\n    function createIBLFactorFunction(model) {\n        return function() {\n            return model._imageBasedLightingFactor;\n        };\n    }\n\n    function createLightColorFunction(model) {\n        return function() {\n            return model._lightColor;\n        };\n    }\n\n    function createLuminanceAtZenithFunction(model) {\n        return function() {\n            return model.luminanceAtZenith;\n        };\n    }\n\n    function createSphericalHarmonicCoefficientsFunction(model) {\n        return function() {\n            return model._sphericalHarmonicCoefficients;\n        };\n    }\n\n    function createSpecularEnvironmentMapFunction(model) {\n        return function() {\n            return model._specularEnvironmentMapAtlas.texture;\n        };\n    }\n\n    function createSpecularEnvironmentMapSizeFunction(model) {\n        return function() {\n            return model._specularEnvironmentMapAtlas.texture.dimensions;\n        };\n    }\n\n    function createSpecularEnvironmentMapLOD(model) {\n        return function() {\n            return model._specularEnvironmentMapAtlas.maximumMipmapLevel;\n        };\n    }\n\n    function triangleCountFromPrimitiveIndices(primitive, indicesCount) {\n        switch (primitive.mode) {\n            case PrimitiveType.TRIANGLES:\n                return (indicesCount / 3);\n            case PrimitiveType.TRIANGLE_STRIP:\n            case PrimitiveType.TRIANGLE_FAN:\n                return Math.max(indicesCount - 2, 0);\n            default:\n                return 0;\n        }\n    }\n\n    function createCommand(model, gltfNode, runtimeNode, context, scene3DOnly) {\n        var nodeCommands = model._nodeCommands;\n        var pickIds = model._pickIds;\n        var allowPicking = model.allowPicking;\n        var runtimeMeshesByName = model._runtime.meshesByName;\n\n        var resources = model._rendererResources;\n        var rendererVertexArrays = resources.vertexArrays;\n        var rendererPrograms = resources.programs;\n        var rendererRenderStates = resources.renderStates;\n        var uniformMaps = model._uniformMaps;\n\n        var gltf = model.gltf;\n        var accessors = gltf.accessors;\n        var gltfMeshes = gltf.meshes;\n\n        var id = gltfNode.mesh;\n        var mesh = gltfMeshes[id];\n\n        var primitives = mesh.primitives;\n        var length = primitives.length;\n\n        // The glTF node hierarchy is a DAG so a node can have more than one\n        // parent, so a node may already have commands.  If so, append more\n        // since they will have a different model matrix.\n\n        for (var i = 0; i < length; ++i) {\n            var primitive = primitives[i];\n            var ix = accessors[primitive.indices];\n            var material = model._runtime.materialsById[primitive.material];\n            var programId = material._program;\n            var decodedData = model._decodedData[id + '.primitive.' + i];\n\n            var boundingSphere;\n            var positionAccessor = primitive.attributes.POSITION;\n            if (defined(positionAccessor)) {\n                var minMax = ModelUtility.getAccessorMinMax(gltf, positionAccessor);\n                boundingSphere = BoundingSphere.fromCornerPoints(Cartesian3.fromArray(minMax.min), Cartesian3.fromArray(minMax.max));\n            }\n\n            var vertexArray = rendererVertexArrays[id + '.primitive.' + i];\n            var offset;\n            var count;\n\n            // Use indices of the previously decoded Draco geometry.\n            if (defined(decodedData)) {\n                count = decodedData.numberOfIndices;\n                offset = 0;\n            } else if (defined(ix)) {\n                count = ix.count;\n                offset = (ix.byteOffset / IndexDatatype.getSizeInBytes(ix.componentType)); // glTF has offset in bytes.  Cesium has offsets in indices\n            } else {\n                var positions = accessors[primitive.attributes.POSITION];\n                count = positions.count;\n                offset = 0;\n            }\n\n            // Update model triangle count using number of indices\n            model._trianglesLength += triangleCountFromPrimitiveIndices(primitive, count);\n\n            var um = uniformMaps[primitive.material];\n            var uniformMap = um.uniformMap;\n            if (defined(um.jointMatrixUniformName)) {\n                var jointUniformMap = {};\n                jointUniformMap[um.jointMatrixUniformName] = createJointMatricesFunction(runtimeNode);\n\n                uniformMap = combine(uniformMap, jointUniformMap);\n            }\n            if (defined(um.morphWeightsUniformName)) {\n                var morphWeightsUniformMap = {};\n                morphWeightsUniformMap[um.morphWeightsUniformName] = createMorphWeightsFunction(runtimeNode);\n\n                uniformMap = combine(uniformMap, morphWeightsUniformMap);\n            }\n\n            uniformMap = combine(uniformMap, {\n                gltf_color : createColorFunction(model),\n                gltf_colorBlend : createColorBlendFunction(model),\n                gltf_clippingPlanes : createClippingPlanesFunction(model),\n                gltf_clippingPlanesEdgeStyle : createClippingPlanesEdgeStyleFunction(model),\n                gltf_clippingPlanesMatrix : createClippingPlanesMatrixFunction(model),\n                gltf_iblFactor : createIBLFactorFunction(model),\n                gltf_lightColor : createLightColorFunction(model),\n                gltf_sphericalHarmonicCoefficients : createSphericalHarmonicCoefficientsFunction(model),\n                gltf_specularMap : createSpecularEnvironmentMapFunction(model),\n                gltf_specularMapSize : createSpecularEnvironmentMapSizeFunction(model),\n                gltf_maxSpecularLOD : createSpecularEnvironmentMapLOD(model),\n                gltf_luminanceAtZenith : createLuminanceAtZenithFunction(model)\n            });\n\n            // Allow callback to modify the uniformMap\n            if (defined(model._uniformMapLoaded)) {\n                uniformMap = model._uniformMapLoaded(uniformMap, programId, runtimeNode);\n            }\n\n            // Add uniforms for decoding quantized attributes if used\n            var quantizedUniformMap = {};\n            if (model.extensionsUsed.WEB3D_quantized_attributes) {\n                quantizedUniformMap = createUniformsForQuantizedAttributes(model, primitive);\n            } else if (model._dequantizeInShader && defined(decodedData)) {\n                quantizedUniformMap = createUniformsForDracoQuantizedAttributes(decodedData);\n            }\n            uniformMap = combine(uniformMap, quantizedUniformMap);\n\n            var rs = rendererRenderStates[primitive.material];\n            var isTranslucent = rs.blending.enabled;\n\n            var owner = model._pickObject;\n            if (!defined(owner)) {\n                owner = {\n                    primitive : model,\n                    id : model.id,\n                    node : runtimeNode.publicNode,\n                    mesh : runtimeMeshesByName[mesh.name]\n                };\n            }\n\n            var castShadows = ShadowMode.castShadows(model._shadows);\n            var receiveShadows = ShadowMode.receiveShadows(model._shadows);\n\n            var pickId;\n            if (allowPicking && !defined(model._uniformMapLoaded)) {\n                pickId = context.createPickId(owner);\n                pickIds.push(pickId);\n                var pickUniforms = {\n                    czm_pickColor : createPickColorFunction(pickId.color)\n                };\n                uniformMap = combine(uniformMap, pickUniforms);\n            }\n\n            if (allowPicking) {\n                if (defined(model._pickIdLoaded) && defined(model._uniformMapLoaded)) {\n                    pickId = model._pickIdLoaded();\n                } else {\n                    pickId = 'czm_pickColor';\n                }\n            }\n\n            var command = new DrawCommand({\n                boundingVolume : new BoundingSphere(), // updated in update()\n                cull : model.cull,\n                modelMatrix : new Matrix4(),           // computed in update()\n                primitiveType : primitive.mode,\n                vertexArray : vertexArray,\n                count : count,\n                offset : offset,\n                shaderProgram : rendererPrograms[programId],\n                castShadows : castShadows,\n                receiveShadows : receiveShadows,\n                uniformMap : uniformMap,\n                renderState : rs,\n                owner : owner,\n                pass : isTranslucent ? Pass.TRANSLUCENT : model.opaquePass,\n                pickId : pickId\n            });\n\n            var command2D;\n            if (!scene3DOnly) {\n                command2D = DrawCommand.shallowClone(command);\n                command2D.boundingVolume = new BoundingSphere(); // updated in update()\n                command2D.modelMatrix = new Matrix4();           // updated in update()\n            }\n\n            var nodeCommand = {\n                show : true,\n                boundingSphere : boundingSphere,\n                command : command,\n                command2D : command2D,\n                // Generated on demand when silhouette size is greater than 0.0 and silhouette alpha is greater than 0.0\n                silhouetteModelCommand : undefined,\n                silhouetteModelCommand2D : undefined,\n                silhouetteColorCommand : undefined,\n                silhouetteColorCommand2D : undefined,\n                // Generated on demand when color alpha is less than 1.0\n                translucentCommand : undefined,\n                translucentCommand2D : undefined,\n                // For updating node commands on shader reconstruction\n                programId : programId\n            };\n            runtimeNode.commands.push(nodeCommand);\n            nodeCommands.push(nodeCommand);\n        }\n    }\n\n    function createRuntimeNodes(model, context, scene3DOnly) {\n        var loadResources = model._loadResources;\n\n        if (!loadResources.finishedEverythingButTextureCreation()) {\n            return;\n        }\n\n        if (!loadResources.createRuntimeNodes) {\n            return;\n        }\n        loadResources.createRuntimeNodes = false;\n\n        var rootNodes = [];\n        var runtimeNodes = model._runtime.nodes;\n\n        var gltf = model.gltf;\n        var nodes = gltf.nodes;\n        var skins = gltf.skins;\n\n        var scene = gltf.scenes[gltf.scene];\n        var sceneNodes = scene.nodes;\n        var length = sceneNodes.length;\n\n        var stack = [];\n        var seen = {};\n\n        for (var i = 0; i < length; ++i) {\n            stack.push({\n                parentRuntimeNode : undefined,\n                gltfNode : nodes[sceneNodes[i]],\n                id : sceneNodes[i]\n            });\n\n            var skeletonIds = [];\n            while (stack.length > 0) {\n                var n = stack.pop();\n                seen[n.id] = true;\n                var parentRuntimeNode = n.parentRuntimeNode;\n                var gltfNode = n.gltfNode;\n\n                // Node hierarchy is a DAG so a node can have more than one parent so it may already exist\n                var runtimeNode = runtimeNodes[n.id];\n                if (runtimeNode.parents.length === 0) {\n                    if (defined(gltfNode.matrix)) {\n                        runtimeNode.matrix = Matrix4.fromColumnMajorArray(gltfNode.matrix);\n                    } else {\n                        // TRS converted to Cesium types\n                        var rotation = gltfNode.rotation;\n                        runtimeNode.translation = Cartesian3.fromArray(gltfNode.translation);\n                        runtimeNode.rotation = Quaternion.unpack(rotation);\n                        runtimeNode.scale = Cartesian3.fromArray(gltfNode.scale);\n                    }\n                }\n\n                if (defined(parentRuntimeNode)) {\n                    parentRuntimeNode.children.push(runtimeNode);\n                    runtimeNode.parents.push(parentRuntimeNode);\n                } else {\n                    rootNodes.push(runtimeNode);\n                }\n\n                if (defined(gltfNode.mesh)) {\n                    createCommand(model, gltfNode, runtimeNode, context, scene3DOnly);\n                }\n\n                var children = gltfNode.children;\n                if (defined(children)) {\n                    var childrenLength = children.length;\n                    for (var j = 0; j < childrenLength; j++) {\n                        var childId = children[j];\n                        if (!seen[childId]) {\n                            stack.push({\n                                parentRuntimeNode : runtimeNode,\n                                gltfNode : nodes[childId],\n                                id : children[j]\n                            });\n                        }\n                    }\n                }\n\n                var skin = gltfNode.skin;\n                if (defined(skin)) {\n                    skeletonIds.push(skins[skin].skeleton);\n                }\n\n                if (stack.length === 0) {\n                    for (var k = 0; k < skeletonIds.length; k++) {\n                        var skeleton = skeletonIds[k];\n                        if (!seen[skeleton]) {\n                            stack.push({\n                                parentRuntimeNode : undefined,\n                                gltfNode : nodes[skeleton],\n                                id : skeleton\n                            });\n                        }\n                    }\n                }\n            }\n        }\n\n        model._runtime.rootNodes = rootNodes;\n        model._runtime.nodes = runtimeNodes;\n    }\n\n    function getGeometryByteLength(buffers) {\n        var memory = 0;\n        for (var id in buffers) {\n            if (buffers.hasOwnProperty(id)) {\n                memory += buffers[id].sizeInBytes;\n            }\n        }\n        return memory;\n    }\n\n    function getTexturesByteLength(textures) {\n        var memory = 0;\n        for (var id in textures) {\n            if (textures.hasOwnProperty(id)) {\n                memory += textures[id].sizeInBytes;\n            }\n        }\n        return memory;\n    }\n\n    function createResources(model, frameState) {\n        var context = frameState.context;\n        var scene3DOnly = frameState.scene3DOnly;\n        var quantizedVertexShaders = model._quantizedVertexShaders;\n        var toClipCoordinates = model._toClipCoordinatesGLSL = {};\n        var techniques = model._sourceTechniques;\n        var programs = model._sourcePrograms;\n\n        var resources = model._rendererResources;\n        var shaders = resources.sourceShaders;\n        if (model._loadRendererResourcesFromCache) {\n            shaders = resources.sourceShaders = model._cachedRendererResources.sourceShaders;\n        }\n\n        for (var techniqueId in techniques) {\n            if (techniques.hasOwnProperty(techniqueId)) {\n                var programId = techniques[techniqueId].program;\n                var program = programs[programId];\n                var shader = shaders[program.vertexShader];\n\n                ModelUtility.checkSupportedGlExtensions(program.glExtensions, context);\n\n                if (model.extensionsUsed.WEB3D_quantized_attributes || model._dequantizeInShader) {\n                    var quantizedVS = quantizedVertexShaders[programId];\n                    if (!defined(quantizedVS)) {\n                        quantizedVS = modifyShaderForQuantizedAttributes(shader, programId, model);\n                        quantizedVertexShaders[programId] = quantizedVS;\n                    }\n                    shader = quantizedVS;\n                }\n\n                shader = modifyShader(shader, programId, model._vertexShaderLoaded);\n                toClipCoordinates[programId] = ModelUtility.toClipCoordinatesGLSL(model.gltf, shader);\n            }\n        }\n\n        if (model._loadRendererResourcesFromCache) {\n            var cachedResources = model._cachedRendererResources;\n\n            resources.buffers = cachedResources.buffers;\n            resources.vertexArrays = cachedResources.vertexArrays;\n            resources.programs = cachedResources.programs;\n            resources.silhouettePrograms = cachedResources.silhouettePrograms;\n            resources.textures = cachedResources.textures;\n            resources.samplers = cachedResources.samplers;\n            resources.renderStates = cachedResources.renderStates;\n\n            // Vertex arrays are unique to this model, create instead of using the cache.\n            if (defined(model._precreatedAttributes)) {\n                createVertexArrays(model, context);\n            }\n\n            model._cachedGeometryByteLength += getGeometryByteLength(cachedResources.buffers);\n            model._cachedTexturesByteLength += getTexturesByteLength(cachedResources.textures);\n        } else {\n            createBuffers(model, frameState); // using glTF bufferViews\n            createPrograms(model, frameState);\n            createSamplers(model, context);\n            loadTexturesFromBufferViews(model);\n            createTextures(model, frameState);\n        }\n\n        createSkins(model);\n        createRuntimeAnimations(model);\n\n        if (!model._loadRendererResourcesFromCache) {\n            createVertexArrays(model, context); // using glTF meshes\n            createRenderStates(model); // using glTF materials/techniques/states\n            // Long-term, we might not cache render states if they could change\n            // due to an animation, e.g., a uniform going from opaque to transparent.\n            // Could use copy-on-write if it is worth it.  Probably overkill.\n        }\n\n        createUniformMaps(model, context);               // using glTF materials/techniques\n        createRuntimeNodes(model, context, scene3DOnly); // using glTF scene\n    }\n\n    ///////////////////////////////////////////////////////////////////////////\n\n    function getNodeMatrix(node, result) {\n        var publicNode = node.publicNode;\n        var publicMatrix = publicNode.matrix;\n\n        if (publicNode.useMatrix && defined(publicMatrix)) {\n            // Public matrix overrides original glTF matrix and glTF animations\n            Matrix4.clone(publicMatrix, result);\n        } else if (defined(node.matrix)) {\n            Matrix4.clone(node.matrix, result);\n        } else {\n            Matrix4.fromTranslationQuaternionRotationScale(node.translation, node.rotation, node.scale, result);\n            // Keep matrix returned by the node in-sync if the node is targeted by an animation.  Only TRS nodes can be targeted.\n            publicNode.setMatrix(result);\n        }\n    }\n\n    var scratchNodeStack = [];\n    var scratchComputedTranslation = new Cartesian4();\n    var scratchComputedMatrixIn2D = new Matrix4();\n\n    function updateNodeHierarchyModelMatrix(model, modelTransformChanged, justLoaded, projection) {\n        var maxDirtyNumber = model._maxDirtyNumber;\n\n        var rootNodes = model._runtime.rootNodes;\n        var length = rootNodes.length;\n\n        var nodeStack = scratchNodeStack;\n        var computedModelMatrix = model._computedModelMatrix;\n\n        if ((model._mode !== SceneMode.SCENE3D) && !model._ignoreCommands) {\n            var translation = Matrix4.getColumn(computedModelMatrix, 3, scratchComputedTranslation);\n            if (!Cartesian4.equals(translation, Cartesian4.UNIT_W)) {\n                computedModelMatrix = Transforms.basisTo2D(projection, computedModelMatrix, scratchComputedMatrixIn2D);\n                model._rtcCenter = model._rtcCenter3D;\n            } else {\n                var center = model.boundingSphere.center;\n                var to2D = Transforms.wgs84To2DModelMatrix(projection, center, scratchComputedMatrixIn2D);\n                computedModelMatrix = Matrix4.multiply(to2D, computedModelMatrix, scratchComputedMatrixIn2D);\n\n                if (defined(model._rtcCenter)) {\n                    Matrix4.setTranslation(computedModelMatrix, Cartesian4.UNIT_W, computedModelMatrix);\n                    model._rtcCenter = model._rtcCenter2D;\n                }\n            }\n        }\n\n        for (var i = 0; i < length; ++i) {\n            var n = rootNodes[i];\n\n            getNodeMatrix(n, n.transformToRoot);\n            nodeStack.push(n);\n\n            while (nodeStack.length > 0) {\n                n = nodeStack.pop();\n                var transformToRoot = n.transformToRoot;\n                var commands = n.commands;\n\n                if ((n.dirtyNumber === maxDirtyNumber) || modelTransformChanged || justLoaded) {\n                    var nodeMatrix = Matrix4.multiplyTransformation(computedModelMatrix, transformToRoot, n.computedMatrix);\n                    var commandsLength = commands.length;\n                    if (commandsLength > 0) {\n                        // Node has meshes, which has primitives.  Update their commands.\n                        for (var j = 0; j < commandsLength; ++j) {\n                            var primitiveCommand = commands[j];\n                            var command = primitiveCommand.command;\n                            Matrix4.clone(nodeMatrix, command.modelMatrix);\n\n                            // PERFORMANCE_IDEA: Can use transformWithoutScale if no node up to the root has scale (including animation)\n                            BoundingSphere.transform(primitiveCommand.boundingSphere, command.modelMatrix, command.boundingVolume);\n\n                            if (defined(model._rtcCenter)) {\n                                Cartesian3.add(model._rtcCenter, command.boundingVolume.center, command.boundingVolume.center);\n                            }\n\n                            // If the model crosses the IDL in 2D, it will be drawn in one viewport, but part of it\n                            // will be clipped by the viewport. We create a second command that translates the model\n                            // model matrix to the opposite side of the map so the part that was clipped in one viewport\n                            // is drawn in the other.\n                            command = primitiveCommand.command2D;\n                            if (defined(command) && model._mode === SceneMode.SCENE2D) {\n                                Matrix4.clone(nodeMatrix, command.modelMatrix);\n                                command.modelMatrix[13] -= CesiumMath.sign(command.modelMatrix[13]) * 2.0 * CesiumMath.PI * projection.ellipsoid.maximumRadius;\n                                BoundingSphere.transform(primitiveCommand.boundingSphere, command.modelMatrix, command.boundingVolume);\n                            }\n                        }\n                    }\n                }\n\n                var children = n.children;\n                if (defined(children)) {\n                    var childrenLength = children.length;\n                    for (var k = 0; k < childrenLength; ++k) {\n                        var child = children[k];\n\n                        // A node's transform needs to be updated if\n                        // - It was targeted for animation this frame, or\n                        // - Any of its ancestors were targeted for animation this frame\n\n                        // PERFORMANCE_IDEA: if a child has multiple parents and only one of the parents\n                        // is dirty, all the subtrees for each child instance will be dirty; we probably\n                        // won't see this in the wild often.\n                        child.dirtyNumber = Math.max(child.dirtyNumber, n.dirtyNumber);\n\n                        if ((child.dirtyNumber === maxDirtyNumber) || justLoaded) {\n                            // Don't check for modelTransformChanged since if only the model's model matrix changed,\n                            // we do not need to rebuild the local transform-to-root, only the final\n                            // [model's-model-matrix][transform-to-root] above.\n                            getNodeMatrix(child, child.transformToRoot);\n                            Matrix4.multiplyTransformation(transformToRoot, child.transformToRoot, child.transformToRoot);\n                        }\n\n                        nodeStack.push(child);\n                    }\n                }\n            }\n        }\n\n        ++model._maxDirtyNumber;\n    }\n\n    var scratchObjectSpace = new Matrix4();\n\n    function applySkins(model) {\n        var skinnedNodes = model._runtime.skinnedNodes;\n        var length = skinnedNodes.length;\n\n        for (var i = 0; i < length; ++i) {\n            var node = skinnedNodes[i];\n\n            scratchObjectSpace = Matrix4.inverseTransformation(node.transformToRoot, scratchObjectSpace);\n\n            var computedJointMatrices = node.computedJointMatrices;\n            var joints = node.joints;\n            var bindShapeMatrix = node.bindShapeMatrix;\n            var inverseBindMatrices = node.inverseBindMatrices;\n            var inverseBindMatricesLength = inverseBindMatrices.length;\n\n            for (var m = 0; m < inverseBindMatricesLength; ++m) {\n                // [joint-matrix] = [node-to-root^-1][joint-to-root][inverse-bind][bind-shape]\n                if (!defined(computedJointMatrices[m])) {\n                    computedJointMatrices[m] = new Matrix4();\n                }\n                computedJointMatrices[m] = Matrix4.multiplyTransformation(scratchObjectSpace, joints[m].transformToRoot, computedJointMatrices[m]);\n                computedJointMatrices[m] = Matrix4.multiplyTransformation(computedJointMatrices[m], inverseBindMatrices[m], computedJointMatrices[m]);\n                if (defined(bindShapeMatrix)) {\n                    // Optimization for when bind shape matrix is the identity.\n                    computedJointMatrices[m] = Matrix4.multiplyTransformation(computedJointMatrices[m], bindShapeMatrix, computedJointMatrices[m]);\n                }\n            }\n        }\n    }\n\n    function updatePerNodeShow(model) {\n        // Totally not worth it, but we could optimize this:\n        // http://help.agi.com/AGIComponents/html/BlogDeletionInBoundingVolumeHierarchies.htm\n\n        var rootNodes = model._runtime.rootNodes;\n        var length = rootNodes.length;\n\n        var nodeStack = scratchNodeStack;\n\n        for (var i = 0; i < length; ++i) {\n            var n = rootNodes[i];\n            n.computedShow = n.publicNode.show;\n            nodeStack.push(n);\n\n            while (nodeStack.length > 0) {\n                n = nodeStack.pop();\n                var show = n.computedShow;\n\n                var nodeCommands = n.commands;\n                var nodeCommandsLength = nodeCommands.length;\n                for (var j = 0; j < nodeCommandsLength; ++j) {\n                    nodeCommands[j].show = show;\n                }\n                // if commandsLength is zero, the node has a light or camera\n\n                var children = n.children;\n                if (defined(children)) {\n                    var childrenLength = children.length;\n                    for (var k = 0; k < childrenLength; ++k) {\n                        var child = children[k];\n                        // Parent needs to be shown for child to be shown.\n                        child.computedShow = show && child.publicNode.show;\n                        nodeStack.push(child);\n                    }\n                }\n            }\n        }\n    }\n\n    function updatePickIds(model, context) {\n        var id = model.id;\n        if (model._id !== id) {\n            model._id = id;\n\n            var pickIds = model._pickIds;\n            var length = pickIds.length;\n            for (var i = 0; i < length; ++i) {\n                pickIds[i].object.id = id;\n            }\n        }\n    }\n\n    function updateWireframe(model) {\n        if (model._debugWireframe !== model.debugWireframe) {\n            model._debugWireframe = model.debugWireframe;\n\n            // This assumes the original primitive was TRIANGLES and that the triangles\n            // are connected for the wireframe to look perfect.\n            var primitiveType = model.debugWireframe ? PrimitiveType.LINES : PrimitiveType.TRIANGLES;\n            var nodeCommands = model._nodeCommands;\n            var length = nodeCommands.length;\n\n            for (var i = 0; i < length; ++i) {\n                nodeCommands[i].command.primitiveType = primitiveType;\n            }\n        }\n    }\n\n    function updateShowBoundingVolume(model) {\n        if (model.debugShowBoundingVolume !== model._debugShowBoundingVolume) {\n            model._debugShowBoundingVolume = model.debugShowBoundingVolume;\n\n            var debugShowBoundingVolume = model.debugShowBoundingVolume;\n            var nodeCommands = model._nodeCommands;\n            var length = nodeCommands.length;\n\n            for (var i = 0; i < length; ++i) {\n                nodeCommands[i].command.debugShowBoundingVolume = debugShowBoundingVolume;\n            }\n        }\n    }\n\n    function updateShadows(model) {\n        if (model.shadows !== model._shadows) {\n            model._shadows = model.shadows;\n\n            var castShadows = ShadowMode.castShadows(model.shadows);\n            var receiveShadows = ShadowMode.receiveShadows(model.shadows);\n            var nodeCommands = model._nodeCommands;\n            var length = nodeCommands.length;\n\n            for (var i = 0; i < length; i++) {\n                var nodeCommand = nodeCommands[i];\n                nodeCommand.command.castShadows = castShadows;\n                nodeCommand.command.receiveShadows = receiveShadows;\n            }\n        }\n    }\n\n    function getTranslucentRenderState(renderState) {\n        var rs = clone(renderState, true);\n        rs.cull.enabled = false;\n        rs.depthTest.enabled = true;\n        rs.depthMask = false;\n        rs.blending = BlendingState.ALPHA_BLEND;\n\n        return RenderState.fromCache(rs);\n    }\n\n    function deriveTranslucentCommand(command) {\n        var translucentCommand = DrawCommand.shallowClone(command);\n        translucentCommand.pass = Pass.TRANSLUCENT;\n        translucentCommand.renderState = getTranslucentRenderState(command.renderState);\n        return translucentCommand;\n    }\n\n    function updateColor(model, frameState, forceDerive) {\n        // Generate translucent commands when the blend color has an alpha in the range (0.0, 1.0) exclusive\n        var scene3DOnly = frameState.scene3DOnly;\n        var alpha = model.color.alpha;\n        if ((alpha > 0.0) && (alpha < 1.0)) {\n            var nodeCommands = model._nodeCommands;\n            var length = nodeCommands.length;\n            if (!defined(nodeCommands[0].translucentCommand) || forceDerive) {\n                for (var i = 0; i < length; ++i) {\n                    var nodeCommand = nodeCommands[i];\n                    var command = nodeCommand.command;\n                    nodeCommand.translucentCommand = deriveTranslucentCommand(command);\n                    if (!scene3DOnly) {\n                        var command2D = nodeCommand.command2D;\n                        nodeCommand.translucentCommand2D = deriveTranslucentCommand(command2D);\n                    }\n                }\n            }\n        }\n    }\n\n    function getProgramId(model, program) {\n        var programs = model._rendererResources.programs;\n        for (var id in programs) {\n            if (programs.hasOwnProperty(id)) {\n                if (programs[id] === program) {\n                    return id;\n                }\n            }\n        }\n    }\n\n    function createSilhouetteProgram(model, program, frameState) {\n        var vs = program.vertexShaderSource.sources[0];\n        var attributeLocations = program._attributeLocations;\n        var normalAttributeName = model._normalAttributeName;\n\n        // Modified from http://forum.unity3d.com/threads/toon-outline-but-with-diffuse-surface.24668/\n        vs = ShaderSource.replaceMain(vs, 'gltf_silhouette_main');\n        vs +=\n            'uniform float gltf_silhouetteSize; \\n' +\n            'void main() \\n' +\n            '{ \\n' +\n            '    gltf_silhouette_main(); \\n' +\n            '    vec3 n = normalize(czm_normal3D * ' + normalAttributeName + '); \\n' +\n            '    n.x *= czm_projection[0][0]; \\n' +\n            '    n.y *= czm_projection[1][1]; \\n' +\n            '    vec4 clip = gl_Position; \\n' +\n            '    clip.xy += n.xy * clip.w * gltf_silhouetteSize * czm_pixelRatio / czm_viewport.z; \\n' +\n            '    gl_Position = clip; \\n' +\n            '}';\n\n        var fs =\n            'uniform vec4 gltf_silhouetteColor; \\n' +\n            'void main() \\n' +\n            '{ \\n' +\n            '    gl_FragColor = czm_gammaCorrect(gltf_silhouetteColor); \\n' +\n            '}';\n\n        return ShaderProgram.fromCache({\n            context : frameState.context,\n            vertexShaderSource : vs,\n            fragmentShaderSource : fs,\n            attributeLocations : attributeLocations\n        });\n    }\n\n    function hasSilhouette(model, frameState) {\n        return silhouetteSupported(frameState.context) && (model.silhouetteSize > 0.0) && (model.silhouetteColor.alpha > 0.0) && defined(model._normalAttributeName);\n    }\n\n    function hasTranslucentCommands(model) {\n        var nodeCommands = model._nodeCommands;\n        var length = nodeCommands.length;\n        for (var i = 0; i < length; ++i) {\n            var nodeCommand = nodeCommands[i];\n            var command = nodeCommand.command;\n            if (command.pass === Pass.TRANSLUCENT) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function isTranslucent(model) {\n        return (model.color.alpha > 0.0) && (model.color.alpha < 1.0);\n    }\n\n    function isInvisible(model) {\n        return (model.color.alpha === 0.0);\n    }\n\n    function alphaDirty(currAlpha, prevAlpha) {\n        // Returns whether the alpha state has changed between invisible, translucent, or opaque\n        return (Math.floor(currAlpha) !== Math.floor(prevAlpha)) || (Math.ceil(currAlpha) !== Math.ceil(prevAlpha));\n    }\n\n    var silhouettesLength = 0;\n\n    function createSilhouetteCommands(model, frameState) {\n        // Wrap around after exceeding the 8-bit stencil limit.\n        // The reference is unique to each model until this point.\n        var stencilReference = (++silhouettesLength) % 255;\n\n        // If the model is translucent the silhouette needs to be in the translucent pass.\n        // Otherwise the silhouette would be rendered before the model.\n        var silhouetteTranslucent = hasTranslucentCommands(model) || isTranslucent(model) || (model.silhouetteColor.alpha < 1.0);\n        var silhouettePrograms = model._rendererResources.silhouettePrograms;\n        var scene3DOnly = frameState.scene3DOnly;\n        var nodeCommands = model._nodeCommands;\n        var length = nodeCommands.length;\n        for (var i = 0; i < length; ++i) {\n            var nodeCommand = nodeCommands[i];\n            var command = nodeCommand.command;\n\n            // Create model command\n            var modelCommand = isTranslucent(model) ? nodeCommand.translucentCommand : command;\n            var silhouetteModelCommand = DrawCommand.shallowClone(modelCommand);\n            var renderState = clone(modelCommand.renderState);\n\n            // Write the reference value into the stencil buffer.\n            renderState.stencilTest = {\n                enabled : true,\n                frontFunction : WebGLConstants.ALWAYS,\n                backFunction : WebGLConstants.ALWAYS,\n                reference : stencilReference,\n                mask : ~0,\n                frontOperation : {\n                    fail : WebGLConstants.KEEP,\n                    zFail : WebGLConstants.KEEP,\n                    zPass : WebGLConstants.REPLACE\n                },\n                backOperation : {\n                    fail : WebGLConstants.KEEP,\n                    zFail : WebGLConstants.KEEP,\n                    zPass : WebGLConstants.REPLACE\n                }\n            };\n\n            if (isInvisible(model)) {\n                // When the model is invisible disable color and depth writes but still write into the stencil buffer\n                renderState.colorMask = {\n                    red : false,\n                    green : false,\n                    blue : false,\n                    alpha : false\n                };\n                renderState.depthMask = false;\n            }\n            renderState = RenderState.fromCache(renderState);\n            silhouetteModelCommand.renderState = renderState;\n            nodeCommand.silhouetteModelCommand = silhouetteModelCommand;\n\n            // Create color command\n            var silhouetteColorCommand = DrawCommand.shallowClone(command);\n            renderState = clone(command.renderState, true);\n            renderState.depthTest.enabled = true;\n            renderState.cull.enabled = false;\n            if (silhouetteTranslucent) {\n                silhouetteColorCommand.pass = Pass.TRANSLUCENT;\n                renderState.depthMask = false;\n                renderState.blending = BlendingState.ALPHA_BLEND;\n            }\n\n            // Only render silhouette if the value in the stencil buffer equals the reference\n            renderState.stencilTest = {\n                enabled : true,\n                frontFunction : WebGLConstants.NOTEQUAL,\n                backFunction : WebGLConstants.NOTEQUAL,\n                reference : stencilReference,\n                mask : ~0,\n                frontOperation : {\n                    fail : WebGLConstants.KEEP,\n                    zFail : WebGLConstants.KEEP,\n                    zPass : WebGLConstants.KEEP\n                },\n                backOperation : {\n                    fail : WebGLConstants.KEEP,\n                    zFail : WebGLConstants.KEEP,\n                    zPass : WebGLConstants.KEEP\n                }\n            };\n            renderState = RenderState.fromCache(renderState);\n\n            // If the silhouette program has already been cached use it\n            var program = command.shaderProgram;\n            var id = getProgramId(model, program);\n            var silhouetteProgram = silhouettePrograms[id];\n            if (!defined(silhouetteProgram)) {\n                silhouetteProgram = createSilhouetteProgram(model, program, frameState);\n                silhouettePrograms[id] = silhouetteProgram;\n            }\n\n            var silhouetteUniformMap = combine(command.uniformMap, {\n                gltf_silhouetteColor : createSilhouetteColorFunction(model),\n                gltf_silhouetteSize : createSilhouetteSizeFunction(model)\n            });\n\n            silhouetteColorCommand.renderState = renderState;\n            silhouetteColorCommand.shaderProgram = silhouetteProgram;\n            silhouetteColorCommand.uniformMap = silhouetteUniformMap;\n            silhouetteColorCommand.castShadows = false;\n            silhouetteColorCommand.receiveShadows = false;\n            nodeCommand.silhouetteColorCommand = silhouetteColorCommand;\n\n            if (!scene3DOnly) {\n                var command2D = nodeCommand.command2D;\n                var silhouetteModelCommand2D = DrawCommand.shallowClone(silhouetteModelCommand);\n                silhouetteModelCommand2D.boundingVolume = command2D.boundingVolume;\n                silhouetteModelCommand2D.modelMatrix = command2D.modelMatrix;\n                nodeCommand.silhouetteModelCommand2D = silhouetteModelCommand2D;\n\n                var silhouetteColorCommand2D = DrawCommand.shallowClone(silhouetteColorCommand);\n                silhouetteModelCommand2D.boundingVolume = command2D.boundingVolume;\n                silhouetteModelCommand2D.modelMatrix = command2D.modelMatrix;\n                nodeCommand.silhouetteColorCommand2D = silhouetteColorCommand2D;\n            }\n        }\n    }\n\n    function modifyShaderForClippingPlanes(shader, clippingPlaneCollection, context) {\n        shader = ShaderSource.replaceMain(shader, 'gltf_clip_main');\n        shader += Model._getClippingFunction(clippingPlaneCollection, context) + '\\n';\n        shader +=\n            'uniform sampler2D gltf_clippingPlanes; \\n' +\n            'uniform mat4 gltf_clippingPlanesMatrix; \\n' +\n            'uniform vec4 gltf_clippingPlanesEdgeStyle; \\n' +\n            'void main() \\n' +\n            '{ \\n' +\n            '    gltf_clip_main(); \\n' +\n            getClipAndStyleCode('gltf_clippingPlanes', 'gltf_clippingPlanesMatrix', 'gltf_clippingPlanesEdgeStyle') +\n            '} \\n';\n        return shader;\n    }\n\n    function updateSilhouette(model, frameState, force) {\n        // Generate silhouette commands when the silhouette size is greater than 0.0 and the alpha is greater than 0.0\n        // There are two silhouette commands:\n        //     1. silhouetteModelCommand : render model normally while enabling stencil mask\n        //     2. silhouetteColorCommand : render enlarged model with a solid color while enabling stencil tests\n        if (!hasSilhouette(model, frameState)) {\n            return;\n        }\n\n        var nodeCommands = model._nodeCommands;\n        var dirty = alphaDirty(model.color.alpha, model._colorPreviousAlpha) ||\n                    alphaDirty(model.silhouetteColor.alpha, model._silhouetteColorPreviousAlpha) ||\n                    !defined(nodeCommands[0].silhouetteModelCommand);\n\n        model._colorPreviousAlpha = model.color.alpha;\n        model._silhouetteColorPreviousAlpha = model.silhouetteColor.alpha;\n\n        if (dirty || force) {\n            createSilhouetteCommands(model, frameState);\n        }\n    }\n\n    function updateClippingPlanes(model, frameState) {\n        var clippingPlanes = model._clippingPlanes;\n        if (defined(clippingPlanes) && clippingPlanes.owner === model) {\n            if (clippingPlanes.enabled) {\n                clippingPlanes.update(frameState);\n            }\n        }\n    }\n\n    var scratchBoundingSphere = new BoundingSphere();\n\n    function scaleInPixels(positionWC, radius, frameState) {\n        scratchBoundingSphere.center = positionWC;\n        scratchBoundingSphere.radius = radius;\n        return frameState.camera.getPixelSize(scratchBoundingSphere, frameState.context.drawingBufferWidth, frameState.context.drawingBufferHeight);\n    }\n\n    var scratchPosition = new Cartesian3();\n    var scratchCartographic = new Cartographic();\n\n    function getScale(model, frameState) {\n        var scale = model.scale;\n\n        if (model.minimumPixelSize !== 0.0) {\n            // Compute size of bounding sphere in pixels\n            var context = frameState.context;\n            var maxPixelSize = Math.max(context.drawingBufferWidth, context.drawingBufferHeight);\n            var m = defined(model._clampedModelMatrix) ? model._clampedModelMatrix : model.modelMatrix;\n            scratchPosition.x = m[12];\n            scratchPosition.y = m[13];\n            scratchPosition.z = m[14];\n\n            if (defined(model._rtcCenter)) {\n                Cartesian3.add(model._rtcCenter, scratchPosition, scratchPosition);\n            }\n\n            if (model._mode !== SceneMode.SCENE3D) {\n                var projection = frameState.mapProjection;\n                var cartographic = projection.ellipsoid.cartesianToCartographic(scratchPosition, scratchCartographic);\n                projection.project(cartographic, scratchPosition);\n                Cartesian3.fromElements(scratchPosition.z, scratchPosition.x, scratchPosition.y, scratchPosition);\n            }\n\n            var radius = model.boundingSphere.radius;\n            var metersPerPixel = scaleInPixels(scratchPosition, radius, frameState);\n\n            // metersPerPixel is always > 0.0\n            var pixelsPerMeter = 1.0 / metersPerPixel;\n            var diameterInPixels = Math.min(pixelsPerMeter * (2.0 * radius), maxPixelSize);\n\n            // Maintain model's minimum pixel size\n            if (diameterInPixels < model.minimumPixelSize) {\n                scale = (model.minimumPixelSize * metersPerPixel) / (2.0 * model._initialRadius);\n            }\n        }\n\n        return defined(model.maximumScale) ? Math.min(model.maximumScale, scale) : scale;\n    }\n\n    function releaseCachedGltf(model) {\n        if (defined(model._cacheKey) && defined(model._cachedGltf) && (--model._cachedGltf.count === 0)) {\n            delete gltfCache[model._cacheKey];\n        }\n        model._cachedGltf = undefined;\n    }\n\n    ///////////////////////////////////////////////////////////////////////////\n\n    function CachedRendererResources(context, cacheKey) {\n        this.buffers = undefined;\n        this.vertexArrays = undefined;\n        this.programs = undefined;\n        this.sourceShaders = undefined;\n        this.silhouettePrograms = undefined;\n        this.textures = undefined;\n        this.samplers = undefined;\n        this.renderStates = undefined;\n        this.ready = false;\n\n        this.context = context;\n        this.cacheKey = cacheKey;\n        this.count = 0;\n    }\n\n    function destroy(property) {\n        for (var name in property) {\n            if (property.hasOwnProperty(name)) {\n                property[name].destroy();\n            }\n        }\n    }\n\n    function destroyCachedRendererResources(resources) {\n        destroy(resources.buffers);\n        destroy(resources.vertexArrays);\n        destroy(resources.programs);\n        destroy(resources.silhouettePrograms);\n        destroy(resources.textures);\n    }\n\n    CachedRendererResources.prototype.release = function() {\n        if (--this.count === 0) {\n            if (defined(this.cacheKey)) {\n                // Remove if this was cached\n                delete this.context.cache.modelRendererResourceCache[this.cacheKey];\n            }\n            destroyCachedRendererResources(this);\n            return destroyObject(this);\n        }\n\n        return undefined;\n    };\n\n    ///////////////////////////////////////////////////////////////////////////\n\n    function getUpdateHeightCallback(model, ellipsoid, cartoPosition) {\n        return function(clampedPosition) {\n            if (model.heightReference === HeightReference.RELATIVE_TO_GROUND) {\n                var clampedCart = ellipsoid.cartesianToCartographic(clampedPosition, scratchCartographic);\n                clampedCart.height += cartoPosition.height;\n                ellipsoid.cartographicToCartesian(clampedCart, clampedPosition);\n            }\n\n            var clampedModelMatrix = model._clampedModelMatrix;\n\n            // Modify clamped model matrix to use new height\n            Matrix4.clone(model.modelMatrix, clampedModelMatrix);\n            clampedModelMatrix[12] = clampedPosition.x;\n            clampedModelMatrix[13] = clampedPosition.y;\n            clampedModelMatrix[14] = clampedPosition.z;\n\n            model._heightChanged = true;\n        };\n    }\n\n    function updateClamping(model) {\n        if (defined(model._removeUpdateHeightCallback)) {\n            model._removeUpdateHeightCallback();\n            model._removeUpdateHeightCallback = undefined;\n        }\n\n        var scene = model._scene;\n        if (!defined(scene) || !defined(scene.globe) || (model.heightReference === HeightReference.NONE)) {\n            \n            model._clampedModelMatrix = undefined;\n            return;\n        }\n\n        var globe = scene.globe;\n        var ellipsoid = globe.ellipsoid;\n\n        // Compute cartographic position so we don't recompute every update\n        var modelMatrix = model.modelMatrix;\n        scratchPosition.x = modelMatrix[12];\n        scratchPosition.y = modelMatrix[13];\n        scratchPosition.z = modelMatrix[14];\n        var cartoPosition = ellipsoid.cartesianToCartographic(scratchPosition);\n\n        if (!defined(model._clampedModelMatrix)) {\n            model._clampedModelMatrix = Matrix4.clone(modelMatrix, new Matrix4());\n        }\n\n        // Install callback to handle updating of terrain tiles\n        var surface = globe._surface;\n        model._removeUpdateHeightCallback = surface.updateHeight(cartoPosition, getUpdateHeightCallback(model, ellipsoid, cartoPosition));\n\n        // Set the correct height now\n        var height = globe.getHeight(cartoPosition);\n        if (defined(height)) {\n            // Get callback with cartoPosition being the non-clamped position\n            var cb = getUpdateHeightCallback(model, ellipsoid, cartoPosition);\n\n            // Compute the clamped cartesian and call updateHeight callback\n            Cartographic.clone(cartoPosition, scratchCartographic);\n            scratchCartographic.height = height;\n            ellipsoid.cartographicToCartesian(scratchCartographic, scratchPosition);\n            cb(scratchPosition);\n        }\n    }\n\n    var scratchDisplayConditionCartesian = new Cartesian3();\n    var scratchDistanceDisplayConditionCartographic = new Cartographic();\n\n    function distanceDisplayConditionVisible(model, frameState) {\n        var distance2;\n        var ddc = model.distanceDisplayCondition;\n        var nearSquared = ddc.near * ddc.near;\n        var farSquared = ddc.far * ddc.far;\n\n        if (frameState.mode === SceneMode.SCENE2D) {\n            var frustum2DWidth = frameState.camera.frustum.right - frameState.camera.frustum.left;\n            distance2 = frustum2DWidth * 0.5;\n            distance2 = distance2 * distance2;\n        } else {\n            // Distance to center of primitive's reference frame\n            var position = Matrix4.getTranslation(model.modelMatrix, scratchDisplayConditionCartesian);\n            if (frameState.mode === SceneMode.COLUMBUS_VIEW) {\n                var projection = frameState.mapProjection;\n                var ellipsoid = projection.ellipsoid;\n                var cartographic = ellipsoid.cartesianToCartographic(position, scratchDistanceDisplayConditionCartographic);\n                position = projection.project(cartographic, position);\n                Cartesian3.fromElements(position.z, position.x, position.y, position);\n            }\n            distance2 = Cartesian3.distanceSquared(position, frameState.camera.positionWC);\n        }\n\n        return (distance2 >= nearSquared) && (distance2 <= farSquared);\n    }\n\n    /**\n     * Called when {@link Viewer} or {@link CesiumWidget} render the scene to\n     * get the draw commands needed to render this primitive.\n     * <p>\n     * Do not call this function directly.  This is documented just to\n     * list the exceptions that may be propagated when the scene is rendered:\n     * </p>\n     *\n     * @exception {RuntimeError} Failed to load external reference.\n     */\n    Model.prototype.update = function(frameState) {\n        if (frameState.mode === SceneMode.MORPHING) {\n            return;\n        }\n\n        if (!FeatureDetection.supportsWebP.initialized) {\n            FeatureDetection.supportsWebP.initialize();\n            return;\n        }\n        var supportsWebP = FeatureDetection.supportsWebP();\n\n        var context = frameState.context;\n        this._defaultTexture = context.defaultTexture;\n\n        if ((this._state === ModelState.NEEDS_LOAD) && defined(this.gltf)) {\n            // Use renderer resources from cache instead of loading/creating them?\n            var cachedRendererResources;\n            var cacheKey = this.cacheKey;\n            if (defined(cacheKey)) { // cache key given? this model will pull from or contribute to context level cache\n                context.cache.modelRendererResourceCache = defaultValue(context.cache.modelRendererResourceCache, {});\n                var modelCaches = context.cache.modelRendererResourceCache;\n\n                cachedRendererResources = modelCaches[this.cacheKey];\n                if (defined(cachedRendererResources)) {\n                    if (!cachedRendererResources.ready) {\n                        // Cached resources for the model are not loaded yet.  We'll\n                        // try again every frame until they are.\n                        return;\n                    }\n\n                    ++cachedRendererResources.count;\n                    this._loadRendererResourcesFromCache = true;\n                } else {\n                    cachedRendererResources = new CachedRendererResources(context, cacheKey);\n                    cachedRendererResources.count = 1;\n                    modelCaches[this.cacheKey] = cachedRendererResources;\n                }\n                this._cachedRendererResources = cachedRendererResources;\n            } else { // cache key not given? this model doesn't care about context level cache at all. Cache is here to simplify freeing on destroy.\n                cachedRendererResources = new CachedRendererResources(context);\n                cachedRendererResources.count = 1;\n                this._cachedRendererResources = cachedRendererResources;\n            }\n\n            this._state = ModelState.LOADING;\n            if (this._state !== ModelState.FAILED) {\n                var extensions = this.gltf.extensions;\n                if (defined(extensions) && defined(extensions.CESIUM_RTC)) {\n                    var center = Cartesian3.fromArray(extensions.CESIUM_RTC.center);\n                    if (!Cartesian3.equals(center, Cartesian3.ZERO)) {\n                        this._rtcCenter3D = center;\n\n                        var projection = frameState.mapProjection;\n                        var ellipsoid = projection.ellipsoid;\n                        var cartographic = ellipsoid.cartesianToCartographic(this._rtcCenter3D);\n                        var projectedCart = projection.project(cartographic);\n                        Cartesian3.fromElements(projectedCart.z, projectedCart.x, projectedCart.y, projectedCart);\n                        this._rtcCenter2D = projectedCart;\n\n                        this._rtcCenterEye = new Cartesian3();\n                        this._rtcCenter = this._rtcCenter3D;\n                    }\n                }\n\n                addPipelineExtras(this.gltf);\n\n                this._loadResources = new ModelLoadResources();\n                if (!this._loadRendererResourcesFromCache) {\n                    // Buffers are required to updateVersion\n                    ModelUtility.parseBuffers(this, bufferLoad);\n                }\n            }\n        }\n\n        var loadResources = this._loadResources;\n        var incrementallyLoadTextures = this._incrementallyLoadTextures;\n        var justLoaded = false;\n\n        if (this._state === ModelState.LOADING) {\n            // Transition from LOADING -> LOADED once resources are downloaded and created.\n            // Textures may continue to stream in while in the LOADED state.\n            if (loadResources.pendingBufferLoads === 0) {\n                if (!loadResources.initialized) {\n                    frameState.brdfLutGenerator.update(frameState);\n\n                    ModelUtility.checkSupportedExtensions(this.extensionsRequired, supportsWebP);\n                    ModelUtility.updateForwardAxis(this);\n\n                    // glTF pipeline updates, not needed if loading from cache\n                    if (!defined(this.gltf.extras.sourceVersion)) {\n                        var gltf = this.gltf;\n                        // Add the original version so it remains cached\n                        gltf.extras.sourceVersion = ModelUtility.getAssetVersion(gltf);\n                        gltf.extras.sourceKHRTechniquesWebGL = defined(ModelUtility.getUsedExtensions(gltf).KHR_techniques_webgl);\n\n                        this._sourceVersion = gltf.extras.sourceVersion;\n                        this._sourceKHRTechniquesWebGL = gltf.extras.sourceKHRTechniquesWebGL;\n\n                        updateVersion(gltf);\n                        addDefaults(gltf);\n\n                        var options = {\n                            addBatchIdToGeneratedShaders: this._addBatchIdToGeneratedShaders\n                        };\n\n                        processModelMaterialsCommon(gltf, options);\n                        processPbrMaterials(gltf, options);\n                    }\n\n                    this._sourceVersion = this.gltf.extras.sourceVersion;\n                    this._sourceKHRTechniquesWebGL = this.gltf.extras.sourceKHRTechniquesWebGL;\n\n                    // Skip dequantizing in the shader if not encoded\n                    this._dequantizeInShader = this._dequantizeInShader && DracoLoader.hasExtension(this);\n\n                    // We do this after to make sure that the ids don't change\n                    addBuffersToLoadResources(this);\n                    parseArticulations(this);\n                    parseTechniques(this);\n                    if (!this._loadRendererResourcesFromCache) {\n                        parseBufferViews(this);\n                        parseShaders(this);\n                        parsePrograms(this);\n                        parseTextures(this, context, supportsWebP);\n                    }\n                    parseMaterials(this);\n                    parseMeshes(this);\n                    parseNodes(this);\n\n                    // Start draco decoding\n                    DracoLoader.parse(this, context);\n\n                    loadResources.initialized = true;\n                }\n\n                if (!loadResources.finishedDecoding()) {\n                    DracoLoader.decodeModel(this, context)\n                        .otherwise(ModelUtility.getFailedLoadFunction(this, 'model', this.basePath));\n                }\n\n                if (loadResources.finishedDecoding() && !loadResources.resourcesParsed) {\n                    this._boundingSphere = ModelUtility.computeBoundingSphere(this);\n                    this._initialRadius = this._boundingSphere.radius;\n\n                    DracoLoader.cacheDataForModel(this);\n\n                    loadResources.resourcesParsed = true;\n                }\n\n                if (loadResources.resourcesParsed &&\n                    loadResources.pendingShaderLoads === 0) {\n                    createResources(this, frameState);\n                }\n            }\n\n            if (loadResources.finished() ||\n                (incrementallyLoadTextures && loadResources.finishedEverythingButTextureCreation())) {\n                this._state = ModelState.LOADED;\n                justLoaded = true;\n            }\n        }\n\n        // Incrementally stream textures.\n        if (defined(loadResources) && (this._state === ModelState.LOADED)) {\n            if (incrementallyLoadTextures && !justLoaded) {\n                createResources(this, frameState);\n            }\n\n            if (loadResources.finished()) {\n                this._loadResources = undefined;  // Clear CPU memory since WebGL resources were created.\n\n                var resources = this._rendererResources;\n                var cachedResources = this._cachedRendererResources;\n\n                cachedResources.buffers = resources.buffers;\n                cachedResources.vertexArrays = resources.vertexArrays;\n                cachedResources.programs = resources.programs;\n                cachedResources.sourceShaders = resources.sourceShaders;\n                cachedResources.silhouettePrograms = resources.silhouettePrograms;\n                cachedResources.textures = resources.textures;\n                cachedResources.samplers = resources.samplers;\n                cachedResources.renderStates = resources.renderStates;\n                cachedResources.ready = true;\n\n                // The normal attribute name is required for silhouettes, so get it before the gltf JSON is released\n                this._normalAttributeName = ModelUtility.getAttributeOrUniformBySemantic(this.gltf, 'NORMAL');\n\n                // Vertex arrays are unique to this model, do not store in cache.\n                if (defined(this._precreatedAttributes)) {\n                    cachedResources.vertexArrays = {};\n                }\n\n                if (this.releaseGltfJson) {\n                    releaseCachedGltf(this);\n                }\n            }\n        }\n\n        var iblSupported = OctahedralProjectedCubeMap.isSupported(context);\n        if (this._shouldUpdateSpecularMapAtlas && iblSupported) {\n            this._shouldUpdateSpecularMapAtlas = false;\n            this._specularEnvironmentMapAtlas = this._specularEnvironmentMapAtlas && this._specularEnvironmentMapAtlas.destroy();\n            this._specularEnvironmentMapAtlas = undefined;\n            if (defined(this._specularEnvironmentMaps)) {\n                this._specularEnvironmentMapAtlas = new OctahedralProjectedCubeMap(this._specularEnvironmentMaps);\n                var that = this;\n                this._specularEnvironmentMapAtlas.readyPromise\n                    .then(function() {\n                        that._shouldRegenerateShaders = true;\n                    })\n                    .otherwise(function(error) {\n                        console.error('Error loading specularEnvironmentMaps: ' + error);\n                    });\n            }\n\n            // Regenerate shaders to not use an environment map. Will be set to true again if there was a new environment map and it is ready.\n            this._shouldRegenerateShaders = true;\n        }\n\n        if (defined(this._specularEnvironmentMapAtlas)) {\n            this._specularEnvironmentMapAtlas.update(frameState);\n        }\n\n        var recompileWithDefaultAtlas = !defined(this._specularEnvironmentMapAtlas) && defined(frameState.specularEnvironmentMaps) && !this._useDefaultSpecularMaps;\n        var recompileWithoutDefaultAtlas = !defined(frameState.specularEnvironmentMaps) && this._useDefaultSpecularMaps;\n\n        var recompileWithDefaultSHCoeffs = !defined(this._sphericalHarmonicCoefficients) && defined(frameState.sphericalHarmonicCoefficients) && !this._useDefaultSphericalHarmonics;\n        var recompileWithoutDefaultSHCoeffs = !defined(frameState.sphericalHarmonicCoefficients) && this._useDefaultSphericalHarmonics;\n\n        this._shouldRegenerateShaders = this._shouldRegenerateShaders || recompileWithDefaultAtlas || recompileWithoutDefaultAtlas || recompileWithDefaultSHCoeffs || recompileWithoutDefaultSHCoeffs;\n\n        this._useDefaultSpecularMaps = !defined(this._specularEnvironmentMapAtlas) && defined(frameState.specularEnvironmentMaps);\n        this._useDefaultSphericalHarmonics = !defined(this._sphericalHarmonicCoefficients) && defined(frameState.sphericalHarmonicCoefficients);\n\n        var silhouette = hasSilhouette(this, frameState);\n        var translucent = isTranslucent(this);\n        var invisible = isInvisible(this);\n        var displayConditionPassed = defined(this.distanceDisplayCondition) ? distanceDisplayConditionVisible(this, frameState) : true;\n        var show = this.show && displayConditionPassed && (this.scale !== 0.0) && (!invisible || silhouette);\n\n        if ((show && this._state === ModelState.LOADED) || justLoaded) {\n            var animated = this.activeAnimations.update(frameState) || this._cesiumAnimationsDirty;\n            this._cesiumAnimationsDirty = false;\n            this._dirty = false;\n            var modelMatrix = this.modelMatrix;\n\n            var modeChanged = frameState.mode !== this._mode;\n            this._mode = frameState.mode;\n\n            // Model's model matrix needs to be updated\n            var modelTransformChanged = !Matrix4.equals(this._modelMatrix, modelMatrix) ||\n                (this._scale !== this.scale) ||\n                (this._minimumPixelSize !== this.minimumPixelSize) || (this.minimumPixelSize !== 0.0) || // Minimum pixel size changed or is enabled\n                (this._maximumScale !== this.maximumScale) ||\n                (this._heightReference !== this.heightReference) || this._heightChanged ||\n                modeChanged;\n\n            if (modelTransformChanged || justLoaded) {\n                Matrix4.clone(modelMatrix, this._modelMatrix);\n\n                updateClamping(this);\n\n                if (defined(this._clampedModelMatrix)) {\n                    modelMatrix = this._clampedModelMatrix;\n                }\n\n                this._scale = this.scale;\n                this._minimumPixelSize = this.minimumPixelSize;\n                this._maximumScale = this.maximumScale;\n                this._heightReference = this.heightReference;\n                this._heightChanged = false;\n\n                var scale = getScale(this, frameState);\n                var computedModelMatrix = this._computedModelMatrix;\n                Matrix4.multiplyByUniformScale(modelMatrix, scale, computedModelMatrix);\n                if (this._upAxis === Axis.Y) {\n                    Matrix4.multiplyTransformation(computedModelMatrix, Axis.Y_UP_TO_Z_UP, computedModelMatrix);\n                } else if (this._upAxis === Axis.X) {\n                    Matrix4.multiplyTransformation(computedModelMatrix, Axis.X_UP_TO_Z_UP, computedModelMatrix);\n                }\n                if (this.forwardAxis === Axis.Z) {\n                    // glTF 2.0 has a Z-forward convention that must be adapted here to X-forward.\n                    Matrix4.multiplyTransformation(computedModelMatrix, Axis.Z_UP_TO_X_UP, computedModelMatrix);\n                }\n            }\n\n            // Update modelMatrix throughout the graph as needed\n            if (animated || modelTransformChanged || justLoaded) {\n                updateNodeHierarchyModelMatrix(this, modelTransformChanged, justLoaded, frameState.mapProjection);\n                this._dirty = true;\n\n                if (animated || justLoaded) {\n                    // Apply skins if animation changed any node transforms\n                    applySkins(this);\n                }\n            }\n\n            if (this._perNodeShowDirty) {\n                this._perNodeShowDirty = false;\n                updatePerNodeShow(this);\n            }\n            updatePickIds(this, context);\n            updateWireframe(this);\n            updateShowBoundingVolume(this);\n            updateShadows(this);\n            updateClippingPlanes(this, frameState);\n\n            // Regenerate shaders if ClippingPlaneCollection state changed or it was removed\n            var clippingPlanes = this._clippingPlanes;\n            var currentClippingPlanesState = 0;\n            var useClippingPlanes = defined(clippingPlanes) && clippingPlanes.enabled && clippingPlanes.length > 0;\n            var usesSH = defined(this._sphericalHarmonicCoefficients) || this._useDefaultSphericalHarmonics;\n            var usesSM = (defined(this._specularEnvironmentMapAtlas) && this._specularEnvironmentMapAtlas.ready) || this._useDefaultSpecularMaps;\n            if (useClippingPlanes || usesSH || usesSM) {\n                var clippingPlanesOriginMatrix = defaultValue(this.clippingPlanesOriginMatrix, modelMatrix);\n                Matrix4.multiply(context.uniformState.view3D, clippingPlanesOriginMatrix, this._clippingPlaneModelViewMatrix);\n            }\n\n            if (useClippingPlanes) {\n                currentClippingPlanesState = clippingPlanes.clippingPlanesState;\n            }\n\n            var shouldRegenerateShaders = this._shouldRegenerateShaders;\n            shouldRegenerateShaders = shouldRegenerateShaders || this._clippingPlanesState !== currentClippingPlanesState;\n            this._clippingPlanesState = currentClippingPlanesState;\n\n            // Regenerate shaders if color shading changed from last update\n            var currentlyColorShadingEnabled = isColorShadingEnabled(this);\n            if (currentlyColorShadingEnabled !== this._colorShadingEnabled) {\n                this._colorShadingEnabled = currentlyColorShadingEnabled;\n                shouldRegenerateShaders = true;\n            }\n\n            if (shouldRegenerateShaders) {\n                regenerateShaders(this, frameState);\n            } else {\n                updateColor(this, frameState, false);\n                updateSilhouette(this, frameState, false);\n            }\n        }\n\n        if (justLoaded) {\n            // Called after modelMatrix update.\n            var model = this;\n            frameState.afterRender.push(function() {\n                model._ready = true;\n                model._readyPromise.resolve(model);\n            });\n            return;\n        }\n\n        // We don't check show at the top of the function since we\n        // want to be able to progressively load models when they are not shown,\n        // and then have them visible immediately when show is set to true.\n        if (show && !this._ignoreCommands) {\n            // PERFORMANCE_IDEA: This is terrible\n            var commandList = frameState.commandList;\n            var passes = frameState.passes;\n            var nodeCommands = this._nodeCommands;\n            var length = nodeCommands.length;\n            var i;\n            var nc;\n\n            var idl2D = frameState.mapProjection.ellipsoid.maximumRadius * CesiumMath.PI;\n            var boundingVolume;\n\n            if (passes.render || (passes.pick && this.allowPicking)) {\n                for (i = 0; i < length; ++i) {\n                    nc = nodeCommands[i];\n                    if (nc.show) {\n                        var command = translucent ? nc.translucentCommand : nc.command;\n                        command = silhouette ? nc.silhouetteModelCommand : command;\n                        commandList.push(command);\n                        boundingVolume = nc.command.boundingVolume;\n                        if (frameState.mode === SceneMode.SCENE2D &&\n                            (boundingVolume.center.y + boundingVolume.radius > idl2D || boundingVolume.center.y - boundingVolume.radius < idl2D)) {\n                            var command2D = translucent ? nc.translucentCommand2D : nc.command2D;\n                            command2D = silhouette ? nc.silhouetteModelCommand2D : command2D;\n                            commandList.push(command2D);\n                        }\n                    }\n                }\n\n                if (silhouette && !passes.pick) {\n                    // Render second silhouette pass\n                    for (i = 0; i < length; ++i) {\n                        nc = nodeCommands[i];\n                        if (nc.show) {\n                            commandList.push(nc.silhouetteColorCommand);\n                            boundingVolume = nc.command.boundingVolume;\n                            if (frameState.mode === SceneMode.SCENE2D &&\n                                (boundingVolume.center.y + boundingVolume.radius > idl2D || boundingVolume.center.y - boundingVolume.radius < idl2D)) {\n                                commandList.push(nc.silhouetteColorCommand2D);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        var credit = this._credit;\n        if (defined(credit)) {\n            frameState.creditDisplay.addCredit(credit);\n        }\n\n        var resourceCredits = this._resourceCredits;\n        var creditCount = resourceCredits.length;\n        for (var c = 0; c < creditCount; c++) {\n            frameState.creditDisplay.addCredit(resourceCredits[c]);\n        }\n    };\n\n    function destroyIfNotCached(rendererResources, cachedRendererResources) {\n        if (rendererResources.programs !== cachedRendererResources.programs) {\n            destroy(rendererResources.programs);\n        }\n        if (rendererResources.silhouettePrograms !== cachedRendererResources.silhouettePrograms) {\n            destroy(rendererResources.silhouettePrograms);\n        }\n    }\n\n    // Run from update iff:\n    // - everything is loaded\n    // - clipping planes state change OR color state set\n    // Run this from destructor after removing color state and clipping plane state\n    function regenerateShaders(model, frameState) {\n        // In regards to _cachedRendererResources:\n        // Fair to assume that this is data that should just never get modified due to clipping planes or model color.\n        // So if clipping planes or model color active:\n        // - delink _rendererResources.*programs and create new dictionaries.\n        // - do NOT destroy any programs - might be used by copies of the model or by might be needed in the future if clipping planes/model color is deactivated\n\n        // If clipping planes and model color inactive:\n        // - destroy _rendererResources.*programs\n        // - relink _rendererResources.*programs to _cachedRendererResources\n\n        // In both cases, need to mark commands as dirty, re-run derived commands (elsewhere)\n\n        var rendererResources = model._rendererResources;\n        var cachedRendererResources = model._cachedRendererResources;\n        destroyIfNotCached(rendererResources, cachedRendererResources);\n\n        var programId;\n        if (isClippingEnabled(model) || isColorShadingEnabled(model) || model._shouldRegenerateShaders) {\n            model._shouldRegenerateShaders = false;\n\n            rendererResources.programs = {};\n            rendererResources.silhouettePrograms = {};\n\n            var visitedPrograms = {};\n            var techniques = model._sourceTechniques;\n            var technique;\n\n            for (var techniqueId in techniques) {\n                if (techniques.hasOwnProperty(techniqueId)) {\n                    technique = techniques[techniqueId];\n                    programId = technique.program;\n                    if (!visitedPrograms[programId]) {\n                        visitedPrograms[programId] = true;\n                        recreateProgram({\n                            programId: programId,\n                            techniqueId: techniqueId\n                        }, model, frameState.context);\n                    }\n                }\n            }\n        } else {\n            rendererResources.programs = cachedRendererResources.programs;\n            rendererResources.silhouettePrograms = cachedRendererResources.silhouettePrograms;\n        }\n\n        // Fix all the commands, marking them as dirty so everything that derives will re-derive\n        var rendererPrograms = rendererResources.programs;\n\n        var nodeCommands = model._nodeCommands;\n        var commandCount = nodeCommands.length;\n        for (var i = 0; i < commandCount; ++i) {\n            var nodeCommand = nodeCommands[i];\n            programId = nodeCommand.programId;\n\n            var renderProgram = rendererPrograms[programId];\n            nodeCommand.command.shaderProgram = renderProgram;\n            if (defined(nodeCommand.command2D)) {\n                nodeCommand.command2D.shaderProgram = renderProgram;\n            }\n        }\n\n        // Force update silhouette commands/shaders\n        updateColor(model, frameState, true);\n        updateSilhouette(model, frameState, true);\n    }\n\n    /**\n     * Returns true if this object was destroyed; otherwise, false.\n     * <br /><br />\n     * If this object was destroyed, it should not be used; calling any function other than\n     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n     *\n     * @returns {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n     *\n     * @see Model#destroy\n     */\n    Model.prototype.isDestroyed = function() {\n        return false;\n    };\n\n    /**\n     * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n     * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n     * <br /><br />\n     * Once an object is destroyed, it should not be used; calling any function other than\n     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n     * assign the return value (<code>undefined</code>) to the object as done in the example.\n     *\n     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n     *\n     *\n     * @example\n     * model = model && model.destroy();\n     *\n     * @see Model#isDestroyed\n     */\n    Model.prototype.destroy = function() {\n        // Vertex arrays are unique to this model, destroy here.\n        if (defined(this._precreatedAttributes)) {\n            destroy(this._rendererResources.vertexArrays);\n        }\n\n        if (defined(this._removeUpdateHeightCallback)) {\n            this._removeUpdateHeightCallback();\n            this._removeUpdateHeightCallback = undefined;\n        }\n\n        if (defined(this._terrainProviderChangedCallback)) {\n            this._terrainProviderChangedCallback();\n            this._terrainProviderChangedCallback = undefined;\n        }\n\n        // Shaders modified for clipping and for color don't get cached, so destroy these manually\n        if (defined(this._cachedRendererResources)) {\n            destroyIfNotCached(this._rendererResources, this._cachedRendererResources);\n        }\n\n        this._rendererResources = undefined;\n        this._cachedRendererResources = this._cachedRendererResources && this._cachedRendererResources.release();\n        DracoLoader.destroyCachedDataForModel(this);\n\n        var pickIds = this._pickIds;\n        var length = pickIds.length;\n        for (var i = 0; i < length; ++i) {\n            pickIds[i].destroy();\n        }\n\n        releaseCachedGltf(this);\n        this._quantizedVertexShaders = undefined;\n\n        // Only destroy the ClippingPlaneCollection if this is the owner - if this model is part of a Cesium3DTileset,\n        // _clippingPlanes references a ClippingPlaneCollection that this model does not own.\n        var clippingPlaneCollection = this._clippingPlanes;\n        if (defined(clippingPlaneCollection) && !clippingPlaneCollection.isDestroyed() && clippingPlaneCollection.owner === this) {\n            clippingPlaneCollection.destroy();\n        }\n        this._clippingPlanes = undefined;\n\n        this._specularEnvironmentMapAtlas = this._specularEnvironmentMapAtlas && this._specularEnvironmentMapAtlas.destroy();\n\n        return destroyObject(this);\n    };\n\n    // exposed for testing\n    Model._getClippingFunction = getClippingFunction;\n    Model._modifyShaderForColor = modifyShaderForColor;\nexport default Model;\n","import AssociativeArray from '../Core/AssociativeArray.js';\nimport Axis from '../Scene/Axis.js';\nimport BoundingSphere from '../Core/BoundingSphere.js';\nimport Cartesian2 from '../Core/Cartesian2.js';\nimport Color from '../Core/Color.js';\nimport defined from '../Core/defined.js';\nimport destroyObject from '../Core/destroyObject.js';\nimport DeveloperError from '../Core/DeveloperError.js';\nimport Matrix4 from '../Core/Matrix4.js';\nimport Resource from '../Core/Resource.js';\nimport ColorBlendMode from '../Scene/ColorBlendMode.js';\nimport HeightReference from '../Scene/HeightReference.js';\nimport Model from '../Scene/Model.js';\nimport ModelAnimationLoop from '../Scene/ModelAnimationLoop.js';\nimport ShadowMode from '../Scene/ShadowMode.js';\nimport BoundingSphereState from './BoundingSphereState.js';\nimport Property from './Property.js';\n\n    var defaultScale = 1.0;\n    var defaultMinimumPixelSize = 0.0;\n    var defaultIncrementallyLoadTextures = true;\n    var defaultClampAnimations = true;\n    var defaultShadows = ShadowMode.ENABLED;\n    var defaultHeightReference = HeightReference.NONE;\n    var defaultSilhouetteColor = Color.RED;\n    var defaultSilhouetteSize = 0.0;\n    var defaultColor = Color.WHITE;\n    var defaultColorBlendMode = ColorBlendMode.HIGHLIGHT;\n    var defaultColorBlendAmount = 0.5;\n    var defaultImageBasedLightingFactor = new Cartesian2(1.0, 1.0);\n    var defaultUpAxis = Axis.Y;\n\n    var modelMatrixScratch = new Matrix4();\n    var nodeMatrixScratch = new Matrix4();\n\n    /**\n     * A {@link Visualizer} which maps {@link Entity#model} to a {@link Model}.\n     * @alias ModelVisualizer\n     * @constructor\n     *\n     * @param {Scene} scene The scene the primitives will be rendered in.\n     * @param {EntityCollection} entityCollection The entityCollection to visualize.\n     */\n    function ModelVisualizer(scene, entityCollection) {\n        \n\n        entityCollection.collectionChanged.addEventListener(ModelVisualizer.prototype._onCollectionChanged, this);\n\n        this._scene = scene;\n        this._primitives = scene.primitives;\n        this._entityCollection = entityCollection;\n        this._modelHash = {};\n        this._entitiesToVisualize = new AssociativeArray();\n        this._onCollectionChanged(entityCollection, entityCollection.values, [], []);\n    }\n\n    /**\n     * Updates models created this visualizer to match their\n     * Entity counterpart at the given time.\n     *\n     * @param {JulianDate} time The time to update to.\n     * @returns {Boolean} This function always returns true.\n     */\n    ModelVisualizer.prototype.update = function(time) {\n        \n\n        var entities = this._entitiesToVisualize.values;\n        var modelHash = this._modelHash;\n        var primitives = this._primitives;\n\n        for (var i = 0, len = entities.length; i < len; i++) {\n            var entity = entities[i];\n            var modelGraphics = entity._model;\n\n            var resource;\n            var modelData = modelHash[entity.id];\n            var show = entity.isShowing && entity.isAvailable(time) && Property.getValueOrDefault(modelGraphics._show, time, true);\n\n            var modelMatrix;\n            if (show) {\n                modelMatrix = entity.computeModelMatrix(time, modelMatrixScratch);\n                resource = Resource.createIfNeeded(Property.getValueOrUndefined(modelGraphics._uri, time));\n                show = defined(modelMatrix) && defined(resource);\n            }\n\n            if (!show) {\n                if (defined(modelData)) {\n                    modelData.modelPrimitive.show = false;\n                }\n                continue;\n            }\n\n            var model = defined(modelData) ? modelData.modelPrimitive : undefined;\n            if (!defined(model) || resource.url !== modelData.url) {\n                if (defined(model)) {\n                    primitives.removeAndDestroy(model);\n                    delete modelHash[entity.id];\n                }\n                model = Model.fromGltf({\n                    url : resource,\n                    incrementallyLoadTextures : Property.getValueOrDefault(modelGraphics._incrementallyLoadTextures, time, defaultIncrementallyLoadTextures),\n                    scene : this._scene\n                });\n                model.id = entity;\n                primitives.add(model);\n\n                modelData = {\n                    modelPrimitive : model,\n                    url : resource.url,\n                    animationsRunning : false,\n                    nodeTransformationsScratch : {},\n                    articulationsScratch : {},\n                    loadFail : false\n                };\n                modelHash[entity.id] = modelData;\n\n                checkModelLoad(model, entity, modelHash);\n            }\n\n            model.show = true;\n            model.scale = Property.getValueOrDefault(modelGraphics._scale, time, defaultScale);\n            model.minimumPixelSize = Property.getValueOrDefault(modelGraphics._minimumPixelSize, time, defaultMinimumPixelSize);\n            model.maximumScale = Property.getValueOrUndefined(modelGraphics._maximumScale, time);\n            model.modelMatrix = Matrix4.clone(modelMatrix, model.modelMatrix);\n            model.shadows = Property.getValueOrDefault(modelGraphics._shadows, time, defaultShadows);\n            model.heightReference = Property.getValueOrDefault(modelGraphics._heightReference, time, defaultHeightReference);\n            model.distanceDisplayCondition = Property.getValueOrUndefined(modelGraphics._distanceDisplayCondition, time);\n            model.silhouetteColor = Property.getValueOrDefault(modelGraphics._silhouetteColor, time, defaultSilhouetteColor, model._silhouetteColor);\n            model.silhouetteSize = Property.getValueOrDefault(modelGraphics._silhouetteSize, time, defaultSilhouetteSize);\n            model.color = Property.getValueOrDefault(modelGraphics._color, time, defaultColor, model._color);\n            model.colorBlendMode = Property.getValueOrDefault(modelGraphics._colorBlendMode, time, defaultColorBlendMode);\n            model.colorBlendAmount = Property.getValueOrDefault(modelGraphics._colorBlendAmount, time, defaultColorBlendAmount);\n            model.clippingPlanes = Property.getValueOrUndefined(modelGraphics._clippingPlanes, time);\n            model.clampAnimations = Property.getValueOrDefault(modelGraphics._clampAnimations, time, defaultClampAnimations);\n            model.imageBasedLightingFactor = Property.getValueOrDefault(modelGraphics._imageBasedLightingFactor, time, defaultImageBasedLightingFactor);\n            model.lightColor = Property.getValueOrUndefined(modelGraphics._lightColor, time);\n            model._upAxis = Property.getValueOrDefault(modelGraphics._upAxis, time, defaultUpAxis);\n            model._forwardAxis = Property.getValueOrUndefined(modelGraphics._forwardAxis, time);\n\n            if (model.ready) {\n                var runAnimations = Property.getValueOrDefault(modelGraphics._runAnimations, time, true);\n                if (modelData.animationsRunning !== runAnimations) {\n                    if (runAnimations) {\n                        model.activeAnimations.addAll({\n                            loop : ModelAnimationLoop.REPEAT\n                        });\n                    } else {\n                        model.activeAnimations.removeAll();\n                    }\n                    modelData.animationsRunning = runAnimations;\n                }\n\n                // Apply node transformations\n                var nodeTransformations = Property.getValueOrUndefined(modelGraphics._nodeTransformations, time, modelData.nodeTransformationsScratch);\n                if (defined(nodeTransformations)) {\n                    var nodeNames = Object.keys(nodeTransformations);\n                    for (var nodeIndex = 0, nodeLength = nodeNames.length; nodeIndex < nodeLength; ++nodeIndex) {\n                        var nodeName = nodeNames[nodeIndex];\n\n                        var nodeTransformation = nodeTransformations[nodeName];\n                        if (!defined(nodeTransformation)) {\n                            continue;\n                        }\n\n                        var modelNode = model.getNode(nodeName);\n                        if (!defined(modelNode)) {\n                            continue;\n                        }\n\n                        var transformationMatrix = Matrix4.fromTranslationRotationScale(nodeTransformation, nodeMatrixScratch);\n                        modelNode.matrix = Matrix4.multiply(modelNode.originalMatrix, transformationMatrix, transformationMatrix);\n                    }\n                }\n\n                // Apply articulations\n                var anyArticulationUpdated = false;\n                var articulations = Property.getValueOrUndefined(modelGraphics._articulations, time, modelData.articulationsScratch);\n                if (defined(articulations)) {\n                    var articulationStageKeys = Object.keys(articulations);\n                    for (var s = 0, numKeys = articulationStageKeys.length; s < numKeys; ++s) {\n                        var key = articulationStageKeys[s];\n\n                        var articulationStageValue = articulations[key];\n                        if (!defined(articulationStageValue)) {\n                            continue;\n                        }\n\n                        anyArticulationUpdated = true;\n                        model.setArticulationStage(key, articulationStageValue);\n                    }\n                }\n\n                if (anyArticulationUpdated) {\n                    model.applyArticulations();\n                }\n            }\n        }\n\n        return true;\n    };\n\n    /**\n     * Returns true if this object was destroyed; otherwise, false.\n     *\n     * @returns {Boolean} True if this object was destroyed; otherwise, false.\n     */\n    ModelVisualizer.prototype.isDestroyed = function() {\n        return false;\n    };\n\n    /**\n     * Removes and destroys all primitives created by this instance.\n     */\n    ModelVisualizer.prototype.destroy = function() {\n        this._entityCollection.collectionChanged.removeEventListener(ModelVisualizer.prototype._onCollectionChanged, this);\n        var entities = this._entitiesToVisualize.values;\n        var modelHash = this._modelHash;\n        var primitives = this._primitives;\n        for (var i = entities.length - 1; i > -1; i--) {\n            removeModel(this, entities[i], modelHash, primitives);\n        }\n        return destroyObject(this);\n    };\n\n    /**\n     * Computes a bounding sphere which encloses the visualization produced for the specified entity.\n     * The bounding sphere is in the fixed frame of the scene's globe.\n     *\n     * @param {Entity} entity The entity whose bounding sphere to compute.\n     * @param {BoundingSphere} result The bounding sphere onto which to store the result.\n     * @returns {BoundingSphereState} BoundingSphereState.DONE if the result contains the bounding sphere,\n     *                       BoundingSphereState.PENDING if the result is still being computed, or\n     *                       BoundingSphereState.FAILED if the entity has no visualization in the current scene.\n     * @private\n     */\n    ModelVisualizer.prototype.getBoundingSphere = function(entity, result) {\n        \n\n        var modelData = this._modelHash[entity.id];\n        if (!defined(modelData) || modelData.loadFail) {\n            return BoundingSphereState.FAILED;\n        }\n\n        var model = modelData.modelPrimitive;\n        if (!defined(model) || !model.show) {\n            return BoundingSphereState.FAILED;\n        }\n\n        if (!model.ready) {\n            return BoundingSphereState.PENDING;\n        }\n\n        if (model.heightReference === HeightReference.NONE) {\n            BoundingSphere.transform(model.boundingSphere, model.modelMatrix, result);\n        } else {\n            if (!defined(model._clampedModelMatrix) || model._heightChanged) {\n                return BoundingSphereState.PENDING;\n            }\n            BoundingSphere.transform(model.boundingSphere, model._clampedModelMatrix, result);\n        }\n        return BoundingSphereState.DONE;\n    };\n\n    /**\n     * @private\n     */\n    ModelVisualizer.prototype._onCollectionChanged = function(entityCollection, added, removed, changed) {\n        var i;\n        var entity;\n        var entities = this._entitiesToVisualize;\n        var modelHash = this._modelHash;\n        var primitives = this._primitives;\n\n        for (i = added.length - 1; i > -1; i--) {\n            entity = added[i];\n            if (defined(entity._model) && defined(entity._position)) {\n                entities.set(entity.id, entity);\n            }\n        }\n\n        for (i = changed.length - 1; i > -1; i--) {\n            entity = changed[i];\n            if (defined(entity._model) && defined(entity._position)) {\n                clearNodeTransformationsArticulationsScratch(entity, modelHash);\n                entities.set(entity.id, entity);\n            } else {\n                removeModel(this, entity, modelHash, primitives);\n                entities.remove(entity.id);\n            }\n        }\n\n        for (i = removed.length - 1; i > -1; i--) {\n            entity = removed[i];\n            removeModel(this, entity, modelHash, primitives);\n            entities.remove(entity.id);\n        }\n    };\n\n    function removeModel(visualizer, entity, modelHash, primitives) {\n        var modelData = modelHash[entity.id];\n        if (defined(modelData)) {\n            primitives.removeAndDestroy(modelData.modelPrimitive);\n            delete modelHash[entity.id];\n        }\n    }\n\n    function clearNodeTransformationsArticulationsScratch(entity, modelHash) {\n        var modelData = modelHash[entity.id];\n        if (defined(modelData)) {\n            modelData.nodeTransformationsScratch = {};\n            modelData.articulationsScratch = {};\n        }\n    }\n\n    function checkModelLoad(model, entity, modelHash){\n        model.readyPromise.otherwise(function(error){\n            console.error(error);\n            modelHash[entity.id].loadFail = true;\n        });\n    }\nexport default ModelVisualizer;\n","import arrayRemoveDuplicates from '../Core/arrayRemoveDuplicates.js';\nimport BoundingSphere from '../Core/BoundingSphere.js';\nimport Cartesian3 from '../Core/Cartesian3.js';\nimport Color from '../Core/Color.js';\nimport defaultValue from '../Core/defaultValue.js';\nimport defined from '../Core/defined.js';\nimport defineProperties from '../Core/defineProperties.js';\nimport DeveloperError from '../Core/DeveloperError.js';\nimport DistanceDisplayCondition from '../Core/DistanceDisplayCondition.js';\nimport Matrix4 from '../Core/Matrix4.js';\nimport PolylinePipeline from '../Core/PolylinePipeline.js';\nimport Material from './Material.js';\n\n    /**\n     * A renderable polyline. Create this by calling {@link PolylineCollection#add}\n     *\n     * @alias Polyline\n     * @internalConstructor\n     * @class\n     *\n     * @param {Object} [options] Object with the following properties:\n     * @param {Boolean} [options.show=true] <code>true</code> if this polyline will be shown; otherwise, <code>false</code>.\n     * @param {Number} [options.width=1.0] The width of the polyline in pixels.\n     * @param {Boolean} [options.loop=false] Whether a line segment will be added between the last and first line positions to make this line a loop.\n     * @param {Material} [options.material=Material.ColorType] The material.\n     * @param {Cartesian3[]} [options.positions] The positions.\n     * @param {Object} [options.id] The user-defined object to be returned when this polyline is picked.\n     * @param {DistanceDisplayCondition} [options.distanceDisplayCondition] The condition specifying at what distance from the camera that this polyline will be displayed.\n     * @param {PolylineCollection} polylineCollection The renderable polyline collection.\n     *\n     * @see PolylineCollection\n     *\n     */\n    function Polyline(options, polylineCollection) {\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n        this._show = defaultValue(options.show, true);\n        this._width = defaultValue(options.width, 1.0);\n        this._loop = defaultValue(options.loop, false);\n        this._distanceDisplayCondition = options.distanceDisplayCondition;\n\n        this._material = options.material;\n        if (!defined(this._material)) {\n            this._material = Material.fromType(Material.ColorType, {\n                color : new Color(1.0, 1.0, 1.0, 1.0)\n            });\n        }\n\n        var positions = options.positions;\n        if (!defined(positions)) {\n            positions = [];\n        }\n\n        this._positions = positions;\n        this._actualPositions = arrayRemoveDuplicates(positions, Cartesian3.equalsEpsilon);\n\n        if (this._loop && this._actualPositions.length > 2) {\n            if (this._actualPositions === this._positions) {\n                this._actualPositions = positions.slice();\n            }\n            this._actualPositions.push(Cartesian3.clone(this._actualPositions[0]));\n        }\n\n        this._length = this._actualPositions.length;\n        this._id = options.id;\n\n        var modelMatrix;\n        if (defined(polylineCollection)) {\n            modelMatrix = Matrix4.clone(polylineCollection.modelMatrix);\n        }\n\n        this._modelMatrix = modelMatrix;\n        this._segments = PolylinePipeline.wrapLongitude(this._actualPositions, modelMatrix);\n\n        this._actualLength = undefined;\n\n        this._propertiesChanged = new Uint32Array(NUMBER_OF_PROPERTIES); //eslint-disable-line no-use-before-define\n        this._polylineCollection = polylineCollection;\n        this._dirty = false;\n        this._pickId = undefined;\n        this._boundingVolume = BoundingSphere.fromPoints(this._actualPositions);\n        this._boundingVolumeWC = BoundingSphere.transform(this._boundingVolume, this._modelMatrix);\n        this._boundingVolume2D = new BoundingSphere(); // modified in PolylineCollection\n    }\n\n    var POSITION_INDEX = Polyline.POSITION_INDEX = 0;\n    var SHOW_INDEX = Polyline.SHOW_INDEX = 1;\n    var WIDTH_INDEX = Polyline.WIDTH_INDEX = 2;\n    var MATERIAL_INDEX = Polyline.MATERIAL_INDEX = 3;\n    var POSITION_SIZE_INDEX = Polyline.POSITION_SIZE_INDEX = 4;\n    var DISTANCE_DISPLAY_CONDITION = Polyline.DISTANCE_DISPLAY_CONDITION = 5;\n    var NUMBER_OF_PROPERTIES = Polyline.NUMBER_OF_PROPERTIES = 6;\n\n    function makeDirty(polyline, propertyChanged) {\n        ++polyline._propertiesChanged[propertyChanged];\n        var polylineCollection = polyline._polylineCollection;\n        if (defined(polylineCollection)) {\n            polylineCollection._updatePolyline(polyline, propertyChanged);\n            polyline._dirty = true;\n        }\n    }\n\n    defineProperties(Polyline.prototype, {\n\n        /**\n         * Determines if this polyline will be shown.  Use this to hide or show a polyline, instead\n         * of removing it and re-adding it to the collection.\n         * @memberof Polyline.prototype\n         * @type {Boolean}\n         */\n        show: {\n            get: function() {\n                return this._show;\n            },\n            set: function(value) {\n                \n\n                if (value !== this._show) {\n                    this._show = value;\n                    makeDirty(this, SHOW_INDEX);\n                }\n            }\n        },\n\n        /**\n         * Gets or sets the positions of the polyline.\n         * @memberof Polyline.prototype\n         * @type {Cartesian3[]}\n         * @example\n         * polyline.positions = Cesium.Cartesian3.fromDegreesArray([\n         *     0.0, 0.0,\n         *     10.0, 0.0,\n         *     0.0, 20.0\n         * ]);\n         */\n        positions : {\n            get: function() {\n                return this._positions;\n            },\n            set: function(value) {\n                \n\n                var positions = arrayRemoveDuplicates(value, Cartesian3.equalsEpsilon);\n\n                if (this._loop && positions.length > 2) {\n                    if (positions === value) {\n                        positions = value.slice();\n                    }\n                    positions.push(Cartesian3.clone(positions[0]));\n                }\n\n                if (this._actualPositions.length !== positions.length || this._actualPositions.length !== this._length) {\n                    makeDirty(this, POSITION_SIZE_INDEX);\n                }\n\n                this._positions = value;\n                this._actualPositions = positions;\n                this._length = positions.length;\n                this._boundingVolume = BoundingSphere.fromPoints(this._actualPositions, this._boundingVolume);\n                this._boundingVolumeWC = BoundingSphere.transform(this._boundingVolume, this._modelMatrix, this._boundingVolumeWC);\n                makeDirty(this, POSITION_INDEX);\n\n                this.update();\n            }\n        },\n\n        /**\n         * Gets or sets the surface appearance of the polyline.  This can be one of several built-in {@link Material} objects or a custom material, scripted with\n         * {@link https://github.com/AnalyticalGraphicsInc/cesium/wiki/Fabric|Fabric}.\n         * @memberof Polyline.prototype\n         * @type {Material}\n         */\n        material: {\n            get: function() {\n                return this._material;\n            },\n            set: function(material) {\n                \n\n                if (this._material !== material) {\n                    this._material = material;\n                    makeDirty(this, MATERIAL_INDEX);\n                }\n            }\n        },\n\n        /**\n         * Gets or sets the width of the polyline.\n         * @memberof Polyline.prototype\n         * @type {Number}\n         */\n        width: {\n            get: function() {\n                return this._width;\n            },\n            set: function(value) {\n                \n\n                var width = this._width;\n                if (value !== width) {\n                    this._width = value;\n                    makeDirty(this, WIDTH_INDEX);\n                }\n            }\n        },\n\n        /**\n         * Gets or sets whether a line segment will be added between the first and last polyline positions.\n         * @memberof Polyline.prototype\n         * @type {Boolean}\n         */\n        loop: {\n            get: function() {\n                return this._loop;\n            },\n            set: function(value) {\n                \n\n                if (value !== this._loop) {\n                    var positions = this._actualPositions;\n                    if (value) {\n                        if (positions.length > 2 && !Cartesian3.equals(positions[0], positions[positions.length - 1])) {\n                            if (positions.length === this._positions.length) {\n                                this._actualPositions = positions = this._positions.slice();\n                            }\n                            positions.push(Cartesian3.clone(positions[0]));\n                        }\n                    } else if (positions.length > 2 && Cartesian3.equals(positions[0], positions[positions.length - 1])) {\n                        if (positions.length - 1 === this._positions.length) {\n                            this._actualPositions = this._positions;\n                        } else {\n                            positions.pop();\n                        }\n                    }\n\n                    this._loop = value;\n                    makeDirty(this, POSITION_SIZE_INDEX);\n                }\n            }\n        },\n\n        /**\n         * Gets or sets the user-defined value returned when the polyline is picked.\n         * @memberof Polyline.prototype\n         * @type {*}\n         */\n        id : {\n            get : function() {\n                return this._id;\n            },\n            set : function(value) {\n                this._id = value;\n                if (defined(this._pickId)) {\n                    this._pickId.object.id = value;\n                }\n            }\n        },\n\n        /**\n         * @private\n         */\n        pickId : {\n            get : function() {\n                return this._pickId;\n            }\n        },\n\n        /**\n         * Gets the destruction status of this polyline\n         * @memberof Polyline.prototype\n         * @type {Boolean}\n         * @default false\n         * @private\n         */\n        isDestroyed : {\n            get : function() {\n                return !defined(this._polylineCollection);\n            }\n        },\n\n        /**\n         * Gets or sets the condition specifying at what distance from the camera that this polyline will be displayed.\n         * @memberof Polyline.prototype\n         * @type {DistanceDisplayCondition}\n         * @default undefined\n         */\n        distanceDisplayCondition : {\n            get : function() {\n                return this._distanceDisplayCondition;\n            },\n            set : function(value) {\n                \n                if (!DistanceDisplayCondition.equals(value, this._distanceDisplayCondition)) {\n                    this._distanceDisplayCondition = DistanceDisplayCondition.clone(value, this._distanceDisplayCondition);\n                    makeDirty(this, DISTANCE_DISPLAY_CONDITION);\n                }\n            }\n        }\n    });\n\n    /**\n     * @private\n     */\n    Polyline.prototype.update = function() {\n        var modelMatrix = Matrix4.IDENTITY;\n        if (defined(this._polylineCollection)) {\n            modelMatrix = this._polylineCollection.modelMatrix;\n        }\n\n        var segmentPositionsLength = this._segments.positions.length;\n        var segmentLengths = this._segments.lengths;\n\n        var positionsChanged = this._propertiesChanged[POSITION_INDEX] > 0 || this._propertiesChanged[POSITION_SIZE_INDEX] > 0;\n        if (!Matrix4.equals(modelMatrix, this._modelMatrix) || positionsChanged) {\n            this._segments = PolylinePipeline.wrapLongitude(this._actualPositions, modelMatrix);\n            this._boundingVolumeWC = BoundingSphere.transform(this._boundingVolume, modelMatrix, this._boundingVolumeWC);\n        }\n\n        this._modelMatrix = Matrix4.clone(modelMatrix, this._modelMatrix);\n\n        if (this._segments.positions.length !== segmentPositionsLength) {\n            // number of positions changed\n            makeDirty(this, POSITION_SIZE_INDEX);\n        } else {\n            var length = segmentLengths.length;\n            for (var i = 0; i < length; ++i) {\n                if (segmentLengths[i] !== this._segments.lengths[i]) {\n                    // indices changed\n                    makeDirty(this, POSITION_SIZE_INDEX);\n                    break;\n                }\n            }\n        }\n    };\n\n    /**\n     * @private\n     */\n    Polyline.prototype.getPickId = function(context) {\n        if (!defined(this._pickId)) {\n            this._pickId = context.createPickId({\n                primitive : this,\n                collection : this._polylineCollection,\n                id : this._id\n            });\n        }\n        return this._pickId;\n    };\n\n    Polyline.prototype._clean = function() {\n        this._dirty = false;\n        var properties = this._propertiesChanged;\n        for ( var k = 0; k < NUMBER_OF_PROPERTIES - 1; ++k) {\n            properties[k] = 0;\n        }\n    };\n\n    Polyline.prototype._destroy = function() {\n        this._pickId = this._pickId && this._pickId.destroy();\n        this._material = this._material && this._material.destroy();\n        this._polylineCollection = undefined;\n    };\nexport default Polyline;\n","import BoundingSphere from '../Core/BoundingSphere.js';\nimport Cartesian2 from '../Core/Cartesian2.js';\nimport Cartesian3 from '../Core/Cartesian3.js';\nimport Cartesian4 from '../Core/Cartesian4.js';\nimport Cartographic from '../Core/Cartographic.js';\nimport Color from '../Core/Color.js';\nimport combine from '../Core/combine.js';\nimport ComponentDatatype from '../Core/ComponentDatatype.js';\nimport defaultValue from '../Core/defaultValue.js';\nimport defined from '../Core/defined.js';\nimport defineProperties from '../Core/defineProperties.js';\nimport destroyObject from '../Core/destroyObject.js';\nimport DeveloperError from '../Core/DeveloperError.js';\nimport EncodedCartesian3 from '../Core/EncodedCartesian3.js';\nimport FeatureDetection from '../Core/FeatureDetection.js';\nimport IndexDatatype from '../Core/IndexDatatype.js';\nimport Intersect from '../Core/Intersect.js';\nimport CesiumMath from '../Core/Math.js';\nimport Matrix4 from '../Core/Matrix4.js';\nimport Plane from '../Core/Plane.js';\nimport RuntimeError from '../Core/RuntimeError.js';\nimport Buffer from '../Renderer/Buffer.js';\nimport BufferUsage from '../Renderer/BufferUsage.js';\nimport ContextLimits from '../Renderer/ContextLimits.js';\nimport DrawCommand from '../Renderer/DrawCommand.js';\nimport Pass from '../Renderer/Pass.js';\nimport RenderState from '../Renderer/RenderState.js';\nimport ShaderProgram from '../Renderer/ShaderProgram.js';\nimport ShaderSource from '../Renderer/ShaderSource.js';\nimport Texture from '../Renderer/Texture.js';\nimport VertexArray from '../Renderer/VertexArray.js';\nimport PolylineCommon from '../Shaders/PolylineCommon.js';\nimport PolylineFS from '../Shaders/PolylineFS.js';\nimport PolylineVS from '../Shaders/PolylineVS.js';\nimport BatchTable from './BatchTable.js';\nimport BlendingState from './BlendingState.js';\nimport Material from './Material.js';\nimport Polyline from './Polyline.js';\nimport SceneMode from './SceneMode.js';\n\n    var SHOW_INDEX = Polyline.SHOW_INDEX;\n    var WIDTH_INDEX = Polyline.WIDTH_INDEX;\n    var POSITION_INDEX = Polyline.POSITION_INDEX;\n    var MATERIAL_INDEX = Polyline.MATERIAL_INDEX;\n    //POSITION_SIZE_INDEX is needed for when the polyline's position array changes size.\n    //When it does, we need to recreate the indicesBuffer.\n    var POSITION_SIZE_INDEX = Polyline.POSITION_SIZE_INDEX;\n    var DISTANCE_DISPLAY_CONDITION = Polyline.DISTANCE_DISPLAY_CONDITION;\n    var NUMBER_OF_PROPERTIES = Polyline.NUMBER_OF_PROPERTIES;\n\n    var attributeLocations = {\n        texCoordExpandAndBatchIndex : 0,\n        position3DHigh : 1,\n        position3DLow : 2,\n        position2DHigh : 3,\n        position2DLow : 4,\n        prevPosition3DHigh : 5,\n        prevPosition3DLow : 6,\n        prevPosition2DHigh : 7,\n        prevPosition2DLow : 8,\n        nextPosition3DHigh : 9,\n        nextPosition3DLow : 10,\n        nextPosition2DHigh : 11,\n        nextPosition2DLow : 12\n    };\n\n    /**\n     * A renderable collection of polylines.\n     * <br /><br />\n     * <div align=\"center\">\n     * <img src=\"Images/Polyline.png\" width=\"400\" height=\"300\" /><br />\n     * Example polylines\n     * </div>\n     * <br /><br />\n     * Polylines are added and removed from the collection using {@link PolylineCollection#add}\n     * and {@link PolylineCollection#remove}.\n     *\n     * @alias PolylineCollection\n     * @constructor\n     *\n     * @param {Object} [options] Object with the following properties:\n     * @param {Matrix4} [options.modelMatrix=Matrix4.IDENTITY] The 4x4 transformation matrix that transforms each polyline from model to world coordinates.\n     * @param {Boolean} [options.debugShowBoundingVolume=false] For debugging only. Determines if this primitive's commands' bounding spheres are shown.\n     *\n     * @performance For best performance, prefer a few collections, each with many polylines, to\n     * many collections with only a few polylines each.  Organize collections so that polylines\n     * with the same update frequency are in the same collection, i.e., polylines that do not\n     * change should be in one collection; polylines that change every frame should be in another\n     * collection; and so on.\n     *\n     * @see PolylineCollection#add\n     * @see PolylineCollection#remove\n     * @see Polyline\n     * @see LabelCollection\n     *\n     * @example\n     * // Create a polyline collection with two polylines\n     * var polylines = new Cesium.PolylineCollection();\n     * polylines.add({\n     *   positions : Cesium.Cartesian3.fromDegreesArray([\n     *     -75.10, 39.57,\n     *     -77.02, 38.53,\n     *     -80.50, 35.14,\n     *     -80.12, 25.46]),\n     *   width : 2\n     * });\n     *\n     * polylines.add({\n     *   positions : Cesium.Cartesian3.fromDegreesArray([\n     *     -73.10, 37.57,\n     *     -75.02, 36.53,\n     *     -78.50, 33.14,\n     *     -78.12, 23.46]),\n     *   width : 4\n     * });\n     */\n    function PolylineCollection(options) {\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n        /**\n         * The 4x4 transformation matrix that transforms each polyline in this collection from model to world coordinates.\n         * When this is the identity matrix, the polylines are drawn in world coordinates, i.e., Earth's WGS84 coordinates.\n         * Local reference frames can be used by providing a different transformation matrix, like that returned\n         * by {@link Transforms.eastNorthUpToFixedFrame}.\n         *\n         * @type {Matrix4}\n         * @default {@link Matrix4.IDENTITY}\n         */\n        this.modelMatrix = Matrix4.clone(defaultValue(options.modelMatrix, Matrix4.IDENTITY));\n        this._modelMatrix = Matrix4.clone(Matrix4.IDENTITY);\n\n        /**\n         * This property is for debugging only; it is not for production use nor is it optimized.\n         * <p>\n         * Draws the bounding sphere for each draw command in the primitive.\n         * </p>\n         *\n         * @type {Boolean}\n         *\n         * @default false\n         */\n        this.debugShowBoundingVolume = defaultValue(options.debugShowBoundingVolume, false);\n\n        this._opaqueRS = undefined;\n        this._translucentRS = undefined;\n\n        this._colorCommands = [];\n\n        this._polylinesUpdated = false;\n        this._polylinesRemoved = false;\n        this._createVertexArray = false;\n        this._propertiesChanged = new Uint32Array(NUMBER_OF_PROPERTIES);\n        this._polylines = [];\n        this._polylineBuckets = {};\n\n        // The buffer usage is determined based on the usage of the attribute over time.\n        this._positionBufferUsage = { bufferUsage : BufferUsage.STATIC_DRAW, frameCount : 0 };\n\n        this._mode = undefined;\n\n        this._polylinesToUpdate = [];\n        this._vertexArrays = [];\n        this._positionBuffer = undefined;\n        this._texCoordExpandAndBatchIndexBuffer = undefined;\n\n        this._batchTable = undefined;\n        this._createBatchTable = false;\n\n        // Only used by Vector3DTilePoints\n        this._useHighlightColor = false;\n        this._highlightColor = Color.clone(Color.WHITE);\n\n        var that = this;\n        this._uniformMap = {\n            u_highlightColor : function() {\n                return that._highlightColor;\n            }\n        };\n    }\n\n    defineProperties(PolylineCollection.prototype, {\n        /**\n         * Returns the number of polylines in this collection.  This is commonly used with\n         * {@link PolylineCollection#get} to iterate over all the polylines\n         * in the collection.\n         * @memberof PolylineCollection.prototype\n         * @type {Number}\n         */\n        length : {\n            get : function() {\n                removePolylines(this);\n                return this._polylines.length;\n            }\n        }\n    });\n\n    /**\n     * Creates and adds a polyline with the specified initial properties to the collection.\n     * The added polyline is returned so it can be modified or removed from the collection later.\n     *\n     * @param {Object}[options] A template describing the polyline's properties as shown in Example 1.\n     * @returns {Polyline} The polyline that was added to the collection.\n     *\n     * @performance After calling <code>add</code>, {@link PolylineCollection#update} is called and\n     * the collection's vertex buffer is rewritten - an <code>O(n)</code> operation that also incurs CPU to GPU overhead.\n     * For best performance, add as many polylines as possible before calling <code>update</code>.\n     *\n     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n     *\n     *\n     * @example\n     * // Example 1:  Add a polyline, specifying all the default values.\n     * var p = polylines.add({\n     *   show : true,\n     *   positions : ellipsoid.cartographicArrayToCartesianArray([\n           Cesium.Cartographic.fromDegrees(-75.10, 39.57),\n           Cesium.Cartographic.fromDegrees(-77.02, 38.53)]),\n     *   width : 1\n     * });\n     *\n     * @see PolylineCollection#remove\n     * @see PolylineCollection#removeAll\n     * @see PolylineCollection#update\n     */\n    PolylineCollection.prototype.add = function(options) {\n        var p = new Polyline(options, this);\n        p._index = this._polylines.length;\n        this._polylines.push(p);\n        this._createVertexArray = true;\n        this._createBatchTable = true;\n        return p;\n    };\n\n    /**\n     * Removes a polyline from the collection.\n     *\n     * @param {Polyline} polyline The polyline to remove.\n     * @returns {Boolean} <code>true</code> if the polyline was removed; <code>false</code> if the polyline was not found in the collection.\n     *\n     * @performance After calling <code>remove</code>, {@link PolylineCollection#update} is called and\n     * the collection's vertex buffer is rewritten - an <code>O(n)</code> operation that also incurs CPU to GPU overhead.\n     * For best performance, remove as many polylines as possible before calling <code>update</code>.\n     * If you intend to temporarily hide a polyline, it is usually more efficient to call\n     * {@link Polyline#show} instead of removing and re-adding the polyline.\n     *\n     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n     *\n     *\n     * @example\n     * var p = polylines.add(...);\n     * polylines.remove(p);  // Returns true\n     *\n     * @see PolylineCollection#add\n     * @see PolylineCollection#removeAll\n     * @see PolylineCollection#update\n     * @see Polyline#show\n     */\n    PolylineCollection.prototype.remove = function(polyline) {\n        if (this.contains(polyline)) {\n            this._polylinesRemoved = true;\n            this._createVertexArray = true;\n            this._createBatchTable = true;\n            if (defined(polyline._bucket)) {\n                var bucket = polyline._bucket;\n                bucket.shaderProgram = bucket.shaderProgram && bucket.shaderProgram.destroy();\n            }\n            polyline._destroy();\n            return true;\n        }\n\n        return false;\n    };\n\n    /**\n     * Removes all polylines from the collection.\n     *\n     * @performance <code>O(n)</code>.  It is more efficient to remove all the polylines\n     * from a collection and then add new ones than to create a new collection entirely.\n     *\n     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n     *\n     *\n     * @example\n     * polylines.add(...);\n     * polylines.add(...);\n     * polylines.removeAll();\n     *\n     * @see PolylineCollection#add\n     * @see PolylineCollection#remove\n     * @see PolylineCollection#update\n     */\n    PolylineCollection.prototype.removeAll = function() {\n        releaseShaders(this);\n        destroyPolylines(this);\n        this._polylineBuckets = {};\n        this._polylinesRemoved = false;\n        this._polylines.length = 0;\n        this._polylinesToUpdate.length = 0;\n        this._createVertexArray = true;\n    };\n\n    /**\n     * Determines if this collection contains the specified polyline.\n     *\n     * @param {Polyline} polyline The polyline to check for.\n     * @returns {Boolean} true if this collection contains the polyline, false otherwise.\n     *\n     * @see PolylineCollection#get\n     */\n    PolylineCollection.prototype.contains = function(polyline) {\n        return defined(polyline) && polyline._polylineCollection === this;\n    };\n\n    /**\n     * Returns the polyline in the collection at the specified index.  Indices are zero-based\n     * and increase as polylines are added.  Removing a polyline shifts all polylines after\n     * it to the left, changing their indices.  This function is commonly used with\n     * {@link PolylineCollection#length} to iterate over all the polylines\n     * in the collection.\n     *\n     * @param {Number} index The zero-based index of the polyline.\n     * @returns {Polyline} The polyline at the specified index.\n     *\n     * @performance If polylines were removed from the collection and\n     * {@link PolylineCollection#update} was not called, an implicit <code>O(n)</code>\n     * operation is performed.\n     *\n     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n     *\n     * @example\n     * // Toggle the show property of every polyline in the collection\n     * var len = polylines.length;\n     * for (var i = 0; i < len; ++i) {\n     *   var p = polylines.get(i);\n     *   p.show = !p.show;\n     * }\n     *\n     * @see PolylineCollection#length\n     */\n    PolylineCollection.prototype.get = function(index) {\n        \n\n        removePolylines(this);\n        return this._polylines[index];\n    };\n\n    function createBatchTable(collection, context) {\n        if (defined(collection._batchTable)) {\n            collection._batchTable.destroy();\n        }\n\n        var attributes = [{\n            functionName : 'batchTable_getWidthAndShow',\n            componentDatatype : ComponentDatatype.UNSIGNED_BYTE,\n            componentsPerAttribute : 2\n        }, {\n            functionName : 'batchTable_getPickColor',\n            componentDatatype : ComponentDatatype.UNSIGNED_BYTE,\n            componentsPerAttribute : 4,\n            normalize : true\n        }, {\n            functionName : 'batchTable_getCenterHigh',\n            componentDatatype : ComponentDatatype.FLOAT,\n            componentsPerAttribute : 3\n        }, {\n            functionName : 'batchTable_getCenterLowAndRadius',\n            componentDatatype : ComponentDatatype.FLOAT,\n            componentsPerAttribute : 4\n        }, {\n            functionName : 'batchTable_getDistanceDisplayCondition',\n            componentDatatype : ComponentDatatype.FLOAT,\n            componentsPerAttribute : 2\n        }];\n\n        collection._batchTable = new BatchTable(context, attributes, collection._polylines.length);\n    }\n\n    var scratchUpdatePolylineEncodedCartesian = new EncodedCartesian3();\n    var scratchUpdatePolylineCartesian4 = new Cartesian4();\n    var scratchNearFarCartesian2 = new Cartesian2();\n\n    /**\n     * Called when {@link Viewer} or {@link CesiumWidget} render the scene to\n     * get the draw commands needed to render this primitive.\n     * <p>\n     * Do not call this function directly.  This is documented just to\n     * list the exceptions that may be propagated when the scene is rendered:\n     * </p>\n     *\n     * @exception {RuntimeError} Vertex texture fetch support is required to render primitives with per-instance attributes. The maximum number of vertex texture image units must be greater than zero.\n     */\n    PolylineCollection.prototype.update = function(frameState) {\n        removePolylines(this);\n\n        if (this._polylines.length === 0) {\n            return;\n        }\n\n        updateMode(this, frameState);\n\n        var context = frameState.context;\n        var projection = frameState.mapProjection;\n        var polyline;\n        var properties = this._propertiesChanged;\n\n        if (this._createBatchTable) {\n            if (ContextLimits.maximumVertexTextureImageUnits === 0) {\n                throw new RuntimeError('Vertex texture fetch support is required to render polylines. The maximum number of vertex texture image units must be greater than zero.');\n            }\n            createBatchTable(this, context);\n            this._createBatchTable = false;\n        }\n\n        if (this._createVertexArray || computeNewBuffersUsage(this)) {\n            createVertexArrays(this, context, projection);\n        } else if (this._polylinesUpdated) {\n            // Polylines were modified, but no polylines were added or removed.\n            var polylinesToUpdate = this._polylinesToUpdate;\n            if (this._mode !== SceneMode.SCENE3D) {\n                var updateLength = polylinesToUpdate.length;\n                for ( var i = 0; i < updateLength; ++i) {\n                    polyline = polylinesToUpdate[i];\n                    polyline.update();\n                }\n            }\n\n            // if a polyline's positions size changes, we need to recreate the vertex arrays and vertex buffers because the indices will be different.\n            // if a polyline's material changes, we need to recreate the VAOs and VBOs because they will be batched differently.\n            if (properties[POSITION_SIZE_INDEX] || properties[MATERIAL_INDEX]) {\n                createVertexArrays(this, context, projection);\n            } else {\n                var length = polylinesToUpdate.length;\n                var polylineBuckets = this._polylineBuckets;\n                for ( var ii = 0; ii < length; ++ii) {\n                    polyline = polylinesToUpdate[ii];\n                    properties = polyline._propertiesChanged;\n                    var bucket = polyline._bucket;\n                    var index = 0;\n                    for (var x in polylineBuckets) {\n                        if (polylineBuckets.hasOwnProperty(x)) {\n                            if (polylineBuckets[x] === bucket) {\n                                if (properties[POSITION_INDEX]) {\n                                    bucket.writeUpdate(index, polyline, this._positionBuffer, projection);\n                                }\n                                break;\n                            }\n                            index += polylineBuckets[x].lengthOfPositions;\n                        }\n                    }\n\n                    if (properties[SHOW_INDEX] || properties[WIDTH_INDEX]) {\n                        this._batchTable.setBatchedAttribute(polyline._index, 0, new Cartesian2(polyline._width, polyline._show));\n                    }\n\n                    if (this._batchTable.attributes.length > 2) {\n                        if (properties[POSITION_INDEX] || properties[POSITION_SIZE_INDEX]) {\n                            var boundingSphere = frameState.mode === SceneMode.SCENE2D ? polyline._boundingVolume2D : polyline._boundingVolumeWC;\n                            var encodedCenter = EncodedCartesian3.fromCartesian(boundingSphere.center, scratchUpdatePolylineEncodedCartesian);\n                            var low = Cartesian4.fromElements(encodedCenter.low.x, encodedCenter.low.y, encodedCenter.low.z, boundingSphere.radius, scratchUpdatePolylineCartesian4);\n                            this._batchTable.setBatchedAttribute(polyline._index, 2, encodedCenter.high);\n                            this._batchTable.setBatchedAttribute(polyline._index, 3, low);\n                        }\n\n                        if (properties[DISTANCE_DISPLAY_CONDITION]) {\n                            var nearFarCartesian = scratchNearFarCartesian2;\n                            nearFarCartesian.x = 0.0;\n                            nearFarCartesian.y = Number.MAX_VALUE;\n\n                            var distanceDisplayCondition = polyline.distanceDisplayCondition;\n                            if (defined(distanceDisplayCondition)) {\n                                nearFarCartesian.x = distanceDisplayCondition.near;\n                                nearFarCartesian.y = distanceDisplayCondition.far;\n                            }\n\n                            this._batchTable.setBatchedAttribute(polyline._index, 4, nearFarCartesian);\n                        }\n                    }\n\n                    polyline._clean();\n                }\n            }\n            polylinesToUpdate.length = 0;\n            this._polylinesUpdated = false;\n        }\n\n        properties = this._propertiesChanged;\n        for ( var k = 0; k < NUMBER_OF_PROPERTIES; ++k) {\n            properties[k] = 0;\n        }\n\n        var modelMatrix = Matrix4.IDENTITY;\n        if (frameState.mode === SceneMode.SCENE3D) {\n            modelMatrix = this.modelMatrix;\n        }\n\n        var pass = frameState.passes;\n        var useDepthTest = (frameState.morphTime !== 0.0);\n\n        if (!defined(this._opaqueRS) || this._opaqueRS.depthTest.enabled !== useDepthTest) {\n            this._opaqueRS = RenderState.fromCache({\n                depthMask : useDepthTest,\n                depthTest : {\n                    enabled : useDepthTest\n                }\n            });\n        }\n\n        if (!defined(this._translucentRS) || this._translucentRS.depthTest.enabled !== useDepthTest) {\n            this._translucentRS = RenderState.fromCache({\n                blending : BlendingState.ALPHA_BLEND,\n                depthMask : !useDepthTest,\n                depthTest : {\n                    enabled : useDepthTest\n                }\n            });\n        }\n\n        this._batchTable.update(frameState);\n\n        if (pass.render || pass.pick) {\n            var colorList = this._colorCommands;\n            createCommandLists(this, frameState, colorList, modelMatrix);\n        }\n    };\n\n    var boundingSphereScratch = new BoundingSphere();\n    var boundingSphereScratch2 = new BoundingSphere();\n\n    function createCommandLists(polylineCollection, frameState, commands, modelMatrix) {\n        var context = frameState.context;\n        var commandList = frameState.commandList;\n\n        var commandsLength = commands.length;\n        var commandIndex = 0;\n        var cloneBoundingSphere = true;\n\n        var vertexArrays = polylineCollection._vertexArrays;\n        var debugShowBoundingVolume = polylineCollection.debugShowBoundingVolume;\n\n        var batchTable = polylineCollection._batchTable;\n        var uniformCallback = batchTable.getUniformMapCallback();\n\n        var length = vertexArrays.length;\n        for ( var m = 0; m < length; ++m) {\n            var va = vertexArrays[m];\n            var buckets = va.buckets;\n            var bucketLength = buckets.length;\n\n            for ( var n = 0; n < bucketLength; ++n) {\n                var bucketLocator = buckets[n];\n\n                var offset = bucketLocator.offset;\n                var sp = bucketLocator.bucket.shaderProgram;\n\n                var polylines = bucketLocator.bucket.polylines;\n                var polylineLength = polylines.length;\n                var currentId;\n                var currentMaterial;\n                var count = 0;\n                var command;\n                var uniformMap;\n\n                for (var s = 0; s < polylineLength; ++s) {\n                    var polyline = polylines[s];\n                    var mId = createMaterialId(polyline._material);\n                    if (mId !== currentId) {\n                        if (defined(currentId) && count > 0) {\n                            var translucent = currentMaterial.isTranslucent();\n\n                            if (commandIndex >= commandsLength) {\n                                command = new DrawCommand({\n                                    owner : polylineCollection\n                                });\n                                commands.push(command);\n                            } else {\n                                command = commands[commandIndex];\n                            }\n\n                            ++commandIndex;\n\n                            uniformMap = combine(uniformCallback(currentMaterial._uniforms), polylineCollection._uniformMap);\n\n                            command.boundingVolume = BoundingSphere.clone(boundingSphereScratch, command.boundingVolume);\n                            command.modelMatrix = modelMatrix;\n                            command.shaderProgram = sp;\n                            command.vertexArray = va.va;\n                            command.renderState = translucent ? polylineCollection._translucentRS : polylineCollection._opaqueRS;\n                            command.pass = translucent ? Pass.TRANSLUCENT : Pass.OPAQUE;\n                            command.debugShowBoundingVolume = debugShowBoundingVolume;\n                            command.pickId = 'v_pickColor';\n\n                            command.uniformMap = uniformMap;\n                            command.count = count;\n                            command.offset = offset;\n\n                            offset += count;\n                            count = 0;\n                            cloneBoundingSphere = true;\n\n                            commandList.push(command);\n                        }\n\n                        currentMaterial = polyline._material;\n                        currentMaterial.update(context);\n                        currentId = mId;\n                    }\n\n                    var locators = polyline._locatorBuckets;\n                    var locatorLength = locators.length;\n                    for (var t = 0; t < locatorLength; ++t) {\n                        var locator = locators[t];\n                        if (locator.locator === bucketLocator) {\n                            count += locator.count;\n                        }\n                    }\n\n                    var boundingVolume;\n                    if (frameState.mode === SceneMode.SCENE3D) {\n                        boundingVolume = polyline._boundingVolumeWC;\n                    } else if (frameState.mode === SceneMode.COLUMBUS_VIEW) {\n                        boundingVolume = polyline._boundingVolume2D;\n                    } else if (frameState.mode === SceneMode.SCENE2D) {\n                        if (defined(polyline._boundingVolume2D)) {\n                            boundingVolume = BoundingSphere.clone(polyline._boundingVolume2D, boundingSphereScratch2);\n                            boundingVolume.center.x = 0.0;\n                        }\n                    } else if (defined(polyline._boundingVolumeWC) && defined(polyline._boundingVolume2D)) {\n                        boundingVolume = BoundingSphere.union(polyline._boundingVolumeWC, polyline._boundingVolume2D, boundingSphereScratch2);\n                    }\n\n                    if (cloneBoundingSphere) {\n                        cloneBoundingSphere = false;\n                        BoundingSphere.clone(boundingVolume, boundingSphereScratch);\n                    } else {\n                        BoundingSphere.union(boundingVolume, boundingSphereScratch, boundingSphereScratch);\n                    }\n                }\n\n                if (defined(currentId) && count > 0) {\n                    if (commandIndex >= commandsLength) {\n                        command = new DrawCommand({\n                            owner : polylineCollection\n                        });\n                        commands.push(command);\n                    } else {\n                        command = commands[commandIndex];\n                    }\n\n                    ++commandIndex;\n\n                    uniformMap = combine(uniformCallback(currentMaterial._uniforms), polylineCollection._uniformMap);\n\n                    command.boundingVolume = BoundingSphere.clone(boundingSphereScratch, command.boundingVolume);\n                    command.modelMatrix = modelMatrix;\n                    command.shaderProgram = sp;\n                    command.vertexArray = va.va;\n                    command.renderState = currentMaterial.isTranslucent() ? polylineCollection._translucentRS : polylineCollection._opaqueRS;\n                    command.pass = currentMaterial.isTranslucent() ? Pass.TRANSLUCENT : Pass.OPAQUE;\n                    command.debugShowBoundingVolume = debugShowBoundingVolume;\n                    command.pickId = 'v_pickColor';\n\n                    command.uniformMap = uniformMap;\n                    command.count = count;\n                    command.offset = offset;\n\n                    cloneBoundingSphere = true;\n\n                    commandList.push(command);\n                }\n\n                currentId = undefined;\n            }\n        }\n\n        commands.length = commandIndex;\n    }\n\n    /**\n     * Returns true if this object was destroyed; otherwise, false.\n     * <br /><br />\n     * If this object was destroyed, it should not be used; calling any function other than\n     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n     *\n     * @returns {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n     *\n     * @see PolylineCollection#destroy\n     */\n    PolylineCollection.prototype.isDestroyed = function() {\n        return false;\n    };\n\n    /**\n     * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n     * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n     * <br /><br />\n     * Once an object is destroyed, it should not be used; calling any function other than\n     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n     * assign the return value (<code>undefined</code>) to the object as done in the example.\n     *\n     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n     *\n     *\n     * @example\n     * polylines = polylines && polylines.destroy();\n     *\n     * @see PolylineCollection#isDestroyed\n     */\n    PolylineCollection.prototype.destroy = function() {\n        destroyVertexArrays(this);\n        releaseShaders(this);\n        destroyPolylines(this);\n        this._batchTable = this._batchTable && this._batchTable.destroy();\n        return destroyObject(this);\n    };\n\n    function computeNewBuffersUsage(collection) {\n        var usageChanged = false;\n        var properties = collection._propertiesChanged;\n        var bufferUsage = collection._positionBufferUsage;\n        if (properties[POSITION_INDEX]) {\n            if (bufferUsage.bufferUsage !== BufferUsage.STREAM_DRAW) {\n                usageChanged = true;\n                bufferUsage.bufferUsage = BufferUsage.STREAM_DRAW;\n                bufferUsage.frameCount = 100;\n            } else {\n                bufferUsage.frameCount = 100;\n            }\n        } else if (bufferUsage.bufferUsage !== BufferUsage.STATIC_DRAW) {\n            if (bufferUsage.frameCount === 0) {\n                usageChanged = true;\n                bufferUsage.bufferUsage = BufferUsage.STATIC_DRAW;\n            } else {\n                bufferUsage.frameCount--;\n            }\n        }\n\n        return usageChanged;\n    }\n\n    var emptyVertexBuffer = [0.0, 0.0, 0.0];\n\n    function createVertexArrays(collection, context, projection) {\n        collection._createVertexArray = false;\n        releaseShaders(collection);\n        destroyVertexArrays(collection);\n        sortPolylinesIntoBuckets(collection);\n\n        //stores all of the individual indices arrays.\n        var totalIndices = [[]];\n        var indices = totalIndices[0];\n\n        var batchTable = collection._batchTable;\n        var useHighlightColor = collection._useHighlightColor;\n\n        //used to determine the vertexBuffer offset if the indicesArray goes over 64k.\n        //if it's the same polyline while it goes over 64k, the offset needs to backtrack componentsPerAttribute * componentDatatype bytes\n        //so that the polyline looks contiguous.\n        //if the polyline ends at the 64k mark, then the offset is just 64k * componentsPerAttribute * componentDatatype\n        var vertexBufferOffset = [0];\n        var offset = 0;\n        var vertexArrayBuckets = [[]];\n        var totalLength = 0;\n        var polylineBuckets = collection._polylineBuckets;\n        var x;\n        var bucket;\n        for (x in polylineBuckets) {\n            if (polylineBuckets.hasOwnProperty(x)) {\n                bucket = polylineBuckets[x];\n                bucket.updateShader(context, batchTable, useHighlightColor);\n                totalLength += bucket.lengthOfPositions;\n            }\n        }\n\n        if (totalLength > 0) {\n            var mode = collection._mode;\n\n            var positionArray = new Float32Array(6 * totalLength * 3);\n            var texCoordExpandAndBatchIndexArray = new Float32Array(totalLength * 4);\n            var position3DArray;\n\n            var positionIndex = 0;\n            var colorIndex = 0;\n            var texCoordExpandAndBatchIndexIndex = 0;\n            for (x in polylineBuckets) {\n                if (polylineBuckets.hasOwnProperty(x)) {\n                    bucket = polylineBuckets[x];\n                    bucket.write(positionArray, texCoordExpandAndBatchIndexArray, positionIndex, colorIndex, texCoordExpandAndBatchIndexIndex, batchTable, context, projection);\n\n                    if (mode === SceneMode.MORPHING) {\n                        if (!defined(position3DArray)) {\n                            position3DArray = new Float32Array(6 * totalLength * 3);\n                        }\n                        bucket.writeForMorph(position3DArray, positionIndex);\n                    }\n\n                    var bucketLength = bucket.lengthOfPositions;\n                    positionIndex += 6 * bucketLength * 3;\n                    colorIndex += bucketLength * 4;\n                    texCoordExpandAndBatchIndexIndex += bucketLength * 4;\n                    offset = bucket.updateIndices(totalIndices, vertexBufferOffset, vertexArrayBuckets, offset);\n                }\n            }\n\n            var positionBufferUsage = collection._positionBufferUsage.bufferUsage;\n            var texCoordExpandAndBatchIndexBufferUsage = BufferUsage.STATIC_DRAW;\n\n            collection._positionBuffer = Buffer.createVertexBuffer({\n                context : context,\n                typedArray : positionArray,\n                usage : positionBufferUsage\n            });\n            var position3DBuffer;\n            if (defined(position3DArray)) {\n                position3DBuffer = Buffer.createVertexBuffer({\n                    context : context,\n                    typedArray : position3DArray,\n                    usage : positionBufferUsage\n                });\n            }\n            collection._texCoordExpandAndBatchIndexBuffer = Buffer.createVertexBuffer({\n                context : context,\n                typedArray : texCoordExpandAndBatchIndexArray,\n                usage : texCoordExpandAndBatchIndexBufferUsage\n            });\n\n            var positionSizeInBytes = 3 * Float32Array.BYTES_PER_ELEMENT;\n            var texCoordExpandAndBatchIndexSizeInBytes = 4 * Float32Array.BYTES_PER_ELEMENT;\n\n            var vbo = 0;\n            var numberOfIndicesArrays = totalIndices.length;\n            for ( var k = 0; k < numberOfIndicesArrays; ++k) {\n                indices = totalIndices[k];\n\n                if (indices.length > 0) {\n                    var indicesArray = new Uint16Array(indices);\n                    var indexBuffer = Buffer.createIndexBuffer({\n                        context : context,\n                        typedArray : indicesArray,\n                        usage : BufferUsage.STATIC_DRAW,\n                        indexDatatype : IndexDatatype.UNSIGNED_SHORT\n                    });\n\n                    vbo += vertexBufferOffset[k];\n\n                    var positionHighOffset = 6 * (k * (positionSizeInBytes * CesiumMath.SIXTY_FOUR_KILOBYTES) - vbo * positionSizeInBytes);//componentsPerAttribute(3) * componentDatatype(4)\n                    var positionLowOffset = positionSizeInBytes + positionHighOffset;\n                    var prevPositionHighOffset =  positionSizeInBytes + positionLowOffset;\n                    var prevPositionLowOffset = positionSizeInBytes + prevPositionHighOffset;\n                    var nextPositionHighOffset = positionSizeInBytes + prevPositionLowOffset;\n                    var nextPositionLowOffset = positionSizeInBytes + nextPositionHighOffset;\n                    var vertexTexCoordExpandAndBatchIndexBufferOffset = k * (texCoordExpandAndBatchIndexSizeInBytes * CesiumMath.SIXTY_FOUR_KILOBYTES) - vbo * texCoordExpandAndBatchIndexSizeInBytes;\n\n                    var attributes = [{\n                        index : attributeLocations.position3DHigh,\n                        componentsPerAttribute : 3,\n                        componentDatatype : ComponentDatatype.FLOAT,\n                        offsetInBytes : positionHighOffset,\n                        strideInBytes : 6 * positionSizeInBytes\n                    }, {\n                        index : attributeLocations.position3DLow,\n                        componentsPerAttribute : 3,\n                        componentDatatype : ComponentDatatype.FLOAT,\n                        offsetInBytes : positionLowOffset,\n                        strideInBytes : 6 * positionSizeInBytes\n                    }, {\n                        index : attributeLocations.position2DHigh,\n                        componentsPerAttribute : 3,\n                        componentDatatype : ComponentDatatype.FLOAT,\n                        offsetInBytes : positionHighOffset,\n                        strideInBytes : 6 * positionSizeInBytes\n                    }, {\n                        index : attributeLocations.position2DLow,\n                        componentsPerAttribute : 3,\n                        componentDatatype : ComponentDatatype.FLOAT,\n                        offsetInBytes : positionLowOffset,\n                        strideInBytes : 6 * positionSizeInBytes\n                    }, {\n                        index : attributeLocations.prevPosition3DHigh,\n                        componentsPerAttribute : 3,\n                        componentDatatype : ComponentDatatype.FLOAT,\n                        offsetInBytes : prevPositionHighOffset,\n                        strideInBytes : 6 * positionSizeInBytes\n                    }, {\n                        index : attributeLocations.prevPosition3DLow,\n                        componentsPerAttribute : 3,\n                        componentDatatype : ComponentDatatype.FLOAT,\n                        offsetInBytes : prevPositionLowOffset,\n                        strideInBytes : 6 * positionSizeInBytes\n                    }, {\n                        index : attributeLocations.prevPosition2DHigh,\n                        componentsPerAttribute : 3,\n                        componentDatatype : ComponentDatatype.FLOAT,\n                        offsetInBytes : prevPositionHighOffset,\n                        strideInBytes : 6 * positionSizeInBytes\n                    }, {\n                        index : attributeLocations.prevPosition2DLow,\n                        componentsPerAttribute : 3,\n                        componentDatatype : ComponentDatatype.FLOAT,\n                        offsetInBytes : prevPositionLowOffset,\n                        strideInBytes : 6 * positionSizeInBytes\n                    }, {\n                        index : attributeLocations.nextPosition3DHigh,\n                        componentsPerAttribute : 3,\n                        componentDatatype : ComponentDatatype.FLOAT,\n                        offsetInBytes : nextPositionHighOffset,\n                        strideInBytes : 6 * positionSizeInBytes\n                    }, {\n                        index : attributeLocations.nextPosition3DLow,\n                        componentsPerAttribute : 3,\n                        componentDatatype : ComponentDatatype.FLOAT,\n                        offsetInBytes : nextPositionLowOffset,\n                        strideInBytes : 6 * positionSizeInBytes\n                    }, {\n                        index : attributeLocations.nextPosition2DHigh,\n                        componentsPerAttribute : 3,\n                        componentDatatype : ComponentDatatype.FLOAT,\n                        offsetInBytes : nextPositionHighOffset,\n                        strideInBytes : 6 * positionSizeInBytes\n                    }, {\n                        index : attributeLocations.nextPosition2DLow,\n                        componentsPerAttribute : 3,\n                        componentDatatype : ComponentDatatype.FLOAT,\n                        offsetInBytes : nextPositionLowOffset,\n                        strideInBytes : 6 * positionSizeInBytes\n                    }, {\n                        index : attributeLocations.texCoordExpandAndBatchIndex,\n                        componentsPerAttribute : 4,\n                        componentDatatype : ComponentDatatype.FLOAT,\n                        vertexBuffer : collection._texCoordExpandAndBatchIndexBuffer,\n                        offsetInBytes : vertexTexCoordExpandAndBatchIndexBufferOffset\n                    }];\n\n                    var buffer3D;\n                    var bufferProperty3D;\n                    var buffer2D;\n                    var bufferProperty2D;\n\n                    if (mode === SceneMode.SCENE3D) {\n                        buffer3D = collection._positionBuffer;\n                        bufferProperty3D = 'vertexBuffer';\n                        buffer2D = emptyVertexBuffer;\n                        bufferProperty2D = 'value';\n                    } else if (mode === SceneMode.SCENE2D || mode === SceneMode.COLUMBUS_VIEW) {\n                        buffer3D = emptyVertexBuffer;\n                        bufferProperty3D = 'value';\n                        buffer2D = collection._positionBuffer;\n                        bufferProperty2D = 'vertexBuffer';\n                    } else {\n                        buffer3D = position3DBuffer;\n                        bufferProperty3D = 'vertexBuffer';\n                        buffer2D = collection._positionBuffer;\n                        bufferProperty2D = 'vertexBuffer';\n                    }\n\n                    attributes[0][bufferProperty3D] = buffer3D;\n                    attributes[1][bufferProperty3D] = buffer3D;\n                    attributes[2][bufferProperty2D] = buffer2D;\n                    attributes[3][bufferProperty2D] = buffer2D;\n                    attributes[4][bufferProperty3D] = buffer3D;\n                    attributes[5][bufferProperty3D] = buffer3D;\n                    attributes[6][bufferProperty2D] = buffer2D;\n                    attributes[7][bufferProperty2D] = buffer2D;\n                    attributes[8][bufferProperty3D] = buffer3D;\n                    attributes[9][bufferProperty3D] = buffer3D;\n                    attributes[10][bufferProperty2D] = buffer2D;\n                    attributes[11][bufferProperty2D] = buffer2D;\n\n                    var va = new VertexArray({\n                        context : context,\n                        attributes : attributes,\n                        indexBuffer : indexBuffer\n                    });\n                    collection._vertexArrays.push({\n                        va : va,\n                        buckets : vertexArrayBuckets[k]\n                    });\n                }\n            }\n        }\n    }\n\n    function replacer(key, value) {\n        if (value instanceof Texture) {\n            return value.id;\n        }\n\n        return value;\n    }\n\n    var scratchUniformArray = [];\n    function createMaterialId(material) {\n        var uniforms = Material._uniformList[material.type];\n        var length = uniforms.length;\n        scratchUniformArray.length = 2.0 * length;\n\n        var index = 0;\n        for (var i = 0; i < length; ++i) {\n            var uniform = uniforms[i];\n            scratchUniformArray[index] = uniform;\n            scratchUniformArray[index + 1] = material._uniforms[uniform]();\n            index += 2;\n        }\n\n        return material.type + ':' + JSON.stringify(scratchUniformArray, replacer);\n    }\n\n    function sortPolylinesIntoBuckets(collection) {\n        var mode = collection._mode;\n        var modelMatrix = collection._modelMatrix;\n\n        var polylineBuckets = collection._polylineBuckets = {};\n        var polylines = collection._polylines;\n        var length = polylines.length;\n        for ( var i = 0; i < length; ++i) {\n            var p = polylines[i];\n            if (p._actualPositions.length > 1) {\n                p.update();\n                var material = p.material;\n                var value = polylineBuckets[material.type];\n                if (!defined(value)) {\n                    value = polylineBuckets[material.type] = new PolylineBucket(material, mode, modelMatrix);\n                }\n                value.addPolyline(p);\n            }\n        }\n    }\n\n    function updateMode(collection, frameState) {\n        var mode = frameState.mode;\n\n        if (collection._mode !== mode || (!Matrix4.equals(collection._modelMatrix, collection.modelMatrix))) {\n            collection._mode = mode;\n            collection._modelMatrix = Matrix4.clone(collection.modelMatrix);\n            collection._createVertexArray = true;\n        }\n    }\n\n    function removePolylines(collection) {\n        if (collection._polylinesRemoved) {\n            collection._polylinesRemoved = false;\n            var definedPolylines = [];\n            var definedPolylinesToUpdate = [];\n            var polyIndex = 0;\n            var polyline;\n\n            var length = collection._polylines.length;\n            for (var i = 0; i < length; ++i) {\n                polyline = collection._polylines[i];\n                if (!polyline.isDestroyed) {\n                    polyline._index = polyIndex++;\n                    definedPolylinesToUpdate.push(polyline);\n                    definedPolylines.push(polyline);\n                }\n            }\n\n            collection._polylines = definedPolylines;\n            collection._polylinesToUpdate = definedPolylinesToUpdate;\n        }\n    }\n\n    function releaseShaders(collection) {\n        var polylines = collection._polylines;\n        var length = polylines.length;\n        for ( var i = 0; i < length; ++i) {\n            if (!polylines[i].isDestroyed) {\n                var bucket = polylines[i]._bucket;\n                if (defined(bucket)) {\n                    bucket.shaderProgram = bucket.shaderProgram && bucket.shaderProgram.destroy();\n                }\n            }\n        }\n    }\n\n    function destroyVertexArrays(collection) {\n        var length = collection._vertexArrays.length;\n        for ( var t = 0; t < length; ++t) {\n            collection._vertexArrays[t].va.destroy();\n        }\n        collection._vertexArrays.length = 0;\n    }\n\n    PolylineCollection.prototype._updatePolyline = function(polyline, propertyChanged) {\n        this._polylinesUpdated = true;\n        if (!polyline._dirty) {\n            this._polylinesToUpdate.push(polyline);\n        }\n        ++this._propertiesChanged[propertyChanged];\n    };\n\n    function destroyPolylines(collection) {\n        var polylines = collection._polylines;\n        var length = polylines.length;\n        for ( var i = 0; i < length; ++i) {\n            if (!polylines[i].isDestroyed) {\n                polylines[i]._destroy();\n            }\n        }\n    }\n\n    function VertexArrayBucketLocator(count, offset, bucket) {\n        this.count = count;\n        this.offset = offset;\n        this.bucket = bucket;\n    }\n\n    function PolylineBucket(material, mode, modelMatrix) {\n        this.polylines = [];\n        this.lengthOfPositions = 0;\n        this.material = material;\n        this.shaderProgram = undefined;\n        this.mode = mode;\n        this.modelMatrix = modelMatrix;\n    }\n\n    PolylineBucket.prototype.addPolyline = function(p) {\n        var polylines = this.polylines;\n        polylines.push(p);\n        p._actualLength = this.getPolylinePositionsLength(p);\n        this.lengthOfPositions += p._actualLength;\n        p._bucket = this;\n    };\n\n    PolylineBucket.prototype.updateShader = function(context, batchTable, useHighlightColor) {\n        if (defined(this.shaderProgram)) {\n            return;\n        }\n\n        var defines = ['DISTANCE_DISPLAY_CONDITION'];\n        if (useHighlightColor) {\n            defines.push('VECTOR_TILE');\n        }\n\n        // Check for use of v_polylineAngle in material shader\n        if (this.material.shaderSource.search(/varying\\s+float\\s+v_polylineAngle;/g) !== -1) {\n            defines.push('POLYLINE_DASH');\n        }\n\n        if (!FeatureDetection.isInternetExplorer()) {\n            defines.push('CLIP_POLYLINE');\n        }\n\n        var fs = new ShaderSource({\n            defines : defines,\n            sources : ['varying vec4 v_pickColor;\\n', this.material.shaderSource, PolylineFS]\n        });\n\n        var vsSource = batchTable.getVertexShaderCallback()(PolylineVS);\n        var vs = new ShaderSource({\n            defines : defines,\n            sources : [PolylineCommon, vsSource]\n        });\n\n        this.shaderProgram = ShaderProgram.fromCache({\n            context : context,\n            vertexShaderSource : vs,\n            fragmentShaderSource : fs,\n            attributeLocations : attributeLocations\n        });\n    };\n\n    function intersectsIDL(polyline) {\n        return Cartesian3.dot(Cartesian3.UNIT_X, polyline._boundingVolume.center) < 0 ||\n            polyline._boundingVolume.intersectPlane(Plane.ORIGIN_ZX_PLANE) === Intersect.INTERSECTING;\n    }\n\n    PolylineBucket.prototype.getPolylinePositionsLength = function(polyline) {\n        var length;\n        if (this.mode === SceneMode.SCENE3D || !intersectsIDL(polyline)) {\n            length = polyline._actualPositions.length;\n            return length * 4.0 - 4.0;\n        }\n\n        var count = 0;\n        var segmentLengths = polyline._segments.lengths;\n        length = segmentLengths.length;\n        for (var i = 0; i < length; ++i) {\n            count += segmentLengths[i] * 4.0 - 4.0;\n        }\n\n        return count;\n    };\n\n    var scratchWritePosition = new Cartesian3();\n    var scratchWritePrevPosition = new Cartesian3();\n    var scratchWriteNextPosition = new Cartesian3();\n    var scratchWriteVector = new Cartesian3();\n    var scratchPickColorCartesian = new Cartesian4();\n    var scratchWidthShowCartesian = new Cartesian2();\n\n    PolylineBucket.prototype.write = function(positionArray, texCoordExpandAndBatchIndexArray, positionIndex, colorIndex, texCoordExpandAndBatchIndexIndex, batchTable, context, projection) {\n        var mode = this.mode;\n        var maxLon = projection.ellipsoid.maximumRadius * CesiumMath.PI;\n\n        var polylines = this.polylines;\n        var length = polylines.length;\n        for ( var i = 0; i < length; ++i) {\n            var polyline = polylines[i];\n            var width = polyline.width;\n            var show = polyline.show && width > 0.0;\n            var polylineBatchIndex = polyline._index;\n            var segments = this.getSegments(polyline, projection);\n            var positions = segments.positions;\n            var lengths = segments.lengths;\n            var positionsLength = positions.length;\n\n            var pickColor = polyline.getPickId(context).color;\n\n            var segmentIndex = 0;\n            var count = 0;\n            var position;\n\n            for ( var j = 0; j < positionsLength; ++j) {\n                if (j === 0) {\n                    if (polyline._loop) {\n                        position = positions[positionsLength - 2];\n                    } else {\n                        position = scratchWriteVector;\n                        Cartesian3.subtract(positions[0], positions[1], position);\n                        Cartesian3.add(positions[0], position, position);\n                    }\n                } else {\n                    position = positions[j - 1];\n                }\n\n                Cartesian3.clone(position, scratchWritePrevPosition);\n                Cartesian3.clone(positions[j], scratchWritePosition);\n\n                if (j === positionsLength - 1) {\n                    if (polyline._loop) {\n                        position = positions[1];\n                    } else {\n                        position = scratchWriteVector;\n                        Cartesian3.subtract(positions[positionsLength - 1], positions[positionsLength - 2], position);\n                        Cartesian3.add(positions[positionsLength - 1], position, position);\n                    }\n                } else {\n                    position = positions[j + 1];\n                }\n\n                Cartesian3.clone(position, scratchWriteNextPosition);\n\n                var segmentLength = lengths[segmentIndex];\n                if (j === count + segmentLength) {\n                    count += segmentLength;\n                    ++segmentIndex;\n                }\n\n                var segmentStart = j - count === 0;\n                var segmentEnd = j === count + lengths[segmentIndex] - 1;\n\n                if (mode === SceneMode.SCENE2D) {\n                    scratchWritePrevPosition.z = 0.0;\n                    scratchWritePosition.z = 0.0;\n                    scratchWriteNextPosition.z = 0.0;\n                }\n\n                if (mode === SceneMode.SCENE2D || mode === SceneMode.MORPHING) {\n                    if ((segmentStart || segmentEnd) && maxLon - Math.abs(scratchWritePosition.x) < 1.0) {\n                        if ((scratchWritePosition.x < 0.0 && scratchWritePrevPosition.x > 0.0) ||\n                            (scratchWritePosition.x > 0.0 && scratchWritePrevPosition.x < 0.0)) {\n                            Cartesian3.clone(scratchWritePosition, scratchWritePrevPosition);\n                        }\n\n                        if ((scratchWritePosition.x < 0.0 && scratchWriteNextPosition.x > 0.0) ||\n                            (scratchWritePosition.x > 0.0 && scratchWriteNextPosition.x < 0.0)) {\n                            Cartesian3.clone(scratchWritePosition, scratchWriteNextPosition);\n                        }\n                    }\n                }\n\n                var startK = (segmentStart) ? 2 : 0;\n                var endK = (segmentEnd) ? 2 : 4;\n\n                for (var k = startK; k < endK; ++k) {\n                    EncodedCartesian3.writeElements(scratchWritePosition, positionArray, positionIndex);\n                    EncodedCartesian3.writeElements(scratchWritePrevPosition, positionArray, positionIndex + 6);\n                    EncodedCartesian3.writeElements(scratchWriteNextPosition, positionArray, positionIndex + 12);\n\n                    var direction = (k - 2 < 0) ? -1.0 : 1.0;\n                    texCoordExpandAndBatchIndexArray[texCoordExpandAndBatchIndexIndex] = j / (positionsLength - 1); // s tex coord\n                    texCoordExpandAndBatchIndexArray[texCoordExpandAndBatchIndexIndex + 1] = 2 * (k % 2) - 1;       // expand direction\n                    texCoordExpandAndBatchIndexArray[texCoordExpandAndBatchIndexIndex + 2] = direction;\n                    texCoordExpandAndBatchIndexArray[texCoordExpandAndBatchIndexIndex + 3] = polylineBatchIndex;\n\n                    positionIndex += 6 * 3;\n                    texCoordExpandAndBatchIndexIndex += 4;\n                }\n            }\n\n            var colorCartesian = scratchPickColorCartesian;\n            colorCartesian.x = Color.floatToByte(pickColor.red);\n            colorCartesian.y = Color.floatToByte(pickColor.green);\n            colorCartesian.z = Color.floatToByte(pickColor.blue);\n            colorCartesian.w = Color.floatToByte(pickColor.alpha);\n\n            var widthShowCartesian = scratchWidthShowCartesian;\n            widthShowCartesian.x = width;\n            widthShowCartesian.y = show ? 1.0 : 0.0;\n\n            var boundingSphere = mode === SceneMode.SCENE2D ? polyline._boundingVolume2D : polyline._boundingVolumeWC;\n            var encodedCenter = EncodedCartesian3.fromCartesian(boundingSphere.center, scratchUpdatePolylineEncodedCartesian);\n            var high = encodedCenter.high;\n            var low = Cartesian4.fromElements(encodedCenter.low.x, encodedCenter.low.y, encodedCenter.low.z, boundingSphere.radius, scratchUpdatePolylineCartesian4);\n\n            var nearFarCartesian = scratchNearFarCartesian2;\n            nearFarCartesian.x = 0.0;\n            nearFarCartesian.y = Number.MAX_VALUE;\n\n            var distanceDisplayCondition = polyline.distanceDisplayCondition;\n            if (defined(distanceDisplayCondition)) {\n                nearFarCartesian.x = distanceDisplayCondition.near;\n                nearFarCartesian.y = distanceDisplayCondition.far;\n            }\n\n            batchTable.setBatchedAttribute(polylineBatchIndex, 0, widthShowCartesian);\n            batchTable.setBatchedAttribute(polylineBatchIndex, 1, colorCartesian);\n\n            if (batchTable.attributes.length > 2) {\n                batchTable.setBatchedAttribute(polylineBatchIndex, 2, high);\n                batchTable.setBatchedAttribute(polylineBatchIndex, 3, low);\n                batchTable.setBatchedAttribute(polylineBatchIndex, 4, nearFarCartesian);\n            }\n        }\n    };\n\n    var morphPositionScratch = new Cartesian3();\n    var morphPrevPositionScratch = new Cartesian3();\n    var morphNextPositionScratch = new Cartesian3();\n    var morphVectorScratch = new Cartesian3();\n\n    PolylineBucket.prototype.writeForMorph = function(positionArray, positionIndex) {\n        var modelMatrix = this.modelMatrix;\n        var polylines = this.polylines;\n        var length = polylines.length;\n        for ( var i = 0; i < length; ++i) {\n            var polyline = polylines[i];\n            var positions = polyline._segments.positions;\n            var lengths = polyline._segments.lengths;\n            var positionsLength = positions.length;\n\n            var segmentIndex = 0;\n            var count = 0;\n\n            for ( var j = 0; j < positionsLength; ++j) {\n                var prevPosition;\n                if (j === 0) {\n                    if (polyline._loop) {\n                        prevPosition = positions[positionsLength - 2];\n                    } else {\n                        prevPosition = morphVectorScratch;\n                        Cartesian3.subtract(positions[0], positions[1], prevPosition);\n                        Cartesian3.add(positions[0], prevPosition, prevPosition);\n                    }\n                } else {\n                    prevPosition = positions[j - 1];\n                }\n\n                prevPosition = Matrix4.multiplyByPoint(modelMatrix, prevPosition, morphPrevPositionScratch);\n\n                var position = Matrix4.multiplyByPoint(modelMatrix, positions[j], morphPositionScratch);\n\n                var nextPosition;\n                if (j === positionsLength - 1) {\n                    if (polyline._loop) {\n                        nextPosition = positions[1];\n                    } else {\n                        nextPosition = morphVectorScratch;\n                        Cartesian3.subtract(positions[positionsLength - 1], positions[positionsLength - 2], nextPosition);\n                        Cartesian3.add(positions[positionsLength - 1], nextPosition, nextPosition);\n                    }\n                } else {\n                    nextPosition = positions[j + 1];\n                }\n\n                nextPosition = Matrix4.multiplyByPoint(modelMatrix, nextPosition, morphNextPositionScratch);\n\n                var segmentLength = lengths[segmentIndex];\n                if (j === count + segmentLength) {\n                    count += segmentLength;\n                    ++segmentIndex;\n                }\n\n                var segmentStart = j - count === 0;\n                var segmentEnd = j === count + lengths[segmentIndex] - 1;\n\n                var startK = (segmentStart) ? 2 : 0;\n                var endK = (segmentEnd) ? 2 : 4;\n\n                for (var k = startK; k < endK; ++k) {\n                    EncodedCartesian3.writeElements(position, positionArray, positionIndex);\n                    EncodedCartesian3.writeElements(prevPosition, positionArray, positionIndex + 6);\n                    EncodedCartesian3.writeElements(nextPosition, positionArray, positionIndex + 12);\n\n                    positionIndex += 6 * 3;\n                }\n            }\n        }\n    };\n\n    var scratchSegmentLengths = new Array(1);\n\n    PolylineBucket.prototype.updateIndices = function(totalIndices, vertexBufferOffset, vertexArrayBuckets, offset) {\n        var vaCount = vertexArrayBuckets.length - 1;\n        var bucketLocator = new VertexArrayBucketLocator(0, offset, this);\n        vertexArrayBuckets[vaCount].push(bucketLocator);\n        var count = 0;\n        var indices = totalIndices[totalIndices.length - 1];\n        var indicesCount = 0;\n        if (indices.length > 0) {\n            indicesCount = indices[indices.length - 1] + 1;\n        }\n        var polylines = this.polylines;\n        var length = polylines.length;\n        for ( var i = 0; i < length; ++i) {\n\n            var polyline = polylines[i];\n            polyline._locatorBuckets = [];\n\n            var segments;\n            if (this.mode === SceneMode.SCENE3D) {\n                segments = scratchSegmentLengths;\n                var positionsLength = polyline._actualPositions.length;\n                if (positionsLength > 0) {\n                    segments[0] = positionsLength;\n                } else {\n                    continue;\n                }\n            } else {\n                segments = polyline._segments.lengths;\n            }\n\n            var numberOfSegments = segments.length;\n            if (numberOfSegments > 0) {\n                var segmentIndexCount = 0;\n                for ( var j = 0; j < numberOfSegments; ++j) {\n                    var segmentLength = segments[j] - 1.0;\n                    for ( var k = 0; k < segmentLength; ++k) {\n                        if (indicesCount + 4 > CesiumMath.SIXTY_FOUR_KILOBYTES) {\n                            polyline._locatorBuckets.push({\n                                locator : bucketLocator,\n                                count : segmentIndexCount\n                            });\n                            segmentIndexCount = 0;\n                            vertexBufferOffset.push(4);\n                            indices = [];\n                            totalIndices.push(indices);\n                            indicesCount = 0;\n                            bucketLocator.count = count;\n                            count = 0;\n                            offset = 0;\n                            bucketLocator = new VertexArrayBucketLocator(0, 0, this);\n                            vertexArrayBuckets[++vaCount] = [bucketLocator];\n                        }\n\n                        indices.push(indicesCount, indicesCount + 2, indicesCount + 1);\n                        indices.push(indicesCount + 1, indicesCount + 2, indicesCount + 3);\n\n                        segmentIndexCount += 6;\n                        count += 6;\n                        offset += 6;\n                        indicesCount += 4;\n                    }\n                }\n\n                polyline._locatorBuckets.push({\n                    locator : bucketLocator,\n                    count : segmentIndexCount\n                });\n\n                if (indicesCount + 4 > CesiumMath.SIXTY_FOUR_KILOBYTES) {\n                    vertexBufferOffset.push(0);\n                    indices = [];\n                    totalIndices.push(indices);\n                    indicesCount = 0;\n                    bucketLocator.count = count;\n                    offset = 0;\n                    count = 0;\n                    bucketLocator = new VertexArrayBucketLocator(0, 0, this);\n                    vertexArrayBuckets[++vaCount] = [bucketLocator];\n                }\n            }\n            polyline._clean();\n        }\n        bucketLocator.count = count;\n        return offset;\n    };\n\n    PolylineBucket.prototype.getPolylineStartIndex = function(polyline) {\n        var polylines = this.polylines;\n        var positionIndex = 0;\n        var length = polylines.length;\n        for ( var i = 0; i < length; ++i) {\n            var p = polylines[i];\n            if (p === polyline) {\n                break;\n            }\n            positionIndex += p._actualLength;\n        }\n        return positionIndex;\n    };\n\n    var scratchSegments = {\n        positions : undefined,\n        lengths : undefined\n    };\n    var scratchLengths = new Array(1);\n    var pscratch = new Cartesian3();\n    var scratchCartographic = new Cartographic();\n\n    PolylineBucket.prototype.getSegments = function(polyline, projection) {\n        var positions = polyline._actualPositions;\n\n        if (this.mode === SceneMode.SCENE3D) {\n            scratchLengths[0] = positions.length;\n            scratchSegments.positions = positions;\n            scratchSegments.lengths = scratchLengths;\n            return scratchSegments;\n        }\n\n        if (intersectsIDL(polyline)) {\n            positions = polyline._segments.positions;\n        }\n\n        var ellipsoid = projection.ellipsoid;\n        var newPositions = [];\n        var modelMatrix = this.modelMatrix;\n        var length = positions.length;\n        var position;\n        var p = pscratch;\n\n        for ( var n = 0; n < length; ++n) {\n            position = positions[n];\n            p = Matrix4.multiplyByPoint(modelMatrix, position, p);\n            newPositions.push(projection.project(ellipsoid.cartesianToCartographic(p, scratchCartographic)));\n        }\n\n        if (newPositions.length > 0) {\n            polyline._boundingVolume2D = BoundingSphere.fromPoints(newPositions, polyline._boundingVolume2D);\n            var center2D = polyline._boundingVolume2D.center;\n            polyline._boundingVolume2D.center = new Cartesian3(center2D.z, center2D.x, center2D.y);\n        }\n\n        scratchSegments.positions = newPositions;\n        scratchSegments.lengths = polyline._segments.lengths;\n        return scratchSegments;\n    };\n\n    var scratchPositionsArray;\n\n    PolylineBucket.prototype.writeUpdate = function(index, polyline, positionBuffer, projection) {\n        var mode = this.mode;\n        var maxLon = projection.ellipsoid.maximumRadius * CesiumMath.PI;\n\n        var positionsLength = polyline._actualLength;\n        if (positionsLength) {\n            index += this.getPolylineStartIndex(polyline);\n\n            var positionArray = scratchPositionsArray;\n            var positionsArrayLength = 6 * positionsLength * 3;\n\n            if (!defined(positionArray) || positionArray.length < positionsArrayLength) {\n                positionArray = scratchPositionsArray = new Float32Array(positionsArrayLength);\n            } else if (positionArray.length > positionsArrayLength) {\n                positionArray = new Float32Array(positionArray.buffer, 0, positionsArrayLength);\n            }\n\n            var segments = this.getSegments(polyline, projection);\n            var positions = segments.positions;\n            var lengths = segments.lengths;\n\n            var positionIndex = 0;\n            var segmentIndex = 0;\n            var count = 0;\n            var position;\n\n            positionsLength = positions.length;\n            for ( var i = 0; i < positionsLength; ++i) {\n                if (i === 0) {\n                    if (polyline._loop) {\n                        position = positions[positionsLength - 2];\n                    } else {\n                        position = scratchWriteVector;\n                        Cartesian3.subtract(positions[0], positions[1], position);\n                        Cartesian3.add(positions[0], position, position);\n                    }\n                } else {\n                    position = positions[i - 1];\n                }\n\n                Cartesian3.clone(position, scratchWritePrevPosition);\n                Cartesian3.clone(positions[i], scratchWritePosition);\n\n                if (i === positionsLength - 1) {\n                    if (polyline._loop) {\n                        position = positions[1];\n                    } else {\n                        position = scratchWriteVector;\n                        Cartesian3.subtract(positions[positionsLength - 1], positions[positionsLength - 2], position);\n                        Cartesian3.add(positions[positionsLength - 1], position, position);\n                    }\n                } else {\n                    position = positions[i + 1];\n                }\n\n                Cartesian3.clone(position, scratchWriteNextPosition);\n\n                var segmentLength = lengths[segmentIndex];\n                if (i === count + segmentLength) {\n                    count += segmentLength;\n                    ++segmentIndex;\n                }\n\n                var segmentStart = i - count === 0;\n                var segmentEnd = i === count + lengths[segmentIndex] - 1;\n\n                if (mode === SceneMode.SCENE2D) {\n                    scratchWritePrevPosition.z = 0.0;\n                    scratchWritePosition.z = 0.0;\n                    scratchWriteNextPosition.z = 0.0;\n                }\n\n                if (mode === SceneMode.SCENE2D || mode === SceneMode.MORPHING) {\n                    if ((segmentStart || segmentEnd) && maxLon - Math.abs(scratchWritePosition.x) < 1.0) {\n                        if ((scratchWritePosition.x < 0.0 && scratchWritePrevPosition.x > 0.0) ||\n                            (scratchWritePosition.x > 0.0 && scratchWritePrevPosition.x < 0.0)) {\n                            Cartesian3.clone(scratchWritePosition, scratchWritePrevPosition);\n                        }\n\n                        if ((scratchWritePosition.x < 0.0 && scratchWriteNextPosition.x > 0.0) ||\n                            (scratchWritePosition.x > 0.0 && scratchWriteNextPosition.x < 0.0)) {\n                            Cartesian3.clone(scratchWritePosition, scratchWriteNextPosition);\n                        }\n                    }\n                }\n\n                var startJ = (segmentStart) ? 2 : 0;\n                var endJ = (segmentEnd) ? 2 : 4;\n\n                for (var j = startJ; j < endJ; ++j) {\n                    EncodedCartesian3.writeElements(scratchWritePosition, positionArray, positionIndex);\n                    EncodedCartesian3.writeElements(scratchWritePrevPosition, positionArray, positionIndex + 6);\n                    EncodedCartesian3.writeElements(scratchWriteNextPosition, positionArray, positionIndex + 12);\n                    positionIndex += 6 * 3;\n                }\n            }\n\n            positionBuffer.copyFromArrayView(positionArray, 6 * 3 * Float32Array.BYTES_PER_ELEMENT * index);\n        }\n    };\nexport default PolylineCollection;\n","//This file is automatically rebuilt by the Cesium build process.\nexport default \"attribute vec3 position3DHigh;\\n\\\nattribute vec3 position3DLow;\\n\\\nattribute vec3 position2DHigh;\\n\\\nattribute vec3 position2DLow;\\n\\\nattribute vec3 prevPosition3DHigh;\\n\\\nattribute vec3 prevPosition3DLow;\\n\\\nattribute vec3 prevPosition2DHigh;\\n\\\nattribute vec3 prevPosition2DLow;\\n\\\nattribute vec3 nextPosition3DHigh;\\n\\\nattribute vec3 nextPosition3DLow;\\n\\\nattribute vec3 nextPosition2DHigh;\\n\\\nattribute vec3 nextPosition2DLow;\\n\\\nattribute vec4 texCoordExpandAndBatchIndex;\\n\\\n\\n\\\nvarying vec2  v_st;\\n\\\nvarying float v_width;\\n\\\nvarying vec4 v_pickColor;\\n\\\nvarying float v_polylineAngle;\\n\\\n\\n\\\nvoid main()\\n\\\n{\\n\\\n    float texCoord = texCoordExpandAndBatchIndex.x;\\n\\\n    float expandDir = texCoordExpandAndBatchIndex.y;\\n\\\n    bool usePrev = texCoordExpandAndBatchIndex.z < 0.0;\\n\\\n    float batchTableIndex = texCoordExpandAndBatchIndex.w;\\n\\\n\\n\\\n    vec2 widthAndShow = batchTable_getWidthAndShow(batchTableIndex);\\n\\\n    float width = widthAndShow.x + 0.5;\\n\\\n    float show = widthAndShow.y;\\n\\\n\\n\\\n    if (width < 1.0)\\n\\\n    {\\n\\\n        show = 0.0;\\n\\\n    }\\n\\\n\\n\\\n    vec4 pickColor = batchTable_getPickColor(batchTableIndex);\\n\\\n\\n\\\n    vec4 p, prev, next;\\n\\\n    if (czm_morphTime == 1.0)\\n\\\n    {\\n\\\n        p = czm_translateRelativeToEye(position3DHigh.xyz, position3DLow.xyz);\\n\\\n        prev = czm_translateRelativeToEye(prevPosition3DHigh.xyz, prevPosition3DLow.xyz);\\n\\\n        next = czm_translateRelativeToEye(nextPosition3DHigh.xyz, nextPosition3DLow.xyz);\\n\\\n    }\\n\\\n    else if (czm_morphTime == 0.0)\\n\\\n    {\\n\\\n        p = czm_translateRelativeToEye(position2DHigh.zxy, position2DLow.zxy);\\n\\\n        prev = czm_translateRelativeToEye(prevPosition2DHigh.zxy, prevPosition2DLow.zxy);\\n\\\n        next = czm_translateRelativeToEye(nextPosition2DHigh.zxy, nextPosition2DLow.zxy);\\n\\\n    }\\n\\\n    else\\n\\\n    {\\n\\\n        p = czm_columbusViewMorph(\\n\\\n                czm_translateRelativeToEye(position2DHigh.zxy, position2DLow.zxy),\\n\\\n                czm_translateRelativeToEye(position3DHigh.xyz, position3DLow.xyz),\\n\\\n                czm_morphTime);\\n\\\n        prev = czm_columbusViewMorph(\\n\\\n                czm_translateRelativeToEye(prevPosition2DHigh.zxy, prevPosition2DLow.zxy),\\n\\\n                czm_translateRelativeToEye(prevPosition3DHigh.xyz, prevPosition3DLow.xyz),\\n\\\n                czm_morphTime);\\n\\\n        next = czm_columbusViewMorph(\\n\\\n                czm_translateRelativeToEye(nextPosition2DHigh.zxy, nextPosition2DLow.zxy),\\n\\\n                czm_translateRelativeToEye(nextPosition3DHigh.xyz, nextPosition3DLow.xyz),\\n\\\n                czm_morphTime);\\n\\\n    }\\n\\\n\\n\\\n    #ifdef DISTANCE_DISPLAY_CONDITION\\n\\\n        vec3 centerHigh = batchTable_getCenterHigh(batchTableIndex);\\n\\\n        vec4 centerLowAndRadius = batchTable_getCenterLowAndRadius(batchTableIndex);\\n\\\n        vec3 centerLow = centerLowAndRadius.xyz;\\n\\\n        float radius = centerLowAndRadius.w;\\n\\\n        vec2 distanceDisplayCondition = batchTable_getDistanceDisplayCondition(batchTableIndex);\\n\\\n\\n\\\n        float lengthSq;\\n\\\n        if (czm_sceneMode == czm_sceneMode2D)\\n\\\n        {\\n\\\n            lengthSq = czm_eyeHeight2D.y;\\n\\\n        }\\n\\\n        else\\n\\\n        {\\n\\\n            vec4 center = czm_translateRelativeToEye(centerHigh.xyz, centerLow.xyz);\\n\\\n            lengthSq = max(0.0, dot(center.xyz, center.xyz) - radius * radius);\\n\\\n        }\\n\\\n\\n\\\n        float nearSq = distanceDisplayCondition.x * distanceDisplayCondition.x;\\n\\\n        float farSq = distanceDisplayCondition.y * distanceDisplayCondition.y;\\n\\\n        if (lengthSq < nearSq || lengthSq > farSq)\\n\\\n        {\\n\\\n            show = 0.0;\\n\\\n        }\\n\\\n    #endif\\n\\\n\\n\\\n    vec4 positionWC = getPolylineWindowCoordinates(p, prev, next, expandDir, width, usePrev, v_polylineAngle);\\n\\\n    gl_Position = czm_viewportOrthographic * positionWC * show;\\n\\\n\\n\\\n    v_st = vec2(texCoord, clamp(expandDir, 0.0, 1.0));\\n\\\n    v_width = width;\\n\\\n    v_pickColor = pickColor;\\n\\\n\\n\\\n#ifdef LOG_DEPTH\\n\\\n    czm_vertexLogDepth(czm_modelViewProjectionRelativeToEye * p);\\n\\\n#endif\\n\\\n}\\n\\\n\";\n","import AssociativeArray from '../Core/AssociativeArray.js';\nimport Cartesian3 from '../Core/Cartesian3.js';\nimport defined from '../Core/defined.js';\nimport destroyObject from '../Core/destroyObject.js';\nimport DeveloperError from '../Core/DeveloperError.js';\nimport JulianDate from '../Core/JulianDate.js';\nimport Matrix3 from '../Core/Matrix3.js';\nimport Matrix4 from '../Core/Matrix4.js';\nimport ReferenceFrame from '../Core/ReferenceFrame.js';\nimport TimeInterval from '../Core/TimeInterval.js';\nimport Transforms from '../Core/Transforms.js';\nimport PolylineCollection from '../Scene/PolylineCollection.js';\nimport SceneMode from '../Scene/SceneMode.js';\nimport CompositePositionProperty from './CompositePositionProperty.js';\nimport ConstantPositionProperty from './ConstantPositionProperty.js';\nimport MaterialProperty from './MaterialProperty.js';\nimport Property from './Property.js';\nimport ReferenceProperty from './ReferenceProperty.js';\nimport SampledPositionProperty from './SampledPositionProperty.js';\nimport ScaledPositionProperty from './ScaledPositionProperty.js';\nimport TimeIntervalCollectionPositionProperty from './TimeIntervalCollectionPositionProperty.js';\n\n    var defaultResolution = 60.0;\n    var defaultWidth = 1.0;\n\n    var scratchTimeInterval = new TimeInterval();\n    var subSampleCompositePropertyScratch = new TimeInterval();\n    var subSampleIntervalPropertyScratch = new TimeInterval();\n\n    function EntityData(entity) {\n        this.entity = entity;\n        this.polyline = undefined;\n        this.index = undefined;\n        this.updater = undefined;\n    }\n\n    function subSampleSampledProperty(property, start, stop, times, updateTime, referenceFrame, maximumStep, startingIndex, result) {\n        var r = startingIndex;\n        //Always step exactly on start (but only use it if it exists.)\n        var tmp;\n        tmp = property.getValueInReferenceFrame(start, referenceFrame, result[r]);\n        if (defined(tmp)) {\n            result[r++] = tmp;\n        }\n\n        var steppedOnNow = !defined(updateTime) || JulianDate.lessThanOrEquals(updateTime, start) || JulianDate.greaterThanOrEquals(updateTime, stop);\n\n        //Iterate over all interval times and add the ones that fall in our\n        //time range.  Note that times can contain data outside of\n        //the intervals range.  This is by design for use with interpolation.\n        var t = 0;\n        var len = times.length;\n        var current = times[t];\n        var loopStop = stop;\n        var sampling = false;\n        var sampleStepsToTake;\n        var sampleStepsTaken;\n        var sampleStepSize;\n\n        while (t < len) {\n            if (!steppedOnNow && JulianDate.greaterThanOrEquals(current, updateTime)) {\n                tmp = property.getValueInReferenceFrame(updateTime, referenceFrame, result[r]);\n                if (defined(tmp)) {\n                    result[r++] = tmp;\n                }\n                steppedOnNow = true;\n            }\n            if (JulianDate.greaterThan(current, start) && JulianDate.lessThan(current, loopStop) && !current.equals(updateTime)) {\n                tmp = property.getValueInReferenceFrame(current, referenceFrame, result[r]);\n                if (defined(tmp)) {\n                    result[r++] = tmp;\n                }\n            }\n\n            if (t < (len - 1)) {\n                if (maximumStep > 0 && !sampling) {\n                    var next = times[t + 1];\n                    var secondsUntilNext = JulianDate.secondsDifference(next, current);\n                    sampling = secondsUntilNext > maximumStep;\n\n                    if (sampling) {\n                        sampleStepsToTake = Math.ceil(secondsUntilNext / maximumStep);\n                        sampleStepsTaken = 0;\n                        sampleStepSize = secondsUntilNext / Math.max(sampleStepsToTake, 2);\n                        sampleStepsToTake = Math.max(sampleStepsToTake - 1, 1);\n                    }\n                }\n\n                if (sampling && sampleStepsTaken < sampleStepsToTake) {\n                    current = JulianDate.addSeconds(current, sampleStepSize, new JulianDate());\n                    sampleStepsTaken++;\n                    continue;\n                }\n            }\n            sampling = false;\n            t++;\n            current = times[t];\n        }\n\n        //Always step exactly on stop (but only use it if it exists.)\n        tmp = property.getValueInReferenceFrame(stop, referenceFrame, result[r]);\n        if (defined(tmp)) {\n            result[r++] = tmp;\n        }\n\n        return r;\n    }\n\n    function subSampleGenericProperty(property, start, stop, updateTime, referenceFrame, maximumStep, startingIndex, result) {\n        var tmp;\n        var i = 0;\n        var index = startingIndex;\n        var time = start;\n        var stepSize = Math.max(maximumStep, 60);\n        var steppedOnNow = !defined(updateTime) || JulianDate.lessThanOrEquals(updateTime, start) || JulianDate.greaterThanOrEquals(updateTime, stop);\n        while (JulianDate.lessThan(time, stop)) {\n            if (!steppedOnNow && JulianDate.greaterThanOrEquals(time, updateTime)) {\n                steppedOnNow = true;\n                tmp = property.getValueInReferenceFrame(updateTime, referenceFrame, result[index]);\n                if (defined(tmp)) {\n                    result[index] = tmp;\n                    index++;\n                }\n            }\n            tmp = property.getValueInReferenceFrame(time, referenceFrame, result[index]);\n            if (defined(tmp)) {\n                result[index] = tmp;\n                index++;\n            }\n            i++;\n            time = JulianDate.addSeconds(start, stepSize * i, new JulianDate());\n        }\n        //Always sample stop.\n        tmp = property.getValueInReferenceFrame(stop, referenceFrame, result[index]);\n        if (defined(tmp)) {\n            result[index] = tmp;\n            index++;\n        }\n        return index;\n    }\n\n    function subSampleIntervalProperty(property, start, stop, updateTime, referenceFrame, maximumStep, startingIndex, result) {\n        subSampleIntervalPropertyScratch.start = start;\n        subSampleIntervalPropertyScratch.stop = stop;\n\n        var index = startingIndex;\n        var intervals = property.intervals;\n        for (var i = 0; i < intervals.length; i++) {\n            var interval = intervals.get(i);\n            if (!TimeInterval.intersect(interval, subSampleIntervalPropertyScratch, scratchTimeInterval).isEmpty) {\n                var time = interval.start;\n                if (!interval.isStartIncluded) {\n                    if (interval.isStopIncluded) {\n                        time = interval.stop;\n                    } else {\n                        time = JulianDate.addSeconds(interval.start, JulianDate.secondsDifference(interval.stop, interval.start) / 2, new JulianDate());\n                    }\n                }\n                var tmp = property.getValueInReferenceFrame(time, referenceFrame, result[index]);\n                if (defined(tmp)) {\n                    result[index] = tmp;\n                    index++;\n                }\n            }\n        }\n        return index;\n    }\n\n    function subSampleConstantProperty(property, start, stop, updateTime, referenceFrame, maximumStep, startingIndex, result) {\n        var tmp = property.getValueInReferenceFrame(start, referenceFrame, result[startingIndex]);\n        if (defined(tmp)) {\n            result[startingIndex++] = tmp;\n        }\n        return startingIndex;\n    }\n\n    function subSampleCompositeProperty(property, start, stop, updateTime, referenceFrame, maximumStep, startingIndex, result) {\n        subSampleCompositePropertyScratch.start = start;\n        subSampleCompositePropertyScratch.stop = stop;\n\n        var index = startingIndex;\n        var intervals = property.intervals;\n        for (var i = 0; i < intervals.length; i++) {\n            var interval = intervals.get(i);\n            if (!TimeInterval.intersect(interval, subSampleCompositePropertyScratch, scratchTimeInterval).isEmpty) {\n                var intervalStart = interval.start;\n                var intervalStop = interval.stop;\n\n                var sampleStart = start;\n                if (JulianDate.greaterThan(intervalStart, sampleStart)) {\n                    sampleStart = intervalStart;\n                }\n\n                var sampleStop = stop;\n                if (JulianDate.lessThan(intervalStop, sampleStop)) {\n                    sampleStop = intervalStop;\n                }\n\n                index = reallySubSample(interval.data, sampleStart, sampleStop, updateTime, referenceFrame, maximumStep, index, result);\n            }\n        }\n        return index;\n    }\n\n    function reallySubSample(property, start, stop, updateTime, referenceFrame, maximumStep, index, result) {\n        //Unwrap any references until we have the actual property.\n        while (property instanceof ReferenceProperty) {\n            property = property.resolvedProperty;\n        }\n\n        if (property instanceof SampledPositionProperty) {\n            var times = property._property._times;\n            index = subSampleSampledProperty(property, start, stop, times, updateTime, referenceFrame, maximumStep, index, result);\n        } else if (property instanceof CompositePositionProperty) {\n            index = subSampleCompositeProperty(property, start, stop, updateTime, referenceFrame, maximumStep, index, result);\n        } else if (property instanceof TimeIntervalCollectionPositionProperty) {\n            index = subSampleIntervalProperty(property, start, stop, updateTime, referenceFrame, maximumStep, index, result);\n        } else if (property instanceof ConstantPositionProperty ||\n                   (property instanceof ScaledPositionProperty && Property.isConstant(property))) {\n            index = subSampleConstantProperty(property, start, stop, updateTime, referenceFrame, maximumStep, index, result);\n        } else {\n            //Fallback to generic sampling.\n            index = subSampleGenericProperty(property, start, stop, updateTime, referenceFrame, maximumStep, index, result);\n        }\n        return index;\n    }\n\n    function subSample(property, start, stop, updateTime, referenceFrame, maximumStep, result) {\n        if (!defined(result)) {\n            result = [];\n        }\n\n        var length = reallySubSample(property, start, stop, updateTime, referenceFrame, maximumStep, 0, result);\n        result.length = length;\n        return result;\n    }\n\n    var toFixedScratch = new Matrix3();\n    function PolylineUpdater(scene, referenceFrame) {\n        this._unusedIndexes = [];\n        this._polylineCollection = new PolylineCollection();\n        this._scene = scene;\n        this._referenceFrame = referenceFrame;\n        scene.primitives.add(this._polylineCollection);\n    }\n\n    PolylineUpdater.prototype.update = function(time) {\n        if (this._referenceFrame === ReferenceFrame.INERTIAL) {\n            var toFixed = Transforms.computeIcrfToFixedMatrix(time, toFixedScratch);\n            if (!defined(toFixed)) {\n                toFixed = Transforms.computeTemeToPseudoFixedMatrix(time, toFixedScratch);\n            }\n            Matrix4.fromRotationTranslation(toFixed, Cartesian3.ZERO, this._polylineCollection.modelMatrix);\n        }\n    };\n\n    PolylineUpdater.prototype.updateObject = function(time, item) {\n        var entity = item.entity;\n        var pathGraphics = entity._path;\n        var positionProperty = entity._position;\n\n        var sampleStart;\n        var sampleStop;\n        var showProperty = pathGraphics._show;\n        var polyline = item.polyline;\n        var show = entity.isShowing && (!defined(showProperty) || showProperty.getValue(time));\n\n        //While we want to show the path, there may not actually be anything to show\n        //depending on lead/trail settings.  Compute the interval of the path to\n        //show and check against actual availability.\n        if (show) {\n            var leadTime = Property.getValueOrUndefined(pathGraphics._leadTime, time);\n            var trailTime = Property.getValueOrUndefined(pathGraphics._trailTime, time);\n            var availability = entity._availability;\n            var hasAvailability = defined(availability);\n            var hasLeadTime = defined(leadTime);\n            var hasTrailTime = defined(trailTime);\n\n            //Objects need to have either defined availability or both a lead and trail time in order to\n            //draw a path (since we can't draw \"infinite\" paths.\n            show = hasAvailability || (hasLeadTime && hasTrailTime);\n\n            //The final step is to compute the actual start/stop times of the path to show.\n            //If current time is outside of the availability interval, there's a chance that\n            //we won't have to draw anything anyway.\n            if (show) {\n                if (hasTrailTime) {\n                    sampleStart = JulianDate.addSeconds(time, -trailTime, new JulianDate());\n                }\n                if (hasLeadTime) {\n                    sampleStop = JulianDate.addSeconds(time, leadTime, new JulianDate());\n                }\n\n                if (hasAvailability) {\n                    var start = availability.start;\n                    var stop = availability.stop;\n\n                    if (!hasTrailTime || JulianDate.greaterThan(start, sampleStart)) {\n                        sampleStart = start;\n                    }\n\n                    if (!hasLeadTime || JulianDate.lessThan(stop, sampleStop)) {\n                        sampleStop = stop;\n                    }\n                }\n                show = JulianDate.lessThan(sampleStart, sampleStop);\n            }\n        }\n\n        if (!show) {\n            //don't bother creating or updating anything else\n            if (defined(polyline)) {\n                this._unusedIndexes.push(item.index);\n                item.polyline = undefined;\n                polyline.show = false;\n                item.index = undefined;\n            }\n            return;\n        }\n\n        if (!defined(polyline)) {\n            var unusedIndexes = this._unusedIndexes;\n            var length = unusedIndexes.length;\n            if (length > 0) {\n                var index = unusedIndexes.pop();\n                polyline = this._polylineCollection.get(index);\n                item.index = index;\n            } else {\n                item.index = this._polylineCollection.length;\n                polyline = this._polylineCollection.add();\n            }\n            polyline.id = entity;\n            item.polyline = polyline;\n        }\n\n        var resolution = Property.getValueOrDefault(pathGraphics._resolution, time, defaultResolution);\n\n        polyline.show = true;\n        polyline.positions = subSample(positionProperty, sampleStart, sampleStop, time, this._referenceFrame, resolution, polyline.positions.slice());\n        polyline.material = MaterialProperty.getValue(time, pathGraphics._material, polyline.material);\n        polyline.width = Property.getValueOrDefault(pathGraphics._width, time, defaultWidth);\n        polyline.distanceDisplayCondition = Property.getValueOrUndefined(pathGraphics._distanceDisplayCondition, time, polyline.distanceDisplayCondition);\n    };\n\n    PolylineUpdater.prototype.removeObject = function(item) {\n        var polyline = item.polyline;\n        if (defined(polyline)) {\n            this._unusedIndexes.push(item.index);\n            item.polyline = undefined;\n            polyline.show = false;\n            polyline.id = undefined;\n            item.index = undefined;\n        }\n    };\n\n    PolylineUpdater.prototype.destroy = function() {\n        this._scene.primitives.remove(this._polylineCollection);\n        return destroyObject(this);\n    };\n\n    /**\n     * A {@link Visualizer} which maps {@link Entity#path} to a {@link Polyline}.\n     * @alias PathVisualizer\n     * @constructor\n     *\n     * @param {Scene} scene The scene the primitives will be rendered in.\n     * @param {EntityCollection} entityCollection The entityCollection to visualize.\n     */\n    function PathVisualizer(scene, entityCollection) {\n        \n\n        entityCollection.collectionChanged.addEventListener(PathVisualizer.prototype._onCollectionChanged, this);\n\n        this._scene = scene;\n        this._updaters = {};\n        this._entityCollection = entityCollection;\n        this._items = new AssociativeArray();\n\n        this._onCollectionChanged(entityCollection, entityCollection.values, [], []);\n    }\n\n    /**\n     * Updates all of the primitives created by this visualizer to match their\n     * Entity counterpart at the given time.\n     *\n     * @param {JulianDate} time The time to update to.\n     * @returns {Boolean} This function always returns true.\n     */\n    PathVisualizer.prototype.update = function(time) {\n        \n\n        var updaters = this._updaters;\n        for (var key in updaters) {\n            if (updaters.hasOwnProperty(key)) {\n                updaters[key].update(time);\n            }\n        }\n\n        var items = this._items.values;\n        if (items.length === 0 && defined(this._updaters) && Object.keys(this._updaters).length > 0) {\n            for (var u in updaters) {\n                if (updaters.hasOwnProperty(u)) {\n                    updaters[u].destroy();\n                }\n            }\n            this._updaters = {};\n        }\n\n        for (var i = 0, len = items.length; i < len; i++) {\n            var item = items[i];\n            var entity = item.entity;\n            var positionProperty = entity._position;\n\n            var lastUpdater = item.updater;\n\n            var frameToVisualize = ReferenceFrame.FIXED;\n            if (this._scene.mode === SceneMode.SCENE3D) {\n                frameToVisualize = positionProperty.referenceFrame;\n            }\n\n            var currentUpdater = this._updaters[frameToVisualize];\n\n            if ((lastUpdater === currentUpdater) && (defined(currentUpdater))) {\n                currentUpdater.updateObject(time, item);\n                continue;\n            }\n\n            if (defined(lastUpdater)) {\n                lastUpdater.removeObject(item);\n            }\n\n            if (!defined(currentUpdater)) {\n                currentUpdater = new PolylineUpdater(this._scene, frameToVisualize);\n                currentUpdater.update(time);\n                this._updaters[frameToVisualize] = currentUpdater;\n            }\n\n            item.updater = currentUpdater;\n            if (defined(currentUpdater)) {\n                currentUpdater.updateObject(time, item);\n            }\n        }\n        return true;\n    };\n\n    /**\n     * Returns true if this object was destroyed; otherwise, false.\n     *\n     * @returns {Boolean} True if this object was destroyed; otherwise, false.\n     */\n    PathVisualizer.prototype.isDestroyed = function() {\n        return false;\n    };\n\n    /**\n     * Removes and destroys all primitives created by this instance.\n     */\n    PathVisualizer.prototype.destroy = function() {\n        this._entityCollection.collectionChanged.removeEventListener(PathVisualizer.prototype._onCollectionChanged, this);\n\n        var updaters = this._updaters;\n        for ( var key in updaters) {\n            if (updaters.hasOwnProperty(key)) {\n                updaters[key].destroy();\n            }\n        }\n\n        return destroyObject(this);\n    };\n\n    PathVisualizer.prototype._onCollectionChanged = function(entityCollection, added, removed, changed) {\n        var i;\n        var entity;\n        var item;\n        var items = this._items;\n\n        for (i = added.length - 1; i > -1; i--) {\n            entity = added[i];\n            if (defined(entity._path) && defined(entity._position)) {\n                items.set(entity.id, new EntityData(entity));\n            }\n        }\n\n        for (i = changed.length - 1; i > -1; i--) {\n            entity = changed[i];\n            if (defined(entity._path) && defined(entity._position)) {\n                if (!items.contains(entity.id)) {\n                    items.set(entity.id, new EntityData(entity));\n                }\n            } else {\n                item = items.get(entity.id);\n                if (defined(item)) {\n                    if (defined(item.updater)) {\n                        item.updater.removeObject(item);\n                    }\n                    items.remove(entity.id);\n                }\n            }\n        }\n\n        for (i = removed.length - 1; i > -1; i--) {\n            entity = removed[i];\n            item = items.get(entity.id);\n            if (defined(item)) {\n                if (defined(item.updater)) {\n                    item.updater.removeObject(item);\n                }\n                items.remove(entity.id);\n            }\n        }\n    };\n\n    //for testing\n    PathVisualizer._subSample = subSample;\nexport default PathVisualizer;\n","\n    /**\n     * Creates a {@link createBillboardPointCallback~CanvasFunction} that will create a canvas with a point.\n     *\n     * @param {Number} centerAlpha The alpha of the center of the point. The value must be in the range [0.0, 1.0].\n     * @param {String} cssColor The CSS color string.\n     * @param {String} cssOutlineColor The CSS color of the point outline.\n     * @param {Number} cssOutlineWidth The width of the outline in pixels.\n     * @param {Number} pixelSize The size of the point in pixels.\n     * @return {createBillboardPointCallback~CanvasFunction} The function that will return a canvas with the point drawn on it.\n     *\n     * @private\n     */\n    function createBillboardPointCallback(centerAlpha, cssColor, cssOutlineColor, cssOutlineWidth, pixelSize) {\n        return function() {\n            var canvas = document.createElement('canvas');\n\n            var length = pixelSize + (2 * cssOutlineWidth);\n            canvas.height = canvas.width = length;\n\n            var context2D = canvas.getContext('2d');\n            context2D.clearRect(0, 0, length, length);\n\n            if (cssOutlineWidth !== 0) {\n                context2D.beginPath();\n                context2D.arc(length / 2, length / 2, length / 2, 0, 2 * Math.PI, true);\n                context2D.closePath();\n                context2D.fillStyle = cssOutlineColor;\n                context2D.fill();\n                // Punch a hole in the center if needed.\n                if (centerAlpha < 1.0) {\n                    context2D.save();\n                    context2D.globalCompositeOperation = 'destination-out';\n                    context2D.beginPath();\n                    context2D.arc(length / 2, length / 2, pixelSize / 2, 0, 2 * Math.PI, true);\n                    context2D.closePath();\n                    context2D.fillStyle = 'black';\n                    context2D.fill();\n                    context2D.restore();\n                }\n            }\n\n            context2D.beginPath();\n            context2D.arc(length / 2, length / 2, pixelSize / 2, 0, 2 * Math.PI, true);\n            context2D.closePath();\n            context2D.fillStyle = cssColor;\n            context2D.fill();\n\n            return canvas;\n        };\n    }\n\n    /**\n     * A function that returns a canvas containing an image of a point.\n     * @callback createBillboardPointCallback~CanvasFunction\n     * @returns {HTMLCanvasElement} The result of the calculation.\n     */\nexport default createBillboardPointCallback;\n","import AssociativeArray from '../Core/AssociativeArray.js';\nimport Cartesian3 from '../Core/Cartesian3.js';\nimport Color from '../Core/Color.js';\nimport defined from '../Core/defined.js';\nimport destroyObject from '../Core/destroyObject.js';\nimport DeveloperError from '../Core/DeveloperError.js';\nimport DistanceDisplayCondition from '../Core/DistanceDisplayCondition.js';\nimport NearFarScalar from '../Core/NearFarScalar.js';\nimport createBillboardPointCallback from '../Scene/createBillboardPointCallback.js';\nimport HeightReference from '../Scene/HeightReference.js';\nimport BoundingSphereState from './BoundingSphereState.js';\nimport Property from './Property.js';\n\n    var defaultColor = Color.WHITE;\n    var defaultOutlineColor = Color.BLACK;\n    var defaultOutlineWidth = 0.0;\n    var defaultPixelSize = 1.0;\n    var defaultDisableDepthTestDistance = 0.0;\n\n    var colorScratch = new Color();\n    var positionScratch = new Cartesian3();\n    var outlineColorScratch = new Color();\n    var scaleByDistanceScratch = new NearFarScalar();\n    var translucencyByDistanceScratch = new NearFarScalar();\n    var distanceDisplayConditionScratch = new DistanceDisplayCondition();\n\n    function EntityData(entity) {\n        this.entity = entity;\n        this.pointPrimitive = undefined;\n        this.billboard = undefined;\n        this.color = undefined;\n        this.outlineColor = undefined;\n        this.pixelSize = undefined;\n        this.outlineWidth = undefined;\n    }\n\n    /**\n     * A {@link Visualizer} which maps {@link Entity#point} to a {@link PointPrimitive}.\n     * @alias PointVisualizer\n     * @constructor\n     *\n     * @param {EntityCluster} entityCluster The entity cluster to manage the collection of billboards and optionally cluster with other entities.\n     * @param {EntityCollection} entityCollection The entityCollection to visualize.\n     */\n    function PointVisualizer(entityCluster, entityCollection) {\n        \n\n        entityCollection.collectionChanged.addEventListener(PointVisualizer.prototype._onCollectionChanged, this);\n\n        this._cluster = entityCluster;\n        this._entityCollection = entityCollection;\n        this._items = new AssociativeArray();\n        this._onCollectionChanged(entityCollection, entityCollection.values, [], []);\n    }\n\n    /**\n     * Updates the primitives created by this visualizer to match their\n     * Entity counterpart at the given time.\n     *\n     * @param {JulianDate} time The time to update to.\n     * @returns {Boolean} This function always returns true.\n     */\n    PointVisualizer.prototype.update = function(time) {\n        \n\n        var items = this._items.values;\n        var cluster = this._cluster;\n        for (var i = 0, len = items.length; i < len; i++) {\n            var item = items[i];\n            var entity = item.entity;\n            var pointGraphics = entity._point;\n            var pointPrimitive = item.pointPrimitive;\n            var billboard = item.billboard;\n            var heightReference = Property.getValueOrDefault(pointGraphics._heightReference, time, HeightReference.NONE);\n            var show = entity.isShowing && entity.isAvailable(time) && Property.getValueOrDefault(pointGraphics._show, time, true);\n            var position;\n            if (show) {\n                position = Property.getValueOrUndefined(entity._position, time, positionScratch);\n                show = defined(position);\n            }\n            if (!show) {\n                returnPrimitive(item, entity, cluster);\n                continue;\n            }\n\n            if (!Property.isConstant(entity._position)) {\n                cluster._clusterDirty = true;\n            }\n\n            var needsRedraw = false;\n            var updateClamping = false;\n            if ((heightReference !== HeightReference.NONE) && !defined(billboard)) {\n                if (defined(pointPrimitive)) {\n                    returnPrimitive(item, entity, cluster);\n                    pointPrimitive = undefined;\n                }\n\n                billboard = cluster.getBillboard(entity);\n                billboard.id = entity;\n                billboard.image = undefined;\n                item.billboard = billboard;\n                needsRedraw = true;\n\n                // If this new billboard happens to have a position and height reference that match our new values,\n                // billboard._updateClamping will not be called automatically. That's a problem because the clamped\n                // height may be based on different terrain than is now loaded. So we'll manually call\n                // _updateClamping below.\n                updateClamping = Cartesian3.equals(billboard.position, position) && billboard.heightReference === heightReference;\n            } else if ((heightReference === HeightReference.NONE) && !defined(pointPrimitive)) {\n                if (defined(billboard)) {\n                    returnPrimitive(item, entity, cluster);\n                    billboard = undefined;\n                }\n\n                pointPrimitive = cluster.getPoint(entity);\n                pointPrimitive.id = entity;\n                item.pointPrimitive = pointPrimitive;\n            }\n\n            if (defined(pointPrimitive)) {\n                pointPrimitive.show = true;\n                pointPrimitive.position = position;\n                pointPrimitive.scaleByDistance = Property.getValueOrUndefined(pointGraphics._scaleByDistance, time, scaleByDistanceScratch);\n                pointPrimitive.translucencyByDistance = Property.getValueOrUndefined(pointGraphics._translucencyByDistance, time, translucencyByDistanceScratch);\n                pointPrimitive.color = Property.getValueOrDefault(pointGraphics._color, time, defaultColor, colorScratch);\n                pointPrimitive.outlineColor = Property.getValueOrDefault(pointGraphics._outlineColor, time, defaultOutlineColor, outlineColorScratch);\n                pointPrimitive.outlineWidth = Property.getValueOrDefault(pointGraphics._outlineWidth, time, defaultOutlineWidth);\n                pointPrimitive.pixelSize = Property.getValueOrDefault(pointGraphics._pixelSize, time, defaultPixelSize);\n                pointPrimitive.distanceDisplayCondition = Property.getValueOrUndefined(pointGraphics._distanceDisplayCondition, time, distanceDisplayConditionScratch);\n                pointPrimitive.disableDepthTestDistance = Property.getValueOrDefault(pointGraphics._disableDepthTestDistance, time, defaultDisableDepthTestDistance);\n            } else if (defined(billboard)) {\n                billboard.show = true;\n                billboard.position = position;\n                billboard.scaleByDistance = Property.getValueOrUndefined(pointGraphics._scaleByDistance, time, scaleByDistanceScratch);\n                billboard.translucencyByDistance = Property.getValueOrUndefined(pointGraphics._translucencyByDistance, time, translucencyByDistanceScratch);\n                billboard.distanceDisplayCondition = Property.getValueOrUndefined(pointGraphics._distanceDisplayCondition, time, distanceDisplayConditionScratch);\n                billboard.disableDepthTestDistance = Property.getValueOrDefault(pointGraphics._disableDepthTestDistance, time, defaultDisableDepthTestDistance);\n                billboard.heightReference = heightReference;\n\n                var newColor = Property.getValueOrDefault(pointGraphics._color, time, defaultColor, colorScratch);\n                var newOutlineColor = Property.getValueOrDefault(pointGraphics._outlineColor, time, defaultOutlineColor, outlineColorScratch);\n                var newOutlineWidth = Math.round(Property.getValueOrDefault(pointGraphics._outlineWidth, time, defaultOutlineWidth));\n                var newPixelSize = Math.max(1, Math.round(Property.getValueOrDefault(pointGraphics._pixelSize, time, defaultPixelSize)));\n\n                if (newOutlineWidth > 0) {\n                    billboard.scale = 1.0;\n                    needsRedraw = needsRedraw || //\n                                 newOutlineWidth !== item.outlineWidth || //\n                                 newPixelSize !== item.pixelSize || //\n                                 !Color.equals(newColor, item.color) || //\n                                 !Color.equals(newOutlineColor, item.outlineColor);\n                } else {\n                    billboard.scale = newPixelSize / 50.0;\n                    newPixelSize = 50.0;\n                    needsRedraw = needsRedraw || //\n                                 newOutlineWidth !== item.outlineWidth || //\n                                 !Color.equals(newColor, item.color) || //\n                                 !Color.equals(newOutlineColor, item.outlineColor);\n                }\n\n                if (needsRedraw) {\n                    item.color = Color.clone(newColor, item.color);\n                    item.outlineColor = Color.clone(newOutlineColor, item.outlineColor);\n                    item.pixelSize = newPixelSize;\n                    item.outlineWidth = newOutlineWidth;\n\n                    var centerAlpha = newColor.alpha;\n                    var cssColor = newColor.toCssColorString();\n                    var cssOutlineColor = newOutlineColor.toCssColorString();\n                    var textureId = JSON.stringify([cssColor, newPixelSize, cssOutlineColor, newOutlineWidth]);\n\n                    billboard.setImage(textureId, createBillboardPointCallback(centerAlpha, cssColor, cssOutlineColor, newOutlineWidth, newPixelSize));\n                }\n\n                if (updateClamping) {\n                    billboard._updateClamping();\n                }\n            }\n        }\n        return true;\n    };\n\n    /**\n     * Computes a bounding sphere which encloses the visualization produced for the specified entity.\n     * The bounding sphere is in the fixed frame of the scene's globe.\n     *\n     * @param {Entity} entity The entity whose bounding sphere to compute.\n     * @param {BoundingSphere} result The bounding sphere onto which to store the result.\n     * @returns {BoundingSphereState} BoundingSphereState.DONE if the result contains the bounding sphere,\n     *                       BoundingSphereState.PENDING if the result is still being computed, or\n     *                       BoundingSphereState.FAILED if the entity has no visualization in the current scene.\n     * @private\n     */\n    PointVisualizer.prototype.getBoundingSphere = function(entity, result) {\n        \n\n        var item = this._items.get(entity.id);\n        if (!defined(item) || !(defined(item.pointPrimitive) || defined(item.billboard))) {\n            return BoundingSphereState.FAILED;\n        }\n\n        if (defined(item.pointPrimitive)) {\n            result.center = Cartesian3.clone(item.pointPrimitive.position, result.center);\n        } else {\n            var billboard = item.billboard;\n            if (!defined(billboard._clampedPosition)) {\n                return BoundingSphereState.PENDING;\n            }\n            result.center = Cartesian3.clone(billboard._clampedPosition, result.center);\n        }\n\n        result.radius = 0;\n        return BoundingSphereState.DONE;\n    };\n\n    /**\n     * Returns true if this object was destroyed; otherwise, false.\n     *\n     * @returns {Boolean} True if this object was destroyed; otherwise, false.\n     */\n    PointVisualizer.prototype.isDestroyed = function() {\n        return false;\n    };\n\n    /**\n     * Removes and destroys all primitives created by this instance.\n     */\n    PointVisualizer.prototype.destroy = function() {\n        this._entityCollection.collectionChanged.removeEventListener(PointVisualizer.prototype._onCollectionChanged, this);\n        var entities = this._entityCollection.values;\n        for (var i = 0; i < entities.length; i++) {\n            this._cluster.removePoint(entities[i]);\n        }\n        return destroyObject(this);\n    };\n\n    PointVisualizer.prototype._onCollectionChanged = function(entityCollection, added, removed, changed) {\n        var i;\n        var entity;\n        var items = this._items;\n        var cluster = this._cluster;\n\n        for (i = added.length - 1; i > -1; i--) {\n            entity = added[i];\n            if (defined(entity._point) && defined(entity._position)) {\n                items.set(entity.id, new EntityData(entity));\n            }\n        }\n\n        for (i = changed.length - 1; i > -1; i--) {\n            entity = changed[i];\n            if (defined(entity._point) && defined(entity._position)) {\n                if (!items.contains(entity.id)) {\n                    items.set(entity.id, new EntityData(entity));\n                }\n            } else {\n                returnPrimitive(items.get(entity.id), entity, cluster);\n                items.remove(entity.id);\n            }\n        }\n\n        for (i = removed.length - 1; i > -1; i--) {\n            entity = removed[i];\n            returnPrimitive(items.get(entity.id), entity, cluster);\n            items.remove(entity.id);\n        }\n    };\n\n    function returnPrimitive(item, entity, cluster) {\n        if (defined(item)) {\n            var pointPrimitive = item.pointPrimitive;\n            if (defined(pointPrimitive)) {\n                item.pointPrimitive = undefined;\n                cluster.removePoint(entity);\n                return;\n            }\n            var billboard = item.billboard;\n            if (defined(billboard)) {\n                item.billboard = undefined;\n                cluster.removeBillboard(entity);\n            }\n        }\n    }\nexport default PointVisualizer;\n","import ArcType from './ArcType.js';\nimport arrayRemoveDuplicates from './arrayRemoveDuplicates.js';\nimport BoundingSphere from './BoundingSphere.js';\nimport Cartesian3 from './Cartesian3.js';\nimport Color from './Color.js';\nimport ComponentDatatype from './ComponentDatatype.js';\nimport defaultValue from './defaultValue.js';\nimport defined from './defined.js';\nimport DeveloperError from './DeveloperError.js';\nimport Ellipsoid from './Ellipsoid.js';\nimport Geometry from './Geometry.js';\nimport GeometryAttribute from './GeometryAttribute.js';\nimport GeometryAttributes from './GeometryAttributes.js';\nimport GeometryType from './GeometryType.js';\nimport IndexDatatype from './IndexDatatype.js';\nimport CesiumMath from './Math.js';\nimport PolylinePipeline from './PolylinePipeline.js';\nimport PrimitiveType from './PrimitiveType.js';\nimport VertexFormat from './VertexFormat.js';\n\n    var scratchInterpolateColorsArray = [];\n\n    function interpolateColors(p0, p1, color0, color1, numPoints) {\n        var colors = scratchInterpolateColorsArray;\n        colors.length = numPoints;\n        var i;\n\n        var r0 = color0.red;\n        var g0 = color0.green;\n        var b0 = color0.blue;\n        var a0 = color0.alpha;\n\n        var r1 = color1.red;\n        var g1 = color1.green;\n        var b1 = color1.blue;\n        var a1 = color1.alpha;\n\n        if (Color.equals(color0, color1)) {\n            for (i = 0; i < numPoints; i++) {\n                colors[i] = Color.clone(color0);\n            }\n            return colors;\n        }\n\n        var redPerVertex = (r1 - r0) / numPoints;\n        var greenPerVertex = (g1 - g0) / numPoints;\n        var bluePerVertex = (b1 - b0) / numPoints;\n        var alphaPerVertex = (a1 - a0) / numPoints;\n\n        for (i = 0; i < numPoints; i++) {\n            colors[i] = new Color(r0 + i * redPerVertex, g0 + i * greenPerVertex, b0 + i * bluePerVertex, a0 + i * alphaPerVertex);\n        }\n\n        return colors;\n    }\n\n    /**\n     * A description of a polyline modeled as a line strip; the first two positions define a line segment,\n     * and each additional position defines a line segment from the previous position. The polyline is capable of\n     * displaying with a material.\n     *\n     * @alias PolylineGeometry\n     * @constructor\n     *\n     * @param {Object} options Object with the following properties:\n     * @param {Cartesian3[]} options.positions An array of {@link Cartesian3} defining the positions in the polyline as a line strip.\n     * @param {Number} [options.width=1.0] The width in pixels.\n     * @param {Color[]} [options.colors] An Array of {@link Color} defining the per vertex or per segment colors.\n     * @param {Boolean} [options.colorsPerVertex=false] A boolean that determines whether the colors will be flat across each segment of the line or interpolated across the vertices.\n     * @param {ArcType} [options.arcType=ArcType.GEODESIC] The type of line the polyline segments must follow.\n     * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude if options.arcType is not ArcType.NONE. Determines the number of positions in the buffer.\n     * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\n     * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid to be used as a reference.\n     *\n     * @exception {DeveloperError} At least two positions are required.\n     * @exception {DeveloperError} width must be greater than or equal to one.\n     * @exception {DeveloperError} colors has an invalid length.\n     *\n     * @see PolylineGeometry#createGeometry\n     *\n     * @demo {@link https://sandcastle.cesium.com/index.html?src=Polyline.html|Cesium Sandcastle Polyline Demo}\n     *\n     * @example\n     * // A polyline with two connected line segments\n     * var polyline = new Cesium.PolylineGeometry({\n     *   positions : Cesium.Cartesian3.fromDegreesArray([\n     *     0.0, 0.0,\n     *     5.0, 0.0,\n     *     5.0, 5.0\n     *   ]),\n     *   width : 10.0\n     * });\n     * var geometry = Cesium.PolylineGeometry.createGeometry(polyline);\n     */\n    function PolylineGeometry(options) {\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n        var positions = options.positions;\n        var colors = options.colors;\n        var width = defaultValue(options.width, 1.0);\n        var colorsPerVertex = defaultValue(options.colorsPerVertex, false);\n\n        \n\n        this._positions = positions;\n        this._colors = colors;\n        this._width = width;\n        this._colorsPerVertex = colorsPerVertex;\n        this._vertexFormat = VertexFormat.clone(defaultValue(options.vertexFormat, VertexFormat.DEFAULT));\n\n        this._arcType = defaultValue(options.arcType, ArcType.GEODESIC);\n        this._granularity = defaultValue(options.granularity, CesiumMath.RADIANS_PER_DEGREE);\n        this._ellipsoid = Ellipsoid.clone(defaultValue(options.ellipsoid, Ellipsoid.WGS84));\n        this._workerName = 'createPolylineGeometry';\n\n        var numComponents = 1 + positions.length * Cartesian3.packedLength;\n        numComponents += defined(colors) ? 1 + colors.length * Color.packedLength : 1;\n\n        /**\n         * The number of elements used to pack the object into an array.\n         * @type {Number}\n         */\n        this.packedLength = numComponents + Ellipsoid.packedLength + VertexFormat.packedLength + 4;\n    }\n\n    /**\n     * Stores the provided instance into the provided array.\n     *\n     * @param {PolylineGeometry} value The value to pack.\n     * @param {Number[]} array The array to pack into.\n     * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n     *\n     * @returns {Number[]} The array that was packed into\n     */\n    PolylineGeometry.pack = function(value, array, startingIndex) {\n        \n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        var i;\n\n        var positions = value._positions;\n        var length = positions.length;\n        array[startingIndex++] = length;\n\n        for (i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {\n            Cartesian3.pack(positions[i], array, startingIndex);\n        }\n\n        var colors = value._colors;\n        length = defined(colors) ? colors.length : 0.0;\n        array[startingIndex++] = length;\n\n        for (i = 0; i < length; ++i, startingIndex += Color.packedLength) {\n            Color.pack(colors[i], array, startingIndex);\n        }\n\n        Ellipsoid.pack(value._ellipsoid, array, startingIndex);\n        startingIndex += Ellipsoid.packedLength;\n\n        VertexFormat.pack(value._vertexFormat, array, startingIndex);\n        startingIndex += VertexFormat.packedLength;\n\n        array[startingIndex++] = value._width;\n        array[startingIndex++] = value._colorsPerVertex ? 1.0 : 0.0;\n        array[startingIndex++] = value._arcType;\n        array[startingIndex]   = value._granularity;\n\n        return array;\n    };\n\n    var scratchEllipsoid = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);\n    var scratchVertexFormat = new VertexFormat();\n    var scratchOptions = {\n        positions : undefined,\n        colors : undefined,\n        ellipsoid : scratchEllipsoid,\n        vertexFormat : scratchVertexFormat,\n        width : undefined,\n        colorsPerVertex : undefined,\n        arcType : undefined,\n        granularity : undefined\n    };\n\n    /**\n     * Retrieves an instance from a packed array.\n     *\n     * @param {Number[]} array The packed array.\n     * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n     * @param {PolylineGeometry} [result] The object into which to store the result.\n     * @returns {PolylineGeometry} The modified result parameter or a new PolylineGeometry instance if one was not provided.\n     */\n    PolylineGeometry.unpack = function(array, startingIndex, result) {\n        \n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        var i;\n\n        var length = array[startingIndex++];\n        var positions = new Array(length);\n\n        for (i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {\n            positions[i] = Cartesian3.unpack(array, startingIndex);\n        }\n\n        length = array[startingIndex++];\n        var colors = length > 0 ? new Array(length) : undefined;\n\n        for (i = 0; i < length; ++i, startingIndex += Color.packedLength) {\n            colors[i] = Color.unpack(array, startingIndex);\n        }\n\n        var ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);\n        startingIndex += Ellipsoid.packedLength;\n\n        var vertexFormat = VertexFormat.unpack(array, startingIndex, scratchVertexFormat);\n        startingIndex += VertexFormat.packedLength;\n\n        var width = array[startingIndex++];\n        var colorsPerVertex = array[startingIndex++] === 1.0;\n        var arcType = array[startingIndex++];\n        var granularity = array[startingIndex];\n\n        if (!defined(result)) {\n            scratchOptions.positions = positions;\n            scratchOptions.colors = colors;\n            scratchOptions.width = width;\n            scratchOptions.colorsPerVertex = colorsPerVertex;\n            scratchOptions.arcType = arcType;\n            scratchOptions.granularity = granularity;\n            return new PolylineGeometry(scratchOptions);\n        }\n\n        result._positions = positions;\n        result._colors = colors;\n        result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);\n        result._vertexFormat = VertexFormat.clone(vertexFormat, result._vertexFormat);\n        result._width = width;\n        result._colorsPerVertex = colorsPerVertex;\n        result._arcType = arcType;\n        result._granularity = granularity;\n\n        return result;\n    };\n\n    var scratchCartesian3 = new Cartesian3();\n    var scratchPosition = new Cartesian3();\n    var scratchPrevPosition = new Cartesian3();\n    var scratchNextPosition = new Cartesian3();\n\n    /**\n     * Computes the geometric representation of a polyline, including its vertices, indices, and a bounding sphere.\n     *\n     * @param {PolylineGeometry} polylineGeometry A description of the polyline.\n     * @returns {Geometry|undefined} The computed vertices and indices.\n     */\n    PolylineGeometry.createGeometry = function(polylineGeometry) {\n        var width = polylineGeometry._width;\n        var vertexFormat = polylineGeometry._vertexFormat;\n        var colors = polylineGeometry._colors;\n        var colorsPerVertex = polylineGeometry._colorsPerVertex;\n        var arcType = polylineGeometry._arcType;\n        var granularity = polylineGeometry._granularity;\n        var ellipsoid = polylineGeometry._ellipsoid;\n\n        var i;\n        var j;\n        var k;\n\n        var positions = arrayRemoveDuplicates(polylineGeometry._positions, Cartesian3.equalsEpsilon);\n        var positionsLength = positions.length;\n\n        // A width of a pixel or less is not a valid geometry, but in order to support external data\n        // that may have errors we treat this as an empty geometry.\n        if (positionsLength < 2 || width <= 0.0) {\n            return undefined;\n        }\n\n        if (arcType === ArcType.GEODESIC || arcType === ArcType.RHUMB) {\n            var subdivisionSize;\n            var numberOfPointsFunction;\n            if (arcType === ArcType.GEODESIC) {\n                subdivisionSize = CesiumMath.chordLength(granularity, ellipsoid.maximumRadius);\n                numberOfPointsFunction = PolylinePipeline.numberOfPoints;\n            } else {\n                subdivisionSize = granularity;\n                numberOfPointsFunction = PolylinePipeline.numberOfPointsRhumbLine;\n            }\n\n            var heights = PolylinePipeline.extractHeights(positions, ellipsoid);\n\n            if (defined(colors)) {\n                var colorLength = 1;\n                for (i = 0; i < positionsLength - 1; ++i) {\n                    colorLength += numberOfPointsFunction(positions[i], positions[i + 1], subdivisionSize);\n                }\n\n                var newColors = new Array(colorLength);\n                var newColorIndex = 0;\n\n                for (i = 0; i < positionsLength - 1; ++i) {\n                    var p0 = positions[i];\n                    var p1 = positions[i + 1];\n                    var c0 = colors[i];\n\n                    var numColors = numberOfPointsFunction(p0, p1, subdivisionSize);\n                    if (colorsPerVertex && i < colorLength) {\n                        var c1 = colors[i + 1];\n                        var interpolatedColors = interpolateColors(p0, p1, c0, c1, numColors);\n                        var interpolatedColorsLength = interpolatedColors.length;\n                        for (j = 0; j < interpolatedColorsLength; ++j) {\n                            newColors[newColorIndex++] = interpolatedColors[j];\n                        }\n                    } else {\n                        for (j = 0; j < numColors; ++j) {\n                            newColors[newColorIndex++] = Color.clone(c0);\n                        }\n                    }\n                }\n\n                newColors[newColorIndex] = Color.clone(colors[colors.length - 1]);\n                colors = newColors;\n\n                scratchInterpolateColorsArray.length = 0;\n            }\n\n            if (arcType === ArcType.GEODESIC) {\n                positions = PolylinePipeline.generateCartesianArc({\n                    positions: positions,\n                    minDistance: subdivisionSize,\n                    ellipsoid: ellipsoid,\n                    height: heights\n                });\n            } else {\n                positions = PolylinePipeline.generateCartesianRhumbArc({\n                    positions: positions,\n                    granularity: subdivisionSize,\n                    ellipsoid: ellipsoid,\n                    height: heights\n                });\n            }\n        }\n\n        positionsLength = positions.length;\n        var size = positionsLength * 4.0 - 4.0;\n\n        var finalPositions = new Float64Array(size * 3);\n        var prevPositions = new Float64Array(size * 3);\n        var nextPositions = new Float64Array(size * 3);\n        var expandAndWidth = new Float32Array(size * 2);\n        var st = vertexFormat.st ? new Float32Array(size * 2) : undefined;\n        var finalColors = defined(colors) ? new Uint8Array(size * 4) : undefined;\n\n        var positionIndex = 0;\n        var expandAndWidthIndex = 0;\n        var stIndex = 0;\n        var colorIndex = 0;\n        var position;\n\n        for (j = 0; j < positionsLength; ++j) {\n            if (j === 0) {\n                position = scratchCartesian3;\n                Cartesian3.subtract(positions[0], positions[1], position);\n                Cartesian3.add(positions[0], position, position);\n            } else {\n                position = positions[j - 1];\n            }\n\n            Cartesian3.clone(position, scratchPrevPosition);\n            Cartesian3.clone(positions[j], scratchPosition);\n\n            if (j === positionsLength - 1) {\n                position = scratchCartesian3;\n                Cartesian3.subtract(positions[positionsLength - 1], positions[positionsLength - 2], position);\n                Cartesian3.add(positions[positionsLength - 1], position, position);\n            } else {\n                position = positions[j + 1];\n            }\n\n            Cartesian3.clone(position, scratchNextPosition);\n\n            var color0, color1;\n            if (defined(finalColors)) {\n                if (j !== 0 && !colorsPerVertex) {\n                    color0 = colors[j - 1];\n                } else {\n                    color0 = colors[j];\n                }\n\n                if (j !== positionsLength - 1) {\n                    color1 = colors[j];\n                }\n            }\n\n            var startK = j === 0 ? 2 : 0;\n            var endK = j === positionsLength - 1 ? 2 : 4;\n\n            for (k = startK; k < endK; ++k) {\n                Cartesian3.pack(scratchPosition, finalPositions, positionIndex);\n                Cartesian3.pack(scratchPrevPosition, prevPositions, positionIndex);\n                Cartesian3.pack(scratchNextPosition, nextPositions, positionIndex);\n                positionIndex += 3;\n\n                var direction = (k - 2 < 0) ? -1.0 : 1.0;\n                expandAndWidth[expandAndWidthIndex++] = 2 * (k % 2) - 1;       // expand direction\n                expandAndWidth[expandAndWidthIndex++] = direction * width;\n\n                if (vertexFormat.st) {\n                    st[stIndex++] = j / (positionsLength - 1);\n                    st[stIndex++] = Math.max(expandAndWidth[expandAndWidthIndex - 2], 0.0);\n                }\n\n                if (defined(finalColors)) {\n                    var color = (k < 2) ? color0 : color1;\n\n                    finalColors[colorIndex++] = Color.floatToByte(color.red);\n                    finalColors[colorIndex++] = Color.floatToByte(color.green);\n                    finalColors[colorIndex++] = Color.floatToByte(color.blue);\n                    finalColors[colorIndex++] = Color.floatToByte(color.alpha);\n                }\n            }\n        }\n\n        var attributes = new GeometryAttributes();\n\n        attributes.position = new GeometryAttribute({\n            componentDatatype : ComponentDatatype.DOUBLE,\n            componentsPerAttribute : 3,\n            values : finalPositions\n        });\n\n        attributes.prevPosition = new GeometryAttribute({\n            componentDatatype : ComponentDatatype.DOUBLE,\n            componentsPerAttribute : 3,\n            values : prevPositions\n        });\n\n        attributes.nextPosition = new GeometryAttribute({\n            componentDatatype : ComponentDatatype.DOUBLE,\n            componentsPerAttribute : 3,\n            values : nextPositions\n        });\n\n        attributes.expandAndWidth = new GeometryAttribute({\n            componentDatatype : ComponentDatatype.FLOAT,\n            componentsPerAttribute : 2,\n            values : expandAndWidth\n        });\n\n        if (vertexFormat.st) {\n            attributes.st = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.FLOAT,\n                componentsPerAttribute : 2,\n                values : st\n            });\n        }\n\n        if (defined(finalColors)) {\n            attributes.color = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.UNSIGNED_BYTE,\n                componentsPerAttribute : 4,\n                values : finalColors,\n                normalize : true\n            });\n        }\n\n        var indices = IndexDatatype.createTypedArray(size, positionsLength * 6 - 6);\n        var index = 0;\n        var indicesIndex = 0;\n        var length = positionsLength - 1.0;\n        for (j = 0; j < length; ++j) {\n            indices[indicesIndex++] = index;\n            indices[indicesIndex++] = index + 2;\n            indices[indicesIndex++] = index + 1;\n\n            indices[indicesIndex++] = index + 1;\n            indices[indicesIndex++] = index + 2;\n            indices[indicesIndex++] = index + 3;\n\n            index += 4;\n        }\n\n        return new Geometry({\n            attributes : attributes,\n            indices : indices,\n            primitiveType : PrimitiveType.TRIANGLES,\n            boundingSphere : BoundingSphere.fromPoints(positions),\n            geometryType : GeometryType.POLYLINES\n        });\n    };\nexport default PolylineGeometry;\n","import ArcType from '../Core/ArcType.js';\nimport BoundingSphere from '../Core/BoundingSphere.js';\nimport Check from '../Core/Check.js';\nimport Color from '../Core/Color.js';\nimport ColorGeometryInstanceAttribute from '../Core/ColorGeometryInstanceAttribute.js';\nimport defaultValue from '../Core/defaultValue.js';\nimport defined from '../Core/defined.js';\nimport defineProperties from '../Core/defineProperties.js';\nimport destroyObject from '../Core/destroyObject.js';\nimport DeveloperError from '../Core/DeveloperError.js';\nimport DistanceDisplayCondition from '../Core/DistanceDisplayCondition.js';\nimport DistanceDisplayConditionGeometryInstanceAttribute from '../Core/DistanceDisplayConditionGeometryInstanceAttribute.js';\nimport Event from '../Core/Event.js';\nimport GeometryInstance from '../Core/GeometryInstance.js';\nimport GroundPolylineGeometry from '../Core/GroundPolylineGeometry.js';\nimport Iso8601 from '../Core/Iso8601.js';\nimport oneTimeWarning from '../Core/oneTimeWarning.js';\nimport PolylineGeometry from '../Core/PolylineGeometry.js';\nimport PolylinePipeline from '../Core/PolylinePipeline.js';\nimport ShowGeometryInstanceAttribute from '../Core/ShowGeometryInstanceAttribute.js';\nimport Entity from '../DataSources/Entity.js';\nimport ClassificationType from '../Scene/ClassificationType.js';\nimport GroundPolylinePrimitive from '../Scene/GroundPolylinePrimitive.js';\nimport PolylineCollection from '../Scene/PolylineCollection.js';\nimport PolylineColorAppearance from '../Scene/PolylineColorAppearance.js';\nimport PolylineMaterialAppearance from '../Scene/PolylineMaterialAppearance.js';\nimport ShadowMode from '../Scene/ShadowMode.js';\nimport BoundingSphereState from './BoundingSphereState.js';\nimport ColorMaterialProperty from './ColorMaterialProperty.js';\nimport ConstantProperty from './ConstantProperty.js';\nimport MaterialProperty from './MaterialProperty.js';\nimport Property from './Property.js';\n\n    var defaultZIndex = new ConstantProperty(0);\n\n    //We use this object to create one polyline collection per-scene.\n    var polylineCollections = {};\n\n    var scratchColor = new Color();\n    var defaultMaterial = new ColorMaterialProperty(Color.WHITE);\n    var defaultShow = new ConstantProperty(true);\n    var defaultShadows = new ConstantProperty(ShadowMode.DISABLED);\n    var defaultDistanceDisplayCondition = new ConstantProperty(new DistanceDisplayCondition());\n    var defaultClassificationType = new ConstantProperty(ClassificationType.BOTH);\n\n    function GeometryOptions() {\n        this.vertexFormat = undefined;\n        this.positions = undefined;\n        this.width = undefined;\n        this.arcType = undefined;\n        this.granularity = undefined;\n    }\n\n    function GroundGeometryOptions() {\n        this.positions = undefined;\n        this.width = undefined;\n        this.arcType = undefined;\n        this.granularity = undefined;\n    }\n\n    /**\n     * A {@link GeometryUpdater} for polylines.\n     * Clients do not normally create this class directly, but instead rely on {@link DataSourceDisplay}.\n     * @alias PolylineGeometryUpdater\n     * @constructor\n     *\n     * @param {Entity} entity The entity containing the geometry to be visualized.\n     * @param {Scene} scene The scene where visualization is taking place.\n     */\n    function PolylineGeometryUpdater(entity, scene) {\n        \n\n        this._entity = entity;\n        this._scene = scene;\n        this._entitySubscription = entity.definitionChanged.addEventListener(PolylineGeometryUpdater.prototype._onEntityPropertyChanged, this);\n        this._fillEnabled = false;\n        this._dynamic = false;\n        this._geometryChanged = new Event();\n        this._showProperty = undefined;\n        this._materialProperty = undefined;\n        this._shadowsProperty = undefined;\n        this._distanceDisplayConditionProperty = undefined;\n        this._classificationTypeProperty = undefined;\n        this._depthFailMaterialProperty = undefined;\n        this._geometryOptions = new GeometryOptions();\n        this._groundGeometryOptions = new GroundGeometryOptions();\n        this._id = 'polyline-' + entity.id;\n        this._clampToGround = false;\n        this._supportsPolylinesOnTerrain = Entity.supportsPolylinesOnTerrain(scene);\n\n        this._zIndex = 0;\n\n        this._onEntityPropertyChanged(entity, 'polyline', entity.polyline, undefined);\n    }\n\n    defineProperties(PolylineGeometryUpdater.prototype, {\n        /**\n         * Gets the unique ID associated with this updater\n         * @memberof PolylineGeometryUpdater.prototype\n         * @type {String}\n         * @readonly\n         */\n        id: {\n            get: function() {\n                return this._id;\n            }\n        },\n        /**\n         * Gets the entity associated with this geometry.\n         * @memberof PolylineGeometryUpdater.prototype\n         *\n         * @type {Entity}\n         * @readonly\n         */\n        entity : {\n            get : function() {\n                return this._entity;\n            }\n        },\n        /**\n         * Gets a value indicating if the geometry has a fill component.\n         * @memberof PolylineGeometryUpdater.prototype\n         *\n         * @type {Boolean}\n         * @readonly\n         */\n        fillEnabled : {\n            get : function() {\n                return this._fillEnabled;\n            }\n        },\n        /**\n         * Gets a value indicating if fill visibility varies with simulation time.\n         * @memberof PolylineGeometryUpdater.prototype\n         *\n         * @type {Boolean}\n         * @readonly\n         */\n        hasConstantFill : {\n            get : function() {\n                return !this._fillEnabled || (!defined(this._entity.availability) && Property.isConstant(this._showProperty));\n            }\n        },\n        /**\n         * Gets the material property used to fill the geometry.\n         * @memberof PolylineGeometryUpdater.prototype\n         *\n         * @type {MaterialProperty}\n         * @readonly\n         */\n        fillMaterialProperty : {\n            get : function() {\n                return this._materialProperty;\n            }\n        },\n        /**\n         * Gets the material property used to fill the geometry when it fails the depth test.\n         * @memberof PolylineGeometryUpdater.prototype\n         *\n         * @type {MaterialProperty}\n         * @readonly\n         */\n        depthFailMaterialProperty : {\n            get : function() {\n                return this._depthFailMaterialProperty;\n            }\n        },\n        /**\n         * Gets a value indicating if the geometry has an outline component.\n         * @memberof PolylineGeometryUpdater.prototype\n         *\n         * @type {Boolean}\n         * @readonly\n         */\n        outlineEnabled : {\n            value : false\n        },\n        /**\n         * Gets a value indicating if outline visibility varies with simulation time.\n         * @memberof PolylineGeometryUpdater.prototype\n         *\n         * @type {Boolean}\n         * @readonly\n         */\n        hasConstantOutline : {\n            value : true\n        },\n        /**\n         * Gets the {@link Color} property for the geometry outline.\n         * @memberof PolylineGeometryUpdater.prototype\n         *\n         * @type {Property}\n         * @readonly\n         */\n        outlineColorProperty : {\n            value : undefined\n        },\n        /**\n         * Gets the property specifying whether the geometry\n         * casts or receives shadows from light sources.\n         * @memberof PolylineGeometryUpdater.prototype\n         *\n         * @type {Property}\n         * @readonly\n         */\n        shadowsProperty : {\n            get : function() {\n                return this._shadowsProperty;\n            }\n        },\n        /**\n         * Gets or sets the {@link DistanceDisplayCondition} Property specifying at what distance from the camera that this geometry will be displayed.\n         * @memberof PolylineGeometryUpdater.prototype\n         *\n         * @type {Property}\n         * @readonly\n         */\n        distanceDisplayConditionProperty : {\n            get : function() {\n                return this._distanceDisplayConditionProperty;\n            }\n        },\n        /**\n         * Gets or sets the {@link ClassificationType} Property specifying if this geometry will classify terrain, 3D Tiles, or both when on the ground.\n         * @memberof PolylineGeometryUpdater.prototype\n         *\n         * @type {Property}\n         * @readonly\n         */\n        classificationTypeProperty : {\n            get : function() {\n                return this._classificationTypeProperty;\n            }\n        },\n        /**\n         * Gets a value indicating if the geometry is time-varying.\n         * If true, all visualization is delegated to the {@link DynamicGeometryUpdater}\n         * returned by GeometryUpdater#createDynamicUpdater.\n         * @memberof PolylineGeometryUpdater.prototype\n         *\n         * @type {Boolean}\n         * @readonly\n         */\n        isDynamic : {\n            get : function() {\n                return this._dynamic;\n            }\n        },\n        /**\n         * Gets a value indicating if the geometry is closed.\n         * This property is only valid for static geometry.\n         * @memberof PolylineGeometryUpdater.prototype\n         *\n         * @type {Boolean}\n         * @readonly\n         */\n        isClosed : {\n            value : false\n        },\n        /**\n         * Gets an event that is raised whenever the public properties\n         * of this updater change.\n         * @memberof PolylineGeometryUpdater.prototype\n         *\n         * @type {Boolean}\n         * @readonly\n         */\n        geometryChanged : {\n            get : function() {\n                return this._geometryChanged;\n            }\n        },\n\n        /**\n         * Gets a value indicating if the path of the line.\n         * @memberof PolylineGeometryUpdater.prototype\n         *\n         * @type {ArcType}\n         * @readonly\n         */\n        arcType : {\n            get : function() {\n                return this._arcType;\n            }\n        },\n\n        /**\n         * Gets a value indicating if the geometry is clamped to the ground.\n         * Returns false if polylines on terrain is not supported.\n         * @memberof PolylineGeometryUpdater.prototype\n         *\n         * @type {Boolean}\n         * @readonly\n         */\n        clampToGround : {\n            get : function() {\n                return this._clampToGround && this._supportsPolylinesOnTerrain;\n            }\n        },\n\n        /**\n         * Gets the zindex\n         * @type {Number}\n         * @memberof PolylineGeometryUpdater.prototype\n         * @readonly\n         */\n        zIndex: {\n            get: function() {\n                return this._zIndex;\n            }\n        }\n    });\n\n    /**\n     * Checks if the geometry is outlined at the provided time.\n     *\n     * @param {JulianDate} time The time for which to retrieve visibility.\n     * @returns {Boolean} true if geometry is outlined at the provided time, false otherwise.\n     */\n    PolylineGeometryUpdater.prototype.isOutlineVisible = function(time) {\n        return false;\n    };\n\n    /**\n     * Checks if the geometry is filled at the provided time.\n     *\n     * @param {JulianDate} time The time for which to retrieve visibility.\n     * @returns {Boolean} true if geometry is filled at the provided time, false otherwise.\n     */\n    PolylineGeometryUpdater.prototype.isFilled = function(time) {\n        var entity = this._entity;\n        var visible = this._fillEnabled && entity.isAvailable(time) && this._showProperty.getValue(time);\n        return defaultValue(visible, false);\n    };\n\n    /**\n     * Creates the geometry instance which represents the fill of the geometry.\n     *\n     * @param {JulianDate} time The time to use when retrieving initial attribute values.\n     * @returns {GeometryInstance} The geometry instance representing the filled portion of the geometry.\n     *\n     * @exception {DeveloperError} This instance does not represent a filled geometry.\n     */\n    PolylineGeometryUpdater.prototype.createFillGeometryInstance = function(time) {\n        \n\n        var entity = this._entity;\n        var isAvailable = entity.isAvailable(time);\n        var show = new ShowGeometryInstanceAttribute(isAvailable && entity.isShowing && this._showProperty.getValue(time));\n        var distanceDisplayCondition = this._distanceDisplayConditionProperty.getValue(time);\n        var distanceDisplayConditionAttribute = DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(distanceDisplayCondition);\n\n        var attributes = {\n            show : show,\n            distanceDisplayCondition : distanceDisplayConditionAttribute\n        };\n\n        var currentColor;\n        if (this._materialProperty instanceof ColorMaterialProperty) {\n            if (defined(this._materialProperty.color) && (this._materialProperty.color.isConstant || isAvailable)) {\n                currentColor = this._materialProperty.color.getValue(time, scratchColor);\n            }\n            if (!defined(currentColor)) {\n                currentColor = Color.WHITE;\n            }\n            attributes.color = ColorGeometryInstanceAttribute.fromColor(currentColor);\n        }\n\n        if (this.clampToGround) {\n            return new GeometryInstance({\n                id : entity,\n                geometry : new GroundPolylineGeometry(this._groundGeometryOptions),\n                attributes : attributes\n            });\n        }\n\n        if (defined(this._depthFailMaterialProperty) && this._depthFailMaterialProperty instanceof ColorMaterialProperty) {\n            if (defined(this._depthFailMaterialProperty.color) && (this._depthFailMaterialProperty.color.isConstant || isAvailable)) {\n                currentColor = this._depthFailMaterialProperty.color.getValue(time, scratchColor);\n            }\n            if (!defined(currentColor)) {\n                currentColor = Color.WHITE;\n            }\n            attributes.depthFailColor = ColorGeometryInstanceAttribute.fromColor(currentColor);\n        }\n\n        return new GeometryInstance({\n            id : entity,\n            geometry : new PolylineGeometry(this._geometryOptions),\n            attributes : attributes\n        });\n    };\n\n    /**\n     * Creates the geometry instance which represents the outline of the geometry.\n     *\n     * @param {JulianDate} time The time to use when retrieving initial attribute values.\n     * @returns {GeometryInstance} The geometry instance representing the outline portion of the geometry.\n     *\n     * @exception {DeveloperError} This instance does not represent an outlined geometry.\n     */\n    PolylineGeometryUpdater.prototype.createOutlineGeometryInstance = function(time) {\n        \n    };\n\n    /**\n     * Returns true if this object was destroyed; otherwise, false.\n     *\n     * @returns {Boolean} True if this object was destroyed; otherwise, false.\n     */\n    PolylineGeometryUpdater.prototype.isDestroyed = function() {\n        return false;\n    };\n\n    /**\n     * Destroys and resources used by the object.  Once an object is destroyed, it should not be used.\n     *\n     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n     */\n    PolylineGeometryUpdater.prototype.destroy = function() {\n        this._entitySubscription();\n        destroyObject(this);\n    };\n\n    PolylineGeometryUpdater.prototype._onEntityPropertyChanged = function(entity, propertyName, newValue, oldValue) {\n        if (!(propertyName === 'availability' || propertyName === 'polyline')) {\n            return;\n        }\n\n        var polyline = this._entity.polyline;\n\n        if (!defined(polyline)) {\n            if (this._fillEnabled) {\n                this._fillEnabled = false;\n                this._geometryChanged.raiseEvent(this);\n            }\n            return;\n        }\n\n        var positionsProperty = polyline.positions;\n\n        var show = polyline.show;\n        if ((defined(show) && show.isConstant && !show.getValue(Iso8601.MINIMUM_VALUE)) || //\n            (!defined(positionsProperty))) {\n            if (this._fillEnabled) {\n                this._fillEnabled = false;\n                this._geometryChanged.raiseEvent(this);\n            }\n            return;\n        }\n\n        var zIndex = polyline.zIndex;\n        var material = defaultValue(polyline.material, defaultMaterial);\n        var isColorMaterial = material instanceof ColorMaterialProperty;\n        this._materialProperty = material;\n        this._depthFailMaterialProperty = polyline.depthFailMaterial;\n        this._showProperty = defaultValue(show, defaultShow);\n        this._shadowsProperty = defaultValue(polyline.shadows, defaultShadows);\n        this._distanceDisplayConditionProperty = defaultValue(polyline.distanceDisplayCondition, defaultDistanceDisplayCondition);\n        this._classificationTypeProperty = defaultValue(polyline.classificationType, defaultClassificationType);\n        this._fillEnabled = true;\n        this._zIndex = defaultValue(zIndex, defaultZIndex);\n\n        var width = polyline.width;\n        var arcType = polyline.arcType;\n        var clampToGround = polyline.clampToGround;\n        var granularity = polyline.granularity;\n\n        if (!positionsProperty.isConstant || !Property.isConstant(width) ||\n            !Property.isConstant(arcType) || !Property.isConstant(granularity) ||\n            !Property.isConstant(clampToGround) || !Property.isConstant(zIndex)) {\n            if (!this._dynamic) {\n                this._dynamic = true;\n                this._geometryChanged.raiseEvent(this);\n            }\n        } else {\n            var geometryOptions = this._geometryOptions;\n            var positions = positionsProperty.getValue(Iso8601.MINIMUM_VALUE, geometryOptions.positions);\n\n            //Because of the way we currently handle reference properties,\n            //we can't automatically assume the positions are always valid.\n            if (!defined(positions) || positions.length < 2) {\n                if (this._fillEnabled) {\n                    this._fillEnabled = false;\n                    this._geometryChanged.raiseEvent(this);\n                }\n                return;\n            }\n\n            var vertexFormat;\n            if (isColorMaterial && (!defined(this._depthFailMaterialProperty) || this._depthFailMaterialProperty instanceof ColorMaterialProperty)) {\n                vertexFormat = PolylineColorAppearance.VERTEX_FORMAT;\n            } else {\n                vertexFormat = PolylineMaterialAppearance.VERTEX_FORMAT;\n            }\n\n            geometryOptions.vertexFormat = vertexFormat;\n            geometryOptions.positions = positions;\n            geometryOptions.width = defined(width) ? width.getValue(Iso8601.MINIMUM_VALUE) : undefined;\n            geometryOptions.arcType = defined(arcType) ? arcType.getValue(Iso8601.MINIMUM_VALUE) : undefined;\n            geometryOptions.granularity = defined(granularity) ? granularity.getValue(Iso8601.MINIMUM_VALUE) : undefined;\n\n            var groundGeometryOptions = this._groundGeometryOptions;\n            groundGeometryOptions.positions = positions;\n            groundGeometryOptions.width = geometryOptions.width;\n            groundGeometryOptions.arcType = geometryOptions.arcType;\n            groundGeometryOptions.granularity = geometryOptions.granularity;\n\n            this._clampToGround = defined(clampToGround) ? clampToGround.getValue(Iso8601.MINIMUM_VALUE) : false;\n\n            if (!this._clampToGround && defined(zIndex)) {\n                oneTimeWarning('Entity polylines must have clampToGround: true when using zIndex.  zIndex will be ignored.');\n            }\n\n            this._dynamic = false;\n            this._geometryChanged.raiseEvent(this);\n        }\n    };\n\n    /**\n     * Creates the dynamic updater to be used when GeometryUpdater#isDynamic is true.\n     *\n     * @param {PrimitiveCollection} primitives The primitive collection to use.\n     * @param {PrimitiveCollection|OrderedGroundPrimitiveCollection} groundPrimitives The primitive collection to use for ordered ground primitives.\n     * @returns {DynamicGeometryUpdater} The dynamic updater used to update the geometry each frame.\n     *\n     * @exception {DeveloperError} This instance does not represent dynamic geometry.\n     */\n    PolylineGeometryUpdater.prototype.createDynamicUpdater = function(primitives, groundPrimitives) {\n        \n\n        return new DynamicGeometryUpdater(primitives, groundPrimitives, this);\n    };\n\n    /**\n     * @private\n     */\n    var generateCartesianArcOptions = {\n        positions : undefined,\n        granularity : undefined,\n        height : undefined,\n        ellipsoid : undefined\n    };\n\n    function DynamicGeometryUpdater(primitives, groundPrimitives, geometryUpdater) {\n        this._line = undefined;\n        this._primitives = primitives;\n        this._groundPrimitives = groundPrimitives;\n        this._groundPolylinePrimitive = undefined;\n        this._material = undefined;\n        this._geometryUpdater = geometryUpdater;\n        this._positions = [];\n    }\n\n    function getLine(dynamicGeometryUpdater) {\n        if (defined(dynamicGeometryUpdater._line)) {\n            return dynamicGeometryUpdater._line;\n        }\n\n        var sceneId = dynamicGeometryUpdater._geometryUpdater._scene.id;\n        var polylineCollection = polylineCollections[sceneId];\n        var primitives = dynamicGeometryUpdater._primitives;\n        if (!defined(polylineCollection) || polylineCollection.isDestroyed()) {\n            polylineCollection = new PolylineCollection();\n            polylineCollections[sceneId] = polylineCollection;\n            primitives.add(polylineCollection);\n        } else if (!primitives.contains(polylineCollection)) {\n            primitives.add(polylineCollection);\n        }\n\n        var line = polylineCollection.add();\n        line.id = dynamicGeometryUpdater._geometryUpdater._entity;\n        dynamicGeometryUpdater._line = line;\n        return line;\n    }\n\n    DynamicGeometryUpdater.prototype.update = function(time) {\n        var geometryUpdater = this._geometryUpdater;\n        var entity = geometryUpdater._entity;\n        var polyline = entity.polyline;\n\n        var positionsProperty = polyline.positions;\n        var positions = Property.getValueOrUndefined(positionsProperty, time, this._positions);\n\n        // Synchronize with geometryUpdater for GroundPolylinePrimitive\n        geometryUpdater._clampToGround = Property.getValueOrDefault(polyline._clampToGround, time, false);\n        geometryUpdater._groundGeometryOptions.positions = positions;\n        geometryUpdater._groundGeometryOptions.width = Property.getValueOrDefault(polyline._width, time, 1);\n        geometryUpdater._groundGeometryOptions.arcType = Property.getValueOrDefault(polyline._arcType, time, ArcType.GEODESIC);\n        geometryUpdater._groundGeometryOptions.granularity = Property.getValueOrDefault(polyline._granularity, time, 9999);\n\n        var groundPrimitives = this._groundPrimitives;\n\n        if (defined(this._groundPolylinePrimitive)) {\n            groundPrimitives.remove(this._groundPolylinePrimitive); // destroys by default\n            this._groundPolylinePrimitive = undefined;\n        }\n\n        if (geometryUpdater.clampToGround) {\n            if (!entity.isShowing || !entity.isAvailable(time) || !Property.getValueOrDefault(polyline._show, time, true)) {\n                return;\n            }\n\n            if (!defined(positions) || positions.length < 2) {\n                return;\n            }\n\n            var fillMaterialProperty = geometryUpdater.fillMaterialProperty;\n            var appearance;\n            if (fillMaterialProperty instanceof ColorMaterialProperty) {\n                appearance = new PolylineColorAppearance();\n            } else {\n                var material = MaterialProperty.getValue(time, fillMaterialProperty, this._material);\n                appearance = new PolylineMaterialAppearance({\n                    material : material,\n                    translucent : material.isTranslucent()\n                });\n                this._material = material;\n            }\n\n            this._groundPolylinePrimitive = groundPrimitives.add(new GroundPolylinePrimitive({\n                geometryInstances : geometryUpdater.createFillGeometryInstance(time),\n                appearance : appearance,\n                classificationType : geometryUpdater.classificationTypeProperty.getValue(time),\n                asynchronous : false\n            }), Property.getValueOrUndefined(geometryUpdater.zIndex, time));\n\n            // Hide the polyline in the collection, if any\n            if (defined(this._line)) {\n                this._line.show = false;\n            }\n            return;\n        }\n\n        var line = getLine(this);\n\n        if (!entity.isShowing || !entity.isAvailable(time) || !Property.getValueOrDefault(polyline._show, time, true)) {\n            line.show = false;\n            return;\n        }\n\n        if (!defined(positions) || positions.length < 2) {\n            line.show = false;\n            return;\n        }\n\n        var arcType = ArcType.GEODESIC;\n        arcType = Property.getValueOrDefault(polyline._arcType, time, arcType);\n\n        var globe = geometryUpdater._scene.globe;\n        if (arcType !== ArcType.NONE && defined(globe)) {\n            generateCartesianArcOptions.ellipsoid = globe.ellipsoid;\n            generateCartesianArcOptions.positions = positions;\n            generateCartesianArcOptions.granularity = Property.getValueOrUndefined(polyline._granularity, time);\n            generateCartesianArcOptions.height = PolylinePipeline.extractHeights(positions, globe.ellipsoid);\n            if (arcType === ArcType.GEODESIC) {\n                positions = PolylinePipeline.generateCartesianArc(generateCartesianArcOptions);\n            } else {\n                positions = PolylinePipeline.generateCartesianRhumbArc(generateCartesianArcOptions);\n            }\n        }\n\n        line.show = true;\n        line.positions = positions.slice();\n        line.material = MaterialProperty.getValue(time, geometryUpdater.fillMaterialProperty, line.material);\n        line.width = Property.getValueOrDefault(polyline._width, time, 1);\n        line.distanceDisplayCondition = Property.getValueOrUndefined(polyline._distanceDisplayCondition, time, line.distanceDisplayCondition);\n    };\n\n    DynamicGeometryUpdater.prototype.getBoundingSphere = function(result) {\n        \n\n        if (!this._geometryUpdater.clampToGround) {\n            var line = getLine(this);\n            if (line.show && line.positions.length > 0) {\n                BoundingSphere.fromPoints(line.positions, result);\n                return BoundingSphereState.DONE;\n            }\n        } else {\n            var groundPolylinePrimitive = this._groundPolylinePrimitive;\n            if (defined(groundPolylinePrimitive) && groundPolylinePrimitive.show && groundPolylinePrimitive.ready) {\n                var attributes = groundPolylinePrimitive.getGeometryInstanceAttributes(this._geometryUpdater._entity);\n                if (defined(attributes) && defined(attributes.boundingSphere)) {\n                    BoundingSphere.clone(attributes.boundingSphere, result);\n                    return BoundingSphereState.DONE;\n                }\n            }\n\n            if ((defined(groundPolylinePrimitive) && !groundPolylinePrimitive.ready)) {\n                return BoundingSphereState.PENDING;\n            }\n\n            return BoundingSphereState.DONE;\n        }\n\n        return BoundingSphereState.FAILED;\n    };\n\n    DynamicGeometryUpdater.prototype.isDestroyed = function() {\n        return false;\n    };\n\n    DynamicGeometryUpdater.prototype.destroy = function() {\n        var geometryUpdater = this._geometryUpdater;\n        var sceneId = geometryUpdater._scene.id;\n        var polylineCollection = polylineCollections[sceneId];\n        if (defined(polylineCollection)) {\n            polylineCollection.remove(this._line);\n            if (polylineCollection.length === 0) {\n                this._primitives.removeAndDestroy(polylineCollection);\n                delete polylineCollections[sceneId];\n            }\n        }\n        if (defined(this._groundPolylinePrimitive)) {\n            this._groundPrimitives.remove(this._groundPolylinePrimitive);\n        }\n        destroyObject(this);\n    };\nexport default PolylineGeometryUpdater;\n","import AssociativeArray from '../Core/AssociativeArray.js';\nimport Color from '../Core/Color.js';\nimport ColorGeometryInstanceAttribute from '../Core/ColorGeometryInstanceAttribute.js';\nimport defaultValue from '../Core/defaultValue.js';\nimport defined from '../Core/defined.js';\nimport DistanceDisplayCondition from '../Core/DistanceDisplayCondition.js';\nimport DistanceDisplayConditionGeometryInstanceAttribute from '../Core/DistanceDisplayConditionGeometryInstanceAttribute.js';\nimport ShowGeometryInstanceAttribute from '../Core/ShowGeometryInstanceAttribute.js';\nimport GroundPolylinePrimitive from '../Scene/GroundPolylinePrimitive.js';\nimport PolylineColorAppearance from '../Scene/PolylineColorAppearance.js';\nimport PolylineMaterialAppearance from '../Scene/PolylineMaterialAppearance.js';\nimport BoundingSphereState from './BoundingSphereState.js';\nimport ColorMaterialProperty from './ColorMaterialProperty.js';\nimport MaterialProperty from './MaterialProperty.js';\nimport Property from './Property.js';\n\n    var scratchColor = new Color();\n    var distanceDisplayConditionScratch = new DistanceDisplayCondition();\n    var defaultDistanceDisplayCondition = new DistanceDisplayCondition();\n\n    // Encapsulates a Primitive and all the entities that it represents.\n    function Batch(orderedGroundPrimitives, classificationType, materialProperty, zIndex, asynchronous) {\n        var appearanceType;\n        if (materialProperty instanceof ColorMaterialProperty) {\n            appearanceType = PolylineColorAppearance;\n        } else {\n            appearanceType = PolylineMaterialAppearance;\n        }\n\n        this.orderedGroundPrimitives = orderedGroundPrimitives; // scene level primitive collection\n        this.classificationType = classificationType;\n        this.appearanceType = appearanceType;\n        this.materialProperty = materialProperty;\n        this.updaters = new AssociativeArray();\n        this.createPrimitive = true;\n        this.primitive = undefined; // a GroundPolylinePrimitive encapsulating all the entities\n        this.oldPrimitive = undefined;\n        this.geometry = new AssociativeArray();\n        this.material = undefined;\n        this.updatersWithAttributes = new AssociativeArray();\n        this.attributes = new AssociativeArray();\n        this.invalidated = false;\n        this.removeMaterialSubscription = materialProperty.definitionChanged.addEventListener(Batch.prototype.onMaterialChanged, this);\n        this.subscriptions = new AssociativeArray();\n        this.showsUpdated = new AssociativeArray();\n        this.zIndex = zIndex;\n\n        this._asynchronous = asynchronous;\n    }\n\n    Batch.prototype.onMaterialChanged = function() {\n        this.invalidated = true;\n    };\n\n    // Check if the given updater's material is compatible with this batch\n    Batch.prototype.isMaterial = function(updater) {\n        var material = this.materialProperty;\n        var updaterMaterial = updater.fillMaterialProperty;\n\n        if (updaterMaterial === material ||\n            (updaterMaterial instanceof ColorMaterialProperty && material instanceof ColorMaterialProperty)) {\n            return true;\n        }\n        return defined(material) && material.equals(updaterMaterial);\n    };\n\n    Batch.prototype.add = function(time, updater, geometryInstance) {\n        var id = updater.id;\n        this.updaters.set(id, updater);\n        this.geometry.set(id, geometryInstance);\n        // Updaters with dynamic attributes must be tracked separately, may exit the batch\n        if (!updater.hasConstantFill || !updater.fillMaterialProperty.isConstant || !Property.isConstant(updater.distanceDisplayConditionProperty)) {\n            this.updatersWithAttributes.set(id, updater);\n        } else {\n            var that = this;\n            // Listen for show changes. These will be synchronized in updateShows.\n            this.subscriptions.set(id, updater.entity.definitionChanged.addEventListener(function(entity, propertyName, newValue, oldValue) {\n                if (propertyName === 'isShowing') {\n                    that.showsUpdated.set(updater.id, updater);\n                }\n            }));\n        }\n        this.createPrimitive = true;\n    };\n\n    Batch.prototype.remove = function(updater) {\n        var id = updater.id;\n        this.createPrimitive = this.geometry.remove(id) || this.createPrimitive;\n        if (this.updaters.remove(id)) {\n            this.updatersWithAttributes.remove(id);\n            var unsubscribe = this.subscriptions.get(id);\n            if (defined(unsubscribe)) {\n                unsubscribe();\n                this.subscriptions.remove(id);\n            }\n            return true;\n        }\n        return false;\n    };\n\n    Batch.prototype.update = function(time) {\n        var isUpdated = true;\n        var primitive = this.primitive;\n        var orderedGroundPrimitives = this.orderedGroundPrimitives;\n        var geometries = this.geometry.values;\n        var i;\n\n        if (this.createPrimitive) {\n            var geometriesLength = geometries.length;\n            if (geometriesLength > 0) {\n                if (defined(primitive)) {\n                    // Keep a handle to the old primitive so it can be removed when the updated version is ready.\n                    if (!defined(this.oldPrimitive)) {\n                        this.oldPrimitive = primitive;\n                    } else {\n                        // For if the new primitive changes again before it is ready.\n                        orderedGroundPrimitives.remove(primitive);\n                    }\n                }\n\n                primitive = new GroundPolylinePrimitive({\n                    show : false,\n                    asynchronous : this._asynchronous,\n                    geometryInstances : geometries.slice(),\n                    appearance : new this.appearanceType(),\n                    classificationType : this.classificationType\n                });\n\n                if (this.appearanceType === PolylineMaterialAppearance) {\n                    this.material = MaterialProperty.getValue(time, this.materialProperty, this.material);\n                    primitive.appearance.material = this.material;\n                }\n\n                orderedGroundPrimitives.add(primitive, this.zIndex);\n                isUpdated = false;\n            } else {\n                if (defined(primitive)) {\n                    orderedGroundPrimitives.remove(primitive);\n                    primitive = undefined;\n                }\n                var oldPrimitive = this.oldPrimitive;\n                if (defined(oldPrimitive)) {\n                    orderedGroundPrimitives.remove(oldPrimitive);\n                    this.oldPrimitive = undefined;\n                }\n            }\n\n            this.attributes.removeAll();\n            this.primitive = primitive;\n            this.createPrimitive = false;\n        } else if (defined(primitive) && primitive.ready) {\n            primitive.show = true;\n            if (defined(this.oldPrimitive)) {\n                orderedGroundPrimitives.remove(this.oldPrimitive);\n                this.oldPrimitive = undefined;\n            }\n\n            if (this.appearanceType === PolylineMaterialAppearance) {\n                this.material = MaterialProperty.getValue(time, this.materialProperty, this.material);\n                this.primitive.appearance.material = this.material;\n            }\n            var updatersWithAttributes = this.updatersWithAttributes.values;\n            var length = updatersWithAttributes.length;\n            for (i = 0; i < length; i++) {\n                var updater = updatersWithAttributes[i];\n                var entity = updater.entity;\n                var instance = this.geometry.get(updater.id);\n\n                var attributes = this.attributes.get(instance.id.id);\n                if (!defined(attributes)) {\n                    attributes = primitive.getGeometryInstanceAttributes(instance.id);\n                    this.attributes.set(instance.id.id, attributes);\n                }\n\n                if (!updater.fillMaterialProperty.isConstant) {\n                    var colorProperty = updater.fillMaterialProperty.color;\n                    var resultColor = Property.getValueOrDefault(colorProperty, time, Color.WHITE, scratchColor);\n                    if (!Color.equals(attributes._lastColor, resultColor)) {\n                        attributes._lastColor = Color.clone(resultColor, attributes._lastColor);\n                        attributes.color = ColorGeometryInstanceAttribute.toValue(resultColor, attributes.color);\n                    }\n                }\n\n                var show = entity.isShowing && (updater.hasConstantFill || updater.isFilled(time));\n                var currentShow = attributes.show[0] === 1;\n                if (show !== currentShow) {\n                    attributes.show = ShowGeometryInstanceAttribute.toValue(show, attributes.show);\n                }\n\n                var distanceDisplayConditionProperty = updater.distanceDisplayConditionProperty;\n                if (!Property.isConstant(distanceDisplayConditionProperty)) {\n                    var distanceDisplayCondition = Property.getValueOrDefault(distanceDisplayConditionProperty, time, defaultDistanceDisplayCondition, distanceDisplayConditionScratch);\n                    if (!DistanceDisplayCondition.equals(distanceDisplayCondition, attributes._lastDistanceDisplayCondition)) {\n                        attributes._lastDistanceDisplayCondition = DistanceDisplayCondition.clone(distanceDisplayCondition, attributes._lastDistanceDisplayCondition);\n                        attributes.distanceDisplayCondition = DistanceDisplayConditionGeometryInstanceAttribute.toValue(distanceDisplayCondition, attributes.distanceDisplayCondition);\n                    }\n                }\n            }\n\n            this.updateShows(primitive);\n        } else if (defined(primitive) && !primitive.ready) {\n            isUpdated = false;\n        }\n        return isUpdated;\n    };\n\n    Batch.prototype.updateShows = function(primitive) {\n        var showsUpdated = this.showsUpdated.values;\n        var length = showsUpdated.length;\n        for (var i = 0; i < length; i++) {\n            var updater = showsUpdated[i];\n            var entity = updater.entity;\n            var instance = this.geometry.get(updater.id);\n\n            var attributes = this.attributes.get(instance.id.id);\n            if (!defined(attributes)) {\n                attributes = primitive.getGeometryInstanceAttributes(instance.id);\n                this.attributes.set(instance.id.id, attributes);\n            }\n\n            var show = entity.isShowing;\n            var currentShow = attributes.show[0] === 1;\n            if (show !== currentShow) {\n                attributes.show = ShowGeometryInstanceAttribute.toValue(show, attributes.show);\n                instance.attributes.show.value[0] = attributes.show[0];\n            }\n        }\n        this.showsUpdated.removeAll();\n    };\n\n    Batch.prototype.contains = function(updater) {\n        return this.updaters.contains(updater.id);\n    };\n\n    Batch.prototype.getBoundingSphere = function(updater, result) {\n        var primitive = this.primitive;\n        if (!primitive.ready) {\n            return BoundingSphereState.PENDING;\n        }\n        var attributes = primitive.getGeometryInstanceAttributes(updater.entity);\n        if (!defined(attributes) || !defined(attributes.boundingSphere) ||\n            (defined(attributes.show) && attributes.show[0] === 0)) {\n            return BoundingSphereState.FAILED;\n        }\n        attributes.boundingSphere.clone(result);\n        return BoundingSphereState.DONE;\n    };\n\n    Batch.prototype.destroy = function() {\n        var primitive = this.primitive;\n        var orderedGroundPrimitives = this.orderedGroundPrimitives;\n        if (defined(primitive)) {\n            orderedGroundPrimitives.remove(primitive);\n        }\n        var oldPrimitive = this.oldPrimitive;\n        if (defined(oldPrimitive)) {\n            orderedGroundPrimitives.remove(oldPrimitive);\n        }\n        this.removeMaterialSubscription();\n    };\n\n    /**\n     * @private\n     */\n    function StaticGroundPolylinePerMaterialBatch(orderedGroundPrimitives, classificationType, asynchronous) {\n        this._items = [];\n        this._orderedGroundPrimitives = orderedGroundPrimitives;\n        this._classificationType = classificationType;\n        this._asynchronous = defaultValue(asynchronous, true);\n    }\n\n    StaticGroundPolylinePerMaterialBatch.prototype.add = function(time, updater) {\n        var items = this._items;\n        var length = items.length;\n        var geometryInstance = updater.createFillGeometryInstance(time);\n        var zIndex = Property.getValueOrDefault(updater.zIndex, 0);\n        // Check if the Entity represented by the updater has the same material or a material representable with per-instance color.\n        for (var i = 0; i < length; ++i) {\n            var item = items[i];\n            if (item.isMaterial(updater) &&\n                item.zIndex === zIndex) {\n                item.add(time, updater, geometryInstance);\n                return;\n            }\n        }\n        // If a compatible batch wasn't found, create a new batch.\n        var batch = new Batch(this._orderedGroundPrimitives, this._classificationType, updater.fillMaterialProperty, zIndex, this._asynchronous);\n        batch.add(time, updater, geometryInstance);\n        items.push(batch);\n    };\n\n    StaticGroundPolylinePerMaterialBatch.prototype.remove = function(updater) {\n        var items = this._items;\n        var length = items.length;\n        for (var i = length - 1; i >= 0; i--) {\n            var item = items[i];\n            if (item.remove(updater)) {\n                if (item.updaters.length === 0) {\n                    items.splice(i, 1);\n                    item.destroy();\n                }\n                break;\n            }\n        }\n    };\n\n    StaticGroundPolylinePerMaterialBatch.prototype.update = function(time) {\n        var i;\n        var items = this._items;\n        var length = items.length;\n\n        for (i = length - 1; i >= 0; i--) {\n            var item = items[i];\n            if (item.invalidated) {\n                items.splice(i, 1);\n                var updaters = item.updaters.values;\n                var updatersLength = updaters.length;\n                for (var h = 0; h < updatersLength; h++) {\n                    this.add(time, updaters[h]);\n                }\n                item.destroy();\n            }\n        }\n\n        var isUpdated = true;\n        for (i = 0; i < items.length; i++) {\n            isUpdated = items[i].update(time) && isUpdated;\n        }\n        return isUpdated;\n    };\n\n    StaticGroundPolylinePerMaterialBatch.prototype.getBoundingSphere = function(updater, result) {\n        var items = this._items;\n        var length = items.length;\n        for (var i = 0; i < length; i++) {\n            var item = items[i];\n            if (item.contains(updater)){\n                return item.getBoundingSphere(updater, result);\n            }\n        }\n        return BoundingSphereState.FAILED;\n    };\n\n    StaticGroundPolylinePerMaterialBatch.prototype.removeAllPrimitives = function() {\n        var items = this._items;\n        var length = items.length;\n        for (var i = 0; i < length; i++) {\n            items[i].destroy();\n        }\n        this._items.length = 0;\n    };\nexport default StaticGroundPolylinePerMaterialBatch;\n","import AssociativeArray from '../Core/AssociativeArray.js';\nimport BoundingSphere from '../Core/BoundingSphere.js';\nimport Check from '../Core/Check.js';\nimport defaultValue from '../Core/defaultValue.js';\nimport defined from '../Core/defined.js';\nimport destroyObject from '../Core/destroyObject.js';\nimport ClassificationType from '../Scene/ClassificationType.js';\nimport PolylineColorAppearance from '../Scene/PolylineColorAppearance.js';\nimport PolylineMaterialAppearance from '../Scene/PolylineMaterialAppearance.js';\nimport ShadowMode from '../Scene/ShadowMode.js';\nimport BoundingSphereState from './BoundingSphereState.js';\nimport ColorMaterialProperty from './ColorMaterialProperty.js';\nimport DynamicGeometryBatch from './DynamicGeometryBatch.js';\nimport PolylineGeometryUpdater from './PolylineGeometryUpdater.js';\nimport StaticGeometryColorBatch from './StaticGeometryColorBatch.js';\nimport StaticGeometryPerMaterialBatch from './StaticGeometryPerMaterialBatch.js';\nimport StaticGroundPolylinePerMaterialBatch from './StaticGroundPolylinePerMaterialBatch.js';\n\n    var emptyArray = [];\n\n    function removeUpdater(that, updater) {\n        //We don't keep track of which batch an updater is in, so just remove it from all of them.\n        var batches = that._batches;\n        var length = batches.length;\n        for (var i = 0; i < length; i++) {\n            batches[i].remove(updater);\n        }\n    }\n\n    function insertUpdaterIntoBatch(that, time, updater) {\n        if (updater.isDynamic) {\n            that._dynamicBatch.add(time, updater);\n            return;\n        }\n\n        if (updater.clampToGround && updater.fillEnabled) { // Also checks for support\n            var classificationType = updater.classificationTypeProperty.getValue(time);\n            that._groundBatches[classificationType].add(time, updater);\n            return;\n        }\n\n        var shadows;\n        if (updater.fillEnabled) {\n            shadows = updater.shadowsProperty.getValue(time);\n        }\n\n        var multiplier = 0;\n        if (defined(updater.depthFailMaterialProperty)) {\n            multiplier = updater.depthFailMaterialProperty instanceof ColorMaterialProperty ? 1 : 2;\n        }\n\n        var index;\n        if (defined(shadows)) {\n            index = shadows + multiplier * ShadowMode.NUMBER_OF_SHADOW_MODES;\n        }\n\n        if (updater.fillEnabled) {\n            if (updater.fillMaterialProperty instanceof ColorMaterialProperty) {\n                that._colorBatches[index].add(time, updater);\n            } else {\n                that._materialBatches[index].add(time, updater);\n            }\n        }\n    }\n\n    /**\n     * A visualizer for polylines represented by {@link Primitive} instances.\n     * @alias PolylineVisualizer\n     * @constructor\n     *\n     * @param {Scene} scene The scene the primitives will be rendered in.\n     * @param {EntityCollection} entityCollection The entityCollection to visualize.\n     * @param {PrimitiveCollection} [primitives=scene.primitives] A collection to add primitives related to the entities\n     * @param {PrimitiveCollection} [groundPrimitives=scene.groundPrimitives] A collection to add ground primitives related to the entities\n     */\n    function PolylineVisualizer(scene, entityCollection, primitives, groundPrimitives) {\n        \n\n        groundPrimitives = defaultValue(groundPrimitives, scene.groundPrimitives);\n        primitives = defaultValue(primitives, scene.primitives);\n\n        this._scene = scene;\n        this._primitives = primitives;\n        this._entityCollection = undefined;\n        this._addedObjects = new AssociativeArray();\n        this._removedObjects = new AssociativeArray();\n        this._changedObjects = new AssociativeArray();\n\n        var i;\n        var numberOfShadowModes = ShadowMode.NUMBER_OF_SHADOW_MODES;\n        this._colorBatches = new Array(numberOfShadowModes * 3);\n        this._materialBatches = new Array(numberOfShadowModes * 3);\n\n        for (i = 0; i < numberOfShadowModes; ++i) {\n            this._colorBatches[i] = new StaticGeometryColorBatch(primitives, PolylineColorAppearance, undefined, false, i); // no depth fail appearance\n            this._materialBatches[i] = new StaticGeometryPerMaterialBatch(primitives, PolylineMaterialAppearance, undefined, false, i);\n\n            this._colorBatches[i + numberOfShadowModes] = new StaticGeometryColorBatch(primitives, PolylineColorAppearance, PolylineColorAppearance, false, i); //depth fail appearance variations\n            this._materialBatches[i + numberOfShadowModes] = new StaticGeometryPerMaterialBatch(primitives, PolylineMaterialAppearance, PolylineColorAppearance, false, i);\n\n            this._colorBatches[i + numberOfShadowModes * 2] = new StaticGeometryColorBatch(primitives, PolylineColorAppearance, PolylineMaterialAppearance, false, i);\n            this._materialBatches[i + numberOfShadowModes * 2] = new StaticGeometryPerMaterialBatch(primitives, PolylineMaterialAppearance, PolylineMaterialAppearance, false, i);\n        }\n\n        this._dynamicBatch = new DynamicGeometryBatch(primitives, groundPrimitives);\n\n        var numberOfClassificationTypes = ClassificationType.NUMBER_OF_CLASSIFICATION_TYPES;\n        this._groundBatches = new Array(numberOfClassificationTypes);\n\n        for (i = 0; i < numberOfClassificationTypes; ++i) {\n            this._groundBatches[i] = new StaticGroundPolylinePerMaterialBatch(groundPrimitives, i);\n        }\n\n        this._batches = this._colorBatches.concat(this._materialBatches, this._dynamicBatch, this._groundBatches);\n\n        this._subscriptions = new AssociativeArray();\n        this._updaters = new AssociativeArray();\n\n        this._entityCollection = entityCollection;\n        entityCollection.collectionChanged.addEventListener(PolylineVisualizer.prototype._onCollectionChanged, this);\n        this._onCollectionChanged(entityCollection, entityCollection.values, emptyArray);\n    }\n\n    /**\n     * Updates all of the primitives created by this visualizer to match their\n     * Entity counterpart at the given time.\n     *\n     * @param {JulianDate} time The time to update to.\n     * @returns {Boolean} True if the visualizer successfully updated to the provided time,\n     * false if the visualizer is waiting for asynchronous primitives to be created.\n     */\n    PolylineVisualizer.prototype.update = function(time) {\n        \n\n        var addedObjects = this._addedObjects;\n        var added = addedObjects.values;\n        var removedObjects = this._removedObjects;\n        var removed = removedObjects.values;\n        var changedObjects = this._changedObjects;\n        var changed = changedObjects.values;\n\n        var i;\n        var entity;\n        var id;\n        var updater;\n\n        for (i = changed.length - 1; i > -1; i--) {\n            entity = changed[i];\n            id = entity.id;\n            updater = this._updaters.get(id);\n\n            //If in a single update, an entity gets removed and a new instance\n            //re-added with the same id, the updater no longer tracks the\n            //correct entity, we need to both remove the old one and\n            //add the new one, which is done by pushing the entity\n            //onto the removed/added lists.\n            if (updater.entity === entity) {\n                removeUpdater(this, updater);\n                insertUpdaterIntoBatch(this, time, updater);\n            } else {\n                removed.push(entity);\n                added.push(entity);\n            }\n        }\n\n        for (i = removed.length - 1; i > -1; i--) {\n            entity = removed[i];\n            id = entity.id;\n            updater = this._updaters.get(id);\n            removeUpdater(this, updater);\n            updater.destroy();\n            this._updaters.remove(id);\n            this._subscriptions.get(id)();\n            this._subscriptions.remove(id);\n        }\n\n        for (i = added.length - 1; i > -1; i--) {\n            entity = added[i];\n            id = entity.id;\n            updater = new PolylineGeometryUpdater(entity, this._scene);\n            this._updaters.set(id, updater);\n            insertUpdaterIntoBatch(this, time, updater);\n            this._subscriptions.set(id, updater.geometryChanged.addEventListener(PolylineVisualizer._onGeometryChanged, this));\n        }\n\n        addedObjects.removeAll();\n        removedObjects.removeAll();\n        changedObjects.removeAll();\n\n        var isUpdated = true;\n        var batches = this._batches;\n        var length = batches.length;\n        for (i = 0; i < length; i++) {\n            isUpdated = batches[i].update(time) && isUpdated;\n        }\n\n        return isUpdated;\n    };\n\n    var getBoundingSphereArrayScratch = [];\n    var getBoundingSphereBoundingSphereScratch = new BoundingSphere();\n\n    /**\n     * Computes a bounding sphere which encloses the visualization produced for the specified entity.\n     * The bounding sphere is in the fixed frame of the scene's globe.\n     *\n     * @param {Entity} entity The entity whose bounding sphere to compute.\n     * @param {BoundingSphere} result The bounding sphere onto which to store the result.\n     * @returns {BoundingSphereState} BoundingSphereState.DONE if the result contains the bounding sphere,\n     *                       BoundingSphereState.PENDING if the result is still being computed, or\n     *                       BoundingSphereState.FAILED if the entity has no visualization in the current scene.\n     * @private\n     */\n    PolylineVisualizer.prototype.getBoundingSphere = function(entity, result) {\n        \n\n        var boundingSpheres = getBoundingSphereArrayScratch;\n        var tmp = getBoundingSphereBoundingSphereScratch;\n\n        var count = 0;\n        var state = BoundingSphereState.DONE;\n        var batches = this._batches;\n        var batchesLength = batches.length;\n        var updater = this._updaters.get(entity.id);\n        for (var i = 0; i < batchesLength; i++) {\n            state = batches[i].getBoundingSphere(updater, tmp);\n            if (state === BoundingSphereState.PENDING) {\n                return BoundingSphereState.PENDING;\n            } else if (state === BoundingSphereState.DONE) {\n                boundingSpheres[count] = BoundingSphere.clone(tmp, boundingSpheres[count]);\n                count++;\n            }\n        }\n\n        if (count === 0) {\n            return BoundingSphereState.FAILED;\n        }\n\n        boundingSpheres.length = count;\n        BoundingSphere.fromBoundingSpheres(boundingSpheres, result);\n        return BoundingSphereState.DONE;\n    };\n\n    /**\n     * Returns true if this object was destroyed; otherwise, false.\n     *\n     * @returns {Boolean} True if this object was destroyed; otherwise, false.\n     */\n    PolylineVisualizer.prototype.isDestroyed = function() {\n        return false;\n    };\n\n    /**\n     * Removes and destroys all primitives created by this instance.\n     */\n    PolylineVisualizer.prototype.destroy = function() {\n        this._entityCollection.collectionChanged.removeEventListener(PolylineVisualizer.prototype._onCollectionChanged, this);\n        this._addedObjects.removeAll();\n        this._removedObjects.removeAll();\n\n        var i;\n        var batches = this._batches;\n        var length = batches.length;\n        for (i = 0; i < length; i++) {\n            batches[i].removeAllPrimitives();\n        }\n\n        var subscriptions = this._subscriptions.values;\n        length = subscriptions.length;\n        for (i = 0; i < length; i++) {\n            subscriptions[i]();\n        }\n        this._subscriptions.removeAll();\n        return destroyObject(this);\n    };\n\n    /**\n     * @private\n     */\n    PolylineVisualizer._onGeometryChanged = function(updater) {\n        var removedObjects = this._removedObjects;\n        var changedObjects = this._changedObjects;\n\n        var entity = updater.entity;\n        var id = entity.id;\n\n        if (!defined(removedObjects.get(id)) && !defined(changedObjects.get(id))) {\n            changedObjects.set(id, entity);\n        }\n    };\n\n    /**\n     * @private\n     */\n    PolylineVisualizer.prototype._onCollectionChanged = function(entityCollection, added, removed) {\n        var addedObjects = this._addedObjects;\n        var removedObjects = this._removedObjects;\n        var changedObjects = this._changedObjects;\n\n        var i;\n        var id;\n        var entity;\n        for (i = removed.length - 1; i > -1; i--) {\n            entity = removed[i];\n            id = entity.id;\n            if (!addedObjects.remove(id)) {\n                removedObjects.set(id, entity);\n                changedObjects.remove(id);\n            }\n        }\n\n        for (i = added.length - 1; i > -1; i--) {\n            entity = added[i];\n            id = entity.id;\n            if (removedObjects.remove(id)) {\n                changedObjects.set(id, entity);\n            } else {\n                addedObjects.set(id, entity);\n            }\n        }\n    };\nexport default PolylineVisualizer;\n","import ApproximateTerrainHeights from '../Core/ApproximateTerrainHeights.js';\nimport BoundingSphere from '../Core/BoundingSphere.js';\nimport Check from '../Core/Check.js';\nimport createGuid from '../Core/createGuid.js';\nimport defaultValue from '../Core/defaultValue.js';\nimport defined from '../Core/defined.js';\nimport defineProperties from '../Core/defineProperties.js';\nimport destroyObject from '../Core/destroyObject.js';\nimport EventHelper from '../Core/EventHelper.js';\nimport GroundPolylinePrimitive from '../Scene/GroundPolylinePrimitive.js';\nimport GroundPrimitive from '../Scene/GroundPrimitive.js';\nimport OrderedGroundPrimitiveCollection from '../Scene/OrderedGroundPrimitiveCollection.js';\nimport PrimitiveCollection from '../Scene/PrimitiveCollection.js';\nimport BillboardVisualizer from './BillboardVisualizer.js';\nimport BoundingSphereState from './BoundingSphereState.js';\nimport CustomDataSource from './CustomDataSource.js';\nimport GeometryVisualizer from './GeometryVisualizer.js';\nimport LabelVisualizer from './LabelVisualizer.js';\nimport ModelVisualizer from './ModelVisualizer.js';\nimport PathVisualizer from './PathVisualizer.js';\nimport PointVisualizer from './PointVisualizer.js';\nimport PolylineVisualizer from './PolylineVisualizer.js';\n\n    /**\n     * Visualizes a collection of {@link DataSource} instances.\n     * @alias DataSourceDisplay\n     * @constructor\n     *\n     * @param {Object} options Object with the following properties:\n     * @param {Scene} options.scene The scene in which to display the data.\n     * @param {DataSourceCollection} options.dataSourceCollection The data sources to display.\n     * @param {DataSourceDisplay~VisualizersCallback} [options.visualizersCallback=DataSourceDisplay.defaultVisualizersCallback]\n     *        A function which creates an array of visualizers used for visualization.\n     *        If undefined, all standard visualizers are used.\n     */\n    function DataSourceDisplay(options) {\n        \n\n        this._displayID = createGuid();\n\n        GroundPrimitive.initializeTerrainHeights();\n        GroundPolylinePrimitive.initializeTerrainHeights();\n\n        var scene = options.scene;\n        var dataSourceCollection = options.dataSourceCollection;\n\n        this._eventHelper = new EventHelper();\n        this._eventHelper.add(dataSourceCollection.dataSourceAdded, this._onDataSourceAdded, this);\n        this._eventHelper.add(dataSourceCollection.dataSourceRemoved, this._onDataSourceRemoved, this);\n        this._eventHelper.add(dataSourceCollection.dataSourceMoved, this._onDataSourceMoved, this);\n        this._eventHelper.add(scene.postRender, this._postRender, this);\n\n        this._dataSourceCollection = dataSourceCollection;\n        this._scene = scene;\n        this._visualizersCallback = defaultValue(options.visualizersCallback, DataSourceDisplay.defaultVisualizersCallback);\n\n        var primitivesAdded = false;\n        var primitives = new PrimitiveCollection();\n        var groundPrimitives = new PrimitiveCollection();\n\n        if (dataSourceCollection.length > 0) {\n            scene.primitives.add(primitives);\n            scene.groundPrimitives.add(groundPrimitives);\n            primitivesAdded = true;\n        }\n\n        this._primitives = primitives;\n        this._groundPrimitives = groundPrimitives;\n\n        for (var i = 0, len = dataSourceCollection.length; i < len; i++) {\n            this._onDataSourceAdded(dataSourceCollection, dataSourceCollection.get(i));\n        }\n\n        var defaultDataSource = new CustomDataSource();\n        this._onDataSourceAdded(undefined, defaultDataSource);\n        this._defaultDataSource = defaultDataSource;\n\n        var removeDefaultDataSourceListener;\n        var removeDataSourceCollectionListener;\n        if (!primitivesAdded) {\n            var that = this;\n            var addPrimitives = function() {\n                scene.primitives.add(primitives);\n                scene.groundPrimitives.add(groundPrimitives);\n                removeDefaultDataSourceListener();\n                removeDataSourceCollectionListener();\n                that._removeDefaultDataSourceListener = undefined;\n                that._removeDataSourceCollectionListener = undefined;\n            };\n            removeDefaultDataSourceListener = defaultDataSource.entities.collectionChanged.addEventListener(addPrimitives);\n            removeDataSourceCollectionListener = dataSourceCollection.dataSourceAdded.addEventListener(addPrimitives);\n        }\n\n        this._removeDefaultDataSourceListener = removeDefaultDataSourceListener;\n        this._removeDataSourceCollectionListener = removeDataSourceCollectionListener;\n\n        this._ready = false;\n    }\n\n    /**\n     * Gets or sets the default function which creates an array of visualizers used for visualization.\n     * By default, this function uses all standard visualizers.\n     *\n     * @type {DataSourceDisplay~VisualizersCallback}\n     */\n    DataSourceDisplay.defaultVisualizersCallback = function(scene, entityCluster, dataSource) {\n        var entities = dataSource.entities;\n        return [new BillboardVisualizer(entityCluster, entities),\n                new GeometryVisualizer(scene, entities, dataSource._primitives, dataSource._groundPrimitives),\n                new LabelVisualizer(entityCluster, entities),\n                new ModelVisualizer(scene, entities),\n                new PointVisualizer(entityCluster, entities),\n                new PathVisualizer(scene, entities),\n                new PolylineVisualizer(scene, entities, dataSource._primitives, dataSource._groundPrimitives)];\n    };\n\n    defineProperties(DataSourceDisplay.prototype, {\n        /**\n         * Gets the scene associated with this display.\n         * @memberof DataSourceDisplay.prototype\n         * @type {Scene}\n         */\n        scene : {\n            get : function() {\n                return this._scene;\n            }\n        },\n        /**\n         * Gets the collection of data sources to display.\n         * @memberof DataSourceDisplay.prototype\n         * @type {DataSourceCollection}\n         */\n        dataSources : {\n            get : function() {\n                return this._dataSourceCollection;\n            }\n        },\n        /**\n         * Gets the default data source instance which can be used to\n         * manually create and visualize entities not tied to\n         * a specific data source. This instance is always available\n         * and does not appear in the list dataSources collection.\n         * @memberof DataSourceDisplay.prototype\n         * @type {CustomDataSource}\n         */\n        defaultDataSource : {\n            get : function() {\n                return this._defaultDataSource;\n            }\n        },\n\n        /**\n         * Gets a value indicating whether or not all entities in the data source are ready\n         * @memberof DataSourceDisplay.prototype\n         * @type {Boolean}\n         * @readonly\n         */\n        ready : {\n            get : function() {\n                return this._ready;\n            }\n        }\n    });\n\n    /**\n     * Returns true if this object was destroyed; otherwise, false.\n     * <br /><br />\n     * If this object was destroyed, it should not be used; calling any function other than\n     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n     *\n     * @returns {Boolean} True if this object was destroyed; otherwise, false.\n     *\n     * @see DataSourceDisplay#destroy\n     */\n    DataSourceDisplay.prototype.isDestroyed = function() {\n        return false;\n    };\n\n    /**\n     * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n     * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n     * <br /><br />\n     * Once an object is destroyed, it should not be used; calling any function other than\n     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n     * assign the return value (<code>undefined</code>) to the object as done in the example.\n     *\n     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n     *\n     *\n     * @example\n     * dataSourceDisplay = dataSourceDisplay.destroy();\n     *\n     * @see DataSourceDisplay#isDestroyed\n     */\n    DataSourceDisplay.prototype.destroy = function() {\n        this._eventHelper.removeAll();\n\n        var dataSourceCollection = this._dataSourceCollection;\n        for (var i = 0, length = dataSourceCollection.length; i < length; ++i) {\n            this._onDataSourceRemoved(this._dataSourceCollection, dataSourceCollection.get(i));\n        }\n        this._onDataSourceRemoved(undefined, this._defaultDataSource);\n\n        if (defined(this._removeDefaultDataSourceListener)) {\n            this._removeDefaultDataSourceListener();\n            this._removeDataSourceCollectionListener();\n        } else {\n            this._scene.primitives.remove(this._primitives);\n            this._scene.groundPrimitives.remove(this._groundPrimitives);\n        }\n\n        return destroyObject(this);\n    };\n\n    /**\n     * Updates the display to the provided time.\n     *\n     * @param {JulianDate} time The simulation time.\n     * @returns {Boolean} True if all data sources are ready to be displayed, false otherwise.\n     */\n    DataSourceDisplay.prototype.update = function(time) {\n        \n\n        if (!ApproximateTerrainHeights.initialized) {\n            this._ready = false;\n            return false;\n        }\n\n        var result = true;\n\n        var i;\n        var x;\n        var visualizers;\n        var vLength;\n        var dataSources = this._dataSourceCollection;\n        var length = dataSources.length;\n        for (i = 0; i < length; i++) {\n            var dataSource = dataSources.get(i);\n            if (defined(dataSource.update)) {\n                result = dataSource.update(time) && result;\n            }\n\n            visualizers = dataSource._visualizersByDisplayID[this._displayID];\n            vLength = visualizers.length;\n            for (x = 0; x < vLength; x++) {\n                result = visualizers[x].update(time) && result;\n            }\n        }\n\n        visualizers = this._defaultDataSource._visualizersByDisplayID[this._displayID];\n        vLength = visualizers.length;\n        for (x = 0; x < vLength; x++) {\n            result = visualizers[x].update(time) && result;\n        }\n\n        this._ready = result;\n\n        return result;\n    };\n\n    DataSourceDisplay.prototype._postRender = function() {\n        // Adds credits for all datasources\n        var frameState = this._scene.frameState;\n        var dataSources = this._dataSourceCollection;\n        var length = dataSources.length;\n        for (var i = 0; i < length; i++) {\n            var dataSource = dataSources.get(i);\n\n            var credit = dataSource.credit;\n            if (defined(credit)) {\n                frameState.creditDisplay.addCredit(credit);\n            }\n\n            // Credits from the resource that the user can't remove\n            var credits = dataSource._resourceCredits;\n            if (defined(credits)) {\n                var creditCount = credits.length;\n                for (var c = 0; c < creditCount; c++) {\n                    frameState.creditDisplay.addCredit(credits[c]);\n                }\n            }\n        }\n    };\n\n    var getBoundingSphereArrayScratch = [];\n    var getBoundingSphereBoundingSphereScratch = new BoundingSphere();\n\n    /**\n     * Computes a bounding sphere which encloses the visualization produced for the specified entity.\n     * The bounding sphere is in the fixed frame of the scene's globe.\n     *\n     * @param {Entity} entity The entity whose bounding sphere to compute.\n     * @param {Boolean} allowPartial If true, pending bounding spheres are ignored and an answer will be returned from the currently available data.\n     *                               If false, the the function will halt and return pending if any of the bounding spheres are pending.\n     * @param {BoundingSphere} result The bounding sphere onto which to store the result.\n     * @returns {BoundingSphereState} BoundingSphereState.DONE if the result contains the bounding sphere,\n     *                       BoundingSphereState.PENDING if the result is still being computed, or\n     *                       BoundingSphereState.FAILED if the entity has no visualization in the current scene.\n     * @private\n     */\n    DataSourceDisplay.prototype.getBoundingSphere = function(entity, allowPartial, result) {\n        \n\n        if (!this._ready) {\n            return BoundingSphereState.PENDING;\n        }\n\n        var i;\n        var length;\n        var dataSource = this._defaultDataSource;\n        if (!dataSource.entities.contains(entity)) {\n            dataSource = undefined;\n\n            var dataSources = this._dataSourceCollection;\n            length = dataSources.length;\n            for (i = 0; i < length; i++) {\n                var d = dataSources.get(i);\n                if (d.entities.contains(entity)) {\n                    dataSource = d;\n                    break;\n                }\n            }\n        }\n\n        if (!defined(dataSource)) {\n            return BoundingSphereState.FAILED;\n        }\n\n        var boundingSpheres = getBoundingSphereArrayScratch;\n        var tmp = getBoundingSphereBoundingSphereScratch;\n\n        var count = 0;\n        var state = BoundingSphereState.DONE;\n        var visualizers = dataSource._visualizers;\n        var visualizersLength = visualizers.length;\n\n        for (i = 0; i < visualizersLength; i++) {\n            var visualizer = visualizers[i];\n            if (defined(visualizer.getBoundingSphere)) {\n                state = visualizers[i].getBoundingSphere(entity, tmp);\n                if (!allowPartial && state === BoundingSphereState.PENDING) {\n                    return BoundingSphereState.PENDING;\n                } else if (state === BoundingSphereState.DONE) {\n                    boundingSpheres[count] = BoundingSphere.clone(tmp, boundingSpheres[count]);\n                    count++;\n                }\n            }\n        }\n\n        if (count === 0) {\n            return BoundingSphereState.FAILED;\n        }\n\n        boundingSpheres.length = count;\n        BoundingSphere.fromBoundingSpheres(boundingSpheres, result);\n        return BoundingSphereState.DONE;\n    };\n\n    DataSourceDisplay.prototype._onDataSourceAdded = function(dataSourceCollection, dataSource) {\n        var scene = this._scene;\n\n        var displayPrimitives = this._primitives;\n        var displayGroundPrimitives = this._groundPrimitives;\n\n        var primitives = displayPrimitives.add(new PrimitiveCollection());\n        var groundPrimitives = displayGroundPrimitives.add(new OrderedGroundPrimitiveCollection());\n\n        dataSource._primitives = primitives;\n        dataSource._groundPrimitives = groundPrimitives;\n\n        var entityCluster = dataSource.clustering;\n        entityCluster._initialize(scene);\n\n        primitives.add(entityCluster);\n\n        var visualizers = this._visualizersCallback(scene, entityCluster, dataSource);\n\n        dataSource._visualizersByDisplayID = dataSource._visualizersByDisplayID || {};\n        dataSource._visualizersByDisplayID[this._displayID] = visualizers;\n\n        dataSource._visualizers = dataSource._visualizers || [];\n        dataSource._visualizers = dataSource._visualizers.concat(visualizers);\n    };\n\n    DataSourceDisplay.prototype._onDataSourceRemoved = function(dataSourceCollection, dataSource) {\n        var displayPrimitives = this._primitives;\n        var displayGroundPrimitives = this._groundPrimitives;\n\n        var primitives = dataSource._primitives;\n        var groundPrimitives = dataSource._groundPrimitives;\n\n        var entityCluster = dataSource.clustering;\n        primitives.remove(entityCluster);\n\n        var visualizers = dataSource._visualizersByDisplayID[this._displayID];\n        if (!defined(visualizers)) {\n            return;\n        }\n\n        var length = visualizers.length;\n        for (var i = 0; i < length; i++) {\n            var visualizer = visualizers[i];\n            visualizer.destroy();\n\n            var index = dataSource._visualizers.indexOf(visualizer);\n            dataSource._visualizers.splice(index, 1);\n        }\n\n        delete dataSource._visualizersByDisplayID[this._displayID];\n\n        displayPrimitives.remove(primitives);\n        displayGroundPrimitives.remove(groundPrimitives);\n    };\n\n    DataSourceDisplay.prototype._onDataSourceMoved = function(dataSource, newIndex, oldIndex) {\n        var displayPrimitives = this._primitives;\n        var displayGroundPrimitives = this._groundPrimitives;\n\n        var primitives = dataSource._primitives;\n        var groundPrimitives = dataSource._groundPrimitives;\n\n        if (newIndex === oldIndex + 1) {\n            displayPrimitives.raise(primitives);\n            displayGroundPrimitives.raise(groundPrimitives);\n        } else if (newIndex === oldIndex - 1) {\n            displayPrimitives.lower(primitives);\n            displayGroundPrimitives.lower(groundPrimitives);\n        } else if (newIndex === 0) {\n            displayPrimitives.lowerToBottom(primitives);\n            displayGroundPrimitives.lowerToBottom(groundPrimitives);\n            displayPrimitives.raise(primitives); // keep defaultDataSource primitives at index 0 since it's not in the collection\n            displayGroundPrimitives.raise(groundPrimitives);\n        } else {\n            displayPrimitives.raiseToTop(primitives);\n            displayGroundPrimitives.raiseToTop(groundPrimitives);\n        }\n    };\n\n    /**\n     * A function which creates an array of visualizers used for visualization.\n     * @callback DataSourceDisplay~VisualizersCallback\n     *\n     * @param {Scene} scene The scene to create visualizers for.\n     * @param {DataSource} dataSource The data source to create visualizers for.\n     * @returns {Visualizer[]} An array of visualizers used for visualization.\n     *\n     * @example\n     * function createVisualizers(scene, dataSource) {\n     *     return [new Cesium.BillboardVisualizer(scene, dataSource.entities)];\n     * }\n     */\nexport default DataSourceDisplay;\n"],"sourceRoot":""}